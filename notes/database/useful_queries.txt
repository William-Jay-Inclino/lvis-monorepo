
// audit logs
SELECT 
    TO_CHAR(created_at, 'HH12:MI AM') AS created_at, 
    username, 
    "action", 
    "table", 
    ip_address, 
    device_info, 
    metadata
FROM public.warehouse_audit
WHERE DATE(created_at) = '2025-02-01'
ORDER BY id DESC;

// user login/logout group by username

SELECT u.username, 
       MAX(event_timestamp) AS latest_event_timestamp,
       COUNT(*) AS event_count -- Optional: To count events per user
FROM user_audit_log log 
INNER JOIN "user" u ON u.id = log.user_id
WHERE DATE(event_timestamp) = '2025-02-01'
GROUP BY u.username;

// user login/logout details

SELECT 
    u.username, 
    event_type, 
    TO_CHAR(event_timestamp, 'HH12:MI AM') AS time,
    ip_address, 
    device_info
FROM user_audit_log log 
INNER JOIN "user" u ON u.id = log.user_id
WHERE DATE(event_timestamp) = '2025-02-01';



// SELECT employee fullname

SELECT 
    CONCAT(e.firstname, ' ', 
           COALESCE(SUBSTRING(e.middlename FROM 1 FOR 1), ''), 
           CASE WHEN e.middlename IS NOT NULL THEN '. ' ELSE '' END, 
           e.lastname) AS fullname
FROM employee e
WHERE e.id = '18334e11-7b58-4088-bf72-7872c5e058a0';



// view for duplicates

SELECT reference_number, reference_table, COUNT(*)
FROM pending
GROUP BY reference_number, reference_table
HAVING COUNT(*) > 1;



// SQL query to calculate the total sum of quantity for each item_id where the approval_status is pending and cancelled_at is null
// Get the total qty on queue for each item

SELECT 
    oi.item_id,
    SUM(oi.quantity) AS total_quantity
FROM 
    seriv_item oi
INNER JOIN 
    seriv o ON o.id = oi.seriv_id
WHERE 
    o.approval_status = 1 
    AND (o.cancelled_at IS NULL OR o.cancelled_by IS NULL)
GROUP BY 
    oi.item_id;




// FOR MRV 
MRV records with approval_status = 1.
MRV records with approval_status = 2:
If the associated MCT has approval_status = 1.
Or if there is no associated MCT.
Ensures that neither MRV nor MCT is canceled (cancelled_at and cancelled_by are NULL).

SELECT 
    mi.item_id,
    SUM(mi.quantity) AS total_quantity
FROM 
    mrv m
INNER JOIN 
    mrv_item mi ON m.id = mi.mrv_id
LEFT JOIN 
    mct t ON m.id = t.mrv_id
WHERE 
    (
        m.approval_status = 1
        OR (
            m.approval_status = 2 
            AND (t.approval_status = 1 OR t.mrv_id IS NULL)
        )
    )
    AND m.cancelled_at IS NULL
    AND m.cancelled_by IS NULL
    AND (t.cancelled_at IS NULL OR t.cancelled_by IS NULL OR t.mrv_id IS NULL)
GROUP BY 
    mi.item_id
ORDER BY 
	mi.item_id ASC;






This query will return:

MRV records with approval_status = 1.
MRV records with approval_status = 2:
If the associated MCT has approval_status = 1.
Or if there is no associated MCT.
Ensures that neither MRV nor MCT is canceled (cancelled_at and cancelled_by are NULL).


SELECT 
    mrv.mrv_number, 
    mrv.approval_status, 
    mrv_item.item_id, 
    mrv_item.quantity
FROM 
    mrv_item
INNER JOIN 
    mrv ON mrv.id = mrv_item.mrv_id
LEFT JOIN 
    mct ON mrv.id = mct.mrv_id
WHERE 
    mrv_item.item_id = '49a2fa4b-ff96-46d7-9991-9088d88f494d'
    AND (
        mrv.approval_status = 1
        OR (
            mrv.approval_status = 2 
            AND (mct.approval_status = 1 OR mct.mrv_id IS NULL)
        )
    )
    AND mrv.cancelled_at IS NULL
    AND mrv.cancelled_by IS NULL
    AND (mct.cancelled_at IS NULL OR mct.cancelled_by IS NULL OR mct.mrv_id IS NULL);




// TRIP TICKET SCAN 

SELECT DISTINCT ON (ip_address) 
    TO_CHAR(created_at, 'HH12:MI AM') AS created_at, 
    username, 
    "action", 
    "table", 
    ip_address, 
    device_info, 
    metadata
FROM public.warehouse_audit
WHERE DATE(created_at) = '2025-02-05'
AND "action" LIKE 'TRIP-RFID-SCAN%'
ORDER BY ip_address, id DESC;


// for checking item code tracker

SELECT * FROM public.item WHERE "code" LIKE 'HW-25%' ORDER BY "code" DESC



// item report 


WITH starting_balance_cte AS (
    SELECT 
        it.item_id, 
        COALESCE(SUM(CASE WHEN it.type = 1 THEN it.quantity ELSE -it.quantity END), 0) AS starting_balance
    FROM item_transaction it
    WHERE it.created_at < '2025-02-01'  
    GROUP BY it.item_id
),

ending_balance_cte AS (
    SELECT 
        it.item_id, 
        COALESCE(SUM(CASE WHEN it.type = 1 THEN it.quantity ELSE -it.quantity END), 0) AS ending_balance
    FROM item_transaction it
    WHERE it.created_at <= '2025-02-28'  
    GROUP BY it.item_id
)

SELECT
	TO_CHAR(it.created_at, 'DD Mon YYYY') AS date,
    i.code AS item_code, 
    i.description, 
    itype.name AS item_type, 
    unit.name AS unit,
	it.quantity,
	it.price AS unit_price,
	it.price * it.quantity AS total_price,
	(CASE WHEN it.type = 1 THEN 'Stock In' ELSE 'Stock Out' END) AS "type",
	CASE 
		WHEN it.rr_item_id IS NOT NULL THEN CONCAT('RR#', rr.rr_number)
		WHEN it.osriv_item_id IS NOT NULL THEN CONCAT('OSRIV#', osriv.osriv_number)
		WHEN it.seriv_item_id IS NOT NULL THEN CONCAT('SERIV#', seriv.seriv_number)
		WHEN it.mrv_item_id IS NOT NULL THEN CONCAT('MCT#', mct.mct_number)
		WHEN it.mcrt_item_id IS NOT NULL THEN CONCAT('MCRT#', mcrt.mcrt_number)
		WHEN it.mst_item_id IS NOT NULL THEN CONCAT('MST#', mst.mst_number)
		ELSE 'N/A'  
	END AS reference_number,
	COALESCE(sb.starting_balance, 0) AS starting_balance,
	COALESCE(eb.ending_balance, 0) AS ending_balance,
	it.remarks
FROM item_transaction it
INNER JOIN item i ON i.id = it.item_id

LEFT JOIN starting_balance_cte sb ON sb.item_id = it.item_id
LEFT JOIN ending_balance_cte eb ON eb.item_id = it.item_id
LEFT JOIN item_type itype ON itype.id = i.item_type_id  
LEFT JOIN unit unit ON unit.id = i.unit_id            

LEFT JOIN rr_item ON rr_item.id = it.rr_item_id             
LEFT JOIN osriv_item ON osriv_item.id = it.osriv_item_id 
LEFT JOIN seriv_item ON seriv_item.id = it.seriv_item_id  
LEFT JOIN mrv_item ON mrv_item.id = it.mrv_item_id          
LEFT JOIN mcrt_item ON mcrt_item.id = it.mcrt_item_id      
LEFT JOIN mst_item ON mst_item.id = it.mst_item_id     

LEFT JOIN receiving_report rr ON rr.id = rr_item.rr_id
LEFT JOIN osriv ON osriv.id = osriv_item.osriv_id
LEFT JOIN seriv ON seriv.id = seriv_item.seriv_id
LEFT JOIN mrv ON mrv.id = mrv_item.mrv_id
LEFT JOIN mct ON mct.mrv_id = mrv.id  -- Changed from INNER JOIN to LEFT JOIN
LEFT JOIN mcrt ON mcrt.id = mcrt_item.mcrt_id
LEFT JOIN mst ON mst.id = mst_item.mst_id

WHERE it.created_at BETWEEN '2025-02-01' AND '2025-02-28' 
ORDER BY date DESC;