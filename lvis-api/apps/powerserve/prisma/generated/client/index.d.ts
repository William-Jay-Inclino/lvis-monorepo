
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Audit
 * 
 */
export type Audit = $Result.DefaultSelection<Prisma.$AuditPayload>
/**
 * Model Lineman
 * 
 */
export type Lineman = $Result.DefaultSelection<Prisma.$LinemanPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Municipality
 * 
 */
export type Municipality = $Result.DefaultSelection<Prisma.$MunicipalityPayload>
/**
 * Model Barangay
 * 
 */
export type Barangay = $Result.DefaultSelection<Prisma.$BarangayPayload>
/**
 * Model Sitio
 * 
 */
export type Sitio = $Result.DefaultSelection<Prisma.$SitioPayload>
/**
 * Model Feeder
 * 
 */
export type Feeder = $Result.DefaultSelection<Prisma.$FeederPayload>
/**
 * Model WeatherCondition
 * 
 */
export type WeatherCondition = $Result.DefaultSelection<Prisma.$WeatherConditionPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model MeterBrand
 * 
 */
export type MeterBrand = $Result.DefaultSelection<Prisma.$MeterBrandPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model ActivityCategory
 * 
 */
export type ActivityCategory = $Result.DefaultSelection<Prisma.$ActivityCategoryPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model ComplaintDetail
 * 
 */
export type ComplaintDetail = $Result.DefaultSelection<Prisma.$ComplaintDetailPayload>
/**
 * Model ComplaintStatus
 * 
 */
export type ComplaintStatus = $Result.DefaultSelection<Prisma.$ComplaintStatusPayload>
/**
 * Model ComplaintReportType
 * 
 */
export type ComplaintReportType = $Result.DefaultSelection<Prisma.$ComplaintReportTypePayload>
/**
 * Model ComplaintLog
 * 
 */
export type ComplaintLog = $Result.DefaultSelection<Prisma.$ComplaintLogPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskAssignment
 * 
 */
export type TaskAssignment = $Result.DefaultSelection<Prisma.$TaskAssignmentPayload>
/**
 * Model TaskLog
 * 
 */
export type TaskLog = $Result.DefaultSelection<Prisma.$TaskLogPayload>
/**
 * Model TaskFile
 * 
 */
export type TaskFile = $Result.DefaultSelection<Prisma.$TaskFilePayload>
/**
 * Model TaskStatus
 * 
 */
export type TaskStatus = $Result.DefaultSelection<Prisma.$TaskStatusPayload>
/**
 * Model TaskDetailPowerInterruption
 * 
 */
export type TaskDetailPowerInterruption = $Result.DefaultSelection<Prisma.$TaskDetailPowerInterruptionPayload>
/**
 * Model PowerInterruptionLineman
 * 
 */
export type PowerInterruptionLineman = $Result.DefaultSelection<Prisma.$PowerInterruptionLinemanPayload>
/**
 * Model TaskDetailKwhMeter
 * 
 */
export type TaskDetailKwhMeter = $Result.DefaultSelection<Prisma.$TaskDetailKwhMeterPayload>
/**
 * Model KwhMeterLineman
 * 
 */
export type KwhMeterLineman = $Result.DefaultSelection<Prisma.$KwhMeterLinemanPayload>
/**
 * Model TaskDetailLineServices
 * 
 */
export type TaskDetailLineServices = $Result.DefaultSelection<Prisma.$TaskDetailLineServicesPayload>
/**
 * Model LineServicesLineman
 * 
 */
export type LineServicesLineman = $Result.DefaultSelection<Prisma.$LineServicesLinemanPayload>
/**
 * Model TaskDetailDles
 * 
 */
export type TaskDetailDles = $Result.DefaultSelection<Prisma.$TaskDetailDlesPayload>
/**
 * Model DlesLineman
 * 
 */
export type DlesLineman = $Result.DefaultSelection<Prisma.$DlesLinemanPayload>
/**
 * Model TaskDetailLmdga
 * 
 */
export type TaskDetailLmdga = $Result.DefaultSelection<Prisma.$TaskDetailLmdgaPayload>
/**
 * Model LmdgaLineman
 * 
 */
export type LmdgaLineman = $Result.DefaultSelection<Prisma.$LmdgaLinemanPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LinemanStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type LinemanStatus = (typeof LinemanStatus)[keyof typeof LinemanStatus]

}

export type LinemanStatus = $Enums.LinemanStatus

export const LinemanStatus: typeof $Enums.LinemanStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Audits
 * const audits = await prisma.audit.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Audits
   * const audits = await prisma.audit.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.audit`: Exposes CRUD operations for the **Audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.AuditDelegate<ExtArgs>;

  /**
   * `prisma.lineman`: Exposes CRUD operations for the **Lineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Linemen
    * const linemen = await prisma.lineman.findMany()
    * ```
    */
  get lineman(): Prisma.LinemanDelegate<ExtArgs>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs>;

  /**
   * `prisma.municipality`: Exposes CRUD operations for the **Municipality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipalities
    * const municipalities = await prisma.municipality.findMany()
    * ```
    */
  get municipality(): Prisma.MunicipalityDelegate<ExtArgs>;

  /**
   * `prisma.barangay`: Exposes CRUD operations for the **Barangay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Barangays
    * const barangays = await prisma.barangay.findMany()
    * ```
    */
  get barangay(): Prisma.BarangayDelegate<ExtArgs>;

  /**
   * `prisma.sitio`: Exposes CRUD operations for the **Sitio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sitios
    * const sitios = await prisma.sitio.findMany()
    * ```
    */
  get sitio(): Prisma.SitioDelegate<ExtArgs>;

  /**
   * `prisma.feeder`: Exposes CRUD operations for the **Feeder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feeders
    * const feeders = await prisma.feeder.findMany()
    * ```
    */
  get feeder(): Prisma.FeederDelegate<ExtArgs>;

  /**
   * `prisma.weatherCondition`: Exposes CRUD operations for the **WeatherCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherConditions
    * const weatherConditions = await prisma.weatherCondition.findMany()
    * ```
    */
  get weatherCondition(): Prisma.WeatherConditionDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.meterBrand`: Exposes CRUD operations for the **MeterBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeterBrands
    * const meterBrands = await prisma.meterBrand.findMany()
    * ```
    */
  get meterBrand(): Prisma.MeterBrandDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.activityCategory`: Exposes CRUD operations for the **ActivityCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityCategories
    * const activityCategories = await prisma.activityCategory.findMany()
    * ```
    */
  get activityCategory(): Prisma.ActivityCategoryDelegate<ExtArgs>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs>;

  /**
   * `prisma.complaintDetail`: Exposes CRUD operations for the **ComplaintDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintDetails
    * const complaintDetails = await prisma.complaintDetail.findMany()
    * ```
    */
  get complaintDetail(): Prisma.ComplaintDetailDelegate<ExtArgs>;

  /**
   * `prisma.complaintStatus`: Exposes CRUD operations for the **ComplaintStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintStatuses
    * const complaintStatuses = await prisma.complaintStatus.findMany()
    * ```
    */
  get complaintStatus(): Prisma.ComplaintStatusDelegate<ExtArgs>;

  /**
   * `prisma.complaintReportType`: Exposes CRUD operations for the **ComplaintReportType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintReportTypes
    * const complaintReportTypes = await prisma.complaintReportType.findMany()
    * ```
    */
  get complaintReportType(): Prisma.ComplaintReportTypeDelegate<ExtArgs>;

  /**
   * `prisma.complaintLog`: Exposes CRUD operations for the **ComplaintLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintLogs
    * const complaintLogs = await prisma.complaintLog.findMany()
    * ```
    */
  get complaintLog(): Prisma.ComplaintLogDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskAssignment`: Exposes CRUD operations for the **TaskAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignments
    * const taskAssignments = await prisma.taskAssignment.findMany()
    * ```
    */
  get taskAssignment(): Prisma.TaskAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.taskLog`: Exposes CRUD operations for the **TaskLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLogs
    * const taskLogs = await prisma.taskLog.findMany()
    * ```
    */
  get taskLog(): Prisma.TaskLogDelegate<ExtArgs>;

  /**
   * `prisma.taskFile`: Exposes CRUD operations for the **TaskFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskFiles
    * const taskFiles = await prisma.taskFile.findMany()
    * ```
    */
  get taskFile(): Prisma.TaskFileDelegate<ExtArgs>;

  /**
   * `prisma.taskStatus`: Exposes CRUD operations for the **TaskStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskStatuses
    * const taskStatuses = await prisma.taskStatus.findMany()
    * ```
    */
  get taskStatus(): Prisma.TaskStatusDelegate<ExtArgs>;

  /**
   * `prisma.taskDetailPowerInterruption`: Exposes CRUD operations for the **TaskDetailPowerInterruption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailPowerInterruptions
    * const taskDetailPowerInterruptions = await prisma.taskDetailPowerInterruption.findMany()
    * ```
    */
  get taskDetailPowerInterruption(): Prisma.TaskDetailPowerInterruptionDelegate<ExtArgs>;

  /**
   * `prisma.powerInterruptionLineman`: Exposes CRUD operations for the **PowerInterruptionLineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PowerInterruptionLinemen
    * const powerInterruptionLinemen = await prisma.powerInterruptionLineman.findMany()
    * ```
    */
  get powerInterruptionLineman(): Prisma.PowerInterruptionLinemanDelegate<ExtArgs>;

  /**
   * `prisma.taskDetailKwhMeter`: Exposes CRUD operations for the **TaskDetailKwhMeter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailKwhMeters
    * const taskDetailKwhMeters = await prisma.taskDetailKwhMeter.findMany()
    * ```
    */
  get taskDetailKwhMeter(): Prisma.TaskDetailKwhMeterDelegate<ExtArgs>;

  /**
   * `prisma.kwhMeterLineman`: Exposes CRUD operations for the **KwhMeterLineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KwhMeterLinemen
    * const kwhMeterLinemen = await prisma.kwhMeterLineman.findMany()
    * ```
    */
  get kwhMeterLineman(): Prisma.KwhMeterLinemanDelegate<ExtArgs>;

  /**
   * `prisma.taskDetailLineServices`: Exposes CRUD operations for the **TaskDetailLineServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailLineServices
    * const taskDetailLineServices = await prisma.taskDetailLineServices.findMany()
    * ```
    */
  get taskDetailLineServices(): Prisma.TaskDetailLineServicesDelegate<ExtArgs>;

  /**
   * `prisma.lineServicesLineman`: Exposes CRUD operations for the **LineServicesLineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineServicesLinemen
    * const lineServicesLinemen = await prisma.lineServicesLineman.findMany()
    * ```
    */
  get lineServicesLineman(): Prisma.LineServicesLinemanDelegate<ExtArgs>;

  /**
   * `prisma.taskDetailDles`: Exposes CRUD operations for the **TaskDetailDles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailDles
    * const taskDetailDles = await prisma.taskDetailDles.findMany()
    * ```
    */
  get taskDetailDles(): Prisma.TaskDetailDlesDelegate<ExtArgs>;

  /**
   * `prisma.dlesLineman`: Exposes CRUD operations for the **DlesLineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DlesLinemen
    * const dlesLinemen = await prisma.dlesLineman.findMany()
    * ```
    */
  get dlesLineman(): Prisma.DlesLinemanDelegate<ExtArgs>;

  /**
   * `prisma.taskDetailLmdga`: Exposes CRUD operations for the **TaskDetailLmdga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailLmdgas
    * const taskDetailLmdgas = await prisma.taskDetailLmdga.findMany()
    * ```
    */
  get taskDetailLmdga(): Prisma.TaskDetailLmdgaDelegate<ExtArgs>;

  /**
   * `prisma.lmdgaLineman`: Exposes CRUD operations for the **LmdgaLineman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LmdgaLinemen
    * const lmdgaLinemen = await prisma.lmdgaLineman.findMany()
    * ```
    */
  get lmdgaLineman(): Prisma.LmdgaLinemanDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Audit: 'Audit',
    Lineman: 'Lineman',
    Area: 'Area',
    Municipality: 'Municipality',
    Barangay: 'Barangay',
    Sitio: 'Sitio',
    Feeder: 'Feeder',
    WeatherCondition: 'WeatherCondition',
    Device: 'Device',
    MeterBrand: 'MeterBrand',
    Activity: 'Activity',
    ActivityCategory: 'ActivityCategory',
    Complaint: 'Complaint',
    ComplaintDetail: 'ComplaintDetail',
    ComplaintStatus: 'ComplaintStatus',
    ComplaintReportType: 'ComplaintReportType',
    ComplaintLog: 'ComplaintLog',
    Task: 'Task',
    TaskAssignment: 'TaskAssignment',
    TaskLog: 'TaskLog',
    TaskFile: 'TaskFile',
    TaskStatus: 'TaskStatus',
    TaskDetailPowerInterruption: 'TaskDetailPowerInterruption',
    PowerInterruptionLineman: 'PowerInterruptionLineman',
    TaskDetailKwhMeter: 'TaskDetailKwhMeter',
    KwhMeterLineman: 'KwhMeterLineman',
    TaskDetailLineServices: 'TaskDetailLineServices',
    LineServicesLineman: 'LineServicesLineman',
    TaskDetailDles: 'TaskDetailDles',
    DlesLineman: 'DlesLineman',
    TaskDetailLmdga: 'TaskDetailLmdga',
    LmdgaLineman: 'LmdgaLineman'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "audit" | "lineman" | "area" | "municipality" | "barangay" | "sitio" | "feeder" | "weatherCondition" | "device" | "meterBrand" | "activity" | "activityCategory" | "complaint" | "complaintDetail" | "complaintStatus" | "complaintReportType" | "complaintLog" | "task" | "taskAssignment" | "taskLog" | "taskFile" | "taskStatus" | "taskDetailPowerInterruption" | "powerInterruptionLineman" | "taskDetailKwhMeter" | "kwhMeterLineman" | "taskDetailLineServices" | "lineServicesLineman" | "taskDetailDles" | "dlesLineman" | "taskDetailLmdga" | "lmdgaLineman"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Audit: {
        payload: Prisma.$AuditPayload<ExtArgs>
        fields: Prisma.AuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findFirst: {
            args: Prisma.AuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findMany: {
            args: Prisma.AuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          create: {
            args: Prisma.AuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          createMany: {
            args: Prisma.AuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          delete: {
            args: Prisma.AuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          update: {
            args: Prisma.AuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          deleteMany: {
            args: Prisma.AuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.AuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      Lineman: {
        payload: Prisma.$LinemanPayload<ExtArgs>
        fields: Prisma.LinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          findFirst: {
            args: Prisma.LinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          findMany: {
            args: Prisma.LinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>[]
          }
          create: {
            args: Prisma.LinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          createMany: {
            args: Prisma.LinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>[]
          }
          delete: {
            args: Prisma.LinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          update: {
            args: Prisma.LinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          deleteMany: {
            args: Prisma.LinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinemanPayload>
          }
          aggregate: {
            args: Prisma.LinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineman>
          }
          groupBy: {
            args: Prisma.LinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinemanCountArgs<ExtArgs>
            result: $Utils.Optional<LinemanCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Municipality: {
        payload: Prisma.$MunicipalityPayload<ExtArgs>
        fields: Prisma.MunicipalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findFirst: {
            args: Prisma.MunicipalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findMany: {
            args: Prisma.MunicipalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          create: {
            args: Prisma.MunicipalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          createMany: {
            args: Prisma.MunicipalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MunicipalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          delete: {
            args: Prisma.MunicipalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          update: {
            args: Prisma.MunicipalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          deleteMany: {
            args: Prisma.MunicipalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          aggregate: {
            args: Prisma.MunicipalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipality>
          }
          groupBy: {
            args: Prisma.MunicipalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipalityCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityCountAggregateOutputType> | number
          }
        }
      }
      Barangay: {
        payload: Prisma.$BarangayPayload<ExtArgs>
        fields: Prisma.BarangayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarangayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarangayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          findFirst: {
            args: Prisma.BarangayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarangayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          findMany: {
            args: Prisma.BarangayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>[]
          }
          create: {
            args: Prisma.BarangayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          createMany: {
            args: Prisma.BarangayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarangayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>[]
          }
          delete: {
            args: Prisma.BarangayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          update: {
            args: Prisma.BarangayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          deleteMany: {
            args: Prisma.BarangayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarangayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BarangayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarangayPayload>
          }
          aggregate: {
            args: Prisma.BarangayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarangay>
          }
          groupBy: {
            args: Prisma.BarangayGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarangayGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarangayCountArgs<ExtArgs>
            result: $Utils.Optional<BarangayCountAggregateOutputType> | number
          }
        }
      }
      Sitio: {
        payload: Prisma.$SitioPayload<ExtArgs>
        fields: Prisma.SitioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SitioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SitioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          findFirst: {
            args: Prisma.SitioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SitioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          findMany: {
            args: Prisma.SitioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>[]
          }
          create: {
            args: Prisma.SitioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          createMany: {
            args: Prisma.SitioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SitioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>[]
          }
          delete: {
            args: Prisma.SitioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          update: {
            args: Prisma.SitioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          deleteMany: {
            args: Prisma.SitioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SitioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SitioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitioPayload>
          }
          aggregate: {
            args: Prisma.SitioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSitio>
          }
          groupBy: {
            args: Prisma.SitioGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitioGroupByOutputType>[]
          }
          count: {
            args: Prisma.SitioCountArgs<ExtArgs>
            result: $Utils.Optional<SitioCountAggregateOutputType> | number
          }
        }
      }
      Feeder: {
        payload: Prisma.$FeederPayload<ExtArgs>
        fields: Prisma.FeederFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeederFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeederFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          findFirst: {
            args: Prisma.FeederFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeederFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          findMany: {
            args: Prisma.FeederFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>[]
          }
          create: {
            args: Prisma.FeederCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          createMany: {
            args: Prisma.FeederCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeederCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>[]
          }
          delete: {
            args: Prisma.FeederDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          update: {
            args: Prisma.FeederUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          deleteMany: {
            args: Prisma.FeederDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeederUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeederUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeederPayload>
          }
          aggregate: {
            args: Prisma.FeederAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeder>
          }
          groupBy: {
            args: Prisma.FeederGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeederGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeederCountArgs<ExtArgs>
            result: $Utils.Optional<FeederCountAggregateOutputType> | number
          }
        }
      }
      WeatherCondition: {
        payload: Prisma.$WeatherConditionPayload<ExtArgs>
        fields: Prisma.WeatherConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          findFirst: {
            args: Prisma.WeatherConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          findMany: {
            args: Prisma.WeatherConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>[]
          }
          create: {
            args: Prisma.WeatherConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          createMany: {
            args: Prisma.WeatherConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>[]
          }
          delete: {
            args: Prisma.WeatherConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          update: {
            args: Prisma.WeatherConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          deleteMany: {
            args: Prisma.WeatherConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeatherConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherConditionPayload>
          }
          aggregate: {
            args: Prisma.WeatherConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherCondition>
          }
          groupBy: {
            args: Prisma.WeatherConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherConditionCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherConditionCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      MeterBrand: {
        payload: Prisma.$MeterBrandPayload<ExtArgs>
        fields: Prisma.MeterBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeterBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeterBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          findFirst: {
            args: Prisma.MeterBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeterBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          findMany: {
            args: Prisma.MeterBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>[]
          }
          create: {
            args: Prisma.MeterBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          createMany: {
            args: Prisma.MeterBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeterBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>[]
          }
          delete: {
            args: Prisma.MeterBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          update: {
            args: Prisma.MeterBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          deleteMany: {
            args: Prisma.MeterBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeterBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeterBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterBrandPayload>
          }
          aggregate: {
            args: Prisma.MeterBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeterBrand>
          }
          groupBy: {
            args: Prisma.MeterBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeterBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeterBrandCountArgs<ExtArgs>
            result: $Utils.Optional<MeterBrandCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      ActivityCategory: {
        payload: Prisma.$ActivityCategoryPayload<ExtArgs>
        fields: Prisma.ActivityCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          findFirst: {
            args: Prisma.ActivityCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          findMany: {
            args: Prisma.ActivityCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>[]
          }
          create: {
            args: Prisma.ActivityCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          createMany: {
            args: Prisma.ActivityCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>[]
          }
          delete: {
            args: Prisma.ActivityCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          update: {
            args: Prisma.ActivityCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ActivityCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          aggregate: {
            args: Prisma.ActivityCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityCategory>
          }
          groupBy: {
            args: Prisma.ActivityCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      ComplaintDetail: {
        payload: Prisma.$ComplaintDetailPayload<ExtArgs>
        fields: Prisma.ComplaintDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          findFirst: {
            args: Prisma.ComplaintDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          findMany: {
            args: Prisma.ComplaintDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>[]
          }
          create: {
            args: Prisma.ComplaintDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          createMany: {
            args: Prisma.ComplaintDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>[]
          }
          delete: {
            args: Prisma.ComplaintDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          update: {
            args: Prisma.ComplaintDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintDetailPayload>
          }
          aggregate: {
            args: Prisma.ComplaintDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintDetail>
          }
          groupBy: {
            args: Prisma.ComplaintDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintDetailCountAggregateOutputType> | number
          }
        }
      }
      ComplaintStatus: {
        payload: Prisma.$ComplaintStatusPayload<ExtArgs>
        fields: Prisma.ComplaintStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          findFirst: {
            args: Prisma.ComplaintStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          findMany: {
            args: Prisma.ComplaintStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>[]
          }
          create: {
            args: Prisma.ComplaintStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          createMany: {
            args: Prisma.ComplaintStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>[]
          }
          delete: {
            args: Prisma.ComplaintStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          update: {
            args: Prisma.ComplaintStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusPayload>
          }
          aggregate: {
            args: Prisma.ComplaintStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintStatus>
          }
          groupBy: {
            args: Prisma.ComplaintStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintStatusCountAggregateOutputType> | number
          }
        }
      }
      ComplaintReportType: {
        payload: Prisma.$ComplaintReportTypePayload<ExtArgs>
        fields: Prisma.ComplaintReportTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintReportTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintReportTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          findFirst: {
            args: Prisma.ComplaintReportTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintReportTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          findMany: {
            args: Prisma.ComplaintReportTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>[]
          }
          create: {
            args: Prisma.ComplaintReportTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          createMany: {
            args: Prisma.ComplaintReportTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintReportTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>[]
          }
          delete: {
            args: Prisma.ComplaintReportTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          update: {
            args: Prisma.ComplaintReportTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          deleteMany: {
            args: Prisma.ComplaintReportTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintReportTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintReportTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintReportTypePayload>
          }
          aggregate: {
            args: Prisma.ComplaintReportTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintReportType>
          }
          groupBy: {
            args: Prisma.ComplaintReportTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintReportTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintReportTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintReportTypeCountAggregateOutputType> | number
          }
        }
      }
      ComplaintLog: {
        payload: Prisma.$ComplaintLogPayload<ExtArgs>
        fields: Prisma.ComplaintLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          findFirst: {
            args: Prisma.ComplaintLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          findMany: {
            args: Prisma.ComplaintLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>[]
          }
          create: {
            args: Prisma.ComplaintLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          createMany: {
            args: Prisma.ComplaintLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>[]
          }
          delete: {
            args: Prisma.ComplaintLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          update: {
            args: Prisma.ComplaintLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintLogPayload>
          }
          aggregate: {
            args: Prisma.ComplaintLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintLog>
          }
          groupBy: {
            args: Prisma.ComplaintLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintLogCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintLogCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignment: {
        payload: Prisma.$TaskAssignmentPayload<ExtArgs>
        fields: Prisma.TaskAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findMany: {
            args: Prisma.TaskAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          create: {
            args: Prisma.TaskAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          createMany: {
            args: Prisma.TaskAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          update: {
            args: Prisma.TaskAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignment>
          }
          groupBy: {
            args: Prisma.TaskAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentCountAggregateOutputType> | number
          }
        }
      }
      TaskLog: {
        payload: Prisma.$TaskLogPayload<ExtArgs>
        fields: Prisma.TaskLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          findFirst: {
            args: Prisma.TaskLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          findMany: {
            args: Prisma.TaskLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>[]
          }
          create: {
            args: Prisma.TaskLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          createMany: {
            args: Prisma.TaskLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>[]
          }
          delete: {
            args: Prisma.TaskLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          update: {
            args: Prisma.TaskLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          deleteMany: {
            args: Prisma.TaskLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          aggregate: {
            args: Prisma.TaskLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLog>
          }
          groupBy: {
            args: Prisma.TaskLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLogCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLogCountAggregateOutputType> | number
          }
        }
      }
      TaskFile: {
        payload: Prisma.$TaskFilePayload<ExtArgs>
        fields: Prisma.TaskFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          findFirst: {
            args: Prisma.TaskFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          findMany: {
            args: Prisma.TaskFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>[]
          }
          create: {
            args: Prisma.TaskFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          createMany: {
            args: Prisma.TaskFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>[]
          }
          delete: {
            args: Prisma.TaskFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          update: {
            args: Prisma.TaskFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          deleteMany: {
            args: Prisma.TaskFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFilePayload>
          }
          aggregate: {
            args: Prisma.TaskFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskFile>
          }
          groupBy: {
            args: Prisma.TaskFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskFileCountArgs<ExtArgs>
            result: $Utils.Optional<TaskFileCountAggregateOutputType> | number
          }
        }
      }
      TaskStatus: {
        payload: Prisma.$TaskStatusPayload<ExtArgs>
        fields: Prisma.TaskStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findFirst: {
            args: Prisma.TaskStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findMany: {
            args: Prisma.TaskStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          create: {
            args: Prisma.TaskStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          createMany: {
            args: Prisma.TaskStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          delete: {
            args: Prisma.TaskStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          update: {
            args: Prisma.TaskStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          deleteMany: {
            args: Prisma.TaskStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          aggregate: {
            args: Prisma.TaskStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskStatus>
          }
          groupBy: {
            args: Prisma.TaskStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusCountAggregateOutputType> | number
          }
        }
      }
      TaskDetailPowerInterruption: {
        payload: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>
        fields: Prisma.TaskDetailPowerInterruptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDetailPowerInterruptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDetailPowerInterruptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          findFirst: {
            args: Prisma.TaskDetailPowerInterruptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDetailPowerInterruptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          findMany: {
            args: Prisma.TaskDetailPowerInterruptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>[]
          }
          create: {
            args: Prisma.TaskDetailPowerInterruptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          createMany: {
            args: Prisma.TaskDetailPowerInterruptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDetailPowerInterruptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>[]
          }
          delete: {
            args: Prisma.TaskDetailPowerInterruptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          update: {
            args: Prisma.TaskDetailPowerInterruptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          deleteMany: {
            args: Prisma.TaskDetailPowerInterruptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDetailPowerInterruptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDetailPowerInterruptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailPowerInterruptionPayload>
          }
          aggregate: {
            args: Prisma.TaskDetailPowerInterruptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDetailPowerInterruption>
          }
          groupBy: {
            args: Prisma.TaskDetailPowerInterruptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailPowerInterruptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDetailPowerInterruptionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailPowerInterruptionCountAggregateOutputType> | number
          }
        }
      }
      PowerInterruptionLineman: {
        payload: Prisma.$PowerInterruptionLinemanPayload<ExtArgs>
        fields: Prisma.PowerInterruptionLinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PowerInterruptionLinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PowerInterruptionLinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          findFirst: {
            args: Prisma.PowerInterruptionLinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PowerInterruptionLinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          findMany: {
            args: Prisma.PowerInterruptionLinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>[]
          }
          create: {
            args: Prisma.PowerInterruptionLinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          createMany: {
            args: Prisma.PowerInterruptionLinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PowerInterruptionLinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>[]
          }
          delete: {
            args: Prisma.PowerInterruptionLinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          update: {
            args: Prisma.PowerInterruptionLinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          deleteMany: {
            args: Prisma.PowerInterruptionLinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PowerInterruptionLinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PowerInterruptionLinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PowerInterruptionLinemanPayload>
          }
          aggregate: {
            args: Prisma.PowerInterruptionLinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePowerInterruptionLineman>
          }
          groupBy: {
            args: Prisma.PowerInterruptionLinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PowerInterruptionLinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PowerInterruptionLinemanCountArgs<ExtArgs>
            result: $Utils.Optional<PowerInterruptionLinemanCountAggregateOutputType> | number
          }
        }
      }
      TaskDetailKwhMeter: {
        payload: Prisma.$TaskDetailKwhMeterPayload<ExtArgs>
        fields: Prisma.TaskDetailKwhMeterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDetailKwhMeterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDetailKwhMeterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          findFirst: {
            args: Prisma.TaskDetailKwhMeterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDetailKwhMeterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          findMany: {
            args: Prisma.TaskDetailKwhMeterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>[]
          }
          create: {
            args: Prisma.TaskDetailKwhMeterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          createMany: {
            args: Prisma.TaskDetailKwhMeterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDetailKwhMeterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>[]
          }
          delete: {
            args: Prisma.TaskDetailKwhMeterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          update: {
            args: Prisma.TaskDetailKwhMeterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          deleteMany: {
            args: Prisma.TaskDetailKwhMeterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDetailKwhMeterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDetailKwhMeterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailKwhMeterPayload>
          }
          aggregate: {
            args: Prisma.TaskDetailKwhMeterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDetailKwhMeter>
          }
          groupBy: {
            args: Prisma.TaskDetailKwhMeterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailKwhMeterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDetailKwhMeterCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailKwhMeterCountAggregateOutputType> | number
          }
        }
      }
      KwhMeterLineman: {
        payload: Prisma.$KwhMeterLinemanPayload<ExtArgs>
        fields: Prisma.KwhMeterLinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KwhMeterLinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KwhMeterLinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          findFirst: {
            args: Prisma.KwhMeterLinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KwhMeterLinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          findMany: {
            args: Prisma.KwhMeterLinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>[]
          }
          create: {
            args: Prisma.KwhMeterLinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          createMany: {
            args: Prisma.KwhMeterLinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KwhMeterLinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>[]
          }
          delete: {
            args: Prisma.KwhMeterLinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          update: {
            args: Prisma.KwhMeterLinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          deleteMany: {
            args: Prisma.KwhMeterLinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KwhMeterLinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KwhMeterLinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KwhMeterLinemanPayload>
          }
          aggregate: {
            args: Prisma.KwhMeterLinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKwhMeterLineman>
          }
          groupBy: {
            args: Prisma.KwhMeterLinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<KwhMeterLinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.KwhMeterLinemanCountArgs<ExtArgs>
            result: $Utils.Optional<KwhMeterLinemanCountAggregateOutputType> | number
          }
        }
      }
      TaskDetailLineServices: {
        payload: Prisma.$TaskDetailLineServicesPayload<ExtArgs>
        fields: Prisma.TaskDetailLineServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDetailLineServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDetailLineServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          findFirst: {
            args: Prisma.TaskDetailLineServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDetailLineServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          findMany: {
            args: Prisma.TaskDetailLineServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>[]
          }
          create: {
            args: Prisma.TaskDetailLineServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          createMany: {
            args: Prisma.TaskDetailLineServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDetailLineServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>[]
          }
          delete: {
            args: Prisma.TaskDetailLineServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          update: {
            args: Prisma.TaskDetailLineServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          deleteMany: {
            args: Prisma.TaskDetailLineServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDetailLineServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDetailLineServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLineServicesPayload>
          }
          aggregate: {
            args: Prisma.TaskDetailLineServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDetailLineServices>
          }
          groupBy: {
            args: Prisma.TaskDetailLineServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailLineServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDetailLineServicesCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailLineServicesCountAggregateOutputType> | number
          }
        }
      }
      LineServicesLineman: {
        payload: Prisma.$LineServicesLinemanPayload<ExtArgs>
        fields: Prisma.LineServicesLinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineServicesLinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineServicesLinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          findFirst: {
            args: Prisma.LineServicesLinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineServicesLinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          findMany: {
            args: Prisma.LineServicesLinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>[]
          }
          create: {
            args: Prisma.LineServicesLinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          createMany: {
            args: Prisma.LineServicesLinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineServicesLinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>[]
          }
          delete: {
            args: Prisma.LineServicesLinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          update: {
            args: Prisma.LineServicesLinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          deleteMany: {
            args: Prisma.LineServicesLinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineServicesLinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LineServicesLinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineServicesLinemanPayload>
          }
          aggregate: {
            args: Prisma.LineServicesLinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineServicesLineman>
          }
          groupBy: {
            args: Prisma.LineServicesLinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineServicesLinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineServicesLinemanCountArgs<ExtArgs>
            result: $Utils.Optional<LineServicesLinemanCountAggregateOutputType> | number
          }
        }
      }
      TaskDetailDles: {
        payload: Prisma.$TaskDetailDlesPayload<ExtArgs>
        fields: Prisma.TaskDetailDlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDetailDlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDetailDlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          findFirst: {
            args: Prisma.TaskDetailDlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDetailDlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          findMany: {
            args: Prisma.TaskDetailDlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>[]
          }
          create: {
            args: Prisma.TaskDetailDlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          createMany: {
            args: Prisma.TaskDetailDlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDetailDlesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>[]
          }
          delete: {
            args: Prisma.TaskDetailDlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          update: {
            args: Prisma.TaskDetailDlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          deleteMany: {
            args: Prisma.TaskDetailDlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDetailDlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDetailDlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailDlesPayload>
          }
          aggregate: {
            args: Prisma.TaskDetailDlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDetailDles>
          }
          groupBy: {
            args: Prisma.TaskDetailDlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailDlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDetailDlesCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailDlesCountAggregateOutputType> | number
          }
        }
      }
      DlesLineman: {
        payload: Prisma.$DlesLinemanPayload<ExtArgs>
        fields: Prisma.DlesLinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DlesLinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DlesLinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          findFirst: {
            args: Prisma.DlesLinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DlesLinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          findMany: {
            args: Prisma.DlesLinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>[]
          }
          create: {
            args: Prisma.DlesLinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          createMany: {
            args: Prisma.DlesLinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DlesLinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>[]
          }
          delete: {
            args: Prisma.DlesLinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          update: {
            args: Prisma.DlesLinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          deleteMany: {
            args: Prisma.DlesLinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DlesLinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DlesLinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DlesLinemanPayload>
          }
          aggregate: {
            args: Prisma.DlesLinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDlesLineman>
          }
          groupBy: {
            args: Prisma.DlesLinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DlesLinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DlesLinemanCountArgs<ExtArgs>
            result: $Utils.Optional<DlesLinemanCountAggregateOutputType> | number
          }
        }
      }
      TaskDetailLmdga: {
        payload: Prisma.$TaskDetailLmdgaPayload<ExtArgs>
        fields: Prisma.TaskDetailLmdgaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDetailLmdgaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDetailLmdgaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          findFirst: {
            args: Prisma.TaskDetailLmdgaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDetailLmdgaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          findMany: {
            args: Prisma.TaskDetailLmdgaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>[]
          }
          create: {
            args: Prisma.TaskDetailLmdgaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          createMany: {
            args: Prisma.TaskDetailLmdgaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDetailLmdgaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>[]
          }
          delete: {
            args: Prisma.TaskDetailLmdgaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          update: {
            args: Prisma.TaskDetailLmdgaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          deleteMany: {
            args: Prisma.TaskDetailLmdgaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDetailLmdgaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDetailLmdgaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDetailLmdgaPayload>
          }
          aggregate: {
            args: Prisma.TaskDetailLmdgaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDetailLmdga>
          }
          groupBy: {
            args: Prisma.TaskDetailLmdgaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailLmdgaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDetailLmdgaCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDetailLmdgaCountAggregateOutputType> | number
          }
        }
      }
      LmdgaLineman: {
        payload: Prisma.$LmdgaLinemanPayload<ExtArgs>
        fields: Prisma.LmdgaLinemanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LmdgaLinemanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LmdgaLinemanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          findFirst: {
            args: Prisma.LmdgaLinemanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LmdgaLinemanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          findMany: {
            args: Prisma.LmdgaLinemanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>[]
          }
          create: {
            args: Prisma.LmdgaLinemanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          createMany: {
            args: Prisma.LmdgaLinemanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LmdgaLinemanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>[]
          }
          delete: {
            args: Prisma.LmdgaLinemanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          update: {
            args: Prisma.LmdgaLinemanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          deleteMany: {
            args: Prisma.LmdgaLinemanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LmdgaLinemanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LmdgaLinemanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LmdgaLinemanPayload>
          }
          aggregate: {
            args: Prisma.LmdgaLinemanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLmdgaLineman>
          }
          groupBy: {
            args: Prisma.LmdgaLinemanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LmdgaLinemanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LmdgaLinemanCountArgs<ExtArgs>
            result: $Utils.Optional<LmdgaLinemanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LinemanCountOutputType
   */

  export type LinemanCountOutputType = {
    power_interruptions: number
    kwh_meters: number
    line_services: number
    dles: number
    lmdgas: number
  }

  export type LinemanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruptions?: boolean | LinemanCountOutputTypeCountPower_interruptionsArgs
    kwh_meters?: boolean | LinemanCountOutputTypeCountKwh_metersArgs
    line_services?: boolean | LinemanCountOutputTypeCountLine_servicesArgs
    dles?: boolean | LinemanCountOutputTypeCountDlesArgs
    lmdgas?: boolean | LinemanCountOutputTypeCountLmdgasArgs
  }

  // Custom InputTypes
  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinemanCountOutputType
     */
    select?: LinemanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeCountPower_interruptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PowerInterruptionLinemanWhereInput
  }

  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeCountKwh_metersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KwhMeterLinemanWhereInput
  }

  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeCountLine_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineServicesLinemanWhereInput
  }

  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeCountDlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DlesLinemanWhereInput
  }

  /**
   * LinemanCountOutputType without action
   */
  export type LinemanCountOutputTypeCountLmdgasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LmdgaLinemanWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    linemen: number
    municipalities: number
    task_assignments: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen?: boolean | AreaCountOutputTypeCountLinemenArgs
    municipalities?: boolean | AreaCountOutputTypeCountMunicipalitiesArgs
    task_assignments?: boolean | AreaCountOutputTypeCountTask_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountLinemenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinemanWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountTask_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }


  /**
   * Count Type MunicipalityCountOutputType
   */

  export type MunicipalityCountOutputType = {
    barangays: number
  }

  export type MunicipalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barangays?: boolean | MunicipalityCountOutputTypeCountBarangaysArgs
  }

  // Custom InputTypes
  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipalityCountOutputType
     */
    select?: MunicipalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountBarangaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarangayWhereInput
  }


  /**
   * Count Type BarangayCountOutputType
   */

  export type BarangayCountOutputType = {
    sitios: number
    complaint_details: number
  }

  export type BarangayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sitios?: boolean | BarangayCountOutputTypeCountSitiosArgs
    complaint_details?: boolean | BarangayCountOutputTypeCountComplaint_detailsArgs
  }

  // Custom InputTypes
  /**
   * BarangayCountOutputType without action
   */
  export type BarangayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarangayCountOutputType
     */
    select?: BarangayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BarangayCountOutputType without action
   */
  export type BarangayCountOutputTypeCountSitiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitioWhereInput
  }

  /**
   * BarangayCountOutputType without action
   */
  export type BarangayCountOutputTypeCountComplaint_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintDetailWhereInput
  }


  /**
   * Count Type SitioCountOutputType
   */

  export type SitioCountOutputType = {
    complaint_details: number
  }

  export type SitioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint_details?: boolean | SitioCountOutputTypeCountComplaint_detailsArgs
  }

  // Custom InputTypes
  /**
   * SitioCountOutputType without action
   */
  export type SitioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitioCountOutputType
     */
    select?: SitioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SitioCountOutputType without action
   */
  export type SitioCountOutputTypeCountComplaint_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintDetailWhereInput
  }


  /**
   * Count Type FeederCountOutputType
   */

  export type FeederCountOutputType = {
    power_interruption_tasks: number
    lmdga_tasks: number
  }

  export type FeederCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | FeederCountOutputTypeCountPower_interruption_tasksArgs
    lmdga_tasks?: boolean | FeederCountOutputTypeCountLmdga_tasksArgs
  }

  // Custom InputTypes
  /**
   * FeederCountOutputType without action
   */
  export type FeederCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeederCountOutputType
     */
    select?: FeederCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeederCountOutputType without action
   */
  export type FeederCountOutputTypeCountPower_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailPowerInterruptionWhereInput
  }

  /**
   * FeederCountOutputType without action
   */
  export type FeederCountOutputTypeCountLmdga_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailLmdgaWhereInput
  }


  /**
   * Count Type WeatherConditionCountOutputType
   */

  export type WeatherConditionCountOutputType = {
    power_interruption_tasks: number
  }

  export type WeatherConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | WeatherConditionCountOutputTypeCountPower_interruption_tasksArgs
  }

  // Custom InputTypes
  /**
   * WeatherConditionCountOutputType without action
   */
  export type WeatherConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherConditionCountOutputType
     */
    select?: WeatherConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeatherConditionCountOutputType without action
   */
  export type WeatherConditionCountOutputTypeCountPower_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailPowerInterruptionWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    power_interruption_tasks: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | DeviceCountOutputTypeCountPower_interruption_tasksArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountPower_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailPowerInterruptionWhereInput
  }


  /**
   * Count Type MeterBrandCountOutputType
   */

  export type MeterBrandCountOutputType = {
    kwh_meter_tasks: number
  }

  export type MeterBrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kwh_meter_tasks?: boolean | MeterBrandCountOutputTypeCountKwh_meter_tasksArgs
  }

  // Custom InputTypes
  /**
   * MeterBrandCountOutputType without action
   */
  export type MeterBrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrandCountOutputType
     */
    select?: MeterBrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeterBrandCountOutputType without action
   */
  export type MeterBrandCountOutputTypeCountKwh_meter_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailKwhMeterWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    tasks: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ActivityCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ActivityCategoryCountOutputType
   */

  export type ActivityCategoryCountOutputType = {
    activities: number
  }

  export type ActivityCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ActivityCategoryCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ActivityCategoryCountOutputType without action
   */
  export type ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategoryCountOutputType
     */
    select?: ActivityCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCategoryCountOutputType without action
   */
  export type ActivityCategoryCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type ComplaintCountOutputType
   */

  export type ComplaintCountOutputType = {
    logs: number
    tasks: number
  }

  export type ComplaintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | ComplaintCountOutputTypeCountLogsArgs
    tasks?: boolean | ComplaintCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintCountOutputType
     */
    select?: ComplaintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintLogWhereInput
  }

  /**
   * ComplaintCountOutputType without action
   */
  export type ComplaintCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ComplaintStatusCountOutputType
   */

  export type ComplaintStatusCountOutputType = {
    complaints: number
    logs: number
  }

  export type ComplaintStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | ComplaintStatusCountOutputTypeCountComplaintsArgs
    logs?: boolean | ComplaintStatusCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ComplaintStatusCountOutputType without action
   */
  export type ComplaintStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusCountOutputType
     */
    select?: ComplaintStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintStatusCountOutputType without action
   */
  export type ComplaintStatusCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * ComplaintStatusCountOutputType without action
   */
  export type ComplaintStatusCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintLogWhereInput
  }


  /**
   * Count Type ComplaintReportTypeCountOutputType
   */

  export type ComplaintReportTypeCountOutputType = {
    complaints: number
  }

  export type ComplaintReportTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | ComplaintReportTypeCountOutputTypeCountComplaintsArgs
  }

  // Custom InputTypes
  /**
   * ComplaintReportTypeCountOutputType without action
   */
  export type ComplaintReportTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportTypeCountOutputType
     */
    select?: ComplaintReportTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplaintReportTypeCountOutputType without action
   */
  export type ComplaintReportTypeCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    logs: number
    files: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | TaskCountOutputTypeCountLogsArgs
    files?: boolean | TaskCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskFileWhereInput
  }


  /**
   * Count Type TaskStatusCountOutputType
   */

  export type TaskStatusCountOutputType = {
    tasks: number
    logs: number
  }

  export type TaskStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatusCountOutputTypeCountTasksArgs
    logs?: boolean | TaskStatusCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatusCountOutputType
     */
    select?: TaskStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
  }


  /**
   * Count Type TaskDetailPowerInterruptionCountOutputType
   */

  export type TaskDetailPowerInterruptionCountOutputType = {
    linemen_incharge: number
  }

  export type TaskDetailPowerInterruptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailPowerInterruptionCountOutputTypeCountLinemen_inchargeArgs
  }

  // Custom InputTypes
  /**
   * TaskDetailPowerInterruptionCountOutputType without action
   */
  export type TaskDetailPowerInterruptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruptionCountOutputType
     */
    select?: TaskDetailPowerInterruptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskDetailPowerInterruptionCountOutputType without action
   */
  export type TaskDetailPowerInterruptionCountOutputTypeCountLinemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PowerInterruptionLinemanWhereInput
  }


  /**
   * Count Type TaskDetailKwhMeterCountOutputType
   */

  export type TaskDetailKwhMeterCountOutputType = {
    linemen_incharge: number
  }

  export type TaskDetailKwhMeterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailKwhMeterCountOutputTypeCountLinemen_inchargeArgs
  }

  // Custom InputTypes
  /**
   * TaskDetailKwhMeterCountOutputType without action
   */
  export type TaskDetailKwhMeterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeterCountOutputType
     */
    select?: TaskDetailKwhMeterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskDetailKwhMeterCountOutputType without action
   */
  export type TaskDetailKwhMeterCountOutputTypeCountLinemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KwhMeterLinemanWhereInput
  }


  /**
   * Count Type TaskDetailLineServicesCountOutputType
   */

  export type TaskDetailLineServicesCountOutputType = {
    linemen_incharge: number
  }

  export type TaskDetailLineServicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailLineServicesCountOutputTypeCountLinemen_inchargeArgs
  }

  // Custom InputTypes
  /**
   * TaskDetailLineServicesCountOutputType without action
   */
  export type TaskDetailLineServicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServicesCountOutputType
     */
    select?: TaskDetailLineServicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskDetailLineServicesCountOutputType without action
   */
  export type TaskDetailLineServicesCountOutputTypeCountLinemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineServicesLinemanWhereInput
  }


  /**
   * Count Type TaskDetailDlesCountOutputType
   */

  export type TaskDetailDlesCountOutputType = {
    linemen_incharge: number
  }

  export type TaskDetailDlesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailDlesCountOutputTypeCountLinemen_inchargeArgs
  }

  // Custom InputTypes
  /**
   * TaskDetailDlesCountOutputType without action
   */
  export type TaskDetailDlesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDlesCountOutputType
     */
    select?: TaskDetailDlesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskDetailDlesCountOutputType without action
   */
  export type TaskDetailDlesCountOutputTypeCountLinemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DlesLinemanWhereInput
  }


  /**
   * Count Type TaskDetailLmdgaCountOutputType
   */

  export type TaskDetailLmdgaCountOutputType = {
    linemen_incharge: number
  }

  export type TaskDetailLmdgaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailLmdgaCountOutputTypeCountLinemen_inchargeArgs
  }

  // Custom InputTypes
  /**
   * TaskDetailLmdgaCountOutputType without action
   */
  export type TaskDetailLmdgaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdgaCountOutputType
     */
    select?: TaskDetailLmdgaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskDetailLmdgaCountOutputType without action
   */
  export type TaskDetailLmdgaCountOutputTypeCountLinemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LmdgaLinemanWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    username: string | null
    table: string | null
    action: string | null
    reference_id: string | null
    ip_address: string | null
    created_at: Date | null
    notes: string | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    username: string | null
    table: string | null
    action: string | null
    reference_id: string | null
    ip_address: string | null
    created_at: Date | null
    notes: string | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    username: number
    table: number
    action: number
    reference_id: number
    metadata: number
    ip_address: number
    device_info: number
    created_at: number
    notes: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    username?: true
    table?: true
    action?: true
    reference_id?: true
    ip_address?: true
    created_at?: true
    notes?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    username?: true
    table?: true
    action?: true
    reference_id?: true
    ip_address?: true
    created_at?: true
    notes?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    username?: true
    table?: true
    action?: true
    reference_id?: true
    metadata?: true
    ip_address?: true
    device_info?: true
    created_at?: true
    notes?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audit to aggregate.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type AuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithAggregationInput | AuditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: AuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    username: string
    table: string
    action: string
    reference_id: string | null
    metadata: JsonValue | null
    ip_address: string | null
    device_info: JsonValue | null
    created_at: Date
    notes: string | null
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends AuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type AuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    table?: boolean
    action?: boolean
    reference_id?: boolean
    metadata?: boolean
    ip_address?: boolean
    device_info?: boolean
    created_at?: boolean
    notes?: boolean
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    table?: boolean
    action?: boolean
    reference_id?: boolean
    metadata?: boolean
    ip_address?: boolean
    device_info?: boolean
    created_at?: boolean
    notes?: boolean
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectScalar = {
    id?: boolean
    username?: boolean
    table?: boolean
    action?: boolean
    reference_id?: boolean
    metadata?: boolean
    ip_address?: boolean
    device_info?: boolean
    created_at?: boolean
    notes?: boolean
  }


  export type $AuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      table: string
      action: string
      reference_id: string | null
      metadata: Prisma.JsonValue | null
      ip_address: string | null
      device_info: Prisma.JsonValue | null
      created_at: Date
      notes: string | null
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type AuditGetPayload<S extends boolean | null | undefined | AuditDefaultArgs> = $Result.GetResult<Prisma.$AuditPayload, S>

  type AuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface AuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audit'], meta: { name: 'Audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {AuditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFindUniqueArgs>(args: SelectSubset<T, AuditFindUniqueArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFindFirstArgs>(args?: SelectSubset<T, AuditFindFirstArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFindManyArgs>(args?: SelectSubset<T, AuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Audit.
     * @param {AuditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends AuditCreateArgs>(args: SelectSubset<T, AuditCreateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Audits.
     * @param {AuditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditCreateManyArgs>(args?: SelectSubset<T, AuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audits and returns the data saved in the database.
     * @param {AuditCreateManyAndReturnArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Audit.
     * @param {AuditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends AuditDeleteArgs>(args: SelectSubset<T, AuditDeleteArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Audit.
     * @param {AuditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditUpdateArgs>(args: SelectSubset<T, AuditUpdateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Audits.
     * @param {AuditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDeleteManyArgs>(args?: SelectSubset<T, AuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditUpdateManyArgs>(args: SelectSubset<T, AuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit.
     * @param {AuditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends AuditUpsertArgs>(args: SelectSubset<T, AuditUpsertArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditCountArgs>(
      args?: Subset<T, AuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditGroupByArgs['orderBy'] }
        : { orderBy?: AuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audit model
   */
  readonly fields: AuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audit model
   */ 
  interface AuditFieldRefs {
    readonly id: FieldRef<"Audit", 'String'>
    readonly username: FieldRef<"Audit", 'String'>
    readonly table: FieldRef<"Audit", 'String'>
    readonly action: FieldRef<"Audit", 'String'>
    readonly reference_id: FieldRef<"Audit", 'String'>
    readonly metadata: FieldRef<"Audit", 'Json'>
    readonly ip_address: FieldRef<"Audit", 'String'>
    readonly device_info: FieldRef<"Audit", 'Json'>
    readonly created_at: FieldRef<"Audit", 'DateTime'>
    readonly notes: FieldRef<"Audit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Audit findUnique
   */
  export type AuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findUniqueOrThrow
   */
  export type AuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findFirst
   */
  export type AuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findFirstOrThrow
   */
  export type AuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findMany
   */
  export type AuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit create
   */
  export type AuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * The data needed to create a Audit.
     */
    data: XOR<AuditCreateInput, AuditUncheckedCreateInput>
  }

  /**
   * Audit createMany
   */
  export type AuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audit createManyAndReturn
   */
  export type AuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audit update
   */
  export type AuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * The data needed to update a Audit.
     */
    data: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
    /**
     * Choose, which Audit to update.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit updateMany
   */
  export type AuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    limit?: number
  }

  /**
   * Audit upsert
   */
  export type AuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * The filter to search for the Audit to update in case it exists.
     */
    where: AuditWhereUniqueInput
    /**
     * In case the Audit found by the `where` argument doesn't exist, create a new Audit with this data.
     */
    create: XOR<AuditCreateInput, AuditUncheckedCreateInput>
    /**
     * In case the Audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
  }

  /**
   * Audit delete
   */
  export type AuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Filter which Audit to delete.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit deleteMany
   */
  export type AuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditWhereInput
    limit?: number
  }

  /**
   * Audit without action
   */
  export type AuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
  }


  /**
   * Model Lineman
   */

  export type AggregateLineman = {
    _count: LinemanCountAggregateOutputType | null
    _min: LinemanMinAggregateOutputType | null
    _max: LinemanMaxAggregateOutputType | null
  }

  export type LinemanMinAggregateOutputType = {
    id: string | null
    employee_id: string | null
    area_id: string | null
    supervisor_id: string | null
    status: $Enums.LinemanStatus | null
  }

  export type LinemanMaxAggregateOutputType = {
    id: string | null
    employee_id: string | null
    area_id: string | null
    supervisor_id: string | null
    status: $Enums.LinemanStatus | null
  }

  export type LinemanCountAggregateOutputType = {
    id: number
    employee_id: number
    area_id: number
    supervisor_id: number
    status: number
    _all: number
  }


  export type LinemanMinAggregateInputType = {
    id?: true
    employee_id?: true
    area_id?: true
    supervisor_id?: true
    status?: true
  }

  export type LinemanMaxAggregateInputType = {
    id?: true
    employee_id?: true
    area_id?: true
    supervisor_id?: true
    status?: true
  }

  export type LinemanCountAggregateInputType = {
    id?: true
    employee_id?: true
    area_id?: true
    supervisor_id?: true
    status?: true
    _all?: true
  }

  export type LinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lineman to aggregate.
     */
    where?: LinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Linemen to fetch.
     */
    orderBy?: LinemanOrderByWithRelationInput | LinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Linemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Linemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Linemen
    **/
    _count?: true | LinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinemanMaxAggregateInputType
  }

  export type GetLinemanAggregateType<T extends LinemanAggregateArgs> = {
        [P in keyof T & keyof AggregateLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineman[P]>
      : GetScalarType<T[P], AggregateLineman[P]>
  }




  export type LinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinemanWhereInput
    orderBy?: LinemanOrderByWithAggregationInput | LinemanOrderByWithAggregationInput[]
    by: LinemanScalarFieldEnum[] | LinemanScalarFieldEnum
    having?: LinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinemanCountAggregateInputType | true
    _min?: LinemanMinAggregateInputType
    _max?: LinemanMaxAggregateInputType
  }

  export type LinemanGroupByOutputType = {
    id: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status: $Enums.LinemanStatus
    _count: LinemanCountAggregateOutputType | null
    _min: LinemanMinAggregateOutputType | null
    _max: LinemanMaxAggregateOutputType | null
  }

  type GetLinemanGroupByPayload<T extends LinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinemanGroupByOutputType[P]>
            : GetScalarType<T[P], LinemanGroupByOutputType[P]>
        }
      >
    >


  export type LinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    area_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    power_interruptions?: boolean | Lineman$power_interruptionsArgs<ExtArgs>
    kwh_meters?: boolean | Lineman$kwh_metersArgs<ExtArgs>
    line_services?: boolean | Lineman$line_servicesArgs<ExtArgs>
    dles?: boolean | Lineman$dlesArgs<ExtArgs>
    lmdgas?: boolean | Lineman$lmdgasArgs<ExtArgs>
    _count?: boolean | LinemanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineman"]>

  export type LinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    area_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineman"]>

  export type LinemanSelectScalar = {
    id?: boolean
    employee_id?: boolean
    area_id?: boolean
    supervisor_id?: boolean
    status?: boolean
  }

  export type LinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    power_interruptions?: boolean | Lineman$power_interruptionsArgs<ExtArgs>
    kwh_meters?: boolean | Lineman$kwh_metersArgs<ExtArgs>
    line_services?: boolean | Lineman$line_servicesArgs<ExtArgs>
    dles?: boolean | Lineman$dlesArgs<ExtArgs>
    lmdgas?: boolean | Lineman$lmdgasArgs<ExtArgs>
    _count?: boolean | LinemanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }

  export type $LinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lineman"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      power_interruptions: Prisma.$PowerInterruptionLinemanPayload<ExtArgs>[]
      kwh_meters: Prisma.$KwhMeterLinemanPayload<ExtArgs>[]
      line_services: Prisma.$LineServicesLinemanPayload<ExtArgs>[]
      dles: Prisma.$DlesLinemanPayload<ExtArgs>[]
      lmdgas: Prisma.$LmdgaLinemanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employee_id: string
      area_id: string
      supervisor_id: string
      status: $Enums.LinemanStatus
    }, ExtArgs["result"]["lineman"]>
    composites: {}
  }

  type LinemanGetPayload<S extends boolean | null | undefined | LinemanDefaultArgs> = $Result.GetResult<Prisma.$LinemanPayload, S>

  type LinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LinemanCountAggregateInputType | true
    }

  export interface LinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lineman'], meta: { name: 'Lineman' } }
    /**
     * Find zero or one Lineman that matches the filter.
     * @param {LinemanFindUniqueArgs} args - Arguments to find a Lineman
     * @example
     * // Get one Lineman
     * const lineman = await prisma.lineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinemanFindUniqueArgs>(args: SelectSubset<T, LinemanFindUniqueArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LinemanFindUniqueOrThrowArgs} args - Arguments to find a Lineman
     * @example
     * // Get one Lineman
     * const lineman = await prisma.lineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, LinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanFindFirstArgs} args - Arguments to find a Lineman
     * @example
     * // Get one Lineman
     * const lineman = await prisma.lineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinemanFindFirstArgs>(args?: SelectSubset<T, LinemanFindFirstArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanFindFirstOrThrowArgs} args - Arguments to find a Lineman
     * @example
     * // Get one Lineman
     * const lineman = await prisma.lineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, LinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Linemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Linemen
     * const linemen = await prisma.lineman.findMany()
     * 
     * // Get first 10 Linemen
     * const linemen = await prisma.lineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linemanWithIdOnly = await prisma.lineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinemanFindManyArgs>(args?: SelectSubset<T, LinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lineman.
     * @param {LinemanCreateArgs} args - Arguments to create a Lineman.
     * @example
     * // Create one Lineman
     * const Lineman = await prisma.lineman.create({
     *   data: {
     *     // ... data to create a Lineman
     *   }
     * })
     * 
     */
    create<T extends LinemanCreateArgs>(args: SelectSubset<T, LinemanCreateArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Linemen.
     * @param {LinemanCreateManyArgs} args - Arguments to create many Linemen.
     * @example
     * // Create many Linemen
     * const lineman = await prisma.lineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinemanCreateManyArgs>(args?: SelectSubset<T, LinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Linemen and returns the data saved in the database.
     * @param {LinemanCreateManyAndReturnArgs} args - Arguments to create many Linemen.
     * @example
     * // Create many Linemen
     * const lineman = await prisma.lineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Linemen and only return the `id`
     * const linemanWithIdOnly = await prisma.lineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, LinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lineman.
     * @param {LinemanDeleteArgs} args - Arguments to delete one Lineman.
     * @example
     * // Delete one Lineman
     * const Lineman = await prisma.lineman.delete({
     *   where: {
     *     // ... filter to delete one Lineman
     *   }
     * })
     * 
     */
    delete<T extends LinemanDeleteArgs>(args: SelectSubset<T, LinemanDeleteArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lineman.
     * @param {LinemanUpdateArgs} args - Arguments to update one Lineman.
     * @example
     * // Update one Lineman
     * const lineman = await prisma.lineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinemanUpdateArgs>(args: SelectSubset<T, LinemanUpdateArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Linemen.
     * @param {LinemanDeleteManyArgs} args - Arguments to filter Linemen to delete.
     * @example
     * // Delete a few Linemen
     * const { count } = await prisma.lineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinemanDeleteManyArgs>(args?: SelectSubset<T, LinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Linemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Linemen
     * const lineman = await prisma.lineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinemanUpdateManyArgs>(args: SelectSubset<T, LinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lineman.
     * @param {LinemanUpsertArgs} args - Arguments to update or create a Lineman.
     * @example
     * // Update or create a Lineman
     * const lineman = await prisma.lineman.upsert({
     *   create: {
     *     // ... data to create a Lineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lineman we want to update
     *   }
     * })
     */
    upsert<T extends LinemanUpsertArgs>(args: SelectSubset<T, LinemanUpsertArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Linemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanCountArgs} args - Arguments to filter Linemen to count.
     * @example
     * // Count the number of Linemen
     * const count = await prisma.lineman.count({
     *   where: {
     *     // ... the filter for the Linemen we want to count
     *   }
     * })
    **/
    count<T extends LinemanCountArgs>(
      args?: Subset<T, LinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinemanAggregateArgs>(args: Subset<T, LinemanAggregateArgs>): Prisma.PrismaPromise<GetLinemanAggregateType<T>>

    /**
     * Group by Lineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinemanGroupByArgs['orderBy'] }
        : { orderBy?: LinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lineman model
   */
  readonly fields: LinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    power_interruptions<T extends Lineman$power_interruptionsArgs<ExtArgs> = {}>(args?: Subset<T, Lineman$power_interruptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    kwh_meters<T extends Lineman$kwh_metersArgs<ExtArgs> = {}>(args?: Subset<T, Lineman$kwh_metersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    line_services<T extends Lineman$line_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Lineman$line_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    dles<T extends Lineman$dlesArgs<ExtArgs> = {}>(args?: Subset<T, Lineman$dlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    lmdgas<T extends Lineman$lmdgasArgs<ExtArgs> = {}>(args?: Subset<T, Lineman$lmdgasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lineman model
   */ 
  interface LinemanFieldRefs {
    readonly id: FieldRef<"Lineman", 'String'>
    readonly employee_id: FieldRef<"Lineman", 'String'>
    readonly area_id: FieldRef<"Lineman", 'String'>
    readonly supervisor_id: FieldRef<"Lineman", 'String'>
    readonly status: FieldRef<"Lineman", 'LinemanStatus'>
  }
    

  // Custom InputTypes
  /**
   * Lineman findUnique
   */
  export type LinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter, which Lineman to fetch.
     */
    where: LinemanWhereUniqueInput
  }

  /**
   * Lineman findUniqueOrThrow
   */
  export type LinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter, which Lineman to fetch.
     */
    where: LinemanWhereUniqueInput
  }

  /**
   * Lineman findFirst
   */
  export type LinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter, which Lineman to fetch.
     */
    where?: LinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Linemen to fetch.
     */
    orderBy?: LinemanOrderByWithRelationInput | LinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Linemen.
     */
    cursor?: LinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Linemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Linemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Linemen.
     */
    distinct?: LinemanScalarFieldEnum | LinemanScalarFieldEnum[]
  }

  /**
   * Lineman findFirstOrThrow
   */
  export type LinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter, which Lineman to fetch.
     */
    where?: LinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Linemen to fetch.
     */
    orderBy?: LinemanOrderByWithRelationInput | LinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Linemen.
     */
    cursor?: LinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Linemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Linemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Linemen.
     */
    distinct?: LinemanScalarFieldEnum | LinemanScalarFieldEnum[]
  }

  /**
   * Lineman findMany
   */
  export type LinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter, which Linemen to fetch.
     */
    where?: LinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Linemen to fetch.
     */
    orderBy?: LinemanOrderByWithRelationInput | LinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Linemen.
     */
    cursor?: LinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Linemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Linemen.
     */
    skip?: number
    distinct?: LinemanScalarFieldEnum | LinemanScalarFieldEnum[]
  }

  /**
   * Lineman create
   */
  export type LinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a Lineman.
     */
    data: XOR<LinemanCreateInput, LinemanUncheckedCreateInput>
  }

  /**
   * Lineman createMany
   */
  export type LinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Linemen.
     */
    data: LinemanCreateManyInput | LinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lineman createManyAndReturn
   */
  export type LinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Linemen.
     */
    data: LinemanCreateManyInput | LinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lineman update
   */
  export type LinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a Lineman.
     */
    data: XOR<LinemanUpdateInput, LinemanUncheckedUpdateInput>
    /**
     * Choose, which Lineman to update.
     */
    where: LinemanWhereUniqueInput
  }

  /**
   * Lineman updateMany
   */
  export type LinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Linemen.
     */
    data: XOR<LinemanUpdateManyMutationInput, LinemanUncheckedUpdateManyInput>
    /**
     * Filter which Linemen to update
     */
    where?: LinemanWhereInput
    limit?: number
  }

  /**
   * Lineman upsert
   */
  export type LinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the Lineman to update in case it exists.
     */
    where: LinemanWhereUniqueInput
    /**
     * In case the Lineman found by the `where` argument doesn't exist, create a new Lineman with this data.
     */
    create: XOR<LinemanCreateInput, LinemanUncheckedCreateInput>
    /**
     * In case the Lineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinemanUpdateInput, LinemanUncheckedUpdateInput>
  }

  /**
   * Lineman delete
   */
  export type LinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    /**
     * Filter which Lineman to delete.
     */
    where: LinemanWhereUniqueInput
  }

  /**
   * Lineman deleteMany
   */
  export type LinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Linemen to delete
     */
    where?: LinemanWhereInput
    limit?: number
  }

  /**
   * Lineman.power_interruptions
   */
  export type Lineman$power_interruptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    where?: PowerInterruptionLinemanWhereInput
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PowerInterruptionLinemanScalarFieldEnum | PowerInterruptionLinemanScalarFieldEnum[]
  }

  /**
   * Lineman.kwh_meters
   */
  export type Lineman$kwh_metersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    where?: KwhMeterLinemanWhereInput
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    cursor?: KwhMeterLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KwhMeterLinemanScalarFieldEnum | KwhMeterLinemanScalarFieldEnum[]
  }

  /**
   * Lineman.line_services
   */
  export type Lineman$line_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    where?: LineServicesLinemanWhereInput
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    cursor?: LineServicesLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineServicesLinemanScalarFieldEnum | LineServicesLinemanScalarFieldEnum[]
  }

  /**
   * Lineman.dles
   */
  export type Lineman$dlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    where?: DlesLinemanWhereInput
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    cursor?: DlesLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DlesLinemanScalarFieldEnum | DlesLinemanScalarFieldEnum[]
  }

  /**
   * Lineman.lmdgas
   */
  export type Lineman$lmdgasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    where?: LmdgaLinemanWhereInput
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    cursor?: LmdgaLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LmdgaLinemanScalarFieldEnum | LmdgaLinemanScalarFieldEnum[]
  }

  /**
   * Lineman without action
   */
  export type LinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaMinAggregateOutputType = {
    id: string | null
    oic_id: string | null
    name: string | null
  }

  export type AreaMaxAggregateOutputType = {
    id: string | null
    oic_id: string | null
    name: string | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    oic_id: number
    name: number
    _all: number
  }


  export type AreaMinAggregateInputType = {
    id?: true
    oic_id?: true
    name?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    oic_id?: true
    name?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    oic_id?: true
    name?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: string
    oic_id: string
    name: string
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oic_id?: boolean
    name?: boolean
    linemen?: boolean | Area$linemenArgs<ExtArgs>
    municipalities?: boolean | Area$municipalitiesArgs<ExtArgs>
    task_assignments?: boolean | Area$task_assignmentsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oic_id?: boolean
    name?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    oic_id?: boolean
    name?: boolean
  }

  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen?: boolean | Area$linemenArgs<ExtArgs>
    municipalities?: boolean | Area$municipalitiesArgs<ExtArgs>
    task_assignments?: boolean | Area$task_assignmentsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      linemen: Prisma.$LinemanPayload<ExtArgs>[]
      municipalities: Prisma.$MunicipalityPayload<ExtArgs>[]
      task_assignments: Prisma.$TaskAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      oic_id: string
      name: string
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen<T extends Area$linemenArgs<ExtArgs> = {}>(args?: Subset<T, Area$linemenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findMany"> | Null>
    municipalities<T extends Area$municipalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Area$municipalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany"> | Null>
    task_assignments<T extends Area$task_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Area$task_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */ 
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'String'>
    readonly oic_id: FieldRef<"Area", 'String'>
    readonly name: FieldRef<"Area", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    limit?: number
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
    limit?: number
  }

  /**
   * Area.linemen
   */
  export type Area$linemenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineman
     */
    select?: LinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinemanInclude<ExtArgs> | null
    where?: LinemanWhereInput
    orderBy?: LinemanOrderByWithRelationInput | LinemanOrderByWithRelationInput[]
    cursor?: LinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinemanScalarFieldEnum | LinemanScalarFieldEnum[]
  }

  /**
   * Area.municipalities
   */
  export type Area$municipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    cursor?: MunicipalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Area.task_assignments
   */
  export type Area$task_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Municipality
   */

  export type AggregateMunicipality = {
    _count: MunicipalityCountAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  export type MunicipalityMinAggregateOutputType = {
    id: string | null
    area_id: string | null
    name: string | null
  }

  export type MunicipalityMaxAggregateOutputType = {
    id: string | null
    area_id: string | null
    name: string | null
  }

  export type MunicipalityCountAggregateOutputType = {
    id: number
    area_id: number
    name: number
    _all: number
  }


  export type MunicipalityMinAggregateInputType = {
    id?: true
    area_id?: true
    name?: true
  }

  export type MunicipalityMaxAggregateInputType = {
    id?: true
    area_id?: true
    name?: true
  }

  export type MunicipalityCountAggregateInputType = {
    id?: true
    area_id?: true
    name?: true
    _all?: true
  }

  export type MunicipalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipality to aggregate.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipalities
    **/
    _count?: true | MunicipalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalityMaxAggregateInputType
  }

  export type GetMunicipalityAggregateType<T extends MunicipalityAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipality[P]>
      : GetScalarType<T[P], AggregateMunicipality[P]>
  }




  export type MunicipalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithAggregationInput | MunicipalityOrderByWithAggregationInput[]
    by: MunicipalityScalarFieldEnum[] | MunicipalityScalarFieldEnum
    having?: MunicipalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalityCountAggregateInputType | true
    _min?: MunicipalityMinAggregateInputType
    _max?: MunicipalityMaxAggregateInputType
  }

  export type MunicipalityGroupByOutputType = {
    id: string
    area_id: string
    name: string
    _count: MunicipalityCountAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  type GetMunicipalityGroupByPayload<T extends MunicipalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
        }
      >
    >


  export type MunicipalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    name?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    barangays?: boolean | Municipality$barangaysArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    name?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectScalar = {
    id?: boolean
    area_id?: boolean
    name?: boolean
  }

  export type MunicipalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    barangays?: boolean | Municipality$barangaysArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }

  export type $MunicipalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipality"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      barangays: Prisma.$BarangayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      area_id: string
      name: string
    }, ExtArgs["result"]["municipality"]>
    composites: {}
  }

  type MunicipalityGetPayload<S extends boolean | null | undefined | MunicipalityDefaultArgs> = $Result.GetResult<Prisma.$MunicipalityPayload, S>

  type MunicipalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipalityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipalityCountAggregateInputType | true
    }

  export interface MunicipalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipality'], meta: { name: 'Municipality' } }
    /**
     * Find zero or one Municipality that matches the filter.
     * @param {MunicipalityFindUniqueArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipalityFindUniqueArgs>(args: SelectSubset<T, MunicipalityFindUniqueArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipalityFindUniqueOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipalityFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipalityFindFirstArgs>(args?: SelectSubset<T, MunicipalityFindFirstArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipalityFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipalities
     * const municipalities = await prisma.municipality.findMany()
     * 
     * // Get first 10 Municipalities
     * const municipalities = await prisma.municipality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalityWithIdOnly = await prisma.municipality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MunicipalityFindManyArgs>(args?: SelectSubset<T, MunicipalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipality.
     * @param {MunicipalityCreateArgs} args - Arguments to create a Municipality.
     * @example
     * // Create one Municipality
     * const Municipality = await prisma.municipality.create({
     *   data: {
     *     // ... data to create a Municipality
     *   }
     * })
     * 
     */
    create<T extends MunicipalityCreateArgs>(args: SelectSubset<T, MunicipalityCreateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipalities.
     * @param {MunicipalityCreateManyArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipalityCreateManyArgs>(args?: SelectSubset<T, MunicipalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Municipalities and returns the data saved in the database.
     * @param {MunicipalityCreateManyAndReturnArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MunicipalityCreateManyAndReturnArgs>(args?: SelectSubset<T, MunicipalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Municipality.
     * @param {MunicipalityDeleteArgs} args - Arguments to delete one Municipality.
     * @example
     * // Delete one Municipality
     * const Municipality = await prisma.municipality.delete({
     *   where: {
     *     // ... filter to delete one Municipality
     *   }
     * })
     * 
     */
    delete<T extends MunicipalityDeleteArgs>(args: SelectSubset<T, MunicipalityDeleteArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipality.
     * @param {MunicipalityUpdateArgs} args - Arguments to update one Municipality.
     * @example
     * // Update one Municipality
     * const municipality = await prisma.municipality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipalityUpdateArgs>(args: SelectSubset<T, MunicipalityUpdateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipalities.
     * @param {MunicipalityDeleteManyArgs} args - Arguments to filter Municipalities to delete.
     * @example
     * // Delete a few Municipalities
     * const { count } = await prisma.municipality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipalityDeleteManyArgs>(args?: SelectSubset<T, MunicipalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipalityUpdateManyArgs>(args: SelectSubset<T, MunicipalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipality.
     * @param {MunicipalityUpsertArgs} args - Arguments to update or create a Municipality.
     * @example
     * // Update or create a Municipality
     * const municipality = await prisma.municipality.upsert({
     *   create: {
     *     // ... data to create a Municipality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipality we want to update
     *   }
     * })
     */
    upsert<T extends MunicipalityUpsertArgs>(args: SelectSubset<T, MunicipalityUpsertArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityCountArgs} args - Arguments to filter Municipalities to count.
     * @example
     * // Count the number of Municipalities
     * const count = await prisma.municipality.count({
     *   where: {
     *     // ... the filter for the Municipalities we want to count
     *   }
     * })
    **/
    count<T extends MunicipalityCountArgs>(
      args?: Subset<T, MunicipalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalityAggregateArgs>(args: Subset<T, MunicipalityAggregateArgs>): Prisma.PrismaPromise<GetMunicipalityAggregateType<T>>

    /**
     * Group by Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipalityGroupByArgs['orderBy'] }
        : { orderBy?: MunicipalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipality model
   */
  readonly fields: MunicipalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    barangays<T extends Municipality$barangaysArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$barangaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipality model
   */ 
  interface MunicipalityFieldRefs {
    readonly id: FieldRef<"Municipality", 'String'>
    readonly area_id: FieldRef<"Municipality", 'String'>
    readonly name: FieldRef<"Municipality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Municipality findUnique
   */
  export type MunicipalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findUniqueOrThrow
   */
  export type MunicipalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findFirst
   */
  export type MunicipalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findFirstOrThrow
   */
  export type MunicipalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findMany
   */
  export type MunicipalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipalities to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality create
   */
  export type MunicipalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipality.
     */
    data: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
  }

  /**
   * Municipality createMany
   */
  export type MunicipalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipality createManyAndReturn
   */
  export type MunicipalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Municipality update
   */
  export type MunicipalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipality.
     */
    data: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
    /**
     * Choose, which Municipality to update.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality updateMany
   */
  export type MunicipalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
    limit?: number
  }

  /**
   * Municipality upsert
   */
  export type MunicipalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipality to update in case it exists.
     */
    where: MunicipalityWhereUniqueInput
    /**
     * In case the Municipality found by the `where` argument doesn't exist, create a new Municipality with this data.
     */
    create: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
    /**
     * In case the Municipality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
  }

  /**
   * Municipality delete
   */
  export type MunicipalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter which Municipality to delete.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality deleteMany
   */
  export type MunicipalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipalities to delete
     */
    where?: MunicipalityWhereInput
    limit?: number
  }

  /**
   * Municipality.barangays
   */
  export type Municipality$barangaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    where?: BarangayWhereInput
    orderBy?: BarangayOrderByWithRelationInput | BarangayOrderByWithRelationInput[]
    cursor?: BarangayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarangayScalarFieldEnum | BarangayScalarFieldEnum[]
  }

  /**
   * Municipality without action
   */
  export type MunicipalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
  }


  /**
   * Model Barangay
   */

  export type AggregateBarangay = {
    _count: BarangayCountAggregateOutputType | null
    _min: BarangayMinAggregateOutputType | null
    _max: BarangayMaxAggregateOutputType | null
  }

  export type BarangayMinAggregateOutputType = {
    id: string | null
    municipality_id: string | null
    name: string | null
  }

  export type BarangayMaxAggregateOutputType = {
    id: string | null
    municipality_id: string | null
    name: string | null
  }

  export type BarangayCountAggregateOutputType = {
    id: number
    municipality_id: number
    name: number
    _all: number
  }


  export type BarangayMinAggregateInputType = {
    id?: true
    municipality_id?: true
    name?: true
  }

  export type BarangayMaxAggregateInputType = {
    id?: true
    municipality_id?: true
    name?: true
  }

  export type BarangayCountAggregateInputType = {
    id?: true
    municipality_id?: true
    name?: true
    _all?: true
  }

  export type BarangayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Barangay to aggregate.
     */
    where?: BarangayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barangays to fetch.
     */
    orderBy?: BarangayOrderByWithRelationInput | BarangayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarangayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barangays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barangays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Barangays
    **/
    _count?: true | BarangayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarangayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarangayMaxAggregateInputType
  }

  export type GetBarangayAggregateType<T extends BarangayAggregateArgs> = {
        [P in keyof T & keyof AggregateBarangay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarangay[P]>
      : GetScalarType<T[P], AggregateBarangay[P]>
  }




  export type BarangayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarangayWhereInput
    orderBy?: BarangayOrderByWithAggregationInput | BarangayOrderByWithAggregationInput[]
    by: BarangayScalarFieldEnum[] | BarangayScalarFieldEnum
    having?: BarangayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarangayCountAggregateInputType | true
    _min?: BarangayMinAggregateInputType
    _max?: BarangayMaxAggregateInputType
  }

  export type BarangayGroupByOutputType = {
    id: string
    municipality_id: string
    name: string
    _count: BarangayCountAggregateOutputType | null
    _min: BarangayMinAggregateOutputType | null
    _max: BarangayMaxAggregateOutputType | null
  }

  type GetBarangayGroupByPayload<T extends BarangayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarangayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarangayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarangayGroupByOutputType[P]>
            : GetScalarType<T[P], BarangayGroupByOutputType[P]>
        }
      >
    >


  export type BarangaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    municipality_id?: boolean
    name?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    sitios?: boolean | Barangay$sitiosArgs<ExtArgs>
    complaint_details?: boolean | Barangay$complaint_detailsArgs<ExtArgs>
    _count?: boolean | BarangayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barangay"]>

  export type BarangaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    municipality_id?: boolean
    name?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barangay"]>

  export type BarangaySelectScalar = {
    id?: boolean
    municipality_id?: boolean
    name?: boolean
  }

  export type BarangayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    sitios?: boolean | Barangay$sitiosArgs<ExtArgs>
    complaint_details?: boolean | Barangay$complaint_detailsArgs<ExtArgs>
    _count?: boolean | BarangayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BarangayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }

  export type $BarangayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Barangay"
    objects: {
      municipality: Prisma.$MunicipalityPayload<ExtArgs>
      sitios: Prisma.$SitioPayload<ExtArgs>[]
      complaint_details: Prisma.$ComplaintDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      municipality_id: string
      name: string
    }, ExtArgs["result"]["barangay"]>
    composites: {}
  }

  type BarangayGetPayload<S extends boolean | null | undefined | BarangayDefaultArgs> = $Result.GetResult<Prisma.$BarangayPayload, S>

  type BarangayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BarangayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BarangayCountAggregateInputType | true
    }

  export interface BarangayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Barangay'], meta: { name: 'Barangay' } }
    /**
     * Find zero or one Barangay that matches the filter.
     * @param {BarangayFindUniqueArgs} args - Arguments to find a Barangay
     * @example
     * // Get one Barangay
     * const barangay = await prisma.barangay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarangayFindUniqueArgs>(args: SelectSubset<T, BarangayFindUniqueArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Barangay that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BarangayFindUniqueOrThrowArgs} args - Arguments to find a Barangay
     * @example
     * // Get one Barangay
     * const barangay = await prisma.barangay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarangayFindUniqueOrThrowArgs>(args: SelectSubset<T, BarangayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Barangay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayFindFirstArgs} args - Arguments to find a Barangay
     * @example
     * // Get one Barangay
     * const barangay = await prisma.barangay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarangayFindFirstArgs>(args?: SelectSubset<T, BarangayFindFirstArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Barangay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayFindFirstOrThrowArgs} args - Arguments to find a Barangay
     * @example
     * // Get one Barangay
     * const barangay = await prisma.barangay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarangayFindFirstOrThrowArgs>(args?: SelectSubset<T, BarangayFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Barangays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barangays
     * const barangays = await prisma.barangay.findMany()
     * 
     * // Get first 10 Barangays
     * const barangays = await prisma.barangay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barangayWithIdOnly = await prisma.barangay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarangayFindManyArgs>(args?: SelectSubset<T, BarangayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Barangay.
     * @param {BarangayCreateArgs} args - Arguments to create a Barangay.
     * @example
     * // Create one Barangay
     * const Barangay = await prisma.barangay.create({
     *   data: {
     *     // ... data to create a Barangay
     *   }
     * })
     * 
     */
    create<T extends BarangayCreateArgs>(args: SelectSubset<T, BarangayCreateArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Barangays.
     * @param {BarangayCreateManyArgs} args - Arguments to create many Barangays.
     * @example
     * // Create many Barangays
     * const barangay = await prisma.barangay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarangayCreateManyArgs>(args?: SelectSubset<T, BarangayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Barangays and returns the data saved in the database.
     * @param {BarangayCreateManyAndReturnArgs} args - Arguments to create many Barangays.
     * @example
     * // Create many Barangays
     * const barangay = await prisma.barangay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Barangays and only return the `id`
     * const barangayWithIdOnly = await prisma.barangay.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarangayCreateManyAndReturnArgs>(args?: SelectSubset<T, BarangayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Barangay.
     * @param {BarangayDeleteArgs} args - Arguments to delete one Barangay.
     * @example
     * // Delete one Barangay
     * const Barangay = await prisma.barangay.delete({
     *   where: {
     *     // ... filter to delete one Barangay
     *   }
     * })
     * 
     */
    delete<T extends BarangayDeleteArgs>(args: SelectSubset<T, BarangayDeleteArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Barangay.
     * @param {BarangayUpdateArgs} args - Arguments to update one Barangay.
     * @example
     * // Update one Barangay
     * const barangay = await prisma.barangay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarangayUpdateArgs>(args: SelectSubset<T, BarangayUpdateArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Barangays.
     * @param {BarangayDeleteManyArgs} args - Arguments to filter Barangays to delete.
     * @example
     * // Delete a few Barangays
     * const { count } = await prisma.barangay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarangayDeleteManyArgs>(args?: SelectSubset<T, BarangayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Barangays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barangays
     * const barangay = await prisma.barangay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarangayUpdateManyArgs>(args: SelectSubset<T, BarangayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Barangay.
     * @param {BarangayUpsertArgs} args - Arguments to update or create a Barangay.
     * @example
     * // Update or create a Barangay
     * const barangay = await prisma.barangay.upsert({
     *   create: {
     *     // ... data to create a Barangay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barangay we want to update
     *   }
     * })
     */
    upsert<T extends BarangayUpsertArgs>(args: SelectSubset<T, BarangayUpsertArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Barangays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayCountArgs} args - Arguments to filter Barangays to count.
     * @example
     * // Count the number of Barangays
     * const count = await prisma.barangay.count({
     *   where: {
     *     // ... the filter for the Barangays we want to count
     *   }
     * })
    **/
    count<T extends BarangayCountArgs>(
      args?: Subset<T, BarangayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarangayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Barangay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarangayAggregateArgs>(args: Subset<T, BarangayAggregateArgs>): Prisma.PrismaPromise<GetBarangayAggregateType<T>>

    /**
     * Group by Barangay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarangayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarangayGroupByArgs['orderBy'] }
        : { orderBy?: BarangayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarangayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarangayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Barangay model
   */
  readonly fields: BarangayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Barangay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarangayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipality<T extends MunicipalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipalityDefaultArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sitios<T extends Barangay$sitiosArgs<ExtArgs> = {}>(args?: Subset<T, Barangay$sitiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findMany"> | Null>
    complaint_details<T extends Barangay$complaint_detailsArgs<ExtArgs> = {}>(args?: Subset<T, Barangay$complaint_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Barangay model
   */ 
  interface BarangayFieldRefs {
    readonly id: FieldRef<"Barangay", 'String'>
    readonly municipality_id: FieldRef<"Barangay", 'String'>
    readonly name: FieldRef<"Barangay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Barangay findUnique
   */
  export type BarangayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter, which Barangay to fetch.
     */
    where: BarangayWhereUniqueInput
  }

  /**
   * Barangay findUniqueOrThrow
   */
  export type BarangayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter, which Barangay to fetch.
     */
    where: BarangayWhereUniqueInput
  }

  /**
   * Barangay findFirst
   */
  export type BarangayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter, which Barangay to fetch.
     */
    where?: BarangayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barangays to fetch.
     */
    orderBy?: BarangayOrderByWithRelationInput | BarangayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Barangays.
     */
    cursor?: BarangayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barangays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barangays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Barangays.
     */
    distinct?: BarangayScalarFieldEnum | BarangayScalarFieldEnum[]
  }

  /**
   * Barangay findFirstOrThrow
   */
  export type BarangayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter, which Barangay to fetch.
     */
    where?: BarangayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barangays to fetch.
     */
    orderBy?: BarangayOrderByWithRelationInput | BarangayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Barangays.
     */
    cursor?: BarangayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barangays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barangays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Barangays.
     */
    distinct?: BarangayScalarFieldEnum | BarangayScalarFieldEnum[]
  }

  /**
   * Barangay findMany
   */
  export type BarangayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter, which Barangays to fetch.
     */
    where?: BarangayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barangays to fetch.
     */
    orderBy?: BarangayOrderByWithRelationInput | BarangayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Barangays.
     */
    cursor?: BarangayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barangays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barangays.
     */
    skip?: number
    distinct?: BarangayScalarFieldEnum | BarangayScalarFieldEnum[]
  }

  /**
   * Barangay create
   */
  export type BarangayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * The data needed to create a Barangay.
     */
    data: XOR<BarangayCreateInput, BarangayUncheckedCreateInput>
  }

  /**
   * Barangay createMany
   */
  export type BarangayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Barangays.
     */
    data: BarangayCreateManyInput | BarangayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Barangay createManyAndReturn
   */
  export type BarangayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Barangays.
     */
    data: BarangayCreateManyInput | BarangayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Barangay update
   */
  export type BarangayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * The data needed to update a Barangay.
     */
    data: XOR<BarangayUpdateInput, BarangayUncheckedUpdateInput>
    /**
     * Choose, which Barangay to update.
     */
    where: BarangayWhereUniqueInput
  }

  /**
   * Barangay updateMany
   */
  export type BarangayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Barangays.
     */
    data: XOR<BarangayUpdateManyMutationInput, BarangayUncheckedUpdateManyInput>
    /**
     * Filter which Barangays to update
     */
    where?: BarangayWhereInput
    limit?: number
  }

  /**
   * Barangay upsert
   */
  export type BarangayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * The filter to search for the Barangay to update in case it exists.
     */
    where: BarangayWhereUniqueInput
    /**
     * In case the Barangay found by the `where` argument doesn't exist, create a new Barangay with this data.
     */
    create: XOR<BarangayCreateInput, BarangayUncheckedCreateInput>
    /**
     * In case the Barangay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarangayUpdateInput, BarangayUncheckedUpdateInput>
  }

  /**
   * Barangay delete
   */
  export type BarangayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
    /**
     * Filter which Barangay to delete.
     */
    where: BarangayWhereUniqueInput
  }

  /**
   * Barangay deleteMany
   */
  export type BarangayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Barangays to delete
     */
    where?: BarangayWhereInput
    limit?: number
  }

  /**
   * Barangay.sitios
   */
  export type Barangay$sitiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    where?: SitioWhereInput
    orderBy?: SitioOrderByWithRelationInput | SitioOrderByWithRelationInput[]
    cursor?: SitioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SitioScalarFieldEnum | SitioScalarFieldEnum[]
  }

  /**
   * Barangay.complaint_details
   */
  export type Barangay$complaint_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    where?: ComplaintDetailWhereInput
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    cursor?: ComplaintDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintDetailScalarFieldEnum | ComplaintDetailScalarFieldEnum[]
  }

  /**
   * Barangay without action
   */
  export type BarangayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barangay
     */
    select?: BarangaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarangayInclude<ExtArgs> | null
  }


  /**
   * Model Sitio
   */

  export type AggregateSitio = {
    _count: SitioCountAggregateOutputType | null
    _min: SitioMinAggregateOutputType | null
    _max: SitioMaxAggregateOutputType | null
  }

  export type SitioMinAggregateOutputType = {
    id: string | null
    barangay_id: string | null
    name: string | null
  }

  export type SitioMaxAggregateOutputType = {
    id: string | null
    barangay_id: string | null
    name: string | null
  }

  export type SitioCountAggregateOutputType = {
    id: number
    barangay_id: number
    name: number
    _all: number
  }


  export type SitioMinAggregateInputType = {
    id?: true
    barangay_id?: true
    name?: true
  }

  export type SitioMaxAggregateInputType = {
    id?: true
    barangay_id?: true
    name?: true
  }

  export type SitioCountAggregateInputType = {
    id?: true
    barangay_id?: true
    name?: true
    _all?: true
  }

  export type SitioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sitio to aggregate.
     */
    where?: SitioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sitios to fetch.
     */
    orderBy?: SitioOrderByWithRelationInput | SitioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SitioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sitios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sitios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sitios
    **/
    _count?: true | SitioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitioMaxAggregateInputType
  }

  export type GetSitioAggregateType<T extends SitioAggregateArgs> = {
        [P in keyof T & keyof AggregateSitio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSitio[P]>
      : GetScalarType<T[P], AggregateSitio[P]>
  }




  export type SitioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitioWhereInput
    orderBy?: SitioOrderByWithAggregationInput | SitioOrderByWithAggregationInput[]
    by: SitioScalarFieldEnum[] | SitioScalarFieldEnum
    having?: SitioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitioCountAggregateInputType | true
    _min?: SitioMinAggregateInputType
    _max?: SitioMaxAggregateInputType
  }

  export type SitioGroupByOutputType = {
    id: string
    barangay_id: string
    name: string
    _count: SitioCountAggregateOutputType | null
    _min: SitioMinAggregateOutputType | null
    _max: SitioMaxAggregateOutputType | null
  }

  type GetSitioGroupByPayload<T extends SitioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitioGroupByOutputType[P]>
            : GetScalarType<T[P], SitioGroupByOutputType[P]>
        }
      >
    >


  export type SitioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barangay_id?: boolean
    name?: boolean
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    complaint_details?: boolean | Sitio$complaint_detailsArgs<ExtArgs>
    _count?: boolean | SitioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sitio"]>

  export type SitioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barangay_id?: boolean
    name?: boolean
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sitio"]>

  export type SitioSelectScalar = {
    id?: boolean
    barangay_id?: boolean
    name?: boolean
  }

  export type SitioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    complaint_details?: boolean | Sitio$complaint_detailsArgs<ExtArgs>
    _count?: boolean | SitioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SitioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
  }

  export type $SitioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sitio"
    objects: {
      barangay: Prisma.$BarangayPayload<ExtArgs>
      complaint_details: Prisma.$ComplaintDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barangay_id: string
      name: string
    }, ExtArgs["result"]["sitio"]>
    composites: {}
  }

  type SitioGetPayload<S extends boolean | null | undefined | SitioDefaultArgs> = $Result.GetResult<Prisma.$SitioPayload, S>

  type SitioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SitioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SitioCountAggregateInputType | true
    }

  export interface SitioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sitio'], meta: { name: 'Sitio' } }
    /**
     * Find zero or one Sitio that matches the filter.
     * @param {SitioFindUniqueArgs} args - Arguments to find a Sitio
     * @example
     * // Get one Sitio
     * const sitio = await prisma.sitio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SitioFindUniqueArgs>(args: SelectSubset<T, SitioFindUniqueArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sitio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SitioFindUniqueOrThrowArgs} args - Arguments to find a Sitio
     * @example
     * // Get one Sitio
     * const sitio = await prisma.sitio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SitioFindUniqueOrThrowArgs>(args: SelectSubset<T, SitioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sitio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioFindFirstArgs} args - Arguments to find a Sitio
     * @example
     * // Get one Sitio
     * const sitio = await prisma.sitio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SitioFindFirstArgs>(args?: SelectSubset<T, SitioFindFirstArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sitio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioFindFirstOrThrowArgs} args - Arguments to find a Sitio
     * @example
     * // Get one Sitio
     * const sitio = await prisma.sitio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SitioFindFirstOrThrowArgs>(args?: SelectSubset<T, SitioFindFirstOrThrowArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sitios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sitios
     * const sitios = await prisma.sitio.findMany()
     * 
     * // Get first 10 Sitios
     * const sitios = await prisma.sitio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitioWithIdOnly = await prisma.sitio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SitioFindManyArgs>(args?: SelectSubset<T, SitioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sitio.
     * @param {SitioCreateArgs} args - Arguments to create a Sitio.
     * @example
     * // Create one Sitio
     * const Sitio = await prisma.sitio.create({
     *   data: {
     *     // ... data to create a Sitio
     *   }
     * })
     * 
     */
    create<T extends SitioCreateArgs>(args: SelectSubset<T, SitioCreateArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sitios.
     * @param {SitioCreateManyArgs} args - Arguments to create many Sitios.
     * @example
     * // Create many Sitios
     * const sitio = await prisma.sitio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SitioCreateManyArgs>(args?: SelectSubset<T, SitioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sitios and returns the data saved in the database.
     * @param {SitioCreateManyAndReturnArgs} args - Arguments to create many Sitios.
     * @example
     * // Create many Sitios
     * const sitio = await prisma.sitio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sitios and only return the `id`
     * const sitioWithIdOnly = await prisma.sitio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SitioCreateManyAndReturnArgs>(args?: SelectSubset<T, SitioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sitio.
     * @param {SitioDeleteArgs} args - Arguments to delete one Sitio.
     * @example
     * // Delete one Sitio
     * const Sitio = await prisma.sitio.delete({
     *   where: {
     *     // ... filter to delete one Sitio
     *   }
     * })
     * 
     */
    delete<T extends SitioDeleteArgs>(args: SelectSubset<T, SitioDeleteArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sitio.
     * @param {SitioUpdateArgs} args - Arguments to update one Sitio.
     * @example
     * // Update one Sitio
     * const sitio = await prisma.sitio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SitioUpdateArgs>(args: SelectSubset<T, SitioUpdateArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sitios.
     * @param {SitioDeleteManyArgs} args - Arguments to filter Sitios to delete.
     * @example
     * // Delete a few Sitios
     * const { count } = await prisma.sitio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SitioDeleteManyArgs>(args?: SelectSubset<T, SitioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sitios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sitios
     * const sitio = await prisma.sitio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SitioUpdateManyArgs>(args: SelectSubset<T, SitioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sitio.
     * @param {SitioUpsertArgs} args - Arguments to update or create a Sitio.
     * @example
     * // Update or create a Sitio
     * const sitio = await prisma.sitio.upsert({
     *   create: {
     *     // ... data to create a Sitio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sitio we want to update
     *   }
     * })
     */
    upsert<T extends SitioUpsertArgs>(args: SelectSubset<T, SitioUpsertArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sitios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioCountArgs} args - Arguments to filter Sitios to count.
     * @example
     * // Count the number of Sitios
     * const count = await prisma.sitio.count({
     *   where: {
     *     // ... the filter for the Sitios we want to count
     *   }
     * })
    **/
    count<T extends SitioCountArgs>(
      args?: Subset<T, SitioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sitio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitioAggregateArgs>(args: Subset<T, SitioAggregateArgs>): Prisma.PrismaPromise<GetSitioAggregateType<T>>

    /**
     * Group by Sitio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SitioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SitioGroupByArgs['orderBy'] }
        : { orderBy?: SitioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SitioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sitio model
   */
  readonly fields: SitioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sitio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SitioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barangay<T extends BarangayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarangayDefaultArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    complaint_details<T extends Sitio$complaint_detailsArgs<ExtArgs> = {}>(args?: Subset<T, Sitio$complaint_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sitio model
   */ 
  interface SitioFieldRefs {
    readonly id: FieldRef<"Sitio", 'String'>
    readonly barangay_id: FieldRef<"Sitio", 'String'>
    readonly name: FieldRef<"Sitio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sitio findUnique
   */
  export type SitioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter, which Sitio to fetch.
     */
    where: SitioWhereUniqueInput
  }

  /**
   * Sitio findUniqueOrThrow
   */
  export type SitioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter, which Sitio to fetch.
     */
    where: SitioWhereUniqueInput
  }

  /**
   * Sitio findFirst
   */
  export type SitioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter, which Sitio to fetch.
     */
    where?: SitioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sitios to fetch.
     */
    orderBy?: SitioOrderByWithRelationInput | SitioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sitios.
     */
    cursor?: SitioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sitios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sitios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sitios.
     */
    distinct?: SitioScalarFieldEnum | SitioScalarFieldEnum[]
  }

  /**
   * Sitio findFirstOrThrow
   */
  export type SitioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter, which Sitio to fetch.
     */
    where?: SitioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sitios to fetch.
     */
    orderBy?: SitioOrderByWithRelationInput | SitioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sitios.
     */
    cursor?: SitioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sitios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sitios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sitios.
     */
    distinct?: SitioScalarFieldEnum | SitioScalarFieldEnum[]
  }

  /**
   * Sitio findMany
   */
  export type SitioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter, which Sitios to fetch.
     */
    where?: SitioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sitios to fetch.
     */
    orderBy?: SitioOrderByWithRelationInput | SitioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sitios.
     */
    cursor?: SitioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sitios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sitios.
     */
    skip?: number
    distinct?: SitioScalarFieldEnum | SitioScalarFieldEnum[]
  }

  /**
   * Sitio create
   */
  export type SitioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * The data needed to create a Sitio.
     */
    data: XOR<SitioCreateInput, SitioUncheckedCreateInput>
  }

  /**
   * Sitio createMany
   */
  export type SitioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sitios.
     */
    data: SitioCreateManyInput | SitioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sitio createManyAndReturn
   */
  export type SitioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sitios.
     */
    data: SitioCreateManyInput | SitioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sitio update
   */
  export type SitioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * The data needed to update a Sitio.
     */
    data: XOR<SitioUpdateInput, SitioUncheckedUpdateInput>
    /**
     * Choose, which Sitio to update.
     */
    where: SitioWhereUniqueInput
  }

  /**
   * Sitio updateMany
   */
  export type SitioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sitios.
     */
    data: XOR<SitioUpdateManyMutationInput, SitioUncheckedUpdateManyInput>
    /**
     * Filter which Sitios to update
     */
    where?: SitioWhereInput
    limit?: number
  }

  /**
   * Sitio upsert
   */
  export type SitioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * The filter to search for the Sitio to update in case it exists.
     */
    where: SitioWhereUniqueInput
    /**
     * In case the Sitio found by the `where` argument doesn't exist, create a new Sitio with this data.
     */
    create: XOR<SitioCreateInput, SitioUncheckedCreateInput>
    /**
     * In case the Sitio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SitioUpdateInput, SitioUncheckedUpdateInput>
  }

  /**
   * Sitio delete
   */
  export type SitioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    /**
     * Filter which Sitio to delete.
     */
    where: SitioWhereUniqueInput
  }

  /**
   * Sitio deleteMany
   */
  export type SitioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sitios to delete
     */
    where?: SitioWhereInput
    limit?: number
  }

  /**
   * Sitio.complaint_details
   */
  export type Sitio$complaint_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    where?: ComplaintDetailWhereInput
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    cursor?: ComplaintDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintDetailScalarFieldEnum | ComplaintDetailScalarFieldEnum[]
  }

  /**
   * Sitio without action
   */
  export type SitioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
  }


  /**
   * Model Feeder
   */

  export type AggregateFeeder = {
    _count: FeederCountAggregateOutputType | null
    _min: FeederMinAggregateOutputType | null
    _max: FeederMaxAggregateOutputType | null
  }

  export type FeederMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FeederMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FeederCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FeederMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FeederMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FeederCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FeederAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feeder to aggregate.
     */
    where?: FeederWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeders to fetch.
     */
    orderBy?: FeederOrderByWithRelationInput | FeederOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeederWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feeders
    **/
    _count?: true | FeederCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeederMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeederMaxAggregateInputType
  }

  export type GetFeederAggregateType<T extends FeederAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeder[P]>
      : GetScalarType<T[P], AggregateFeeder[P]>
  }




  export type FeederGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeederWhereInput
    orderBy?: FeederOrderByWithAggregationInput | FeederOrderByWithAggregationInput[]
    by: FeederScalarFieldEnum[] | FeederScalarFieldEnum
    having?: FeederScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeederCountAggregateInputType | true
    _min?: FeederMinAggregateInputType
    _max?: FeederMaxAggregateInputType
  }

  export type FeederGroupByOutputType = {
    id: string
    name: string
    _count: FeederCountAggregateOutputType | null
    _min: FeederMinAggregateOutputType | null
    _max: FeederMaxAggregateOutputType | null
  }

  type GetFeederGroupByPayload<T extends FeederGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeederGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeederGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeederGroupByOutputType[P]>
            : GetScalarType<T[P], FeederGroupByOutputType[P]>
        }
      >
    >


  export type FeederSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    power_interruption_tasks?: boolean | Feeder$power_interruption_tasksArgs<ExtArgs>
    lmdga_tasks?: boolean | Feeder$lmdga_tasksArgs<ExtArgs>
    _count?: boolean | FeederCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeder"]>

  export type FeederSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["feeder"]>

  export type FeederSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type FeederInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | Feeder$power_interruption_tasksArgs<ExtArgs>
    lmdga_tasks?: boolean | Feeder$lmdga_tasksArgs<ExtArgs>
    _count?: boolean | FeederCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeederIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeederPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feeder"
    objects: {
      power_interruption_tasks: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>[]
      lmdga_tasks: Prisma.$TaskDetailLmdgaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["feeder"]>
    composites: {}
  }

  type FeederGetPayload<S extends boolean | null | undefined | FeederDefaultArgs> = $Result.GetResult<Prisma.$FeederPayload, S>

  type FeederCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeederFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeederCountAggregateInputType | true
    }

  export interface FeederDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feeder'], meta: { name: 'Feeder' } }
    /**
     * Find zero or one Feeder that matches the filter.
     * @param {FeederFindUniqueArgs} args - Arguments to find a Feeder
     * @example
     * // Get one Feeder
     * const feeder = await prisma.feeder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeederFindUniqueArgs>(args: SelectSubset<T, FeederFindUniqueArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feeder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeederFindUniqueOrThrowArgs} args - Arguments to find a Feeder
     * @example
     * // Get one Feeder
     * const feeder = await prisma.feeder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeederFindUniqueOrThrowArgs>(args: SelectSubset<T, FeederFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feeder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederFindFirstArgs} args - Arguments to find a Feeder
     * @example
     * // Get one Feeder
     * const feeder = await prisma.feeder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeederFindFirstArgs>(args?: SelectSubset<T, FeederFindFirstArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feeder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederFindFirstOrThrowArgs} args - Arguments to find a Feeder
     * @example
     * // Get one Feeder
     * const feeder = await prisma.feeder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeederFindFirstOrThrowArgs>(args?: SelectSubset<T, FeederFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feeders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feeders
     * const feeders = await prisma.feeder.findMany()
     * 
     * // Get first 10 Feeders
     * const feeders = await prisma.feeder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feederWithIdOnly = await prisma.feeder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeederFindManyArgs>(args?: SelectSubset<T, FeederFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feeder.
     * @param {FeederCreateArgs} args - Arguments to create a Feeder.
     * @example
     * // Create one Feeder
     * const Feeder = await prisma.feeder.create({
     *   data: {
     *     // ... data to create a Feeder
     *   }
     * })
     * 
     */
    create<T extends FeederCreateArgs>(args: SelectSubset<T, FeederCreateArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feeders.
     * @param {FeederCreateManyArgs} args - Arguments to create many Feeders.
     * @example
     * // Create many Feeders
     * const feeder = await prisma.feeder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeederCreateManyArgs>(args?: SelectSubset<T, FeederCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feeders and returns the data saved in the database.
     * @param {FeederCreateManyAndReturnArgs} args - Arguments to create many Feeders.
     * @example
     * // Create many Feeders
     * const feeder = await prisma.feeder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feeders and only return the `id`
     * const feederWithIdOnly = await prisma.feeder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeederCreateManyAndReturnArgs>(args?: SelectSubset<T, FeederCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feeder.
     * @param {FeederDeleteArgs} args - Arguments to delete one Feeder.
     * @example
     * // Delete one Feeder
     * const Feeder = await prisma.feeder.delete({
     *   where: {
     *     // ... filter to delete one Feeder
     *   }
     * })
     * 
     */
    delete<T extends FeederDeleteArgs>(args: SelectSubset<T, FeederDeleteArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feeder.
     * @param {FeederUpdateArgs} args - Arguments to update one Feeder.
     * @example
     * // Update one Feeder
     * const feeder = await prisma.feeder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeederUpdateArgs>(args: SelectSubset<T, FeederUpdateArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feeders.
     * @param {FeederDeleteManyArgs} args - Arguments to filter Feeders to delete.
     * @example
     * // Delete a few Feeders
     * const { count } = await prisma.feeder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeederDeleteManyArgs>(args?: SelectSubset<T, FeederDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feeders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feeders
     * const feeder = await prisma.feeder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeederUpdateManyArgs>(args: SelectSubset<T, FeederUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feeder.
     * @param {FeederUpsertArgs} args - Arguments to update or create a Feeder.
     * @example
     * // Update or create a Feeder
     * const feeder = await prisma.feeder.upsert({
     *   create: {
     *     // ... data to create a Feeder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feeder we want to update
     *   }
     * })
     */
    upsert<T extends FeederUpsertArgs>(args: SelectSubset<T, FeederUpsertArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feeders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederCountArgs} args - Arguments to filter Feeders to count.
     * @example
     * // Count the number of Feeders
     * const count = await prisma.feeder.count({
     *   where: {
     *     // ... the filter for the Feeders we want to count
     *   }
     * })
    **/
    count<T extends FeederCountArgs>(
      args?: Subset<T, FeederCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeederCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feeder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeederAggregateArgs>(args: Subset<T, FeederAggregateArgs>): Prisma.PrismaPromise<GetFeederAggregateType<T>>

    /**
     * Group by Feeder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeederGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeederGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeederGroupByArgs['orderBy'] }
        : { orderBy?: FeederGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeederGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeederGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feeder model
   */
  readonly fields: FeederFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feeder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeederClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    power_interruption_tasks<T extends Feeder$power_interruption_tasksArgs<ExtArgs> = {}>(args?: Subset<T, Feeder$power_interruption_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findMany"> | Null>
    lmdga_tasks<T extends Feeder$lmdga_tasksArgs<ExtArgs> = {}>(args?: Subset<T, Feeder$lmdga_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feeder model
   */ 
  interface FeederFieldRefs {
    readonly id: FieldRef<"Feeder", 'String'>
    readonly name: FieldRef<"Feeder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feeder findUnique
   */
  export type FeederFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter, which Feeder to fetch.
     */
    where: FeederWhereUniqueInput
  }

  /**
   * Feeder findUniqueOrThrow
   */
  export type FeederFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter, which Feeder to fetch.
     */
    where: FeederWhereUniqueInput
  }

  /**
   * Feeder findFirst
   */
  export type FeederFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter, which Feeder to fetch.
     */
    where?: FeederWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeders to fetch.
     */
    orderBy?: FeederOrderByWithRelationInput | FeederOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feeders.
     */
    cursor?: FeederWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feeders.
     */
    distinct?: FeederScalarFieldEnum | FeederScalarFieldEnum[]
  }

  /**
   * Feeder findFirstOrThrow
   */
  export type FeederFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter, which Feeder to fetch.
     */
    where?: FeederWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeders to fetch.
     */
    orderBy?: FeederOrderByWithRelationInput | FeederOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feeders.
     */
    cursor?: FeederWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feeders.
     */
    distinct?: FeederScalarFieldEnum | FeederScalarFieldEnum[]
  }

  /**
   * Feeder findMany
   */
  export type FeederFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter, which Feeders to fetch.
     */
    where?: FeederWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeders to fetch.
     */
    orderBy?: FeederOrderByWithRelationInput | FeederOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feeders.
     */
    cursor?: FeederWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeders.
     */
    skip?: number
    distinct?: FeederScalarFieldEnum | FeederScalarFieldEnum[]
  }

  /**
   * Feeder create
   */
  export type FeederCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * The data needed to create a Feeder.
     */
    data: XOR<FeederCreateInput, FeederUncheckedCreateInput>
  }

  /**
   * Feeder createMany
   */
  export type FeederCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feeders.
     */
    data: FeederCreateManyInput | FeederCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feeder createManyAndReturn
   */
  export type FeederCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feeders.
     */
    data: FeederCreateManyInput | FeederCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feeder update
   */
  export type FeederUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * The data needed to update a Feeder.
     */
    data: XOR<FeederUpdateInput, FeederUncheckedUpdateInput>
    /**
     * Choose, which Feeder to update.
     */
    where: FeederWhereUniqueInput
  }

  /**
   * Feeder updateMany
   */
  export type FeederUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feeders.
     */
    data: XOR<FeederUpdateManyMutationInput, FeederUncheckedUpdateManyInput>
    /**
     * Filter which Feeders to update
     */
    where?: FeederWhereInput
    limit?: number
  }

  /**
   * Feeder upsert
   */
  export type FeederUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * The filter to search for the Feeder to update in case it exists.
     */
    where: FeederWhereUniqueInput
    /**
     * In case the Feeder found by the `where` argument doesn't exist, create a new Feeder with this data.
     */
    create: XOR<FeederCreateInput, FeederUncheckedCreateInput>
    /**
     * In case the Feeder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeederUpdateInput, FeederUncheckedUpdateInput>
  }

  /**
   * Feeder delete
   */
  export type FeederDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
    /**
     * Filter which Feeder to delete.
     */
    where: FeederWhereUniqueInput
  }

  /**
   * Feeder deleteMany
   */
  export type FeederDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feeders to delete
     */
    where?: FeederWhereInput
    limit?: number
  }

  /**
   * Feeder.power_interruption_tasks
   */
  export type Feeder$power_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    where?: TaskDetailPowerInterruptionWhereInput
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * Feeder.lmdga_tasks
   */
  export type Feeder$lmdga_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    where?: TaskDetailLmdgaWhereInput
    orderBy?: TaskDetailLmdgaOrderByWithRelationInput | TaskDetailLmdgaOrderByWithRelationInput[]
    cursor?: TaskDetailLmdgaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDetailLmdgaScalarFieldEnum | TaskDetailLmdgaScalarFieldEnum[]
  }

  /**
   * Feeder without action
   */
  export type FeederDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeder
     */
    select?: FeederSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeederInclude<ExtArgs> | null
  }


  /**
   * Model WeatherCondition
   */

  export type AggregateWeatherCondition = {
    _count: WeatherConditionCountAggregateOutputType | null
    _min: WeatherConditionMinAggregateOutputType | null
    _max: WeatherConditionMaxAggregateOutputType | null
  }

  export type WeatherConditionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeatherConditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeatherConditionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WeatherConditionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeatherConditionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeatherConditionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WeatherConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherCondition to aggregate.
     */
    where?: WeatherConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherConditions to fetch.
     */
    orderBy?: WeatherConditionOrderByWithRelationInput | WeatherConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherConditions
    **/
    _count?: true | WeatherConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherConditionMaxAggregateInputType
  }

  export type GetWeatherConditionAggregateType<T extends WeatherConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherCondition[P]>
      : GetScalarType<T[P], AggregateWeatherCondition[P]>
  }




  export type WeatherConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherConditionWhereInput
    orderBy?: WeatherConditionOrderByWithAggregationInput | WeatherConditionOrderByWithAggregationInput[]
    by: WeatherConditionScalarFieldEnum[] | WeatherConditionScalarFieldEnum
    having?: WeatherConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherConditionCountAggregateInputType | true
    _min?: WeatherConditionMinAggregateInputType
    _max?: WeatherConditionMaxAggregateInputType
  }

  export type WeatherConditionGroupByOutputType = {
    id: string
    name: string
    _count: WeatherConditionCountAggregateOutputType | null
    _min: WeatherConditionMinAggregateOutputType | null
    _max: WeatherConditionMaxAggregateOutputType | null
  }

  type GetWeatherConditionGroupByPayload<T extends WeatherConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherConditionGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherConditionGroupByOutputType[P]>
        }
      >
    >


  export type WeatherConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    power_interruption_tasks?: boolean | WeatherCondition$power_interruption_tasksArgs<ExtArgs>
    _count?: boolean | WeatherConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherCondition"]>

  export type WeatherConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weatherCondition"]>

  export type WeatherConditionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type WeatherConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | WeatherCondition$power_interruption_tasksArgs<ExtArgs>
    _count?: boolean | WeatherConditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeatherConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WeatherConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherCondition"
    objects: {
      power_interruption_tasks: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["weatherCondition"]>
    composites: {}
  }

  type WeatherConditionGetPayload<S extends boolean | null | undefined | WeatherConditionDefaultArgs> = $Result.GetResult<Prisma.$WeatherConditionPayload, S>

  type WeatherConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeatherConditionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeatherConditionCountAggregateInputType | true
    }

  export interface WeatherConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherCondition'], meta: { name: 'WeatherCondition' } }
    /**
     * Find zero or one WeatherCondition that matches the filter.
     * @param {WeatherConditionFindUniqueArgs} args - Arguments to find a WeatherCondition
     * @example
     * // Get one WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherConditionFindUniqueArgs>(args: SelectSubset<T, WeatherConditionFindUniqueArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeatherCondition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeatherConditionFindUniqueOrThrowArgs} args - Arguments to find a WeatherCondition
     * @example
     * // Get one WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeatherCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionFindFirstArgs} args - Arguments to find a WeatherCondition
     * @example
     * // Get one WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherConditionFindFirstArgs>(args?: SelectSubset<T, WeatherConditionFindFirstArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeatherCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionFindFirstOrThrowArgs} args - Arguments to find a WeatherCondition
     * @example
     * // Get one WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeatherConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherConditions
     * const weatherConditions = await prisma.weatherCondition.findMany()
     * 
     * // Get first 10 WeatherConditions
     * const weatherConditions = await prisma.weatherCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherConditionWithIdOnly = await prisma.weatherCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherConditionFindManyArgs>(args?: SelectSubset<T, WeatherConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeatherCondition.
     * @param {WeatherConditionCreateArgs} args - Arguments to create a WeatherCondition.
     * @example
     * // Create one WeatherCondition
     * const WeatherCondition = await prisma.weatherCondition.create({
     *   data: {
     *     // ... data to create a WeatherCondition
     *   }
     * })
     * 
     */
    create<T extends WeatherConditionCreateArgs>(args: SelectSubset<T, WeatherConditionCreateArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeatherConditions.
     * @param {WeatherConditionCreateManyArgs} args - Arguments to create many WeatherConditions.
     * @example
     * // Create many WeatherConditions
     * const weatherCondition = await prisma.weatherCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherConditionCreateManyArgs>(args?: SelectSubset<T, WeatherConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeatherConditions and returns the data saved in the database.
     * @param {WeatherConditionCreateManyAndReturnArgs} args - Arguments to create many WeatherConditions.
     * @example
     * // Create many WeatherConditions
     * const weatherCondition = await prisma.weatherCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeatherConditions and only return the `id`
     * const weatherConditionWithIdOnly = await prisma.weatherCondition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeatherCondition.
     * @param {WeatherConditionDeleteArgs} args - Arguments to delete one WeatherCondition.
     * @example
     * // Delete one WeatherCondition
     * const WeatherCondition = await prisma.weatherCondition.delete({
     *   where: {
     *     // ... filter to delete one WeatherCondition
     *   }
     * })
     * 
     */
    delete<T extends WeatherConditionDeleteArgs>(args: SelectSubset<T, WeatherConditionDeleteArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeatherCondition.
     * @param {WeatherConditionUpdateArgs} args - Arguments to update one WeatherCondition.
     * @example
     * // Update one WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherConditionUpdateArgs>(args: SelectSubset<T, WeatherConditionUpdateArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeatherConditions.
     * @param {WeatherConditionDeleteManyArgs} args - Arguments to filter WeatherConditions to delete.
     * @example
     * // Delete a few WeatherConditions
     * const { count } = await prisma.weatherCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherConditionDeleteManyArgs>(args?: SelectSubset<T, WeatherConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherConditions
     * const weatherCondition = await prisma.weatherCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherConditionUpdateManyArgs>(args: SelectSubset<T, WeatherConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeatherCondition.
     * @param {WeatherConditionUpsertArgs} args - Arguments to update or create a WeatherCondition.
     * @example
     * // Update or create a WeatherCondition
     * const weatherCondition = await prisma.weatherCondition.upsert({
     *   create: {
     *     // ... data to create a WeatherCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherCondition we want to update
     *   }
     * })
     */
    upsert<T extends WeatherConditionUpsertArgs>(args: SelectSubset<T, WeatherConditionUpsertArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeatherConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionCountArgs} args - Arguments to filter WeatherConditions to count.
     * @example
     * // Count the number of WeatherConditions
     * const count = await prisma.weatherCondition.count({
     *   where: {
     *     // ... the filter for the WeatherConditions we want to count
     *   }
     * })
    **/
    count<T extends WeatherConditionCountArgs>(
      args?: Subset<T, WeatherConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherConditionAggregateArgs>(args: Subset<T, WeatherConditionAggregateArgs>): Prisma.PrismaPromise<GetWeatherConditionAggregateType<T>>

    /**
     * Group by WeatherCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherConditionGroupByArgs['orderBy'] }
        : { orderBy?: WeatherConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherCondition model
   */
  readonly fields: WeatherConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    power_interruption_tasks<T extends WeatherCondition$power_interruption_tasksArgs<ExtArgs> = {}>(args?: Subset<T, WeatherCondition$power_interruption_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherCondition model
   */ 
  interface WeatherConditionFieldRefs {
    readonly id: FieldRef<"WeatherCondition", 'String'>
    readonly name: FieldRef<"WeatherCondition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeatherCondition findUnique
   */
  export type WeatherConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter, which WeatherCondition to fetch.
     */
    where: WeatherConditionWhereUniqueInput
  }

  /**
   * WeatherCondition findUniqueOrThrow
   */
  export type WeatherConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter, which WeatherCondition to fetch.
     */
    where: WeatherConditionWhereUniqueInput
  }

  /**
   * WeatherCondition findFirst
   */
  export type WeatherConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter, which WeatherCondition to fetch.
     */
    where?: WeatherConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherConditions to fetch.
     */
    orderBy?: WeatherConditionOrderByWithRelationInput | WeatherConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherConditions.
     */
    cursor?: WeatherConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherConditions.
     */
    distinct?: WeatherConditionScalarFieldEnum | WeatherConditionScalarFieldEnum[]
  }

  /**
   * WeatherCondition findFirstOrThrow
   */
  export type WeatherConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter, which WeatherCondition to fetch.
     */
    where?: WeatherConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherConditions to fetch.
     */
    orderBy?: WeatherConditionOrderByWithRelationInput | WeatherConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherConditions.
     */
    cursor?: WeatherConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherConditions.
     */
    distinct?: WeatherConditionScalarFieldEnum | WeatherConditionScalarFieldEnum[]
  }

  /**
   * WeatherCondition findMany
   */
  export type WeatherConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter, which WeatherConditions to fetch.
     */
    where?: WeatherConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherConditions to fetch.
     */
    orderBy?: WeatherConditionOrderByWithRelationInput | WeatherConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherConditions.
     */
    cursor?: WeatherConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherConditions.
     */
    skip?: number
    distinct?: WeatherConditionScalarFieldEnum | WeatherConditionScalarFieldEnum[]
  }

  /**
   * WeatherCondition create
   */
  export type WeatherConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a WeatherCondition.
     */
    data: XOR<WeatherConditionCreateInput, WeatherConditionUncheckedCreateInput>
  }

  /**
   * WeatherCondition createMany
   */
  export type WeatherConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherConditions.
     */
    data: WeatherConditionCreateManyInput | WeatherConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherCondition createManyAndReturn
   */
  export type WeatherConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeatherConditions.
     */
    data: WeatherConditionCreateManyInput | WeatherConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherCondition update
   */
  export type WeatherConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a WeatherCondition.
     */
    data: XOR<WeatherConditionUpdateInput, WeatherConditionUncheckedUpdateInput>
    /**
     * Choose, which WeatherCondition to update.
     */
    where: WeatherConditionWhereUniqueInput
  }

  /**
   * WeatherCondition updateMany
   */
  export type WeatherConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherConditions.
     */
    data: XOR<WeatherConditionUpdateManyMutationInput, WeatherConditionUncheckedUpdateManyInput>
    /**
     * Filter which WeatherConditions to update
     */
    where?: WeatherConditionWhereInput
    limit?: number
  }

  /**
   * WeatherCondition upsert
   */
  export type WeatherConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the WeatherCondition to update in case it exists.
     */
    where: WeatherConditionWhereUniqueInput
    /**
     * In case the WeatherCondition found by the `where` argument doesn't exist, create a new WeatherCondition with this data.
     */
    create: XOR<WeatherConditionCreateInput, WeatherConditionUncheckedCreateInput>
    /**
     * In case the WeatherCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherConditionUpdateInput, WeatherConditionUncheckedUpdateInput>
  }

  /**
   * WeatherCondition delete
   */
  export type WeatherConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
    /**
     * Filter which WeatherCondition to delete.
     */
    where: WeatherConditionWhereUniqueInput
  }

  /**
   * WeatherCondition deleteMany
   */
  export type WeatherConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherConditions to delete
     */
    where?: WeatherConditionWhereInput
    limit?: number
  }

  /**
   * WeatherCondition.power_interruption_tasks
   */
  export type WeatherCondition$power_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    where?: TaskDetailPowerInterruptionWhereInput
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * WeatherCondition without action
   */
  export type WeatherConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherCondition
     */
    select?: WeatherConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherConditionInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    name: string
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    power_interruption_tasks?: boolean | Device$power_interruption_tasksArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    power_interruption_tasks?: boolean | Device$power_interruption_tasksArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      power_interruption_tasks: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    power_interruption_tasks<T extends Device$power_interruption_tasksArgs<ExtArgs> = {}>(args?: Subset<T, Device$power_interruption_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly name: FieldRef<"Device", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    limit?: number
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    limit?: number
  }

  /**
   * Device.power_interruption_tasks
   */
  export type Device$power_interruption_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    where?: TaskDetailPowerInterruptionWhereInput
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model MeterBrand
   */

  export type AggregateMeterBrand = {
    _count: MeterBrandCountAggregateOutputType | null
    _min: MeterBrandMinAggregateOutputType | null
    _max: MeterBrandMaxAggregateOutputType | null
  }

  export type MeterBrandMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type MeterBrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type MeterBrandCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MeterBrandMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MeterBrandMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MeterBrandCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MeterBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeterBrand to aggregate.
     */
    where?: MeterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterBrands to fetch.
     */
    orderBy?: MeterBrandOrderByWithRelationInput | MeterBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeterBrands
    **/
    _count?: true | MeterBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeterBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeterBrandMaxAggregateInputType
  }

  export type GetMeterBrandAggregateType<T extends MeterBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateMeterBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeterBrand[P]>
      : GetScalarType<T[P], AggregateMeterBrand[P]>
  }




  export type MeterBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterBrandWhereInput
    orderBy?: MeterBrandOrderByWithAggregationInput | MeterBrandOrderByWithAggregationInput[]
    by: MeterBrandScalarFieldEnum[] | MeterBrandScalarFieldEnum
    having?: MeterBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeterBrandCountAggregateInputType | true
    _min?: MeterBrandMinAggregateInputType
    _max?: MeterBrandMaxAggregateInputType
  }

  export type MeterBrandGroupByOutputType = {
    id: string
    name: string
    _count: MeterBrandCountAggregateOutputType | null
    _min: MeterBrandMinAggregateOutputType | null
    _max: MeterBrandMaxAggregateOutputType | null
  }

  type GetMeterBrandGroupByPayload<T extends MeterBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeterBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeterBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeterBrandGroupByOutputType[P]>
            : GetScalarType<T[P], MeterBrandGroupByOutputType[P]>
        }
      >
    >


  export type MeterBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    kwh_meter_tasks?: boolean | MeterBrand$kwh_meter_tasksArgs<ExtArgs>
    _count?: boolean | MeterBrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meterBrand"]>

  export type MeterBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["meterBrand"]>

  export type MeterBrandSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type MeterBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kwh_meter_tasks?: boolean | MeterBrand$kwh_meter_tasksArgs<ExtArgs>
    _count?: boolean | MeterBrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeterBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MeterBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeterBrand"
    objects: {
      kwh_meter_tasks: Prisma.$TaskDetailKwhMeterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["meterBrand"]>
    composites: {}
  }

  type MeterBrandGetPayload<S extends boolean | null | undefined | MeterBrandDefaultArgs> = $Result.GetResult<Prisma.$MeterBrandPayload, S>

  type MeterBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeterBrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeterBrandCountAggregateInputType | true
    }

  export interface MeterBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeterBrand'], meta: { name: 'MeterBrand' } }
    /**
     * Find zero or one MeterBrand that matches the filter.
     * @param {MeterBrandFindUniqueArgs} args - Arguments to find a MeterBrand
     * @example
     * // Get one MeterBrand
     * const meterBrand = await prisma.meterBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeterBrandFindUniqueArgs>(args: SelectSubset<T, MeterBrandFindUniqueArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MeterBrand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeterBrandFindUniqueOrThrowArgs} args - Arguments to find a MeterBrand
     * @example
     * // Get one MeterBrand
     * const meterBrand = await prisma.meterBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeterBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, MeterBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MeterBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandFindFirstArgs} args - Arguments to find a MeterBrand
     * @example
     * // Get one MeterBrand
     * const meterBrand = await prisma.meterBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeterBrandFindFirstArgs>(args?: SelectSubset<T, MeterBrandFindFirstArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MeterBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandFindFirstOrThrowArgs} args - Arguments to find a MeterBrand
     * @example
     * // Get one MeterBrand
     * const meterBrand = await prisma.meterBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeterBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, MeterBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MeterBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeterBrands
     * const meterBrands = await prisma.meterBrand.findMany()
     * 
     * // Get first 10 MeterBrands
     * const meterBrands = await prisma.meterBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meterBrandWithIdOnly = await prisma.meterBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeterBrandFindManyArgs>(args?: SelectSubset<T, MeterBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MeterBrand.
     * @param {MeterBrandCreateArgs} args - Arguments to create a MeterBrand.
     * @example
     * // Create one MeterBrand
     * const MeterBrand = await prisma.meterBrand.create({
     *   data: {
     *     // ... data to create a MeterBrand
     *   }
     * })
     * 
     */
    create<T extends MeterBrandCreateArgs>(args: SelectSubset<T, MeterBrandCreateArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MeterBrands.
     * @param {MeterBrandCreateManyArgs} args - Arguments to create many MeterBrands.
     * @example
     * // Create many MeterBrands
     * const meterBrand = await prisma.meterBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeterBrandCreateManyArgs>(args?: SelectSubset<T, MeterBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeterBrands and returns the data saved in the database.
     * @param {MeterBrandCreateManyAndReturnArgs} args - Arguments to create many MeterBrands.
     * @example
     * // Create many MeterBrands
     * const meterBrand = await prisma.meterBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeterBrands and only return the `id`
     * const meterBrandWithIdOnly = await prisma.meterBrand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeterBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, MeterBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MeterBrand.
     * @param {MeterBrandDeleteArgs} args - Arguments to delete one MeterBrand.
     * @example
     * // Delete one MeterBrand
     * const MeterBrand = await prisma.meterBrand.delete({
     *   where: {
     *     // ... filter to delete one MeterBrand
     *   }
     * })
     * 
     */
    delete<T extends MeterBrandDeleteArgs>(args: SelectSubset<T, MeterBrandDeleteArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MeterBrand.
     * @param {MeterBrandUpdateArgs} args - Arguments to update one MeterBrand.
     * @example
     * // Update one MeterBrand
     * const meterBrand = await prisma.meterBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeterBrandUpdateArgs>(args: SelectSubset<T, MeterBrandUpdateArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MeterBrands.
     * @param {MeterBrandDeleteManyArgs} args - Arguments to filter MeterBrands to delete.
     * @example
     * // Delete a few MeterBrands
     * const { count } = await prisma.meterBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeterBrandDeleteManyArgs>(args?: SelectSubset<T, MeterBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeterBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeterBrands
     * const meterBrand = await prisma.meterBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeterBrandUpdateManyArgs>(args: SelectSubset<T, MeterBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeterBrand.
     * @param {MeterBrandUpsertArgs} args - Arguments to update or create a MeterBrand.
     * @example
     * // Update or create a MeterBrand
     * const meterBrand = await prisma.meterBrand.upsert({
     *   create: {
     *     // ... data to create a MeterBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeterBrand we want to update
     *   }
     * })
     */
    upsert<T extends MeterBrandUpsertArgs>(args: SelectSubset<T, MeterBrandUpsertArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MeterBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandCountArgs} args - Arguments to filter MeterBrands to count.
     * @example
     * // Count the number of MeterBrands
     * const count = await prisma.meterBrand.count({
     *   where: {
     *     // ... the filter for the MeterBrands we want to count
     *   }
     * })
    **/
    count<T extends MeterBrandCountArgs>(
      args?: Subset<T, MeterBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeterBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeterBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeterBrandAggregateArgs>(args: Subset<T, MeterBrandAggregateArgs>): Prisma.PrismaPromise<GetMeterBrandAggregateType<T>>

    /**
     * Group by MeterBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeterBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeterBrandGroupByArgs['orderBy'] }
        : { orderBy?: MeterBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeterBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeterBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeterBrand model
   */
  readonly fields: MeterBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeterBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeterBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kwh_meter_tasks<T extends MeterBrand$kwh_meter_tasksArgs<ExtArgs> = {}>(args?: Subset<T, MeterBrand$kwh_meter_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeterBrand model
   */ 
  interface MeterBrandFieldRefs {
    readonly id: FieldRef<"MeterBrand", 'String'>
    readonly name: FieldRef<"MeterBrand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MeterBrand findUnique
   */
  export type MeterBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter, which MeterBrand to fetch.
     */
    where: MeterBrandWhereUniqueInput
  }

  /**
   * MeterBrand findUniqueOrThrow
   */
  export type MeterBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter, which MeterBrand to fetch.
     */
    where: MeterBrandWhereUniqueInput
  }

  /**
   * MeterBrand findFirst
   */
  export type MeterBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter, which MeterBrand to fetch.
     */
    where?: MeterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterBrands to fetch.
     */
    orderBy?: MeterBrandOrderByWithRelationInput | MeterBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeterBrands.
     */
    cursor?: MeterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeterBrands.
     */
    distinct?: MeterBrandScalarFieldEnum | MeterBrandScalarFieldEnum[]
  }

  /**
   * MeterBrand findFirstOrThrow
   */
  export type MeterBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter, which MeterBrand to fetch.
     */
    where?: MeterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterBrands to fetch.
     */
    orderBy?: MeterBrandOrderByWithRelationInput | MeterBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeterBrands.
     */
    cursor?: MeterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeterBrands.
     */
    distinct?: MeterBrandScalarFieldEnum | MeterBrandScalarFieldEnum[]
  }

  /**
   * MeterBrand findMany
   */
  export type MeterBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter, which MeterBrands to fetch.
     */
    where?: MeterBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterBrands to fetch.
     */
    orderBy?: MeterBrandOrderByWithRelationInput | MeterBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeterBrands.
     */
    cursor?: MeterBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterBrands.
     */
    skip?: number
    distinct?: MeterBrandScalarFieldEnum | MeterBrandScalarFieldEnum[]
  }

  /**
   * MeterBrand create
   */
  export type MeterBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a MeterBrand.
     */
    data: XOR<MeterBrandCreateInput, MeterBrandUncheckedCreateInput>
  }

  /**
   * MeterBrand createMany
   */
  export type MeterBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeterBrands.
     */
    data: MeterBrandCreateManyInput | MeterBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeterBrand createManyAndReturn
   */
  export type MeterBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MeterBrands.
     */
    data: MeterBrandCreateManyInput | MeterBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeterBrand update
   */
  export type MeterBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a MeterBrand.
     */
    data: XOR<MeterBrandUpdateInput, MeterBrandUncheckedUpdateInput>
    /**
     * Choose, which MeterBrand to update.
     */
    where: MeterBrandWhereUniqueInput
  }

  /**
   * MeterBrand updateMany
   */
  export type MeterBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeterBrands.
     */
    data: XOR<MeterBrandUpdateManyMutationInput, MeterBrandUncheckedUpdateManyInput>
    /**
     * Filter which MeterBrands to update
     */
    where?: MeterBrandWhereInput
    limit?: number
  }

  /**
   * MeterBrand upsert
   */
  export type MeterBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the MeterBrand to update in case it exists.
     */
    where: MeterBrandWhereUniqueInput
    /**
     * In case the MeterBrand found by the `where` argument doesn't exist, create a new MeterBrand with this data.
     */
    create: XOR<MeterBrandCreateInput, MeterBrandUncheckedCreateInput>
    /**
     * In case the MeterBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeterBrandUpdateInput, MeterBrandUncheckedUpdateInput>
  }

  /**
   * MeterBrand delete
   */
  export type MeterBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
    /**
     * Filter which MeterBrand to delete.
     */
    where: MeterBrandWhereUniqueInput
  }

  /**
   * MeterBrand deleteMany
   */
  export type MeterBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeterBrands to delete
     */
    where?: MeterBrandWhereInput
    limit?: number
  }

  /**
   * MeterBrand.kwh_meter_tasks
   */
  export type MeterBrand$kwh_meter_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    where?: TaskDetailKwhMeterWhereInput
    orderBy?: TaskDetailKwhMeterOrderByWithRelationInput | TaskDetailKwhMeterOrderByWithRelationInput[]
    cursor?: TaskDetailKwhMeterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDetailKwhMeterScalarFieldEnum | TaskDetailKwhMeterScalarFieldEnum[]
  }

  /**
   * MeterBrand without action
   */
  export type MeterBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterBrand
     */
    select?: MeterBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterBrandInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    category_id: number | null
  }

  export type ActivitySumAggregateOutputType = {
    category_id: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    category_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    category_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    category_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    category_id?: true
  }

  export type ActivitySumAggregateInputType = {
    category_id?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    category_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    category_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    category_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    category_id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean | Activity$categoryArgs<ExtArgs>
    tasks?: boolean | Activity$tasksArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    category?: boolean | Activity$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    category_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Activity$categoryArgs<ExtArgs>
    tasks?: boolean | Activity$tasksArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Activity$categoryArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      category: Prisma.$ActivityCategoryPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category_id: number
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Activity$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Activity$categoryArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tasks<T extends Activity$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Activity$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly category_id: FieldRef<"Activity", 'Int'>
    readonly name: FieldRef<"Activity", 'String'>
    readonly created_at: FieldRef<"Activity", 'DateTime'>
    readonly updated_at: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    limit?: number
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    limit?: number
  }

  /**
   * Activity.category
   */
  export type Activity$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    where?: ActivityCategoryWhereInput
  }

  /**
   * Activity.tasks
   */
  export type Activity$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model ActivityCategory
   */

  export type AggregateActivityCategory = {
    _count: ActivityCategoryCountAggregateOutputType | null
    _avg: ActivityCategoryAvgAggregateOutputType | null
    _sum: ActivityCategorySumAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  export type ActivityCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ActivityCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ActivityCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActivityCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActivityCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ActivityCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ActivityCategorySumAggregateInputType = {
    id?: true
  }

  export type ActivityCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActivityCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActivityCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ActivityCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityCategory to aggregate.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityCategories
    **/
    _count?: true | ActivityCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type GetActivityCategoryAggregateType<T extends ActivityCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityCategory[P]>
      : GetScalarType<T[P], AggregateActivityCategory[P]>
  }




  export type ActivityCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityCategoryWhereInput
    orderBy?: ActivityCategoryOrderByWithAggregationInput | ActivityCategoryOrderByWithAggregationInput[]
    by: ActivityCategoryScalarFieldEnum[] | ActivityCategoryScalarFieldEnum
    having?: ActivityCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCategoryCountAggregateInputType | true
    _avg?: ActivityCategoryAvgAggregateInputType
    _sum?: ActivityCategorySumAggregateInputType
    _min?: ActivityCategoryMinAggregateInputType
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type ActivityCategoryGroupByOutputType = {
    id: number
    name: string
    _count: ActivityCategoryCountAggregateOutputType | null
    _avg: ActivityCategoryAvgAggregateOutputType | null
    _sum: ActivityCategorySumAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  type GetActivityCategoryGroupByPayload<T extends ActivityCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ActivityCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    activities?: boolean | ActivityCategory$activitiesArgs<ExtArgs>
    _count?: boolean | ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityCategory"]>

  export type ActivityCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type ActivityCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ActivityCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ActivityCategory$activitiesArgs<ExtArgs>
    _count?: boolean | ActivityCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActivityCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityCategory"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["activityCategory"]>
    composites: {}
  }

  type ActivityCategoryGetPayload<S extends boolean | null | undefined | ActivityCategoryDefaultArgs> = $Result.GetResult<Prisma.$ActivityCategoryPayload, S>

  type ActivityCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCategoryCountAggregateInputType | true
    }

  export interface ActivityCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityCategory'], meta: { name: 'ActivityCategory' } }
    /**
     * Find zero or one ActivityCategory that matches the filter.
     * @param {ActivityCategoryFindUniqueArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityCategoryFindUniqueArgs>(args: SelectSubset<T, ActivityCategoryFindUniqueArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityCategoryFindUniqueOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindFirstArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityCategoryFindFirstArgs>(args?: SelectSubset<T, ActivityCategoryFindFirstArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindFirstOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany()
     * 
     * // Get first 10 ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityCategoryFindManyArgs>(args?: SelectSubset<T, ActivityCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityCategory.
     * @param {ActivityCategoryCreateArgs} args - Arguments to create a ActivityCategory.
     * @example
     * // Create one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.create({
     *   data: {
     *     // ... data to create a ActivityCategory
     *   }
     * })
     * 
     */
    create<T extends ActivityCategoryCreateArgs>(args: SelectSubset<T, ActivityCategoryCreateArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityCategories.
     * @param {ActivityCategoryCreateManyArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCategoryCreateManyArgs>(args?: SelectSubset<T, ActivityCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityCategories and returns the data saved in the database.
     * @param {ActivityCategoryCreateManyAndReturnArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityCategories and only return the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityCategory.
     * @param {ActivityCategoryDeleteArgs} args - Arguments to delete one ActivityCategory.
     * @example
     * // Delete one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.delete({
     *   where: {
     *     // ... filter to delete one ActivityCategory
     *   }
     * })
     * 
     */
    delete<T extends ActivityCategoryDeleteArgs>(args: SelectSubset<T, ActivityCategoryDeleteArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityCategory.
     * @param {ActivityCategoryUpdateArgs} args - Arguments to update one ActivityCategory.
     * @example
     * // Update one ActivityCategory
     * const activityCategory = await prisma.activityCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityCategoryUpdateArgs>(args: SelectSubset<T, ActivityCategoryUpdateArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityCategories.
     * @param {ActivityCategoryDeleteManyArgs} args - Arguments to filter ActivityCategories to delete.
     * @example
     * // Delete a few ActivityCategories
     * const { count } = await prisma.activityCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityCategoryDeleteManyArgs>(args?: SelectSubset<T, ActivityCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityCategories
     * const activityCategory = await prisma.activityCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityCategoryUpdateManyArgs>(args: SelectSubset<T, ActivityCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityCategory.
     * @param {ActivityCategoryUpsertArgs} args - Arguments to update or create a ActivityCategory.
     * @example
     * // Update or create a ActivityCategory
     * const activityCategory = await prisma.activityCategory.upsert({
     *   create: {
     *     // ... data to create a ActivityCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityCategory we want to update
     *   }
     * })
     */
    upsert<T extends ActivityCategoryUpsertArgs>(args: SelectSubset<T, ActivityCategoryUpsertArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryCountArgs} args - Arguments to filter ActivityCategories to count.
     * @example
     * // Count the number of ActivityCategories
     * const count = await prisma.activityCategory.count({
     *   where: {
     *     // ... the filter for the ActivityCategories we want to count
     *   }
     * })
    **/
    count<T extends ActivityCategoryCountArgs>(
      args?: Subset<T, ActivityCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityCategoryAggregateArgs>(args: Subset<T, ActivityCategoryAggregateArgs>): Prisma.PrismaPromise<GetActivityCategoryAggregateType<T>>

    /**
     * Group by ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ActivityCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityCategory model
   */
  readonly fields: ActivityCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends ActivityCategory$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityCategory$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityCategory model
   */ 
  interface ActivityCategoryFieldRefs {
    readonly id: FieldRef<"ActivityCategory", 'Int'>
    readonly name: FieldRef<"ActivityCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityCategory findUnique
   */
  export type ActivityCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory findUniqueOrThrow
   */
  export type ActivityCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory findFirst
   */
  export type ActivityCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory findFirstOrThrow
   */
  export type ActivityCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory findMany
   */
  export type ActivityCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ActivityCategories to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory create
   */
  export type ActivityCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityCategory.
     */
    data: XOR<ActivityCategoryCreateInput, ActivityCategoryUncheckedCreateInput>
  }

  /**
   * ActivityCategory createMany
   */
  export type ActivityCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityCategories.
     */
    data: ActivityCategoryCreateManyInput | ActivityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityCategory createManyAndReturn
   */
  export type ActivityCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityCategories.
     */
    data: ActivityCategoryCreateManyInput | ActivityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityCategory update
   */
  export type ActivityCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityCategory.
     */
    data: XOR<ActivityCategoryUpdateInput, ActivityCategoryUncheckedUpdateInput>
    /**
     * Choose, which ActivityCategory to update.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory updateMany
   */
  export type ActivityCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityCategories.
     */
    data: XOR<ActivityCategoryUpdateManyMutationInput, ActivityCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ActivityCategories to update
     */
    where?: ActivityCategoryWhereInput
    limit?: number
  }

  /**
   * ActivityCategory upsert
   */
  export type ActivityCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityCategory to update in case it exists.
     */
    where: ActivityCategoryWhereUniqueInput
    /**
     * In case the ActivityCategory found by the `where` argument doesn't exist, create a new ActivityCategory with this data.
     */
    create: XOR<ActivityCategoryCreateInput, ActivityCategoryUncheckedCreateInput>
    /**
     * In case the ActivityCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityCategoryUpdateInput, ActivityCategoryUncheckedUpdateInput>
  }

  /**
   * ActivityCategory delete
   */
  export type ActivityCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
    /**
     * Filter which ActivityCategory to delete.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory deleteMany
   */
  export type ActivityCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityCategories to delete
     */
    where?: ActivityCategoryWhereInput
    limit?: number
  }

  /**
   * ActivityCategory.activities
   */
  export type ActivityCategory$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * ActivityCategory without action
   */
  export type ActivityCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    report_type_id: number | null
    complaint_status_id: number | null
    assigned_group_type: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    report_type_id: number | null
    complaint_status_id: number | null
    assigned_group_type: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    report_type_id: number | null
    complaint_status_id: number | null
    assigned_group_id: string | null
    assigned_group_type: number | null
    ref_number: string | null
    complainant_name: string | null
    complainant_contact_no: string | null
    description: string | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    report_type_id: number | null
    complaint_status_id: number | null
    assigned_group_id: string | null
    assigned_group_type: number | null
    ref_number: string | null
    complainant_name: string | null
    complainant_contact_no: string | null
    description: string | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: number
    assigned_group_type: number
    ref_number: number
    complainant_name: number
    complainant_contact_no: number
    description: number
    remarks: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    report_type_id?: true
    complaint_status_id?: true
    assigned_group_type?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    report_type_id?: true
    complaint_status_id?: true
    assigned_group_type?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    report_type_id?: true
    complaint_status_id?: true
    assigned_group_id?: true
    assigned_group_type?: true
    ref_number?: true
    complainant_name?: true
    complainant_contact_no?: true
    description?: true
    remarks?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    report_type_id?: true
    complaint_status_id?: true
    assigned_group_id?: true
    assigned_group_type?: true
    ref_number?: true
    complainant_name?: true
    complainant_contact_no?: true
    description?: true
    remarks?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    report_type_id?: true
    complaint_status_id?: true
    assigned_group_id?: true
    assigned_group_type?: true
    ref_number?: true
    complainant_name?: true
    complainant_contact_no?: true
    description?: true
    remarks?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type_id?: boolean
    complaint_status_id?: boolean
    assigned_group_id?: boolean
    assigned_group_type?: boolean
    ref_number?: boolean
    complainant_name?: boolean
    complainant_contact_no?: boolean
    description?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    complaint_detail?: boolean | Complaint$complaint_detailArgs<ExtArgs>
    logs?: boolean | Complaint$logsArgs<ExtArgs>
    tasks?: boolean | Complaint$tasksArgs<ExtArgs>
    report_type?: boolean | ComplaintReportTypeDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type_id?: boolean
    complaint_status_id?: boolean
    assigned_group_id?: boolean
    assigned_group_type?: boolean
    ref_number?: boolean
    complainant_name?: boolean
    complainant_contact_no?: boolean
    description?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    report_type?: boolean | ComplaintReportTypeDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectScalar = {
    id?: boolean
    report_type_id?: boolean
    complaint_status_id?: boolean
    assigned_group_id?: boolean
    assigned_group_type?: boolean
    ref_number?: boolean
    complainant_name?: boolean
    complainant_contact_no?: boolean
    description?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint_detail?: boolean | Complaint$complaint_detailArgs<ExtArgs>
    logs?: boolean | Complaint$logsArgs<ExtArgs>
    tasks?: boolean | Complaint$tasksArgs<ExtArgs>
    report_type?: boolean | ComplaintReportTypeDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
    _count?: boolean | ComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComplaintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report_type?: boolean | ComplaintReportTypeDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      complaint_detail: Prisma.$ComplaintDetailPayload<ExtArgs> | null
      logs: Prisma.$ComplaintLogPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      report_type: Prisma.$ComplaintReportTypePayload<ExtArgs>
      status: Prisma.$ComplaintStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      report_type_id: number
      complaint_status_id: number
      assigned_group_id: string
      assigned_group_type: number
      ref_number: string
      complainant_name: string
      complainant_contact_no: string
      description: string
      remarks: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {ComplaintCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintWithIdOnly = await prisma.complaint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint_detail<T extends Complaint$complaint_detailArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$complaint_detailArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Complaint$logsArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Complaint$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    report_type<T extends ComplaintReportTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintReportTypeDefaultArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends ComplaintStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintStatusDefaultArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */ 
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly report_type_id: FieldRef<"Complaint", 'Int'>
    readonly complaint_status_id: FieldRef<"Complaint", 'Int'>
    readonly assigned_group_id: FieldRef<"Complaint", 'String'>
    readonly assigned_group_type: FieldRef<"Complaint", 'Int'>
    readonly ref_number: FieldRef<"Complaint", 'String'>
    readonly complainant_name: FieldRef<"Complaint", 'String'>
    readonly complainant_contact_no: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly remarks: FieldRef<"Complaint", 'String'>
    readonly created_by: FieldRef<"Complaint", 'String'>
    readonly created_at: FieldRef<"Complaint", 'DateTime'>
    readonly updated_at: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint createManyAndReturn
   */
  export type ComplaintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    limit?: number
  }

  /**
   * Complaint.complaint_detail
   */
  export type Complaint$complaint_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    where?: ComplaintDetailWhereInput
  }

  /**
   * Complaint.logs
   */
  export type Complaint$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    where?: ComplaintLogWhereInput
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    cursor?: ComplaintLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintLogScalarFieldEnum | ComplaintLogScalarFieldEnum[]
  }

  /**
   * Complaint.tasks
   */
  export type Complaint$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintDetail
   */

  export type AggregateComplaintDetail = {
    _count: ComplaintDetailCountAggregateOutputType | null
    _avg: ComplaintDetailAvgAggregateOutputType | null
    _sum: ComplaintDetailSumAggregateOutputType | null
    _min: ComplaintDetailMinAggregateOutputType | null
    _max: ComplaintDetailMaxAggregateOutputType | null
  }

  export type ComplaintDetailAvgAggregateOutputType = {
    id: number | null
    complaint_id: number | null
  }

  export type ComplaintDetailSumAggregateOutputType = {
    id: number | null
    complaint_id: number | null
  }

  export type ComplaintDetailMinAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    consumer_id: string | null
    barangay_id: string | null
    sitio_id: string | null
    landmark: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintDetailMaxAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    consumer_id: string | null
    barangay_id: string | null
    sitio_id: string | null
    landmark: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintDetailCountAggregateOutputType = {
    id: number
    complaint_id: number
    consumer_id: number
    barangay_id: number
    sitio_id: number
    landmark: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComplaintDetailAvgAggregateInputType = {
    id?: true
    complaint_id?: true
  }

  export type ComplaintDetailSumAggregateInputType = {
    id?: true
    complaint_id?: true
  }

  export type ComplaintDetailMinAggregateInputType = {
    id?: true
    complaint_id?: true
    consumer_id?: true
    barangay_id?: true
    sitio_id?: true
    landmark?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintDetailMaxAggregateInputType = {
    id?: true
    complaint_id?: true
    consumer_id?: true
    barangay_id?: true
    sitio_id?: true
    landmark?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintDetailCountAggregateInputType = {
    id?: true
    complaint_id?: true
    consumer_id?: true
    barangay_id?: true
    sitio_id?: true
    landmark?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComplaintDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintDetail to aggregate.
     */
    where?: ComplaintDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintDetails to fetch.
     */
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintDetails
    **/
    _count?: true | ComplaintDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintDetailMaxAggregateInputType
  }

  export type GetComplaintDetailAggregateType<T extends ComplaintDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintDetail[P]>
      : GetScalarType<T[P], AggregateComplaintDetail[P]>
  }




  export type ComplaintDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintDetailWhereInput
    orderBy?: ComplaintDetailOrderByWithAggregationInput | ComplaintDetailOrderByWithAggregationInput[]
    by: ComplaintDetailScalarFieldEnum[] | ComplaintDetailScalarFieldEnum
    having?: ComplaintDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintDetailCountAggregateInputType | true
    _avg?: ComplaintDetailAvgAggregateInputType
    _sum?: ComplaintDetailSumAggregateInputType
    _min?: ComplaintDetailMinAggregateInputType
    _max?: ComplaintDetailMaxAggregateInputType
  }

  export type ComplaintDetailGroupByOutputType = {
    id: number
    complaint_id: number
    consumer_id: string | null
    barangay_id: string
    sitio_id: string | null
    landmark: string | null
    created_at: Date
    updated_at: Date
    _count: ComplaintDetailCountAggregateOutputType | null
    _avg: ComplaintDetailAvgAggregateOutputType | null
    _sum: ComplaintDetailSumAggregateOutputType | null
    _min: ComplaintDetailMinAggregateOutputType | null
    _max: ComplaintDetailMaxAggregateOutputType | null
  }

  type GetComplaintDetailGroupByPayload<T extends ComplaintDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintDetailGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaint_id?: boolean
    consumer_id?: boolean
    barangay_id?: boolean
    sitio_id?: boolean
    landmark?: boolean
    created_at?: boolean
    updated_at?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    sitio?: boolean | ComplaintDetail$sitioArgs<ExtArgs>
  }, ExtArgs["result"]["complaintDetail"]>

  export type ComplaintDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaint_id?: boolean
    consumer_id?: boolean
    barangay_id?: boolean
    sitio_id?: boolean
    landmark?: boolean
    created_at?: boolean
    updated_at?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    sitio?: boolean | ComplaintDetail$sitioArgs<ExtArgs>
  }, ExtArgs["result"]["complaintDetail"]>

  export type ComplaintDetailSelectScalar = {
    id?: boolean
    complaint_id?: boolean
    consumer_id?: boolean
    barangay_id?: boolean
    sitio_id?: boolean
    landmark?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ComplaintDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    sitio?: boolean | ComplaintDetail$sitioArgs<ExtArgs>
  }
  export type ComplaintDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    barangay?: boolean | BarangayDefaultArgs<ExtArgs>
    sitio?: boolean | ComplaintDetail$sitioArgs<ExtArgs>
  }

  export type $ComplaintDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintDetail"
    objects: {
      complaint: Prisma.$ComplaintPayload<ExtArgs>
      barangay: Prisma.$BarangayPayload<ExtArgs>
      sitio: Prisma.$SitioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      complaint_id: number
      consumer_id: string | null
      barangay_id: string
      sitio_id: string | null
      landmark: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["complaintDetail"]>
    composites: {}
  }

  type ComplaintDetailGetPayload<S extends boolean | null | undefined | ComplaintDetailDefaultArgs> = $Result.GetResult<Prisma.$ComplaintDetailPayload, S>

  type ComplaintDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintDetailCountAggregateInputType | true
    }

  export interface ComplaintDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintDetail'], meta: { name: 'ComplaintDetail' } }
    /**
     * Find zero or one ComplaintDetail that matches the filter.
     * @param {ComplaintDetailFindUniqueArgs} args - Arguments to find a ComplaintDetail
     * @example
     * // Get one ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintDetailFindUniqueArgs>(args: SelectSubset<T, ComplaintDetailFindUniqueArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplaintDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintDetailFindUniqueOrThrowArgs} args - Arguments to find a ComplaintDetail
     * @example
     * // Get one ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplaintDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailFindFirstArgs} args - Arguments to find a ComplaintDetail
     * @example
     * // Get one ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintDetailFindFirstArgs>(args?: SelectSubset<T, ComplaintDetailFindFirstArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplaintDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailFindFirstOrThrowArgs} args - Arguments to find a ComplaintDetail
     * @example
     * // Get one ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplaintDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintDetails
     * const complaintDetails = await prisma.complaintDetail.findMany()
     * 
     * // Get first 10 ComplaintDetails
     * const complaintDetails = await prisma.complaintDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintDetailWithIdOnly = await prisma.complaintDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintDetailFindManyArgs>(args?: SelectSubset<T, ComplaintDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplaintDetail.
     * @param {ComplaintDetailCreateArgs} args - Arguments to create a ComplaintDetail.
     * @example
     * // Create one ComplaintDetail
     * const ComplaintDetail = await prisma.complaintDetail.create({
     *   data: {
     *     // ... data to create a ComplaintDetail
     *   }
     * })
     * 
     */
    create<T extends ComplaintDetailCreateArgs>(args: SelectSubset<T, ComplaintDetailCreateArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplaintDetails.
     * @param {ComplaintDetailCreateManyArgs} args - Arguments to create many ComplaintDetails.
     * @example
     * // Create many ComplaintDetails
     * const complaintDetail = await prisma.complaintDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintDetailCreateManyArgs>(args?: SelectSubset<T, ComplaintDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplaintDetails and returns the data saved in the database.
     * @param {ComplaintDetailCreateManyAndReturnArgs} args - Arguments to create many ComplaintDetails.
     * @example
     * // Create many ComplaintDetails
     * const complaintDetail = await prisma.complaintDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplaintDetails and only return the `id`
     * const complaintDetailWithIdOnly = await prisma.complaintDetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplaintDetail.
     * @param {ComplaintDetailDeleteArgs} args - Arguments to delete one ComplaintDetail.
     * @example
     * // Delete one ComplaintDetail
     * const ComplaintDetail = await prisma.complaintDetail.delete({
     *   where: {
     *     // ... filter to delete one ComplaintDetail
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDetailDeleteArgs>(args: SelectSubset<T, ComplaintDetailDeleteArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplaintDetail.
     * @param {ComplaintDetailUpdateArgs} args - Arguments to update one ComplaintDetail.
     * @example
     * // Update one ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintDetailUpdateArgs>(args: SelectSubset<T, ComplaintDetailUpdateArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplaintDetails.
     * @param {ComplaintDetailDeleteManyArgs} args - Arguments to filter ComplaintDetails to delete.
     * @example
     * // Delete a few ComplaintDetails
     * const { count } = await prisma.complaintDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDetailDeleteManyArgs>(args?: SelectSubset<T, ComplaintDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintDetails
     * const complaintDetail = await prisma.complaintDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintDetailUpdateManyArgs>(args: SelectSubset<T, ComplaintDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintDetail.
     * @param {ComplaintDetailUpsertArgs} args - Arguments to update or create a ComplaintDetail.
     * @example
     * // Update or create a ComplaintDetail
     * const complaintDetail = await prisma.complaintDetail.upsert({
     *   create: {
     *     // ... data to create a ComplaintDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintDetail we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintDetailUpsertArgs>(args: SelectSubset<T, ComplaintDetailUpsertArgs<ExtArgs>>): Prisma__ComplaintDetailClient<$Result.GetResult<Prisma.$ComplaintDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplaintDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailCountArgs} args - Arguments to filter ComplaintDetails to count.
     * @example
     * // Count the number of ComplaintDetails
     * const count = await prisma.complaintDetail.count({
     *   where: {
     *     // ... the filter for the ComplaintDetails we want to count
     *   }
     * })
    **/
    count<T extends ComplaintDetailCountArgs>(
      args?: Subset<T, ComplaintDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintDetailAggregateArgs>(args: Subset<T, ComplaintDetailAggregateArgs>): Prisma.PrismaPromise<GetComplaintDetailAggregateType<T>>

    /**
     * Group by ComplaintDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintDetailGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintDetail model
   */
  readonly fields: ComplaintDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends ComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDefaultArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    barangay<T extends BarangayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarangayDefaultArgs<ExtArgs>>): Prisma__BarangayClient<$Result.GetResult<Prisma.$BarangayPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sitio<T extends ComplaintDetail$sitioArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDetail$sitioArgs<ExtArgs>>): Prisma__SitioClient<$Result.GetResult<Prisma.$SitioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintDetail model
   */ 
  interface ComplaintDetailFieldRefs {
    readonly id: FieldRef<"ComplaintDetail", 'Int'>
    readonly complaint_id: FieldRef<"ComplaintDetail", 'Int'>
    readonly consumer_id: FieldRef<"ComplaintDetail", 'String'>
    readonly barangay_id: FieldRef<"ComplaintDetail", 'String'>
    readonly sitio_id: FieldRef<"ComplaintDetail", 'String'>
    readonly landmark: FieldRef<"ComplaintDetail", 'String'>
    readonly created_at: FieldRef<"ComplaintDetail", 'DateTime'>
    readonly updated_at: FieldRef<"ComplaintDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintDetail findUnique
   */
  export type ComplaintDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintDetail to fetch.
     */
    where: ComplaintDetailWhereUniqueInput
  }

  /**
   * ComplaintDetail findUniqueOrThrow
   */
  export type ComplaintDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintDetail to fetch.
     */
    where: ComplaintDetailWhereUniqueInput
  }

  /**
   * ComplaintDetail findFirst
   */
  export type ComplaintDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintDetail to fetch.
     */
    where?: ComplaintDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintDetails to fetch.
     */
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintDetails.
     */
    cursor?: ComplaintDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintDetails.
     */
    distinct?: ComplaintDetailScalarFieldEnum | ComplaintDetailScalarFieldEnum[]
  }

  /**
   * ComplaintDetail findFirstOrThrow
   */
  export type ComplaintDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintDetail to fetch.
     */
    where?: ComplaintDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintDetails to fetch.
     */
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintDetails.
     */
    cursor?: ComplaintDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintDetails.
     */
    distinct?: ComplaintDetailScalarFieldEnum | ComplaintDetailScalarFieldEnum[]
  }

  /**
   * ComplaintDetail findMany
   */
  export type ComplaintDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintDetails to fetch.
     */
    where?: ComplaintDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintDetails to fetch.
     */
    orderBy?: ComplaintDetailOrderByWithRelationInput | ComplaintDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintDetails.
     */
    cursor?: ComplaintDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintDetails.
     */
    skip?: number
    distinct?: ComplaintDetailScalarFieldEnum | ComplaintDetailScalarFieldEnum[]
  }

  /**
   * ComplaintDetail create
   */
  export type ComplaintDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintDetail.
     */
    data: XOR<ComplaintDetailCreateInput, ComplaintDetailUncheckedCreateInput>
  }

  /**
   * ComplaintDetail createMany
   */
  export type ComplaintDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintDetails.
     */
    data: ComplaintDetailCreateManyInput | ComplaintDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintDetail createManyAndReturn
   */
  export type ComplaintDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplaintDetails.
     */
    data: ComplaintDetailCreateManyInput | ComplaintDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplaintDetail update
   */
  export type ComplaintDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintDetail.
     */
    data: XOR<ComplaintDetailUpdateInput, ComplaintDetailUncheckedUpdateInput>
    /**
     * Choose, which ComplaintDetail to update.
     */
    where: ComplaintDetailWhereUniqueInput
  }

  /**
   * ComplaintDetail updateMany
   */
  export type ComplaintDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintDetails.
     */
    data: XOR<ComplaintDetailUpdateManyMutationInput, ComplaintDetailUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintDetails to update
     */
    where?: ComplaintDetailWhereInput
    limit?: number
  }

  /**
   * ComplaintDetail upsert
   */
  export type ComplaintDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintDetail to update in case it exists.
     */
    where: ComplaintDetailWhereUniqueInput
    /**
     * In case the ComplaintDetail found by the `where` argument doesn't exist, create a new ComplaintDetail with this data.
     */
    create: XOR<ComplaintDetailCreateInput, ComplaintDetailUncheckedCreateInput>
    /**
     * In case the ComplaintDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintDetailUpdateInput, ComplaintDetailUncheckedUpdateInput>
  }

  /**
   * ComplaintDetail delete
   */
  export type ComplaintDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
    /**
     * Filter which ComplaintDetail to delete.
     */
    where: ComplaintDetailWhereUniqueInput
  }

  /**
   * ComplaintDetail deleteMany
   */
  export type ComplaintDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintDetails to delete
     */
    where?: ComplaintDetailWhereInput
    limit?: number
  }

  /**
   * ComplaintDetail.sitio
   */
  export type ComplaintDetail$sitioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sitio
     */
    select?: SitioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitioInclude<ExtArgs> | null
    where?: SitioWhereInput
  }

  /**
   * ComplaintDetail without action
   */
  export type ComplaintDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintDetail
     */
    select?: ComplaintDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintDetailInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintStatus
   */

  export type AggregateComplaintStatus = {
    _count: ComplaintStatusCountAggregateOutputType | null
    _avg: ComplaintStatusAvgAggregateOutputType | null
    _sum: ComplaintStatusSumAggregateOutputType | null
    _min: ComplaintStatusMinAggregateOutputType | null
    _max: ComplaintStatusMaxAggregateOutputType | null
  }

  export type ComplaintStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type ComplaintStatusSumAggregateOutputType = {
    id: number | null
  }

  export type ComplaintStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    color_class: string | null
    description: string | null
  }

  export type ComplaintStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color_class: string | null
    description: string | null
  }

  export type ComplaintStatusCountAggregateOutputType = {
    id: number
    name: number
    color_class: number
    description: number
    _all: number
  }


  export type ComplaintStatusAvgAggregateInputType = {
    id?: true
  }

  export type ComplaintStatusSumAggregateInputType = {
    id?: true
  }

  export type ComplaintStatusMinAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
  }

  export type ComplaintStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
  }

  export type ComplaintStatusCountAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
    _all?: true
  }

  export type ComplaintStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintStatus to aggregate.
     */
    where?: ComplaintStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatuses to fetch.
     */
    orderBy?: ComplaintStatusOrderByWithRelationInput | ComplaintStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintStatuses
    **/
    _count?: true | ComplaintStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintStatusMaxAggregateInputType
  }

  export type GetComplaintStatusAggregateType<T extends ComplaintStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintStatus[P]>
      : GetScalarType<T[P], AggregateComplaintStatus[P]>
  }




  export type ComplaintStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintStatusWhereInput
    orderBy?: ComplaintStatusOrderByWithAggregationInput | ComplaintStatusOrderByWithAggregationInput[]
    by: ComplaintStatusScalarFieldEnum[] | ComplaintStatusScalarFieldEnum
    having?: ComplaintStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintStatusCountAggregateInputType | true
    _avg?: ComplaintStatusAvgAggregateInputType
    _sum?: ComplaintStatusSumAggregateInputType
    _min?: ComplaintStatusMinAggregateInputType
    _max?: ComplaintStatusMaxAggregateInputType
  }

  export type ComplaintStatusGroupByOutputType = {
    id: number
    name: string
    color_class: string
    description: string
    _count: ComplaintStatusCountAggregateOutputType | null
    _avg: ComplaintStatusAvgAggregateOutputType | null
    _sum: ComplaintStatusSumAggregateOutputType | null
    _min: ComplaintStatusMinAggregateOutputType | null
    _max: ComplaintStatusMaxAggregateOutputType | null
  }

  type GetComplaintStatusGroupByPayload<T extends ComplaintStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintStatusGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
    complaints?: boolean | ComplaintStatus$complaintsArgs<ExtArgs>
    logs?: boolean | ComplaintStatus$logsArgs<ExtArgs>
    _count?: boolean | ComplaintStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintStatus"]>

  export type ComplaintStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
  }, ExtArgs["result"]["complaintStatus"]>

  export type ComplaintStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
  }

  export type ComplaintStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | ComplaintStatus$complaintsArgs<ExtArgs>
    logs?: boolean | ComplaintStatus$logsArgs<ExtArgs>
    _count?: boolean | ComplaintStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComplaintStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComplaintStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintStatus"
    objects: {
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      logs: Prisma.$ComplaintLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color_class: string
      description: string
    }, ExtArgs["result"]["complaintStatus"]>
    composites: {}
  }

  type ComplaintStatusGetPayload<S extends boolean | null | undefined | ComplaintStatusDefaultArgs> = $Result.GetResult<Prisma.$ComplaintStatusPayload, S>

  type ComplaintStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintStatusCountAggregateInputType | true
    }

  export interface ComplaintStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintStatus'], meta: { name: 'ComplaintStatus' } }
    /**
     * Find zero or one ComplaintStatus that matches the filter.
     * @param {ComplaintStatusFindUniqueArgs} args - Arguments to find a ComplaintStatus
     * @example
     * // Get one ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintStatusFindUniqueArgs>(args: SelectSubset<T, ComplaintStatusFindUniqueArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplaintStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintStatusFindUniqueOrThrowArgs} args - Arguments to find a ComplaintStatus
     * @example
     * // Get one ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplaintStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusFindFirstArgs} args - Arguments to find a ComplaintStatus
     * @example
     * // Get one ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintStatusFindFirstArgs>(args?: SelectSubset<T, ComplaintStatusFindFirstArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplaintStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusFindFirstOrThrowArgs} args - Arguments to find a ComplaintStatus
     * @example
     * // Get one ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplaintStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintStatuses
     * const complaintStatuses = await prisma.complaintStatus.findMany()
     * 
     * // Get first 10 ComplaintStatuses
     * const complaintStatuses = await prisma.complaintStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintStatusWithIdOnly = await prisma.complaintStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintStatusFindManyArgs>(args?: SelectSubset<T, ComplaintStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplaintStatus.
     * @param {ComplaintStatusCreateArgs} args - Arguments to create a ComplaintStatus.
     * @example
     * // Create one ComplaintStatus
     * const ComplaintStatus = await prisma.complaintStatus.create({
     *   data: {
     *     // ... data to create a ComplaintStatus
     *   }
     * })
     * 
     */
    create<T extends ComplaintStatusCreateArgs>(args: SelectSubset<T, ComplaintStatusCreateArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplaintStatuses.
     * @param {ComplaintStatusCreateManyArgs} args - Arguments to create many ComplaintStatuses.
     * @example
     * // Create many ComplaintStatuses
     * const complaintStatus = await prisma.complaintStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintStatusCreateManyArgs>(args?: SelectSubset<T, ComplaintStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplaintStatuses and returns the data saved in the database.
     * @param {ComplaintStatusCreateManyAndReturnArgs} args - Arguments to create many ComplaintStatuses.
     * @example
     * // Create many ComplaintStatuses
     * const complaintStatus = await prisma.complaintStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplaintStatuses and only return the `id`
     * const complaintStatusWithIdOnly = await prisma.complaintStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplaintStatus.
     * @param {ComplaintStatusDeleteArgs} args - Arguments to delete one ComplaintStatus.
     * @example
     * // Delete one ComplaintStatus
     * const ComplaintStatus = await prisma.complaintStatus.delete({
     *   where: {
     *     // ... filter to delete one ComplaintStatus
     *   }
     * })
     * 
     */
    delete<T extends ComplaintStatusDeleteArgs>(args: SelectSubset<T, ComplaintStatusDeleteArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplaintStatus.
     * @param {ComplaintStatusUpdateArgs} args - Arguments to update one ComplaintStatus.
     * @example
     * // Update one ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintStatusUpdateArgs>(args: SelectSubset<T, ComplaintStatusUpdateArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplaintStatuses.
     * @param {ComplaintStatusDeleteManyArgs} args - Arguments to filter ComplaintStatuses to delete.
     * @example
     * // Delete a few ComplaintStatuses
     * const { count } = await prisma.complaintStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintStatusDeleteManyArgs>(args?: SelectSubset<T, ComplaintStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintStatuses
     * const complaintStatus = await prisma.complaintStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintStatusUpdateManyArgs>(args: SelectSubset<T, ComplaintStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintStatus.
     * @param {ComplaintStatusUpsertArgs} args - Arguments to update or create a ComplaintStatus.
     * @example
     * // Update or create a ComplaintStatus
     * const complaintStatus = await prisma.complaintStatus.upsert({
     *   create: {
     *     // ... data to create a ComplaintStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintStatus we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintStatusUpsertArgs>(args: SelectSubset<T, ComplaintStatusUpsertArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplaintStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusCountArgs} args - Arguments to filter ComplaintStatuses to count.
     * @example
     * // Count the number of ComplaintStatuses
     * const count = await prisma.complaintStatus.count({
     *   where: {
     *     // ... the filter for the ComplaintStatuses we want to count
     *   }
     * })
    **/
    count<T extends ComplaintStatusCountArgs>(
      args?: Subset<T, ComplaintStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintStatusAggregateArgs>(args: Subset<T, ComplaintStatusAggregateArgs>): Prisma.PrismaPromise<GetComplaintStatusAggregateType<T>>

    /**
     * Group by ComplaintStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintStatusGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintStatus model
   */
  readonly fields: ComplaintStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends ComplaintStatus$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintStatus$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends ComplaintStatus$logsArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintStatus$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintStatus model
   */ 
  interface ComplaintStatusFieldRefs {
    readonly id: FieldRef<"ComplaintStatus", 'Int'>
    readonly name: FieldRef<"ComplaintStatus", 'String'>
    readonly color_class: FieldRef<"ComplaintStatus", 'String'>
    readonly description: FieldRef<"ComplaintStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintStatus findUnique
   */
  export type ComplaintStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatus to fetch.
     */
    where: ComplaintStatusWhereUniqueInput
  }

  /**
   * ComplaintStatus findUniqueOrThrow
   */
  export type ComplaintStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatus to fetch.
     */
    where: ComplaintStatusWhereUniqueInput
  }

  /**
   * ComplaintStatus findFirst
   */
  export type ComplaintStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatus to fetch.
     */
    where?: ComplaintStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatuses to fetch.
     */
    orderBy?: ComplaintStatusOrderByWithRelationInput | ComplaintStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintStatuses.
     */
    cursor?: ComplaintStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintStatuses.
     */
    distinct?: ComplaintStatusScalarFieldEnum | ComplaintStatusScalarFieldEnum[]
  }

  /**
   * ComplaintStatus findFirstOrThrow
   */
  export type ComplaintStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatus to fetch.
     */
    where?: ComplaintStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatuses to fetch.
     */
    orderBy?: ComplaintStatusOrderByWithRelationInput | ComplaintStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintStatuses.
     */
    cursor?: ComplaintStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintStatuses.
     */
    distinct?: ComplaintStatusScalarFieldEnum | ComplaintStatusScalarFieldEnum[]
  }

  /**
   * ComplaintStatus findMany
   */
  export type ComplaintStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatuses to fetch.
     */
    where?: ComplaintStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatuses to fetch.
     */
    orderBy?: ComplaintStatusOrderByWithRelationInput | ComplaintStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintStatuses.
     */
    cursor?: ComplaintStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatuses.
     */
    skip?: number
    distinct?: ComplaintStatusScalarFieldEnum | ComplaintStatusScalarFieldEnum[]
  }

  /**
   * ComplaintStatus create
   */
  export type ComplaintStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintStatus.
     */
    data: XOR<ComplaintStatusCreateInput, ComplaintStatusUncheckedCreateInput>
  }

  /**
   * ComplaintStatus createMany
   */
  export type ComplaintStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintStatuses.
     */
    data: ComplaintStatusCreateManyInput | ComplaintStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintStatus createManyAndReturn
   */
  export type ComplaintStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplaintStatuses.
     */
    data: ComplaintStatusCreateManyInput | ComplaintStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintStatus update
   */
  export type ComplaintStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintStatus.
     */
    data: XOR<ComplaintStatusUpdateInput, ComplaintStatusUncheckedUpdateInput>
    /**
     * Choose, which ComplaintStatus to update.
     */
    where: ComplaintStatusWhereUniqueInput
  }

  /**
   * ComplaintStatus updateMany
   */
  export type ComplaintStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintStatuses.
     */
    data: XOR<ComplaintStatusUpdateManyMutationInput, ComplaintStatusUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintStatuses to update
     */
    where?: ComplaintStatusWhereInput
    limit?: number
  }

  /**
   * ComplaintStatus upsert
   */
  export type ComplaintStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintStatus to update in case it exists.
     */
    where: ComplaintStatusWhereUniqueInput
    /**
     * In case the ComplaintStatus found by the `where` argument doesn't exist, create a new ComplaintStatus with this data.
     */
    create: XOR<ComplaintStatusCreateInput, ComplaintStatusUncheckedCreateInput>
    /**
     * In case the ComplaintStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintStatusUpdateInput, ComplaintStatusUncheckedUpdateInput>
  }

  /**
   * ComplaintStatus delete
   */
  export type ComplaintStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
    /**
     * Filter which ComplaintStatus to delete.
     */
    where: ComplaintStatusWhereUniqueInput
  }

  /**
   * ComplaintStatus deleteMany
   */
  export type ComplaintStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintStatuses to delete
     */
    where?: ComplaintStatusWhereInput
    limit?: number
  }

  /**
   * ComplaintStatus.complaints
   */
  export type ComplaintStatus$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * ComplaintStatus.logs
   */
  export type ComplaintStatus$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    where?: ComplaintLogWhereInput
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    cursor?: ComplaintLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintLogScalarFieldEnum | ComplaintLogScalarFieldEnum[]
  }

  /**
   * ComplaintStatus without action
   */
  export type ComplaintStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatus
     */
    select?: ComplaintStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintReportType
   */

  export type AggregateComplaintReportType = {
    _count: ComplaintReportTypeCountAggregateOutputType | null
    _avg: ComplaintReportTypeAvgAggregateOutputType | null
    _sum: ComplaintReportTypeSumAggregateOutputType | null
    _min: ComplaintReportTypeMinAggregateOutputType | null
    _max: ComplaintReportTypeMaxAggregateOutputType | null
  }

  export type ComplaintReportTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ComplaintReportTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ComplaintReportTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ComplaintReportTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ComplaintReportTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ComplaintReportTypeAvgAggregateInputType = {
    id?: true
  }

  export type ComplaintReportTypeSumAggregateInputType = {
    id?: true
  }

  export type ComplaintReportTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ComplaintReportTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ComplaintReportTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ComplaintReportTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintReportType to aggregate.
     */
    where?: ComplaintReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintReportTypes to fetch.
     */
    orderBy?: ComplaintReportTypeOrderByWithRelationInput | ComplaintReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintReportTypes
    **/
    _count?: true | ComplaintReportTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintReportTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintReportTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintReportTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintReportTypeMaxAggregateInputType
  }

  export type GetComplaintReportTypeAggregateType<T extends ComplaintReportTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintReportType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintReportType[P]>
      : GetScalarType<T[P], AggregateComplaintReportType[P]>
  }




  export type ComplaintReportTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintReportTypeWhereInput
    orderBy?: ComplaintReportTypeOrderByWithAggregationInput | ComplaintReportTypeOrderByWithAggregationInput[]
    by: ComplaintReportTypeScalarFieldEnum[] | ComplaintReportTypeScalarFieldEnum
    having?: ComplaintReportTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintReportTypeCountAggregateInputType | true
    _avg?: ComplaintReportTypeAvgAggregateInputType
    _sum?: ComplaintReportTypeSumAggregateInputType
    _min?: ComplaintReportTypeMinAggregateInputType
    _max?: ComplaintReportTypeMaxAggregateInputType
  }

  export type ComplaintReportTypeGroupByOutputType = {
    id: number
    name: string
    _count: ComplaintReportTypeCountAggregateOutputType | null
    _avg: ComplaintReportTypeAvgAggregateOutputType | null
    _sum: ComplaintReportTypeSumAggregateOutputType | null
    _min: ComplaintReportTypeMinAggregateOutputType | null
    _max: ComplaintReportTypeMaxAggregateOutputType | null
  }

  type GetComplaintReportTypeGroupByPayload<T extends ComplaintReportTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintReportTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintReportTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintReportTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintReportTypeGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintReportTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    complaints?: boolean | ComplaintReportType$complaintsArgs<ExtArgs>
    _count?: boolean | ComplaintReportTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintReportType"]>

  export type ComplaintReportTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["complaintReportType"]>

  export type ComplaintReportTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ComplaintReportTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | ComplaintReportType$complaintsArgs<ExtArgs>
    _count?: boolean | ComplaintReportTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComplaintReportTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComplaintReportTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintReportType"
    objects: {
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["complaintReportType"]>
    composites: {}
  }

  type ComplaintReportTypeGetPayload<S extends boolean | null | undefined | ComplaintReportTypeDefaultArgs> = $Result.GetResult<Prisma.$ComplaintReportTypePayload, S>

  type ComplaintReportTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintReportTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintReportTypeCountAggregateInputType | true
    }

  export interface ComplaintReportTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintReportType'], meta: { name: 'ComplaintReportType' } }
    /**
     * Find zero or one ComplaintReportType that matches the filter.
     * @param {ComplaintReportTypeFindUniqueArgs} args - Arguments to find a ComplaintReportType
     * @example
     * // Get one ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintReportTypeFindUniqueArgs>(args: SelectSubset<T, ComplaintReportTypeFindUniqueArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplaintReportType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintReportTypeFindUniqueOrThrowArgs} args - Arguments to find a ComplaintReportType
     * @example
     * // Get one ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintReportTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintReportTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplaintReportType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeFindFirstArgs} args - Arguments to find a ComplaintReportType
     * @example
     * // Get one ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintReportTypeFindFirstArgs>(args?: SelectSubset<T, ComplaintReportTypeFindFirstArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplaintReportType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeFindFirstOrThrowArgs} args - Arguments to find a ComplaintReportType
     * @example
     * // Get one ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintReportTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintReportTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplaintReportTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintReportTypes
     * const complaintReportTypes = await prisma.complaintReportType.findMany()
     * 
     * // Get first 10 ComplaintReportTypes
     * const complaintReportTypes = await prisma.complaintReportType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintReportTypeWithIdOnly = await prisma.complaintReportType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintReportTypeFindManyArgs>(args?: SelectSubset<T, ComplaintReportTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplaintReportType.
     * @param {ComplaintReportTypeCreateArgs} args - Arguments to create a ComplaintReportType.
     * @example
     * // Create one ComplaintReportType
     * const ComplaintReportType = await prisma.complaintReportType.create({
     *   data: {
     *     // ... data to create a ComplaintReportType
     *   }
     * })
     * 
     */
    create<T extends ComplaintReportTypeCreateArgs>(args: SelectSubset<T, ComplaintReportTypeCreateArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplaintReportTypes.
     * @param {ComplaintReportTypeCreateManyArgs} args - Arguments to create many ComplaintReportTypes.
     * @example
     * // Create many ComplaintReportTypes
     * const complaintReportType = await prisma.complaintReportType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintReportTypeCreateManyArgs>(args?: SelectSubset<T, ComplaintReportTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplaintReportTypes and returns the data saved in the database.
     * @param {ComplaintReportTypeCreateManyAndReturnArgs} args - Arguments to create many ComplaintReportTypes.
     * @example
     * // Create many ComplaintReportTypes
     * const complaintReportType = await prisma.complaintReportType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplaintReportTypes and only return the `id`
     * const complaintReportTypeWithIdOnly = await prisma.complaintReportType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintReportTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintReportTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplaintReportType.
     * @param {ComplaintReportTypeDeleteArgs} args - Arguments to delete one ComplaintReportType.
     * @example
     * // Delete one ComplaintReportType
     * const ComplaintReportType = await prisma.complaintReportType.delete({
     *   where: {
     *     // ... filter to delete one ComplaintReportType
     *   }
     * })
     * 
     */
    delete<T extends ComplaintReportTypeDeleteArgs>(args: SelectSubset<T, ComplaintReportTypeDeleteArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplaintReportType.
     * @param {ComplaintReportTypeUpdateArgs} args - Arguments to update one ComplaintReportType.
     * @example
     * // Update one ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintReportTypeUpdateArgs>(args: SelectSubset<T, ComplaintReportTypeUpdateArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplaintReportTypes.
     * @param {ComplaintReportTypeDeleteManyArgs} args - Arguments to filter ComplaintReportTypes to delete.
     * @example
     * // Delete a few ComplaintReportTypes
     * const { count } = await prisma.complaintReportType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintReportTypeDeleteManyArgs>(args?: SelectSubset<T, ComplaintReportTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintReportTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintReportTypes
     * const complaintReportType = await prisma.complaintReportType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintReportTypeUpdateManyArgs>(args: SelectSubset<T, ComplaintReportTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintReportType.
     * @param {ComplaintReportTypeUpsertArgs} args - Arguments to update or create a ComplaintReportType.
     * @example
     * // Update or create a ComplaintReportType
     * const complaintReportType = await prisma.complaintReportType.upsert({
     *   create: {
     *     // ... data to create a ComplaintReportType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintReportType we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintReportTypeUpsertArgs>(args: SelectSubset<T, ComplaintReportTypeUpsertArgs<ExtArgs>>): Prisma__ComplaintReportTypeClient<$Result.GetResult<Prisma.$ComplaintReportTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplaintReportTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeCountArgs} args - Arguments to filter ComplaintReportTypes to count.
     * @example
     * // Count the number of ComplaintReportTypes
     * const count = await prisma.complaintReportType.count({
     *   where: {
     *     // ... the filter for the ComplaintReportTypes we want to count
     *   }
     * })
    **/
    count<T extends ComplaintReportTypeCountArgs>(
      args?: Subset<T, ComplaintReportTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintReportTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintReportType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintReportTypeAggregateArgs>(args: Subset<T, ComplaintReportTypeAggregateArgs>): Prisma.PrismaPromise<GetComplaintReportTypeAggregateType<T>>

    /**
     * Group by ComplaintReportType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintReportTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintReportTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintReportTypeGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintReportTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintReportTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintReportTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintReportType model
   */
  readonly fields: ComplaintReportTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintReportType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintReportTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends ComplaintReportType$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintReportType$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintReportType model
   */ 
  interface ComplaintReportTypeFieldRefs {
    readonly id: FieldRef<"ComplaintReportType", 'Int'>
    readonly name: FieldRef<"ComplaintReportType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintReportType findUnique
   */
  export type ComplaintReportTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintReportType to fetch.
     */
    where: ComplaintReportTypeWhereUniqueInput
  }

  /**
   * ComplaintReportType findUniqueOrThrow
   */
  export type ComplaintReportTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintReportType to fetch.
     */
    where: ComplaintReportTypeWhereUniqueInput
  }

  /**
   * ComplaintReportType findFirst
   */
  export type ComplaintReportTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintReportType to fetch.
     */
    where?: ComplaintReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintReportTypes to fetch.
     */
    orderBy?: ComplaintReportTypeOrderByWithRelationInput | ComplaintReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintReportTypes.
     */
    cursor?: ComplaintReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintReportTypes.
     */
    distinct?: ComplaintReportTypeScalarFieldEnum | ComplaintReportTypeScalarFieldEnum[]
  }

  /**
   * ComplaintReportType findFirstOrThrow
   */
  export type ComplaintReportTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintReportType to fetch.
     */
    where?: ComplaintReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintReportTypes to fetch.
     */
    orderBy?: ComplaintReportTypeOrderByWithRelationInput | ComplaintReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintReportTypes.
     */
    cursor?: ComplaintReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintReportTypes.
     */
    distinct?: ComplaintReportTypeScalarFieldEnum | ComplaintReportTypeScalarFieldEnum[]
  }

  /**
   * ComplaintReportType findMany
   */
  export type ComplaintReportTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintReportTypes to fetch.
     */
    where?: ComplaintReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintReportTypes to fetch.
     */
    orderBy?: ComplaintReportTypeOrderByWithRelationInput | ComplaintReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintReportTypes.
     */
    cursor?: ComplaintReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintReportTypes.
     */
    skip?: number
    distinct?: ComplaintReportTypeScalarFieldEnum | ComplaintReportTypeScalarFieldEnum[]
  }

  /**
   * ComplaintReportType create
   */
  export type ComplaintReportTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintReportType.
     */
    data: XOR<ComplaintReportTypeCreateInput, ComplaintReportTypeUncheckedCreateInput>
  }

  /**
   * ComplaintReportType createMany
   */
  export type ComplaintReportTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintReportTypes.
     */
    data: ComplaintReportTypeCreateManyInput | ComplaintReportTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintReportType createManyAndReturn
   */
  export type ComplaintReportTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplaintReportTypes.
     */
    data: ComplaintReportTypeCreateManyInput | ComplaintReportTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintReportType update
   */
  export type ComplaintReportTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintReportType.
     */
    data: XOR<ComplaintReportTypeUpdateInput, ComplaintReportTypeUncheckedUpdateInput>
    /**
     * Choose, which ComplaintReportType to update.
     */
    where: ComplaintReportTypeWhereUniqueInput
  }

  /**
   * ComplaintReportType updateMany
   */
  export type ComplaintReportTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintReportTypes.
     */
    data: XOR<ComplaintReportTypeUpdateManyMutationInput, ComplaintReportTypeUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintReportTypes to update
     */
    where?: ComplaintReportTypeWhereInput
    limit?: number
  }

  /**
   * ComplaintReportType upsert
   */
  export type ComplaintReportTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintReportType to update in case it exists.
     */
    where: ComplaintReportTypeWhereUniqueInput
    /**
     * In case the ComplaintReportType found by the `where` argument doesn't exist, create a new ComplaintReportType with this data.
     */
    create: XOR<ComplaintReportTypeCreateInput, ComplaintReportTypeUncheckedCreateInput>
    /**
     * In case the ComplaintReportType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintReportTypeUpdateInput, ComplaintReportTypeUncheckedUpdateInput>
  }

  /**
   * ComplaintReportType delete
   */
  export type ComplaintReportTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
    /**
     * Filter which ComplaintReportType to delete.
     */
    where: ComplaintReportTypeWhereUniqueInput
  }

  /**
   * ComplaintReportType deleteMany
   */
  export type ComplaintReportTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintReportTypes to delete
     */
    where?: ComplaintReportTypeWhereInput
    limit?: number
  }

  /**
   * ComplaintReportType.complaints
   */
  export type ComplaintReportType$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * ComplaintReportType without action
   */
  export type ComplaintReportTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintReportType
     */
    select?: ComplaintReportTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintReportTypeInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintLog
   */

  export type AggregateComplaintLog = {
    _count: ComplaintLogCountAggregateOutputType | null
    _avg: ComplaintLogAvgAggregateOutputType | null
    _sum: ComplaintLogSumAggregateOutputType | null
    _min: ComplaintLogMinAggregateOutputType | null
    _max: ComplaintLogMaxAggregateOutputType | null
  }

  export type ComplaintLogAvgAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    complaint_status_id: number | null
  }

  export type ComplaintLogSumAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    complaint_status_id: number | null
  }

  export type ComplaintLogMinAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    complaint_status_id: number | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ComplaintLogMaxAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    complaint_status_id: number | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ComplaintLogCountAggregateOutputType = {
    id: number
    complaint_id: number
    complaint_status_id: number
    remarks: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ComplaintLogAvgAggregateInputType = {
    id?: true
    complaint_id?: true
    complaint_status_id?: true
  }

  export type ComplaintLogSumAggregateInputType = {
    id?: true
    complaint_id?: true
    complaint_status_id?: true
  }

  export type ComplaintLogMinAggregateInputType = {
    id?: true
    complaint_id?: true
    complaint_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
  }

  export type ComplaintLogMaxAggregateInputType = {
    id?: true
    complaint_id?: true
    complaint_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
  }

  export type ComplaintLogCountAggregateInputType = {
    id?: true
    complaint_id?: true
    complaint_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ComplaintLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintLog to aggregate.
     */
    where?: ComplaintLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintLogs to fetch.
     */
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintLogs
    **/
    _count?: true | ComplaintLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintLogMaxAggregateInputType
  }

  export type GetComplaintLogAggregateType<T extends ComplaintLogAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintLog[P]>
      : GetScalarType<T[P], AggregateComplaintLog[P]>
  }




  export type ComplaintLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintLogWhereInput
    orderBy?: ComplaintLogOrderByWithAggregationInput | ComplaintLogOrderByWithAggregationInput[]
    by: ComplaintLogScalarFieldEnum[] | ComplaintLogScalarFieldEnum
    having?: ComplaintLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintLogCountAggregateInputType | true
    _avg?: ComplaintLogAvgAggregateInputType
    _sum?: ComplaintLogSumAggregateInputType
    _min?: ComplaintLogMinAggregateInputType
    _max?: ComplaintLogMaxAggregateInputType
  }

  export type ComplaintLogGroupByOutputType = {
    id: number
    complaint_id: number
    complaint_status_id: number
    remarks: string | null
    created_by: string
    created_at: Date
    _count: ComplaintLogCountAggregateOutputType | null
    _avg: ComplaintLogAvgAggregateOutputType | null
    _sum: ComplaintLogSumAggregateOutputType | null
    _min: ComplaintLogMinAggregateOutputType | null
    _max: ComplaintLogMaxAggregateOutputType | null
  }

  type GetComplaintLogGroupByPayload<T extends ComplaintLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintLogGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintLogGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaint_id?: boolean
    complaint_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintLog"]>

  export type ComplaintLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaint_id?: boolean
    complaint_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintLog"]>

  export type ComplaintLogSelectScalar = {
    id?: boolean
    complaint_id?: boolean
    complaint_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type ComplaintLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }
  export type ComplaintLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | ComplaintDefaultArgs<ExtArgs>
    status?: boolean | ComplaintStatusDefaultArgs<ExtArgs>
  }

  export type $ComplaintLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintLog"
    objects: {
      complaint: Prisma.$ComplaintPayload<ExtArgs>
      status: Prisma.$ComplaintStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      complaint_id: number
      complaint_status_id: number
      remarks: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["complaintLog"]>
    composites: {}
  }

  type ComplaintLogGetPayload<S extends boolean | null | undefined | ComplaintLogDefaultArgs> = $Result.GetResult<Prisma.$ComplaintLogPayload, S>

  type ComplaintLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintLogCountAggregateInputType | true
    }

  export interface ComplaintLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintLog'], meta: { name: 'ComplaintLog' } }
    /**
     * Find zero or one ComplaintLog that matches the filter.
     * @param {ComplaintLogFindUniqueArgs} args - Arguments to find a ComplaintLog
     * @example
     * // Get one ComplaintLog
     * const complaintLog = await prisma.complaintLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintLogFindUniqueArgs>(args: SelectSubset<T, ComplaintLogFindUniqueArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplaintLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintLogFindUniqueOrThrowArgs} args - Arguments to find a ComplaintLog
     * @example
     * // Get one ComplaintLog
     * const complaintLog = await prisma.complaintLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplaintLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogFindFirstArgs} args - Arguments to find a ComplaintLog
     * @example
     * // Get one ComplaintLog
     * const complaintLog = await prisma.complaintLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintLogFindFirstArgs>(args?: SelectSubset<T, ComplaintLogFindFirstArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplaintLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogFindFirstOrThrowArgs} args - Arguments to find a ComplaintLog
     * @example
     * // Get one ComplaintLog
     * const complaintLog = await prisma.complaintLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplaintLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintLogs
     * const complaintLogs = await prisma.complaintLog.findMany()
     * 
     * // Get first 10 ComplaintLogs
     * const complaintLogs = await prisma.complaintLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintLogWithIdOnly = await prisma.complaintLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintLogFindManyArgs>(args?: SelectSubset<T, ComplaintLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplaintLog.
     * @param {ComplaintLogCreateArgs} args - Arguments to create a ComplaintLog.
     * @example
     * // Create one ComplaintLog
     * const ComplaintLog = await prisma.complaintLog.create({
     *   data: {
     *     // ... data to create a ComplaintLog
     *   }
     * })
     * 
     */
    create<T extends ComplaintLogCreateArgs>(args: SelectSubset<T, ComplaintLogCreateArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplaintLogs.
     * @param {ComplaintLogCreateManyArgs} args - Arguments to create many ComplaintLogs.
     * @example
     * // Create many ComplaintLogs
     * const complaintLog = await prisma.complaintLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintLogCreateManyArgs>(args?: SelectSubset<T, ComplaintLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplaintLogs and returns the data saved in the database.
     * @param {ComplaintLogCreateManyAndReturnArgs} args - Arguments to create many ComplaintLogs.
     * @example
     * // Create many ComplaintLogs
     * const complaintLog = await prisma.complaintLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplaintLogs and only return the `id`
     * const complaintLogWithIdOnly = await prisma.complaintLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplaintLog.
     * @param {ComplaintLogDeleteArgs} args - Arguments to delete one ComplaintLog.
     * @example
     * // Delete one ComplaintLog
     * const ComplaintLog = await prisma.complaintLog.delete({
     *   where: {
     *     // ... filter to delete one ComplaintLog
     *   }
     * })
     * 
     */
    delete<T extends ComplaintLogDeleteArgs>(args: SelectSubset<T, ComplaintLogDeleteArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplaintLog.
     * @param {ComplaintLogUpdateArgs} args - Arguments to update one ComplaintLog.
     * @example
     * // Update one ComplaintLog
     * const complaintLog = await prisma.complaintLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintLogUpdateArgs>(args: SelectSubset<T, ComplaintLogUpdateArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplaintLogs.
     * @param {ComplaintLogDeleteManyArgs} args - Arguments to filter ComplaintLogs to delete.
     * @example
     * // Delete a few ComplaintLogs
     * const { count } = await prisma.complaintLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintLogDeleteManyArgs>(args?: SelectSubset<T, ComplaintLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintLogs
     * const complaintLog = await prisma.complaintLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintLogUpdateManyArgs>(args: SelectSubset<T, ComplaintLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplaintLog.
     * @param {ComplaintLogUpsertArgs} args - Arguments to update or create a ComplaintLog.
     * @example
     * // Update or create a ComplaintLog
     * const complaintLog = await prisma.complaintLog.upsert({
     *   create: {
     *     // ... data to create a ComplaintLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintLog we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintLogUpsertArgs>(args: SelectSubset<T, ComplaintLogUpsertArgs<ExtArgs>>): Prisma__ComplaintLogClient<$Result.GetResult<Prisma.$ComplaintLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplaintLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogCountArgs} args - Arguments to filter ComplaintLogs to count.
     * @example
     * // Count the number of ComplaintLogs
     * const count = await prisma.complaintLog.count({
     *   where: {
     *     // ... the filter for the ComplaintLogs we want to count
     *   }
     * })
    **/
    count<T extends ComplaintLogCountArgs>(
      args?: Subset<T, ComplaintLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintLogAggregateArgs>(args: Subset<T, ComplaintLogAggregateArgs>): Prisma.PrismaPromise<GetComplaintLogAggregateType<T>>

    /**
     * Group by ComplaintLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintLogGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintLog model
   */
  readonly fields: ComplaintLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends ComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintDefaultArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends ComplaintStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplaintStatusDefaultArgs<ExtArgs>>): Prisma__ComplaintStatusClient<$Result.GetResult<Prisma.$ComplaintStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintLog model
   */ 
  interface ComplaintLogFieldRefs {
    readonly id: FieldRef<"ComplaintLog", 'Int'>
    readonly complaint_id: FieldRef<"ComplaintLog", 'Int'>
    readonly complaint_status_id: FieldRef<"ComplaintLog", 'Int'>
    readonly remarks: FieldRef<"ComplaintLog", 'String'>
    readonly created_by: FieldRef<"ComplaintLog", 'String'>
    readonly created_at: FieldRef<"ComplaintLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintLog findUnique
   */
  export type ComplaintLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintLog to fetch.
     */
    where: ComplaintLogWhereUniqueInput
  }

  /**
   * ComplaintLog findUniqueOrThrow
   */
  export type ComplaintLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintLog to fetch.
     */
    where: ComplaintLogWhereUniqueInput
  }

  /**
   * ComplaintLog findFirst
   */
  export type ComplaintLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintLog to fetch.
     */
    where?: ComplaintLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintLogs to fetch.
     */
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintLogs.
     */
    cursor?: ComplaintLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintLogs.
     */
    distinct?: ComplaintLogScalarFieldEnum | ComplaintLogScalarFieldEnum[]
  }

  /**
   * ComplaintLog findFirstOrThrow
   */
  export type ComplaintLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintLog to fetch.
     */
    where?: ComplaintLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintLogs to fetch.
     */
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintLogs.
     */
    cursor?: ComplaintLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintLogs.
     */
    distinct?: ComplaintLogScalarFieldEnum | ComplaintLogScalarFieldEnum[]
  }

  /**
   * ComplaintLog findMany
   */
  export type ComplaintLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintLogs to fetch.
     */
    where?: ComplaintLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintLogs to fetch.
     */
    orderBy?: ComplaintLogOrderByWithRelationInput | ComplaintLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintLogs.
     */
    cursor?: ComplaintLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintLogs.
     */
    skip?: number
    distinct?: ComplaintLogScalarFieldEnum | ComplaintLogScalarFieldEnum[]
  }

  /**
   * ComplaintLog create
   */
  export type ComplaintLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintLog.
     */
    data: XOR<ComplaintLogCreateInput, ComplaintLogUncheckedCreateInput>
  }

  /**
   * ComplaintLog createMany
   */
  export type ComplaintLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintLogs.
     */
    data: ComplaintLogCreateManyInput | ComplaintLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintLog createManyAndReturn
   */
  export type ComplaintLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplaintLogs.
     */
    data: ComplaintLogCreateManyInput | ComplaintLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplaintLog update
   */
  export type ComplaintLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintLog.
     */
    data: XOR<ComplaintLogUpdateInput, ComplaintLogUncheckedUpdateInput>
    /**
     * Choose, which ComplaintLog to update.
     */
    where: ComplaintLogWhereUniqueInput
  }

  /**
   * ComplaintLog updateMany
   */
  export type ComplaintLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintLogs.
     */
    data: XOR<ComplaintLogUpdateManyMutationInput, ComplaintLogUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintLogs to update
     */
    where?: ComplaintLogWhereInput
    limit?: number
  }

  /**
   * ComplaintLog upsert
   */
  export type ComplaintLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintLog to update in case it exists.
     */
    where: ComplaintLogWhereUniqueInput
    /**
     * In case the ComplaintLog found by the `where` argument doesn't exist, create a new ComplaintLog with this data.
     */
    create: XOR<ComplaintLogCreateInput, ComplaintLogUncheckedCreateInput>
    /**
     * In case the ComplaintLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintLogUpdateInput, ComplaintLogUncheckedUpdateInput>
  }

  /**
   * ComplaintLog delete
   */
  export type ComplaintLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
    /**
     * Filter which ComplaintLog to delete.
     */
    where: ComplaintLogWhereUniqueInput
  }

  /**
   * ComplaintLog deleteMany
   */
  export type ComplaintLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintLogs to delete
     */
    where?: ComplaintLogWhereInput
    limit?: number
  }

  /**
   * ComplaintLog without action
   */
  export type ComplaintLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintLog
     */
    select?: ComplaintLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintLogInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    task_status_id: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    complaint_id: number | null
    task_status_id: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    ref_number: string | null
    complaint_id: number | null
    assignee_id: string | null
    task_status_id: number | null
    activity_id: string | null
    description: string | null
    remarks: string | null
    accomplishment: string | null
    action_taken: string | null
    acted_at: Date | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    ref_number: string | null
    complaint_id: number | null
    assignee_id: string | null
    task_status_id: number | null
    activity_id: string | null
    description: string | null
    remarks: string | null
    accomplishment: string | null
    action_taken: string | null
    acted_at: Date | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    ref_number: number
    complaint_id: number
    assignee_id: number
    task_status_id: number
    activity_id: number
    description: number
    remarks: number
    accomplishment: number
    action_taken: number
    acted_at: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    complaint_id?: true
    task_status_id?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    complaint_id?: true
    task_status_id?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    ref_number?: true
    complaint_id?: true
    assignee_id?: true
    task_status_id?: true
    activity_id?: true
    description?: true
    remarks?: true
    accomplishment?: true
    action_taken?: true
    acted_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    ref_number?: true
    complaint_id?: true
    assignee_id?: true
    task_status_id?: true
    activity_id?: true
    description?: true
    remarks?: true
    accomplishment?: true
    action_taken?: true
    acted_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    ref_number?: true
    complaint_id?: true
    assignee_id?: true
    task_status_id?: true
    activity_id?: true
    description?: true
    remarks?: true
    accomplishment?: true
    action_taken?: true
    acted_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    ref_number: string
    complaint_id: number | null
    assignee_id: string | null
    task_status_id: number
    activity_id: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at: Date | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ref_number?: boolean
    complaint_id?: boolean
    assignee_id?: boolean
    task_status_id?: boolean
    activity_id?: boolean
    description?: boolean
    remarks?: boolean
    accomplishment?: boolean
    action_taken?: boolean
    acted_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    task_assignment?: boolean | Task$task_assignmentArgs<ExtArgs>
    logs?: boolean | Task$logsArgs<ExtArgs>
    files?: boolean | Task$filesArgs<ExtArgs>
    complaint?: boolean | Task$complaintArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
    activity?: boolean | Task$activityArgs<ExtArgs>
    task_detail_power_interruption?: boolean | Task$task_detail_power_interruptionArgs<ExtArgs>
    task_detail_kwh_meter?: boolean | Task$task_detail_kwh_meterArgs<ExtArgs>
    task_detail_line_services?: boolean | Task$task_detail_line_servicesArgs<ExtArgs>
    task_detail_dles?: boolean | Task$task_detail_dlesArgs<ExtArgs>
    task_detail_lmdga?: boolean | Task$task_detail_lmdgaArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ref_number?: boolean
    complaint_id?: boolean
    assignee_id?: boolean
    task_status_id?: boolean
    activity_id?: boolean
    description?: boolean
    remarks?: boolean
    accomplishment?: boolean
    action_taken?: boolean
    acted_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    complaint?: boolean | Task$complaintArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
    activity?: boolean | Task$activityArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    ref_number?: boolean
    complaint_id?: boolean
    assignee_id?: boolean
    task_status_id?: boolean
    activity_id?: boolean
    description?: boolean
    remarks?: boolean
    accomplishment?: boolean
    action_taken?: boolean
    acted_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_assignment?: boolean | Task$task_assignmentArgs<ExtArgs>
    logs?: boolean | Task$logsArgs<ExtArgs>
    files?: boolean | Task$filesArgs<ExtArgs>
    complaint?: boolean | Task$complaintArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
    activity?: boolean | Task$activityArgs<ExtArgs>
    task_detail_power_interruption?: boolean | Task$task_detail_power_interruptionArgs<ExtArgs>
    task_detail_kwh_meter?: boolean | Task$task_detail_kwh_meterArgs<ExtArgs>
    task_detail_line_services?: boolean | Task$task_detail_line_servicesArgs<ExtArgs>
    task_detail_dles?: boolean | Task$task_detail_dlesArgs<ExtArgs>
    task_detail_lmdga?: boolean | Task$task_detail_lmdgaArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | Task$complaintArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
    activity?: boolean | Task$activityArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      task_assignment: Prisma.$TaskAssignmentPayload<ExtArgs> | null
      logs: Prisma.$TaskLogPayload<ExtArgs>[]
      files: Prisma.$TaskFilePayload<ExtArgs>[]
      complaint: Prisma.$ComplaintPayload<ExtArgs> | null
      status: Prisma.$TaskStatusPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs> | null
      task_detail_power_interruption: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs> | null
      task_detail_kwh_meter: Prisma.$TaskDetailKwhMeterPayload<ExtArgs> | null
      task_detail_line_services: Prisma.$TaskDetailLineServicesPayload<ExtArgs> | null
      task_detail_dles: Prisma.$TaskDetailDlesPayload<ExtArgs> | null
      task_detail_lmdga: Prisma.$TaskDetailLmdgaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ref_number: string
      complaint_id: number | null
      assignee_id: string | null
      task_status_id: number
      activity_id: string | null
      description: string
      remarks: string
      accomplishment: string
      action_taken: string
      acted_at: Date | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_assignment<T extends Task$task_assignmentArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_assignmentArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Task$logsArgs<ExtArgs> = {}>(args?: Subset<T, Task$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Task$filesArgs<ExtArgs> = {}>(args?: Subset<T, Task$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findMany"> | Null>
    complaint<T extends Task$complaintArgs<ExtArgs> = {}>(args?: Subset<T, Task$complaintArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    status<T extends TaskStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatusDefaultArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity<T extends Task$activityArgs<ExtArgs> = {}>(args?: Subset<T, Task$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_detail_power_interruption<T extends Task$task_detail_power_interruptionArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_detail_power_interruptionArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_detail_kwh_meter<T extends Task$task_detail_kwh_meterArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_detail_kwh_meterArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_detail_line_services<T extends Task$task_detail_line_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_detail_line_servicesArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_detail_dles<T extends Task$task_detail_dlesArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_detail_dlesArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_detail_lmdga<T extends Task$task_detail_lmdgaArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_detail_lmdgaArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly ref_number: FieldRef<"Task", 'String'>
    readonly complaint_id: FieldRef<"Task", 'Int'>
    readonly assignee_id: FieldRef<"Task", 'String'>
    readonly task_status_id: FieldRef<"Task", 'Int'>
    readonly activity_id: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly remarks: FieldRef<"Task", 'String'>
    readonly accomplishment: FieldRef<"Task", 'String'>
    readonly action_taken: FieldRef<"Task", 'String'>
    readonly acted_at: FieldRef<"Task", 'DateTime'>
    readonly created_by: FieldRef<"Task", 'String'>
    readonly created_at: FieldRef<"Task", 'DateTime'>
    readonly updated_at: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    limit?: number
  }

  /**
   * Task.task_assignment
   */
  export type Task$task_assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
  }

  /**
   * Task.logs
   */
  export type Task$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    cursor?: TaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * Task.files
   */
  export type Task$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    where?: TaskFileWhereInput
    orderBy?: TaskFileOrderByWithRelationInput | TaskFileOrderByWithRelationInput[]
    cursor?: TaskFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskFileScalarFieldEnum | TaskFileScalarFieldEnum[]
  }

  /**
   * Task.complaint
   */
  export type Task$complaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
  }

  /**
   * Task.activity
   */
  export type Task$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Task.task_detail_power_interruption
   */
  export type Task$task_detail_power_interruptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    where?: TaskDetailPowerInterruptionWhereInput
  }

  /**
   * Task.task_detail_kwh_meter
   */
  export type Task$task_detail_kwh_meterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    where?: TaskDetailKwhMeterWhereInput
  }

  /**
   * Task.task_detail_line_services
   */
  export type Task$task_detail_line_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    where?: TaskDetailLineServicesWhereInput
  }

  /**
   * Task.task_detail_dles
   */
  export type Task$task_detail_dlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    where?: TaskDetailDlesWhereInput
  }

  /**
   * Task.task_detail_lmdga
   */
  export type Task$task_detail_lmdgaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    where?: TaskDetailLmdgaWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignment
   */

  export type AggregateTaskAssignment = {
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  export type TaskAssignmentAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskAssignmentSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskAssignmentMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    area_id: string | null
    department_id: string | null
    division_id: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type TaskAssignmentMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    area_id: string | null
    department_id: string | null
    division_id: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type TaskAssignmentCountAggregateOutputType = {
    id: number
    task_id: number
    area_id: number
    department_id: number
    division_id: number
    created_by: number
    created_at: number
    _all: number
  }


  export type TaskAssignmentAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskAssignmentSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskAssignmentMinAggregateInputType = {
    id?: true
    task_id?: true
    area_id?: true
    department_id?: true
    division_id?: true
    created_by?: true
    created_at?: true
  }

  export type TaskAssignmentMaxAggregateInputType = {
    id?: true
    task_id?: true
    area_id?: true
    department_id?: true
    division_id?: true
    created_by?: true
    created_at?: true
  }

  export type TaskAssignmentCountAggregateInputType = {
    id?: true
    task_id?: true
    area_id?: true
    department_id?: true
    division_id?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type TaskAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignment to aggregate.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignments
    **/
    _count?: true | TaskAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type GetTaskAssignmentAggregateType<T extends TaskAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignment[P]>
      : GetScalarType<T[P], AggregateTaskAssignment[P]>
  }




  export type TaskAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithAggregationInput | TaskAssignmentOrderByWithAggregationInput[]
    by: TaskAssignmentScalarFieldEnum[] | TaskAssignmentScalarFieldEnum
    having?: TaskAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssignmentCountAggregateInputType | true
    _avg?: TaskAssignmentAvgAggregateInputType
    _sum?: TaskAssignmentSumAggregateInputType
    _min?: TaskAssignmentMinAggregateInputType
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type TaskAssignmentGroupByOutputType = {
    id: number
    task_id: number
    area_id: string | null
    department_id: string | null
    division_id: string | null
    created_by: string
    created_at: Date
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  type GetTaskAssignmentGroupByPayload<T extends TaskAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    area_id?: boolean
    department_id?: boolean
    division_id?: boolean
    created_by?: boolean
    created_at?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    area?: boolean | TaskAssignment$areaArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    area_id?: boolean
    department_id?: boolean
    division_id?: boolean
    created_by?: boolean
    created_at?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    area?: boolean | TaskAssignment$areaArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectScalar = {
    id?: boolean
    task_id?: boolean
    area_id?: boolean
    department_id?: boolean
    division_id?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type TaskAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    area?: boolean | TaskAssignment$areaArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    area?: boolean | TaskAssignment$areaArgs<ExtArgs>
  }

  export type $TaskAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      area: Prisma.$AreaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      area_id: string | null
      department_id: string | null
      division_id: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["taskAssignment"]>
    composites: {}
  }

  type TaskAssignmentGetPayload<S extends boolean | null | undefined | TaskAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAssignmentPayload, S>

  type TaskAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskAssignmentCountAggregateInputType | true
    }

  export interface TaskAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignment'], meta: { name: 'TaskAssignment' } }
    /**
     * Find zero or one TaskAssignment that matches the filter.
     * @param {TaskAssignmentFindUniqueArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssignmentFindUniqueArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssignmentFindFirstArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany()
     * 
     * // Get first 10 TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssignmentFindManyArgs>(args?: SelectSubset<T, TaskAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskAssignment.
     * @param {TaskAssignmentCreateArgs} args - Arguments to create a TaskAssignment.
     * @example
     * // Create one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.create({
     *   data: {
     *     // ... data to create a TaskAssignment
     *   }
     * })
     * 
     */
    create<T extends TaskAssignmentCreateArgs>(args: SelectSubset<T, TaskAssignmentCreateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskAssignments.
     * @param {TaskAssignmentCreateManyArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssignmentCreateManyArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignments and returns the data saved in the database.
     * @param {TaskAssignmentCreateManyAndReturnArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignments and only return the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskAssignment.
     * @param {TaskAssignmentDeleteArgs} args - Arguments to delete one TaskAssignment.
     * @example
     * // Delete one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignment
     *   }
     * })
     * 
     */
    delete<T extends TaskAssignmentDeleteArgs>(args: SelectSubset<T, TaskAssignmentDeleteArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskAssignment.
     * @param {TaskAssignmentUpdateArgs} args - Arguments to update one TaskAssignment.
     * @example
     * // Update one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssignmentUpdateArgs>(args: SelectSubset<T, TaskAssignmentUpdateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskAssignments.
     * @param {TaskAssignmentDeleteManyArgs} args - Arguments to filter TaskAssignments to delete.
     * @example
     * // Delete a few TaskAssignments
     * const { count } = await prisma.taskAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssignmentDeleteManyArgs>(args?: SelectSubset<T, TaskAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssignmentUpdateManyArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskAssignment.
     * @param {TaskAssignmentUpsertArgs} args - Arguments to update or create a TaskAssignment.
     * @example
     * // Update or create a TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.upsert({
     *   create: {
     *     // ... data to create a TaskAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssignmentUpsertArgs>(args: SelectSubset<T, TaskAssignmentUpsertArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentCountArgs} args - Arguments to filter TaskAssignments to count.
     * @example
     * // Count the number of TaskAssignments
     * const count = await prisma.taskAssignment.count({
     *   where: {
     *     // ... the filter for the TaskAssignments we want to count
     *   }
     * })
    **/
    count<T extends TaskAssignmentCountArgs>(
      args?: Subset<T, TaskAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssignmentAggregateArgs>(args: Subset<T, TaskAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAssignmentAggregateType<T>>

    /**
     * Group by TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignment model
   */
  readonly fields: TaskAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    area<T extends TaskAssignment$areaArgs<ExtArgs> = {}>(args?: Subset<T, TaskAssignment$areaArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignment model
   */ 
  interface TaskAssignmentFieldRefs {
    readonly id: FieldRef<"TaskAssignment", 'Int'>
    readonly task_id: FieldRef<"TaskAssignment", 'Int'>
    readonly area_id: FieldRef<"TaskAssignment", 'String'>
    readonly department_id: FieldRef<"TaskAssignment", 'String'>
    readonly division_id: FieldRef<"TaskAssignment", 'String'>
    readonly created_by: FieldRef<"TaskAssignment", 'String'>
    readonly created_at: FieldRef<"TaskAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignment findUnique
   */
  export type TaskAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findUniqueOrThrow
   */
  export type TaskAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findFirst
   */
  export type TaskAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findFirstOrThrow
   */
  export type TaskAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findMany
   */
  export type TaskAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignments to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment create
   */
  export type TaskAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignment.
     */
    data: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
  }

  /**
   * TaskAssignment createMany
   */
  export type TaskAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignment createManyAndReturn
   */
  export type TaskAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment update
   */
  export type TaskAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignment.
     */
    data: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignment to update.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment updateMany
   */
  export type TaskAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    limit?: number
  }

  /**
   * TaskAssignment upsert
   */
  export type TaskAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignment to update in case it exists.
     */
    where: TaskAssignmentWhereUniqueInput
    /**
     * In case the TaskAssignment found by the `where` argument doesn't exist, create a new TaskAssignment with this data.
     */
    create: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
    /**
     * In case the TaskAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
  }

  /**
   * TaskAssignment delete
   */
  export type TaskAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignment to delete.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment deleteMany
   */
  export type TaskAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignments to delete
     */
    where?: TaskAssignmentWhereInput
    limit?: number
  }

  /**
   * TaskAssignment.area
   */
  export type TaskAssignment$areaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
  }

  /**
   * TaskAssignment without action
   */
  export type TaskAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskLog
   */

  export type AggregateTaskLog = {
    _count: TaskLogCountAggregateOutputType | null
    _avg: TaskLogAvgAggregateOutputType | null
    _sum: TaskLogSumAggregateOutputType | null
    _min: TaskLogMinAggregateOutputType | null
    _max: TaskLogMaxAggregateOutputType | null
  }

  export type TaskLogAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
    task_status_id: number | null
  }

  export type TaskLogSumAggregateOutputType = {
    id: number | null
    task_id: number | null
    task_status_id: number | null
  }

  export type TaskLogMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    task_status_id: number | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type TaskLogMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    task_status_id: number | null
    remarks: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type TaskLogCountAggregateOutputType = {
    id: number
    task_id: number
    task_status_id: number
    remarks: number
    created_by: number
    created_at: number
    _all: number
  }


  export type TaskLogAvgAggregateInputType = {
    id?: true
    task_id?: true
    task_status_id?: true
  }

  export type TaskLogSumAggregateInputType = {
    id?: true
    task_id?: true
    task_status_id?: true
  }

  export type TaskLogMinAggregateInputType = {
    id?: true
    task_id?: true
    task_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
  }

  export type TaskLogMaxAggregateInputType = {
    id?: true
    task_id?: true
    task_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
  }

  export type TaskLogCountAggregateInputType = {
    id?: true
    task_id?: true
    task_status_id?: true
    remarks?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type TaskLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLog to aggregate.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLogs
    **/
    _count?: true | TaskLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLogMaxAggregateInputType
  }

  export type GetTaskLogAggregateType<T extends TaskLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLog[P]>
      : GetScalarType<T[P], AggregateTaskLog[P]>
  }




  export type TaskLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithAggregationInput | TaskLogOrderByWithAggregationInput[]
    by: TaskLogScalarFieldEnum[] | TaskLogScalarFieldEnum
    having?: TaskLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLogCountAggregateInputType | true
    _avg?: TaskLogAvgAggregateInputType
    _sum?: TaskLogSumAggregateInputType
    _min?: TaskLogMinAggregateInputType
    _max?: TaskLogMaxAggregateInputType
  }

  export type TaskLogGroupByOutputType = {
    id: number
    task_id: number
    task_status_id: number
    remarks: string | null
    created_by: string
    created_at: Date
    _count: TaskLogCountAggregateOutputType | null
    _avg: TaskLogAvgAggregateOutputType | null
    _sum: TaskLogSumAggregateOutputType | null
    _min: TaskLogMinAggregateOutputType | null
    _max: TaskLogMaxAggregateOutputType | null
  }

  type GetTaskLogGroupByPayload<T extends TaskLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLogGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLogGroupByOutputType[P]>
        }
      >
    >


  export type TaskLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    task_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLog"]>

  export type TaskLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    task_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLog"]>

  export type TaskLogSelectScalar = {
    id?: boolean
    task_id?: boolean
    task_status_id?: boolean
    remarks?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type TaskLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
  }
  export type TaskLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    status?: boolean | TaskStatusDefaultArgs<ExtArgs>
  }

  export type $TaskLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLog"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      status: Prisma.$TaskStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      task_status_id: number
      remarks: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["taskLog"]>
    composites: {}
  }

  type TaskLogGetPayload<S extends boolean | null | undefined | TaskLogDefaultArgs> = $Result.GetResult<Prisma.$TaskLogPayload, S>

  type TaskLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskLogCountAggregateInputType | true
    }

  export interface TaskLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLog'], meta: { name: 'TaskLog' } }
    /**
     * Find zero or one TaskLog that matches the filter.
     * @param {TaskLogFindUniqueArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLogFindUniqueArgs>(args: SelectSubset<T, TaskLogFindUniqueArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskLogFindUniqueOrThrowArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindFirstArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLogFindFirstArgs>(args?: SelectSubset<T, TaskLogFindFirstArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindFirstOrThrowArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLogs
     * const taskLogs = await prisma.taskLog.findMany()
     * 
     * // Get first 10 TaskLogs
     * const taskLogs = await prisma.taskLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskLogWithIdOnly = await prisma.taskLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskLogFindManyArgs>(args?: SelectSubset<T, TaskLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskLog.
     * @param {TaskLogCreateArgs} args - Arguments to create a TaskLog.
     * @example
     * // Create one TaskLog
     * const TaskLog = await prisma.taskLog.create({
     *   data: {
     *     // ... data to create a TaskLog
     *   }
     * })
     * 
     */
    create<T extends TaskLogCreateArgs>(args: SelectSubset<T, TaskLogCreateArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskLogs.
     * @param {TaskLogCreateManyArgs} args - Arguments to create many TaskLogs.
     * @example
     * // Create many TaskLogs
     * const taskLog = await prisma.taskLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLogCreateManyArgs>(args?: SelectSubset<T, TaskLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskLogs and returns the data saved in the database.
     * @param {TaskLogCreateManyAndReturnArgs} args - Arguments to create many TaskLogs.
     * @example
     * // Create many TaskLogs
     * const taskLog = await prisma.taskLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskLogs and only return the `id`
     * const taskLogWithIdOnly = await prisma.taskLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskLog.
     * @param {TaskLogDeleteArgs} args - Arguments to delete one TaskLog.
     * @example
     * // Delete one TaskLog
     * const TaskLog = await prisma.taskLog.delete({
     *   where: {
     *     // ... filter to delete one TaskLog
     *   }
     * })
     * 
     */
    delete<T extends TaskLogDeleteArgs>(args: SelectSubset<T, TaskLogDeleteArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskLog.
     * @param {TaskLogUpdateArgs} args - Arguments to update one TaskLog.
     * @example
     * // Update one TaskLog
     * const taskLog = await prisma.taskLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLogUpdateArgs>(args: SelectSubset<T, TaskLogUpdateArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskLogs.
     * @param {TaskLogDeleteManyArgs} args - Arguments to filter TaskLogs to delete.
     * @example
     * // Delete a few TaskLogs
     * const { count } = await prisma.taskLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLogDeleteManyArgs>(args?: SelectSubset<T, TaskLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLogs
     * const taskLog = await prisma.taskLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLogUpdateManyArgs>(args: SelectSubset<T, TaskLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskLog.
     * @param {TaskLogUpsertArgs} args - Arguments to update or create a TaskLog.
     * @example
     * // Update or create a TaskLog
     * const taskLog = await prisma.taskLog.upsert({
     *   create: {
     *     // ... data to create a TaskLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLog we want to update
     *   }
     * })
     */
    upsert<T extends TaskLogUpsertArgs>(args: SelectSubset<T, TaskLogUpsertArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogCountArgs} args - Arguments to filter TaskLogs to count.
     * @example
     * // Count the number of TaskLogs
     * const count = await prisma.taskLog.count({
     *   where: {
     *     // ... the filter for the TaskLogs we want to count
     *   }
     * })
    **/
    count<T extends TaskLogCountArgs>(
      args?: Subset<T, TaskLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLogAggregateArgs>(args: Subset<T, TaskLogAggregateArgs>): Prisma.PrismaPromise<GetTaskLogAggregateType<T>>

    /**
     * Group by TaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLogGroupByArgs['orderBy'] }
        : { orderBy?: TaskLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLog model
   */
  readonly fields: TaskLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends TaskStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatusDefaultArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLog model
   */ 
  interface TaskLogFieldRefs {
    readonly id: FieldRef<"TaskLog", 'Int'>
    readonly task_id: FieldRef<"TaskLog", 'Int'>
    readonly task_status_id: FieldRef<"TaskLog", 'Int'>
    readonly remarks: FieldRef<"TaskLog", 'String'>
    readonly created_by: FieldRef<"TaskLog", 'String'>
    readonly created_at: FieldRef<"TaskLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskLog findUnique
   */
  export type TaskLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog findUniqueOrThrow
   */
  export type TaskLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog findFirst
   */
  export type TaskLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLogs.
     */
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog findFirstOrThrow
   */
  export type TaskLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLogs.
     */
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog findMany
   */
  export type TaskLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLogs to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog create
   */
  export type TaskLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLog.
     */
    data: XOR<TaskLogCreateInput, TaskLogUncheckedCreateInput>
  }

  /**
   * TaskLog createMany
   */
  export type TaskLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLogs.
     */
    data: TaskLogCreateManyInput | TaskLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskLog createManyAndReturn
   */
  export type TaskLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskLogs.
     */
    data: TaskLogCreateManyInput | TaskLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLog update
   */
  export type TaskLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLog.
     */
    data: XOR<TaskLogUpdateInput, TaskLogUncheckedUpdateInput>
    /**
     * Choose, which TaskLog to update.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog updateMany
   */
  export type TaskLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLogs.
     */
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskLogs to update
     */
    where?: TaskLogWhereInput
    limit?: number
  }

  /**
   * TaskLog upsert
   */
  export type TaskLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLog to update in case it exists.
     */
    where: TaskLogWhereUniqueInput
    /**
     * In case the TaskLog found by the `where` argument doesn't exist, create a new TaskLog with this data.
     */
    create: XOR<TaskLogCreateInput, TaskLogUncheckedCreateInput>
    /**
     * In case the TaskLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLogUpdateInput, TaskLogUncheckedUpdateInput>
  }

  /**
   * TaskLog delete
   */
  export type TaskLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter which TaskLog to delete.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog deleteMany
   */
  export type TaskLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLogs to delete
     */
    where?: TaskLogWhereInput
    limit?: number
  }

  /**
   * TaskLog without action
   */
  export type TaskLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
  }


  /**
   * Model TaskFile
   */

  export type AggregateTaskFile = {
    _count: TaskFileCountAggregateOutputType | null
    _avg: TaskFileAvgAggregateOutputType | null
    _sum: TaskFileSumAggregateOutputType | null
    _min: TaskFileMinAggregateOutputType | null
    _max: TaskFileMaxAggregateOutputType | null
  }

  export type TaskFileAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskFileSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskFileMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    filename: string | null
    source_path: string | null
  }

  export type TaskFileMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    filename: string | null
    source_path: string | null
  }

  export type TaskFileCountAggregateOutputType = {
    id: number
    task_id: number
    filename: number
    source_path: number
    _all: number
  }


  export type TaskFileAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskFileSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskFileMinAggregateInputType = {
    id?: true
    task_id?: true
    filename?: true
    source_path?: true
  }

  export type TaskFileMaxAggregateInputType = {
    id?: true
    task_id?: true
    filename?: true
    source_path?: true
  }

  export type TaskFileCountAggregateInputType = {
    id?: true
    task_id?: true
    filename?: true
    source_path?: true
    _all?: true
  }

  export type TaskFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskFile to aggregate.
     */
    where?: TaskFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFiles to fetch.
     */
    orderBy?: TaskFileOrderByWithRelationInput | TaskFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskFiles
    **/
    _count?: true | TaskFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskFileMaxAggregateInputType
  }

  export type GetTaskFileAggregateType<T extends TaskFileAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskFile[P]>
      : GetScalarType<T[P], AggregateTaskFile[P]>
  }




  export type TaskFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskFileWhereInput
    orderBy?: TaskFileOrderByWithAggregationInput | TaskFileOrderByWithAggregationInput[]
    by: TaskFileScalarFieldEnum[] | TaskFileScalarFieldEnum
    having?: TaskFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskFileCountAggregateInputType | true
    _avg?: TaskFileAvgAggregateInputType
    _sum?: TaskFileSumAggregateInputType
    _min?: TaskFileMinAggregateInputType
    _max?: TaskFileMaxAggregateInputType
  }

  export type TaskFileGroupByOutputType = {
    id: number
    task_id: number
    filename: string
    source_path: string
    _count: TaskFileCountAggregateOutputType | null
    _avg: TaskFileAvgAggregateOutputType | null
    _sum: TaskFileSumAggregateOutputType | null
    _min: TaskFileMinAggregateOutputType | null
    _max: TaskFileMaxAggregateOutputType | null
  }

  type GetTaskFileGroupByPayload<T extends TaskFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskFileGroupByOutputType[P]>
            : GetScalarType<T[P], TaskFileGroupByOutputType[P]>
        }
      >
    >


  export type TaskFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    filename?: boolean
    source_path?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskFile"]>

  export type TaskFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    filename?: boolean
    source_path?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskFile"]>

  export type TaskFileSelectScalar = {
    id?: boolean
    task_id?: boolean
    filename?: boolean
    source_path?: boolean
  }

  export type TaskFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskFile"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      filename: string
      source_path: string
    }, ExtArgs["result"]["taskFile"]>
    composites: {}
  }

  type TaskFileGetPayload<S extends boolean | null | undefined | TaskFileDefaultArgs> = $Result.GetResult<Prisma.$TaskFilePayload, S>

  type TaskFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskFileCountAggregateInputType | true
    }

  export interface TaskFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskFile'], meta: { name: 'TaskFile' } }
    /**
     * Find zero or one TaskFile that matches the filter.
     * @param {TaskFileFindUniqueArgs} args - Arguments to find a TaskFile
     * @example
     * // Get one TaskFile
     * const taskFile = await prisma.taskFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFileFindUniqueArgs>(args: SelectSubset<T, TaskFileFindUniqueArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFileFindUniqueOrThrowArgs} args - Arguments to find a TaskFile
     * @example
     * // Get one TaskFile
     * const taskFile = await prisma.taskFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFileFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileFindFirstArgs} args - Arguments to find a TaskFile
     * @example
     * // Get one TaskFile
     * const taskFile = await prisma.taskFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFileFindFirstArgs>(args?: SelectSubset<T, TaskFileFindFirstArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileFindFirstOrThrowArgs} args - Arguments to find a TaskFile
     * @example
     * // Get one TaskFile
     * const taskFile = await prisma.taskFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFileFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskFiles
     * const taskFiles = await prisma.taskFile.findMany()
     * 
     * // Get first 10 TaskFiles
     * const taskFiles = await prisma.taskFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskFileWithIdOnly = await prisma.taskFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFileFindManyArgs>(args?: SelectSubset<T, TaskFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskFile.
     * @param {TaskFileCreateArgs} args - Arguments to create a TaskFile.
     * @example
     * // Create one TaskFile
     * const TaskFile = await prisma.taskFile.create({
     *   data: {
     *     // ... data to create a TaskFile
     *   }
     * })
     * 
     */
    create<T extends TaskFileCreateArgs>(args: SelectSubset<T, TaskFileCreateArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskFiles.
     * @param {TaskFileCreateManyArgs} args - Arguments to create many TaskFiles.
     * @example
     * // Create many TaskFiles
     * const taskFile = await prisma.taskFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskFileCreateManyArgs>(args?: SelectSubset<T, TaskFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskFiles and returns the data saved in the database.
     * @param {TaskFileCreateManyAndReturnArgs} args - Arguments to create many TaskFiles.
     * @example
     * // Create many TaskFiles
     * const taskFile = await prisma.taskFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskFiles and only return the `id`
     * const taskFileWithIdOnly = await prisma.taskFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskFileCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskFile.
     * @param {TaskFileDeleteArgs} args - Arguments to delete one TaskFile.
     * @example
     * // Delete one TaskFile
     * const TaskFile = await prisma.taskFile.delete({
     *   where: {
     *     // ... filter to delete one TaskFile
     *   }
     * })
     * 
     */
    delete<T extends TaskFileDeleteArgs>(args: SelectSubset<T, TaskFileDeleteArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskFile.
     * @param {TaskFileUpdateArgs} args - Arguments to update one TaskFile.
     * @example
     * // Update one TaskFile
     * const taskFile = await prisma.taskFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskFileUpdateArgs>(args: SelectSubset<T, TaskFileUpdateArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskFiles.
     * @param {TaskFileDeleteManyArgs} args - Arguments to filter TaskFiles to delete.
     * @example
     * // Delete a few TaskFiles
     * const { count } = await prisma.taskFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskFileDeleteManyArgs>(args?: SelectSubset<T, TaskFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskFiles
     * const taskFile = await prisma.taskFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskFileUpdateManyArgs>(args: SelectSubset<T, TaskFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskFile.
     * @param {TaskFileUpsertArgs} args - Arguments to update or create a TaskFile.
     * @example
     * // Update or create a TaskFile
     * const taskFile = await prisma.taskFile.upsert({
     *   create: {
     *     // ... data to create a TaskFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskFile we want to update
     *   }
     * })
     */
    upsert<T extends TaskFileUpsertArgs>(args: SelectSubset<T, TaskFileUpsertArgs<ExtArgs>>): Prisma__TaskFileClient<$Result.GetResult<Prisma.$TaskFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileCountArgs} args - Arguments to filter TaskFiles to count.
     * @example
     * // Count the number of TaskFiles
     * const count = await prisma.taskFile.count({
     *   where: {
     *     // ... the filter for the TaskFiles we want to count
     *   }
     * })
    **/
    count<T extends TaskFileCountArgs>(
      args?: Subset<T, TaskFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskFileAggregateArgs>(args: Subset<T, TaskFileAggregateArgs>): Prisma.PrismaPromise<GetTaskFileAggregateType<T>>

    /**
     * Group by TaskFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskFileGroupByArgs['orderBy'] }
        : { orderBy?: TaskFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskFile model
   */
  readonly fields: TaskFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskFile model
   */ 
  interface TaskFileFieldRefs {
    readonly id: FieldRef<"TaskFile", 'Int'>
    readonly task_id: FieldRef<"TaskFile", 'Int'>
    readonly filename: FieldRef<"TaskFile", 'String'>
    readonly source_path: FieldRef<"TaskFile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskFile findUnique
   */
  export type TaskFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter, which TaskFile to fetch.
     */
    where: TaskFileWhereUniqueInput
  }

  /**
   * TaskFile findUniqueOrThrow
   */
  export type TaskFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter, which TaskFile to fetch.
     */
    where: TaskFileWhereUniqueInput
  }

  /**
   * TaskFile findFirst
   */
  export type TaskFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter, which TaskFile to fetch.
     */
    where?: TaskFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFiles to fetch.
     */
    orderBy?: TaskFileOrderByWithRelationInput | TaskFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFiles.
     */
    cursor?: TaskFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFiles.
     */
    distinct?: TaskFileScalarFieldEnum | TaskFileScalarFieldEnum[]
  }

  /**
   * TaskFile findFirstOrThrow
   */
  export type TaskFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter, which TaskFile to fetch.
     */
    where?: TaskFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFiles to fetch.
     */
    orderBy?: TaskFileOrderByWithRelationInput | TaskFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFiles.
     */
    cursor?: TaskFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFiles.
     */
    distinct?: TaskFileScalarFieldEnum | TaskFileScalarFieldEnum[]
  }

  /**
   * TaskFile findMany
   */
  export type TaskFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter, which TaskFiles to fetch.
     */
    where?: TaskFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFiles to fetch.
     */
    orderBy?: TaskFileOrderByWithRelationInput | TaskFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskFiles.
     */
    cursor?: TaskFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFiles.
     */
    skip?: number
    distinct?: TaskFileScalarFieldEnum | TaskFileScalarFieldEnum[]
  }

  /**
   * TaskFile create
   */
  export type TaskFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskFile.
     */
    data: XOR<TaskFileCreateInput, TaskFileUncheckedCreateInput>
  }

  /**
   * TaskFile createMany
   */
  export type TaskFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskFiles.
     */
    data: TaskFileCreateManyInput | TaskFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskFile createManyAndReturn
   */
  export type TaskFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskFiles.
     */
    data: TaskFileCreateManyInput | TaskFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskFile update
   */
  export type TaskFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskFile.
     */
    data: XOR<TaskFileUpdateInput, TaskFileUncheckedUpdateInput>
    /**
     * Choose, which TaskFile to update.
     */
    where: TaskFileWhereUniqueInput
  }

  /**
   * TaskFile updateMany
   */
  export type TaskFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskFiles.
     */
    data: XOR<TaskFileUpdateManyMutationInput, TaskFileUncheckedUpdateManyInput>
    /**
     * Filter which TaskFiles to update
     */
    where?: TaskFileWhereInput
    limit?: number
  }

  /**
   * TaskFile upsert
   */
  export type TaskFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskFile to update in case it exists.
     */
    where: TaskFileWhereUniqueInput
    /**
     * In case the TaskFile found by the `where` argument doesn't exist, create a new TaskFile with this data.
     */
    create: XOR<TaskFileCreateInput, TaskFileUncheckedCreateInput>
    /**
     * In case the TaskFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskFileUpdateInput, TaskFileUncheckedUpdateInput>
  }

  /**
   * TaskFile delete
   */
  export type TaskFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
    /**
     * Filter which TaskFile to delete.
     */
    where: TaskFileWhereUniqueInput
  }

  /**
   * TaskFile deleteMany
   */
  export type TaskFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskFiles to delete
     */
    where?: TaskFileWhereInput
    limit?: number
  }

  /**
   * TaskFile without action
   */
  export type TaskFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFile
     */
    select?: TaskFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFileInclude<ExtArgs> | null
  }


  /**
   * Model TaskStatus
   */

  export type AggregateTaskStatus = {
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  export type TaskStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type TaskStatusSumAggregateOutputType = {
    id: number | null
  }

  export type TaskStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    color_class: string | null
    description: string | null
  }

  export type TaskStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color_class: string | null
    description: string | null
  }

  export type TaskStatusCountAggregateOutputType = {
    id: number
    name: number
    color_class: number
    description: number
    _all: number
  }


  export type TaskStatusAvgAggregateInputType = {
    id?: true
  }

  export type TaskStatusSumAggregateInputType = {
    id?: true
  }

  export type TaskStatusMinAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
  }

  export type TaskStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
  }

  export type TaskStatusCountAggregateInputType = {
    id?: true
    name?: true
    color_class?: true
    description?: true
    _all?: true
  }

  export type TaskStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatus to aggregate.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskStatuses
    **/
    _count?: true | TaskStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskStatusMaxAggregateInputType
  }

  export type GetTaskStatusAggregateType<T extends TaskStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskStatus[P]>
      : GetScalarType<T[P], AggregateTaskStatus[P]>
  }




  export type TaskStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskStatusWhereInput
    orderBy?: TaskStatusOrderByWithAggregationInput | TaskStatusOrderByWithAggregationInput[]
    by: TaskStatusScalarFieldEnum[] | TaskStatusScalarFieldEnum
    having?: TaskStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskStatusCountAggregateInputType | true
    _avg?: TaskStatusAvgAggregateInputType
    _sum?: TaskStatusSumAggregateInputType
    _min?: TaskStatusMinAggregateInputType
    _max?: TaskStatusMaxAggregateInputType
  }

  export type TaskStatusGroupByOutputType = {
    id: number
    name: string
    color_class: string
    description: string
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  type GetTaskStatusGroupByPayload<T extends TaskStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
        }
      >
    >


  export type TaskStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    logs?: boolean | TaskStatus$logsArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskStatus"]>

  export type TaskStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
  }, ExtArgs["result"]["taskStatus"]>

  export type TaskStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color_class?: boolean
    description?: boolean
  }

  export type TaskStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    logs?: boolean | TaskStatus$logsArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskStatus"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      logs: Prisma.$TaskLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color_class: string
      description: string
    }, ExtArgs["result"]["taskStatus"]>
    composites: {}
  }

  type TaskStatusGetPayload<S extends boolean | null | undefined | TaskStatusDefaultArgs> = $Result.GetResult<Prisma.$TaskStatusPayload, S>

  type TaskStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskStatusCountAggregateInputType | true
    }

  export interface TaskStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskStatus'], meta: { name: 'TaskStatus' } }
    /**
     * Find zero or one TaskStatus that matches the filter.
     * @param {TaskStatusFindUniqueArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskStatusFindUniqueArgs>(args: SelectSubset<T, TaskStatusFindUniqueArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskStatusFindUniqueOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskStatusFindFirstArgs>(args?: SelectSubset<T, TaskStatusFindFirstArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany()
     * 
     * // Get first 10 TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskStatusFindManyArgs>(args?: SelectSubset<T, TaskStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskStatus.
     * @param {TaskStatusCreateArgs} args - Arguments to create a TaskStatus.
     * @example
     * // Create one TaskStatus
     * const TaskStatus = await prisma.taskStatus.create({
     *   data: {
     *     // ... data to create a TaskStatus
     *   }
     * })
     * 
     */
    create<T extends TaskStatusCreateArgs>(args: SelectSubset<T, TaskStatusCreateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskStatuses.
     * @param {TaskStatusCreateManyArgs} args - Arguments to create many TaskStatuses.
     * @example
     * // Create many TaskStatuses
     * const taskStatus = await prisma.taskStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskStatusCreateManyArgs>(args?: SelectSubset<T, TaskStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskStatuses and returns the data saved in the database.
     * @param {TaskStatusCreateManyAndReturnArgs} args - Arguments to create many TaskStatuses.
     * @example
     * // Create many TaskStatuses
     * const taskStatus = await prisma.taskStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskStatuses and only return the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskStatus.
     * @param {TaskStatusDeleteArgs} args - Arguments to delete one TaskStatus.
     * @example
     * // Delete one TaskStatus
     * const TaskStatus = await prisma.taskStatus.delete({
     *   where: {
     *     // ... filter to delete one TaskStatus
     *   }
     * })
     * 
     */
    delete<T extends TaskStatusDeleteArgs>(args: SelectSubset<T, TaskStatusDeleteArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskStatus.
     * @param {TaskStatusUpdateArgs} args - Arguments to update one TaskStatus.
     * @example
     * // Update one TaskStatus
     * const taskStatus = await prisma.taskStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskStatusUpdateArgs>(args: SelectSubset<T, TaskStatusUpdateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskStatuses.
     * @param {TaskStatusDeleteManyArgs} args - Arguments to filter TaskStatuses to delete.
     * @example
     * // Delete a few TaskStatuses
     * const { count } = await prisma.taskStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskStatusDeleteManyArgs>(args?: SelectSubset<T, TaskStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskStatuses
     * const taskStatus = await prisma.taskStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskStatusUpdateManyArgs>(args: SelectSubset<T, TaskStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskStatus.
     * @param {TaskStatusUpsertArgs} args - Arguments to update or create a TaskStatus.
     * @example
     * // Update or create a TaskStatus
     * const taskStatus = await prisma.taskStatus.upsert({
     *   create: {
     *     // ... data to create a TaskStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskStatus we want to update
     *   }
     * })
     */
    upsert<T extends TaskStatusUpsertArgs>(args: SelectSubset<T, TaskStatusUpsertArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusCountArgs} args - Arguments to filter TaskStatuses to count.
     * @example
     * // Count the number of TaskStatuses
     * const count = await prisma.taskStatus.count({
     *   where: {
     *     // ... the filter for the TaskStatuses we want to count
     *   }
     * })
    **/
    count<T extends TaskStatusCountArgs>(
      args?: Subset<T, TaskStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskStatusAggregateArgs>(args: Subset<T, TaskStatusAggregateArgs>): Prisma.PrismaPromise<GetTaskStatusAggregateType<T>>

    /**
     * Group by TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskStatusGroupByArgs['orderBy'] }
        : { orderBy?: TaskStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskStatus model
   */
  readonly fields: TaskStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends TaskStatus$tasksArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatus$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends TaskStatus$logsArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatus$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskStatus model
   */ 
  interface TaskStatusFieldRefs {
    readonly id: FieldRef<"TaskStatus", 'Int'>
    readonly name: FieldRef<"TaskStatus", 'String'>
    readonly color_class: FieldRef<"TaskStatus", 'String'>
    readonly description: FieldRef<"TaskStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskStatus findUnique
   */
  export type TaskStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findUniqueOrThrow
   */
  export type TaskStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findFirst
   */
  export type TaskStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findFirstOrThrow
   */
  export type TaskStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findMany
   */
  export type TaskStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatuses to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus create
   */
  export type TaskStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskStatus.
     */
    data: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
  }

  /**
   * TaskStatus createMany
   */
  export type TaskStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskStatuses.
     */
    data: TaskStatusCreateManyInput | TaskStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskStatus createManyAndReturn
   */
  export type TaskStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskStatuses.
     */
    data: TaskStatusCreateManyInput | TaskStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskStatus update
   */
  export type TaskStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskStatus.
     */
    data: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
    /**
     * Choose, which TaskStatus to update.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus updateMany
   */
  export type TaskStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskStatuses.
     */
    data: XOR<TaskStatusUpdateManyMutationInput, TaskStatusUncheckedUpdateManyInput>
    /**
     * Filter which TaskStatuses to update
     */
    where?: TaskStatusWhereInput
    limit?: number
  }

  /**
   * TaskStatus upsert
   */
  export type TaskStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskStatus to update in case it exists.
     */
    where: TaskStatusWhereUniqueInput
    /**
     * In case the TaskStatus found by the `where` argument doesn't exist, create a new TaskStatus with this data.
     */
    create: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
    /**
     * In case the TaskStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
  }

  /**
   * TaskStatus delete
   */
  export type TaskStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter which TaskStatus to delete.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus deleteMany
   */
  export type TaskStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatuses to delete
     */
    where?: TaskStatusWhereInput
    limit?: number
  }

  /**
   * TaskStatus.tasks
   */
  export type TaskStatus$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskStatus.logs
   */
  export type TaskStatus$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    cursor?: TaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskStatus without action
   */
  export type TaskStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
  }


  /**
   * Model TaskDetailPowerInterruption
   */

  export type AggregateTaskDetailPowerInterruption = {
    _count: TaskDetailPowerInterruptionCountAggregateOutputType | null
    _avg: TaskDetailPowerInterruptionAvgAggregateOutputType | null
    _sum: TaskDetailPowerInterruptionSumAggregateOutputType | null
    _min: TaskDetailPowerInterruptionMinAggregateOutputType | null
    _max: TaskDetailPowerInterruptionMaxAggregateOutputType | null
  }

  export type TaskDetailPowerInterruptionAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailPowerInterruptionSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailPowerInterruptionMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    feeder_id: string | null
    weather_condition_id: string | null
    device_id: string | null
    affected_area: string | null
    cause: string | null
    equipment_failed: string | null
    fuse_rating: string | null
  }

  export type TaskDetailPowerInterruptionMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    feeder_id: string | null
    weather_condition_id: string | null
    device_id: string | null
    affected_area: string | null
    cause: string | null
    equipment_failed: string | null
    fuse_rating: string | null
  }

  export type TaskDetailPowerInterruptionCountAggregateOutputType = {
    id: number
    task_id: number
    feeder_id: number
    weather_condition_id: number
    device_id: number
    affected_area: number
    cause: number
    equipment_failed: number
    fuse_rating: number
    _all: number
  }


  export type TaskDetailPowerInterruptionAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailPowerInterruptionSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailPowerInterruptionMinAggregateInputType = {
    id?: true
    task_id?: true
    feeder_id?: true
    weather_condition_id?: true
    device_id?: true
    affected_area?: true
    cause?: true
    equipment_failed?: true
    fuse_rating?: true
  }

  export type TaskDetailPowerInterruptionMaxAggregateInputType = {
    id?: true
    task_id?: true
    feeder_id?: true
    weather_condition_id?: true
    device_id?: true
    affected_area?: true
    cause?: true
    equipment_failed?: true
    fuse_rating?: true
  }

  export type TaskDetailPowerInterruptionCountAggregateInputType = {
    id?: true
    task_id?: true
    feeder_id?: true
    weather_condition_id?: true
    device_id?: true
    affected_area?: true
    cause?: true
    equipment_failed?: true
    fuse_rating?: true
    _all?: true
  }

  export type TaskDetailPowerInterruptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailPowerInterruption to aggregate.
     */
    where?: TaskDetailPowerInterruptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailPowerInterruptions to fetch.
     */
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailPowerInterruptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailPowerInterruptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailPowerInterruptions
    **/
    _count?: true | TaskDetailPowerInterruptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailPowerInterruptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailPowerInterruptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailPowerInterruptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailPowerInterruptionMaxAggregateInputType
  }

  export type GetTaskDetailPowerInterruptionAggregateType<T extends TaskDetailPowerInterruptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailPowerInterruption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailPowerInterruption[P]>
      : GetScalarType<T[P], AggregateTaskDetailPowerInterruption[P]>
  }




  export type TaskDetailPowerInterruptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailPowerInterruptionWhereInput
    orderBy?: TaskDetailPowerInterruptionOrderByWithAggregationInput | TaskDetailPowerInterruptionOrderByWithAggregationInput[]
    by: TaskDetailPowerInterruptionScalarFieldEnum[] | TaskDetailPowerInterruptionScalarFieldEnum
    having?: TaskDetailPowerInterruptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailPowerInterruptionCountAggregateInputType | true
    _avg?: TaskDetailPowerInterruptionAvgAggregateInputType
    _sum?: TaskDetailPowerInterruptionSumAggregateInputType
    _min?: TaskDetailPowerInterruptionMinAggregateInputType
    _max?: TaskDetailPowerInterruptionMaxAggregateInputType
  }

  export type TaskDetailPowerInterruptionGroupByOutputType = {
    id: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    _count: TaskDetailPowerInterruptionCountAggregateOutputType | null
    _avg: TaskDetailPowerInterruptionAvgAggregateOutputType | null
    _sum: TaskDetailPowerInterruptionSumAggregateOutputType | null
    _min: TaskDetailPowerInterruptionMinAggregateOutputType | null
    _max: TaskDetailPowerInterruptionMaxAggregateOutputType | null
  }

  type GetTaskDetailPowerInterruptionGroupByPayload<T extends TaskDetailPowerInterruptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDetailPowerInterruptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailPowerInterruptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailPowerInterruptionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailPowerInterruptionGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailPowerInterruptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    feeder_id?: boolean
    weather_condition_id?: boolean
    device_id?: boolean
    affected_area?: boolean
    cause?: boolean
    equipment_failed?: boolean
    fuse_rating?: boolean
    linemen_incharge?: boolean | TaskDetailPowerInterruption$linemen_inchargeArgs<ExtArgs>
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    weather_condition?: boolean | WeatherConditionDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailPowerInterruptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailPowerInterruption"]>

  export type TaskDetailPowerInterruptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    feeder_id?: boolean
    weather_condition_id?: boolean
    device_id?: boolean
    affected_area?: boolean
    cause?: boolean
    equipment_failed?: boolean
    fuse_rating?: boolean
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    weather_condition?: boolean | WeatherConditionDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailPowerInterruption"]>

  export type TaskDetailPowerInterruptionSelectScalar = {
    id?: boolean
    task_id?: boolean
    feeder_id?: boolean
    weather_condition_id?: boolean
    device_id?: boolean
    affected_area?: boolean
    cause?: boolean
    equipment_failed?: boolean
    fuse_rating?: boolean
  }

  export type TaskDetailPowerInterruptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailPowerInterruption$linemen_inchargeArgs<ExtArgs>
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    weather_condition?: boolean | WeatherConditionDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailPowerInterruptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskDetailPowerInterruptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    weather_condition?: boolean | WeatherConditionDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDetailPowerInterruptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDetailPowerInterruption"
    objects: {
      linemen_incharge: Prisma.$PowerInterruptionLinemanPayload<ExtArgs>[]
      feeder: Prisma.$FeederPayload<ExtArgs>
      weather_condition: Prisma.$WeatherConditionPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      feeder_id: string
      weather_condition_id: string
      device_id: string
      affected_area: string
      cause: string
      equipment_failed: string
      fuse_rating: string
    }, ExtArgs["result"]["taskDetailPowerInterruption"]>
    composites: {}
  }

  type TaskDetailPowerInterruptionGetPayload<S extends boolean | null | undefined | TaskDetailPowerInterruptionDefaultArgs> = $Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload, S>

  type TaskDetailPowerInterruptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDetailPowerInterruptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDetailPowerInterruptionCountAggregateInputType | true
    }

  export interface TaskDetailPowerInterruptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDetailPowerInterruption'], meta: { name: 'TaskDetailPowerInterruption' } }
    /**
     * Find zero or one TaskDetailPowerInterruption that matches the filter.
     * @param {TaskDetailPowerInterruptionFindUniqueArgs} args - Arguments to find a TaskDetailPowerInterruption
     * @example
     * // Get one TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDetailPowerInterruptionFindUniqueArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionFindUniqueArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDetailPowerInterruption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDetailPowerInterruptionFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailPowerInterruption
     * @example
     * // Get one TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDetailPowerInterruptionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDetailPowerInterruption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionFindFirstArgs} args - Arguments to find a TaskDetailPowerInterruption
     * @example
     * // Get one TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDetailPowerInterruptionFindFirstArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionFindFirstArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDetailPowerInterruption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionFindFirstOrThrowArgs} args - Arguments to find a TaskDetailPowerInterruption
     * @example
     * // Get one TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDetailPowerInterruptionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDetailPowerInterruptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailPowerInterruptions
     * const taskDetailPowerInterruptions = await prisma.taskDetailPowerInterruption.findMany()
     * 
     * // Get first 10 TaskDetailPowerInterruptions
     * const taskDetailPowerInterruptions = await prisma.taskDetailPowerInterruption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailPowerInterruptionWithIdOnly = await prisma.taskDetailPowerInterruption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDetailPowerInterruptionFindManyArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDetailPowerInterruption.
     * @param {TaskDetailPowerInterruptionCreateArgs} args - Arguments to create a TaskDetailPowerInterruption.
     * @example
     * // Create one TaskDetailPowerInterruption
     * const TaskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.create({
     *   data: {
     *     // ... data to create a TaskDetailPowerInterruption
     *   }
     * })
     * 
     */
    create<T extends TaskDetailPowerInterruptionCreateArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionCreateArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDetailPowerInterruptions.
     * @param {TaskDetailPowerInterruptionCreateManyArgs} args - Arguments to create many TaskDetailPowerInterruptions.
     * @example
     * // Create many TaskDetailPowerInterruptions
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDetailPowerInterruptionCreateManyArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDetailPowerInterruptions and returns the data saved in the database.
     * @param {TaskDetailPowerInterruptionCreateManyAndReturnArgs} args - Arguments to create many TaskDetailPowerInterruptions.
     * @example
     * // Create many TaskDetailPowerInterruptions
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDetailPowerInterruptions and only return the `id`
     * const taskDetailPowerInterruptionWithIdOnly = await prisma.taskDetailPowerInterruption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDetailPowerInterruptionCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDetailPowerInterruption.
     * @param {TaskDetailPowerInterruptionDeleteArgs} args - Arguments to delete one TaskDetailPowerInterruption.
     * @example
     * // Delete one TaskDetailPowerInterruption
     * const TaskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailPowerInterruption
     *   }
     * })
     * 
     */
    delete<T extends TaskDetailPowerInterruptionDeleteArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionDeleteArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDetailPowerInterruption.
     * @param {TaskDetailPowerInterruptionUpdateArgs} args - Arguments to update one TaskDetailPowerInterruption.
     * @example
     * // Update one TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDetailPowerInterruptionUpdateArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionUpdateArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDetailPowerInterruptions.
     * @param {TaskDetailPowerInterruptionDeleteManyArgs} args - Arguments to filter TaskDetailPowerInterruptions to delete.
     * @example
     * // Delete a few TaskDetailPowerInterruptions
     * const { count } = await prisma.taskDetailPowerInterruption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDetailPowerInterruptionDeleteManyArgs>(args?: SelectSubset<T, TaskDetailPowerInterruptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailPowerInterruptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailPowerInterruptions
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDetailPowerInterruptionUpdateManyArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailPowerInterruption.
     * @param {TaskDetailPowerInterruptionUpsertArgs} args - Arguments to update or create a TaskDetailPowerInterruption.
     * @example
     * // Update or create a TaskDetailPowerInterruption
     * const taskDetailPowerInterruption = await prisma.taskDetailPowerInterruption.upsert({
     *   create: {
     *     // ... data to create a TaskDetailPowerInterruption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailPowerInterruption we want to update
     *   }
     * })
     */
    upsert<T extends TaskDetailPowerInterruptionUpsertArgs>(args: SelectSubset<T, TaskDetailPowerInterruptionUpsertArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDetailPowerInterruptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionCountArgs} args - Arguments to filter TaskDetailPowerInterruptions to count.
     * @example
     * // Count the number of TaskDetailPowerInterruptions
     * const count = await prisma.taskDetailPowerInterruption.count({
     *   where: {
     *     // ... the filter for the TaskDetailPowerInterruptions we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailPowerInterruptionCountArgs>(
      args?: Subset<T, TaskDetailPowerInterruptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailPowerInterruptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailPowerInterruption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailPowerInterruptionAggregateArgs>(args: Subset<T, TaskDetailPowerInterruptionAggregateArgs>): Prisma.PrismaPromise<GetTaskDetailPowerInterruptionAggregateType<T>>

    /**
     * Group by TaskDetailPowerInterruption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailPowerInterruptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailPowerInterruptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailPowerInterruptionGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailPowerInterruptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailPowerInterruptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailPowerInterruptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDetailPowerInterruption model
   */
  readonly fields: TaskDetailPowerInterruptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailPowerInterruption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDetailPowerInterruptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen_incharge<T extends TaskDetailPowerInterruption$linemen_inchargeArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailPowerInterruption$linemen_inchargeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    feeder<T extends FeederDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeederDefaultArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    weather_condition<T extends WeatherConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeatherConditionDefaultArgs<ExtArgs>>): Prisma__WeatherConditionClient<$Result.GetResult<Prisma.$WeatherConditionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDetailPowerInterruption model
   */ 
  interface TaskDetailPowerInterruptionFieldRefs {
    readonly id: FieldRef<"TaskDetailPowerInterruption", 'Int'>
    readonly task_id: FieldRef<"TaskDetailPowerInterruption", 'Int'>
    readonly feeder_id: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly weather_condition_id: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly device_id: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly affected_area: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly cause: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly equipment_failed: FieldRef<"TaskDetailPowerInterruption", 'String'>
    readonly fuse_rating: FieldRef<"TaskDetailPowerInterruption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskDetailPowerInterruption findUnique
   */
  export type TaskDetailPowerInterruptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailPowerInterruption to fetch.
     */
    where: TaskDetailPowerInterruptionWhereUniqueInput
  }

  /**
   * TaskDetailPowerInterruption findUniqueOrThrow
   */
  export type TaskDetailPowerInterruptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailPowerInterruption to fetch.
     */
    where: TaskDetailPowerInterruptionWhereUniqueInput
  }

  /**
   * TaskDetailPowerInterruption findFirst
   */
  export type TaskDetailPowerInterruptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailPowerInterruption to fetch.
     */
    where?: TaskDetailPowerInterruptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailPowerInterruptions to fetch.
     */
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailPowerInterruptions.
     */
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailPowerInterruptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailPowerInterruptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailPowerInterruptions.
     */
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * TaskDetailPowerInterruption findFirstOrThrow
   */
  export type TaskDetailPowerInterruptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailPowerInterruption to fetch.
     */
    where?: TaskDetailPowerInterruptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailPowerInterruptions to fetch.
     */
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailPowerInterruptions.
     */
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailPowerInterruptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailPowerInterruptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailPowerInterruptions.
     */
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * TaskDetailPowerInterruption findMany
   */
  export type TaskDetailPowerInterruptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailPowerInterruptions to fetch.
     */
    where?: TaskDetailPowerInterruptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailPowerInterruptions to fetch.
     */
    orderBy?: TaskDetailPowerInterruptionOrderByWithRelationInput | TaskDetailPowerInterruptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailPowerInterruptions.
     */
    cursor?: TaskDetailPowerInterruptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailPowerInterruptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailPowerInterruptions.
     */
    skip?: number
    distinct?: TaskDetailPowerInterruptionScalarFieldEnum | TaskDetailPowerInterruptionScalarFieldEnum[]
  }

  /**
   * TaskDetailPowerInterruption create
   */
  export type TaskDetailPowerInterruptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDetailPowerInterruption.
     */
    data: XOR<TaskDetailPowerInterruptionCreateInput, TaskDetailPowerInterruptionUncheckedCreateInput>
  }

  /**
   * TaskDetailPowerInterruption createMany
   */
  export type TaskDetailPowerInterruptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDetailPowerInterruptions.
     */
    data: TaskDetailPowerInterruptionCreateManyInput | TaskDetailPowerInterruptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDetailPowerInterruption createManyAndReturn
   */
  export type TaskDetailPowerInterruptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDetailPowerInterruptions.
     */
    data: TaskDetailPowerInterruptionCreateManyInput | TaskDetailPowerInterruptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDetailPowerInterruption update
   */
  export type TaskDetailPowerInterruptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDetailPowerInterruption.
     */
    data: XOR<TaskDetailPowerInterruptionUpdateInput, TaskDetailPowerInterruptionUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailPowerInterruption to update.
     */
    where: TaskDetailPowerInterruptionWhereUniqueInput
  }

  /**
   * TaskDetailPowerInterruption updateMany
   */
  export type TaskDetailPowerInterruptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDetailPowerInterruptions.
     */
    data: XOR<TaskDetailPowerInterruptionUpdateManyMutationInput, TaskDetailPowerInterruptionUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailPowerInterruptions to update
     */
    where?: TaskDetailPowerInterruptionWhereInput
    limit?: number
  }

  /**
   * TaskDetailPowerInterruption upsert
   */
  export type TaskDetailPowerInterruptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDetailPowerInterruption to update in case it exists.
     */
    where: TaskDetailPowerInterruptionWhereUniqueInput
    /**
     * In case the TaskDetailPowerInterruption found by the `where` argument doesn't exist, create a new TaskDetailPowerInterruption with this data.
     */
    create: XOR<TaskDetailPowerInterruptionCreateInput, TaskDetailPowerInterruptionUncheckedCreateInput>
    /**
     * In case the TaskDetailPowerInterruption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDetailPowerInterruptionUpdateInput, TaskDetailPowerInterruptionUncheckedUpdateInput>
  }

  /**
   * TaskDetailPowerInterruption delete
   */
  export type TaskDetailPowerInterruptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
    /**
     * Filter which TaskDetailPowerInterruption to delete.
     */
    where: TaskDetailPowerInterruptionWhereUniqueInput
  }

  /**
   * TaskDetailPowerInterruption deleteMany
   */
  export type TaskDetailPowerInterruptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailPowerInterruptions to delete
     */
    where?: TaskDetailPowerInterruptionWhereInput
    limit?: number
  }

  /**
   * TaskDetailPowerInterruption.linemen_incharge
   */
  export type TaskDetailPowerInterruption$linemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    where?: PowerInterruptionLinemanWhereInput
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PowerInterruptionLinemanScalarFieldEnum | PowerInterruptionLinemanScalarFieldEnum[]
  }

  /**
   * TaskDetailPowerInterruption without action
   */
  export type TaskDetailPowerInterruptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailPowerInterruption
     */
    select?: TaskDetailPowerInterruptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailPowerInterruptionInclude<ExtArgs> | null
  }


  /**
   * Model PowerInterruptionLineman
   */

  export type AggregatePowerInterruptionLineman = {
    _count: PowerInterruptionLinemanCountAggregateOutputType | null
    _avg: PowerInterruptionLinemanAvgAggregateOutputType | null
    _sum: PowerInterruptionLinemanSumAggregateOutputType | null
    _min: PowerInterruptionLinemanMinAggregateOutputType | null
    _max: PowerInterruptionLinemanMaxAggregateOutputType | null
  }

  export type PowerInterruptionLinemanAvgAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type PowerInterruptionLinemanSumAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type PowerInterruptionLinemanMinAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type PowerInterruptionLinemanMaxAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type PowerInterruptionLinemanCountAggregateOutputType = {
    id: number
    task_detail_id: number
    lineman_id: number
    _all: number
  }


  export type PowerInterruptionLinemanAvgAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type PowerInterruptionLinemanSumAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type PowerInterruptionLinemanMinAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type PowerInterruptionLinemanMaxAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type PowerInterruptionLinemanCountAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
    _all?: true
  }

  export type PowerInterruptionLinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PowerInterruptionLineman to aggregate.
     */
    where?: PowerInterruptionLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerInterruptionLinemen to fetch.
     */
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerInterruptionLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerInterruptionLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PowerInterruptionLinemen
    **/
    _count?: true | PowerInterruptionLinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PowerInterruptionLinemanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PowerInterruptionLinemanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PowerInterruptionLinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PowerInterruptionLinemanMaxAggregateInputType
  }

  export type GetPowerInterruptionLinemanAggregateType<T extends PowerInterruptionLinemanAggregateArgs> = {
        [P in keyof T & keyof AggregatePowerInterruptionLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePowerInterruptionLineman[P]>
      : GetScalarType<T[P], AggregatePowerInterruptionLineman[P]>
  }




  export type PowerInterruptionLinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PowerInterruptionLinemanWhereInput
    orderBy?: PowerInterruptionLinemanOrderByWithAggregationInput | PowerInterruptionLinemanOrderByWithAggregationInput[]
    by: PowerInterruptionLinemanScalarFieldEnum[] | PowerInterruptionLinemanScalarFieldEnum
    having?: PowerInterruptionLinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PowerInterruptionLinemanCountAggregateInputType | true
    _avg?: PowerInterruptionLinemanAvgAggregateInputType
    _sum?: PowerInterruptionLinemanSumAggregateInputType
    _min?: PowerInterruptionLinemanMinAggregateInputType
    _max?: PowerInterruptionLinemanMaxAggregateInputType
  }

  export type PowerInterruptionLinemanGroupByOutputType = {
    id: number
    task_detail_id: number
    lineman_id: string
    _count: PowerInterruptionLinemanCountAggregateOutputType | null
    _avg: PowerInterruptionLinemanAvgAggregateOutputType | null
    _sum: PowerInterruptionLinemanSumAggregateOutputType | null
    _min: PowerInterruptionLinemanMinAggregateOutputType | null
    _max: PowerInterruptionLinemanMaxAggregateOutputType | null
  }

  type GetPowerInterruptionLinemanGroupByPayload<T extends PowerInterruptionLinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PowerInterruptionLinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PowerInterruptionLinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PowerInterruptionLinemanGroupByOutputType[P]>
            : GetScalarType<T[P], PowerInterruptionLinemanGroupByOutputType[P]>
        }
      >
    >


  export type PowerInterruptionLinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailPowerInterruptionDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["powerInterruptionLineman"]>

  export type PowerInterruptionLinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailPowerInterruptionDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["powerInterruptionLineman"]>

  export type PowerInterruptionLinemanSelectScalar = {
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
  }

  export type PowerInterruptionLinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailPowerInterruptionDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }
  export type PowerInterruptionLinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailPowerInterruptionDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }

  export type $PowerInterruptionLinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PowerInterruptionLineman"
    objects: {
      task_detail: Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>
      lineman: Prisma.$LinemanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_detail_id: number
      lineman_id: string
    }, ExtArgs["result"]["powerInterruptionLineman"]>
    composites: {}
  }

  type PowerInterruptionLinemanGetPayload<S extends boolean | null | undefined | PowerInterruptionLinemanDefaultArgs> = $Result.GetResult<Prisma.$PowerInterruptionLinemanPayload, S>

  type PowerInterruptionLinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PowerInterruptionLinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PowerInterruptionLinemanCountAggregateInputType | true
    }

  export interface PowerInterruptionLinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PowerInterruptionLineman'], meta: { name: 'PowerInterruptionLineman' } }
    /**
     * Find zero or one PowerInterruptionLineman that matches the filter.
     * @param {PowerInterruptionLinemanFindUniqueArgs} args - Arguments to find a PowerInterruptionLineman
     * @example
     * // Get one PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PowerInterruptionLinemanFindUniqueArgs>(args: SelectSubset<T, PowerInterruptionLinemanFindUniqueArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PowerInterruptionLineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PowerInterruptionLinemanFindUniqueOrThrowArgs} args - Arguments to find a PowerInterruptionLineman
     * @example
     * // Get one PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PowerInterruptionLinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, PowerInterruptionLinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PowerInterruptionLineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanFindFirstArgs} args - Arguments to find a PowerInterruptionLineman
     * @example
     * // Get one PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PowerInterruptionLinemanFindFirstArgs>(args?: SelectSubset<T, PowerInterruptionLinemanFindFirstArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PowerInterruptionLineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanFindFirstOrThrowArgs} args - Arguments to find a PowerInterruptionLineman
     * @example
     * // Get one PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PowerInterruptionLinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, PowerInterruptionLinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PowerInterruptionLinemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PowerInterruptionLinemen
     * const powerInterruptionLinemen = await prisma.powerInterruptionLineman.findMany()
     * 
     * // Get first 10 PowerInterruptionLinemen
     * const powerInterruptionLinemen = await prisma.powerInterruptionLineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const powerInterruptionLinemanWithIdOnly = await prisma.powerInterruptionLineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PowerInterruptionLinemanFindManyArgs>(args?: SelectSubset<T, PowerInterruptionLinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PowerInterruptionLineman.
     * @param {PowerInterruptionLinemanCreateArgs} args - Arguments to create a PowerInterruptionLineman.
     * @example
     * // Create one PowerInterruptionLineman
     * const PowerInterruptionLineman = await prisma.powerInterruptionLineman.create({
     *   data: {
     *     // ... data to create a PowerInterruptionLineman
     *   }
     * })
     * 
     */
    create<T extends PowerInterruptionLinemanCreateArgs>(args: SelectSubset<T, PowerInterruptionLinemanCreateArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PowerInterruptionLinemen.
     * @param {PowerInterruptionLinemanCreateManyArgs} args - Arguments to create many PowerInterruptionLinemen.
     * @example
     * // Create many PowerInterruptionLinemen
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PowerInterruptionLinemanCreateManyArgs>(args?: SelectSubset<T, PowerInterruptionLinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PowerInterruptionLinemen and returns the data saved in the database.
     * @param {PowerInterruptionLinemanCreateManyAndReturnArgs} args - Arguments to create many PowerInterruptionLinemen.
     * @example
     * // Create many PowerInterruptionLinemen
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PowerInterruptionLinemen and only return the `id`
     * const powerInterruptionLinemanWithIdOnly = await prisma.powerInterruptionLineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PowerInterruptionLinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, PowerInterruptionLinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PowerInterruptionLineman.
     * @param {PowerInterruptionLinemanDeleteArgs} args - Arguments to delete one PowerInterruptionLineman.
     * @example
     * // Delete one PowerInterruptionLineman
     * const PowerInterruptionLineman = await prisma.powerInterruptionLineman.delete({
     *   where: {
     *     // ... filter to delete one PowerInterruptionLineman
     *   }
     * })
     * 
     */
    delete<T extends PowerInterruptionLinemanDeleteArgs>(args: SelectSubset<T, PowerInterruptionLinemanDeleteArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PowerInterruptionLineman.
     * @param {PowerInterruptionLinemanUpdateArgs} args - Arguments to update one PowerInterruptionLineman.
     * @example
     * // Update one PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PowerInterruptionLinemanUpdateArgs>(args: SelectSubset<T, PowerInterruptionLinemanUpdateArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PowerInterruptionLinemen.
     * @param {PowerInterruptionLinemanDeleteManyArgs} args - Arguments to filter PowerInterruptionLinemen to delete.
     * @example
     * // Delete a few PowerInterruptionLinemen
     * const { count } = await prisma.powerInterruptionLineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PowerInterruptionLinemanDeleteManyArgs>(args?: SelectSubset<T, PowerInterruptionLinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PowerInterruptionLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PowerInterruptionLinemen
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PowerInterruptionLinemanUpdateManyArgs>(args: SelectSubset<T, PowerInterruptionLinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PowerInterruptionLineman.
     * @param {PowerInterruptionLinemanUpsertArgs} args - Arguments to update or create a PowerInterruptionLineman.
     * @example
     * // Update or create a PowerInterruptionLineman
     * const powerInterruptionLineman = await prisma.powerInterruptionLineman.upsert({
     *   create: {
     *     // ... data to create a PowerInterruptionLineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PowerInterruptionLineman we want to update
     *   }
     * })
     */
    upsert<T extends PowerInterruptionLinemanUpsertArgs>(args: SelectSubset<T, PowerInterruptionLinemanUpsertArgs<ExtArgs>>): Prisma__PowerInterruptionLinemanClient<$Result.GetResult<Prisma.$PowerInterruptionLinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PowerInterruptionLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanCountArgs} args - Arguments to filter PowerInterruptionLinemen to count.
     * @example
     * // Count the number of PowerInterruptionLinemen
     * const count = await prisma.powerInterruptionLineman.count({
     *   where: {
     *     // ... the filter for the PowerInterruptionLinemen we want to count
     *   }
     * })
    **/
    count<T extends PowerInterruptionLinemanCountArgs>(
      args?: Subset<T, PowerInterruptionLinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PowerInterruptionLinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PowerInterruptionLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PowerInterruptionLinemanAggregateArgs>(args: Subset<T, PowerInterruptionLinemanAggregateArgs>): Prisma.PrismaPromise<GetPowerInterruptionLinemanAggregateType<T>>

    /**
     * Group by PowerInterruptionLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PowerInterruptionLinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PowerInterruptionLinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PowerInterruptionLinemanGroupByArgs['orderBy'] }
        : { orderBy?: PowerInterruptionLinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PowerInterruptionLinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPowerInterruptionLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PowerInterruptionLineman model
   */
  readonly fields: PowerInterruptionLinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PowerInterruptionLineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PowerInterruptionLinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_detail<T extends TaskDetailPowerInterruptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailPowerInterruptionDefaultArgs<ExtArgs>>): Prisma__TaskDetailPowerInterruptionClient<$Result.GetResult<Prisma.$TaskDetailPowerInterruptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineman<T extends LinemanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinemanDefaultArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PowerInterruptionLineman model
   */ 
  interface PowerInterruptionLinemanFieldRefs {
    readonly id: FieldRef<"PowerInterruptionLineman", 'Int'>
    readonly task_detail_id: FieldRef<"PowerInterruptionLineman", 'Int'>
    readonly lineman_id: FieldRef<"PowerInterruptionLineman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PowerInterruptionLineman findUnique
   */
  export type PowerInterruptionLinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter, which PowerInterruptionLineman to fetch.
     */
    where: PowerInterruptionLinemanWhereUniqueInput
  }

  /**
   * PowerInterruptionLineman findUniqueOrThrow
   */
  export type PowerInterruptionLinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter, which PowerInterruptionLineman to fetch.
     */
    where: PowerInterruptionLinemanWhereUniqueInput
  }

  /**
   * PowerInterruptionLineman findFirst
   */
  export type PowerInterruptionLinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter, which PowerInterruptionLineman to fetch.
     */
    where?: PowerInterruptionLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerInterruptionLinemen to fetch.
     */
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PowerInterruptionLinemen.
     */
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerInterruptionLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerInterruptionLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PowerInterruptionLinemen.
     */
    distinct?: PowerInterruptionLinemanScalarFieldEnum | PowerInterruptionLinemanScalarFieldEnum[]
  }

  /**
   * PowerInterruptionLineman findFirstOrThrow
   */
  export type PowerInterruptionLinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter, which PowerInterruptionLineman to fetch.
     */
    where?: PowerInterruptionLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerInterruptionLinemen to fetch.
     */
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PowerInterruptionLinemen.
     */
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerInterruptionLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerInterruptionLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PowerInterruptionLinemen.
     */
    distinct?: PowerInterruptionLinemanScalarFieldEnum | PowerInterruptionLinemanScalarFieldEnum[]
  }

  /**
   * PowerInterruptionLineman findMany
   */
  export type PowerInterruptionLinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter, which PowerInterruptionLinemen to fetch.
     */
    where?: PowerInterruptionLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PowerInterruptionLinemen to fetch.
     */
    orderBy?: PowerInterruptionLinemanOrderByWithRelationInput | PowerInterruptionLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PowerInterruptionLinemen.
     */
    cursor?: PowerInterruptionLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PowerInterruptionLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PowerInterruptionLinemen.
     */
    skip?: number
    distinct?: PowerInterruptionLinemanScalarFieldEnum | PowerInterruptionLinemanScalarFieldEnum[]
  }

  /**
   * PowerInterruptionLineman create
   */
  export type PowerInterruptionLinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a PowerInterruptionLineman.
     */
    data: XOR<PowerInterruptionLinemanCreateInput, PowerInterruptionLinemanUncheckedCreateInput>
  }

  /**
   * PowerInterruptionLineman createMany
   */
  export type PowerInterruptionLinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PowerInterruptionLinemen.
     */
    data: PowerInterruptionLinemanCreateManyInput | PowerInterruptionLinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PowerInterruptionLineman createManyAndReturn
   */
  export type PowerInterruptionLinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PowerInterruptionLinemen.
     */
    data: PowerInterruptionLinemanCreateManyInput | PowerInterruptionLinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PowerInterruptionLineman update
   */
  export type PowerInterruptionLinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a PowerInterruptionLineman.
     */
    data: XOR<PowerInterruptionLinemanUpdateInput, PowerInterruptionLinemanUncheckedUpdateInput>
    /**
     * Choose, which PowerInterruptionLineman to update.
     */
    where: PowerInterruptionLinemanWhereUniqueInput
  }

  /**
   * PowerInterruptionLineman updateMany
   */
  export type PowerInterruptionLinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PowerInterruptionLinemen.
     */
    data: XOR<PowerInterruptionLinemanUpdateManyMutationInput, PowerInterruptionLinemanUncheckedUpdateManyInput>
    /**
     * Filter which PowerInterruptionLinemen to update
     */
    where?: PowerInterruptionLinemanWhereInput
    limit?: number
  }

  /**
   * PowerInterruptionLineman upsert
   */
  export type PowerInterruptionLinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the PowerInterruptionLineman to update in case it exists.
     */
    where: PowerInterruptionLinemanWhereUniqueInput
    /**
     * In case the PowerInterruptionLineman found by the `where` argument doesn't exist, create a new PowerInterruptionLineman with this data.
     */
    create: XOR<PowerInterruptionLinemanCreateInput, PowerInterruptionLinemanUncheckedCreateInput>
    /**
     * In case the PowerInterruptionLineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PowerInterruptionLinemanUpdateInput, PowerInterruptionLinemanUncheckedUpdateInput>
  }

  /**
   * PowerInterruptionLineman delete
   */
  export type PowerInterruptionLinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
    /**
     * Filter which PowerInterruptionLineman to delete.
     */
    where: PowerInterruptionLinemanWhereUniqueInput
  }

  /**
   * PowerInterruptionLineman deleteMany
   */
  export type PowerInterruptionLinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PowerInterruptionLinemen to delete
     */
    where?: PowerInterruptionLinemanWhereInput
    limit?: number
  }

  /**
   * PowerInterruptionLineman without action
   */
  export type PowerInterruptionLinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PowerInterruptionLineman
     */
    select?: PowerInterruptionLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PowerInterruptionLinemanInclude<ExtArgs> | null
  }


  /**
   * Model TaskDetailKwhMeter
   */

  export type AggregateTaskDetailKwhMeter = {
    _count: TaskDetailKwhMeterCountAggregateOutputType | null
    _avg: TaskDetailKwhMeterAvgAggregateOutputType | null
    _sum: TaskDetailKwhMeterSumAggregateOutputType | null
    _min: TaskDetailKwhMeterMinAggregateOutputType | null
    _max: TaskDetailKwhMeterMaxAggregateOutputType | null
  }

  export type TaskDetailKwhMeterAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailKwhMeterSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailKwhMeterMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    meter_number: string | null
    meter_brand_id: string | null
    last_reading: string | null
    initial_reading: string | null
    meter_class: string | null
  }

  export type TaskDetailKwhMeterMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    meter_number: string | null
    meter_brand_id: string | null
    last_reading: string | null
    initial_reading: string | null
    meter_class: string | null
  }

  export type TaskDetailKwhMeterCountAggregateOutputType = {
    id: number
    task_id: number
    meter_number: number
    meter_brand_id: number
    last_reading: number
    initial_reading: number
    meter_class: number
    _all: number
  }


  export type TaskDetailKwhMeterAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailKwhMeterSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailKwhMeterMinAggregateInputType = {
    id?: true
    task_id?: true
    meter_number?: true
    meter_brand_id?: true
    last_reading?: true
    initial_reading?: true
    meter_class?: true
  }

  export type TaskDetailKwhMeterMaxAggregateInputType = {
    id?: true
    task_id?: true
    meter_number?: true
    meter_brand_id?: true
    last_reading?: true
    initial_reading?: true
    meter_class?: true
  }

  export type TaskDetailKwhMeterCountAggregateInputType = {
    id?: true
    task_id?: true
    meter_number?: true
    meter_brand_id?: true
    last_reading?: true
    initial_reading?: true
    meter_class?: true
    _all?: true
  }

  export type TaskDetailKwhMeterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailKwhMeter to aggregate.
     */
    where?: TaskDetailKwhMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailKwhMeters to fetch.
     */
    orderBy?: TaskDetailKwhMeterOrderByWithRelationInput | TaskDetailKwhMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDetailKwhMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailKwhMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailKwhMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailKwhMeters
    **/
    _count?: true | TaskDetailKwhMeterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailKwhMeterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailKwhMeterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailKwhMeterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailKwhMeterMaxAggregateInputType
  }

  export type GetTaskDetailKwhMeterAggregateType<T extends TaskDetailKwhMeterAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailKwhMeter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailKwhMeter[P]>
      : GetScalarType<T[P], AggregateTaskDetailKwhMeter[P]>
  }




  export type TaskDetailKwhMeterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailKwhMeterWhereInput
    orderBy?: TaskDetailKwhMeterOrderByWithAggregationInput | TaskDetailKwhMeterOrderByWithAggregationInput[]
    by: TaskDetailKwhMeterScalarFieldEnum[] | TaskDetailKwhMeterScalarFieldEnum
    having?: TaskDetailKwhMeterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailKwhMeterCountAggregateInputType | true
    _avg?: TaskDetailKwhMeterAvgAggregateInputType
    _sum?: TaskDetailKwhMeterSumAggregateInputType
    _min?: TaskDetailKwhMeterMinAggregateInputType
    _max?: TaskDetailKwhMeterMaxAggregateInputType
  }

  export type TaskDetailKwhMeterGroupByOutputType = {
    id: number
    task_id: number
    meter_number: string
    meter_brand_id: string
    last_reading: string
    initial_reading: string
    meter_class: string
    _count: TaskDetailKwhMeterCountAggregateOutputType | null
    _avg: TaskDetailKwhMeterAvgAggregateOutputType | null
    _sum: TaskDetailKwhMeterSumAggregateOutputType | null
    _min: TaskDetailKwhMeterMinAggregateOutputType | null
    _max: TaskDetailKwhMeterMaxAggregateOutputType | null
  }

  type GetTaskDetailKwhMeterGroupByPayload<T extends TaskDetailKwhMeterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDetailKwhMeterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailKwhMeterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailKwhMeterGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailKwhMeterGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailKwhMeterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    meter_number?: boolean
    meter_brand_id?: boolean
    last_reading?: boolean
    initial_reading?: boolean
    meter_class?: boolean
    linemen_incharge?: boolean | TaskDetailKwhMeter$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    meter_brand?: boolean | MeterBrandDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailKwhMeterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailKwhMeter"]>

  export type TaskDetailKwhMeterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    meter_number?: boolean
    meter_brand_id?: boolean
    last_reading?: boolean
    initial_reading?: boolean
    meter_class?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    meter_brand?: boolean | MeterBrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailKwhMeter"]>

  export type TaskDetailKwhMeterSelectScalar = {
    id?: boolean
    task_id?: boolean
    meter_number?: boolean
    meter_brand_id?: boolean
    last_reading?: boolean
    initial_reading?: boolean
    meter_class?: boolean
  }

  export type TaskDetailKwhMeterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailKwhMeter$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    meter_brand?: boolean | MeterBrandDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailKwhMeterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskDetailKwhMeterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    meter_brand?: boolean | MeterBrandDefaultArgs<ExtArgs>
  }

  export type $TaskDetailKwhMeterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDetailKwhMeter"
    objects: {
      linemen_incharge: Prisma.$KwhMeterLinemanPayload<ExtArgs>[]
      task: Prisma.$TaskPayload<ExtArgs>
      meter_brand: Prisma.$MeterBrandPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      meter_number: string
      meter_brand_id: string
      last_reading: string
      initial_reading: string
      meter_class: string
    }, ExtArgs["result"]["taskDetailKwhMeter"]>
    composites: {}
  }

  type TaskDetailKwhMeterGetPayload<S extends boolean | null | undefined | TaskDetailKwhMeterDefaultArgs> = $Result.GetResult<Prisma.$TaskDetailKwhMeterPayload, S>

  type TaskDetailKwhMeterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDetailKwhMeterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDetailKwhMeterCountAggregateInputType | true
    }

  export interface TaskDetailKwhMeterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDetailKwhMeter'], meta: { name: 'TaskDetailKwhMeter' } }
    /**
     * Find zero or one TaskDetailKwhMeter that matches the filter.
     * @param {TaskDetailKwhMeterFindUniqueArgs} args - Arguments to find a TaskDetailKwhMeter
     * @example
     * // Get one TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDetailKwhMeterFindUniqueArgs>(args: SelectSubset<T, TaskDetailKwhMeterFindUniqueArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDetailKwhMeter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDetailKwhMeterFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailKwhMeter
     * @example
     * // Get one TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDetailKwhMeterFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDetailKwhMeterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDetailKwhMeter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterFindFirstArgs} args - Arguments to find a TaskDetailKwhMeter
     * @example
     * // Get one TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDetailKwhMeterFindFirstArgs>(args?: SelectSubset<T, TaskDetailKwhMeterFindFirstArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDetailKwhMeter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterFindFirstOrThrowArgs} args - Arguments to find a TaskDetailKwhMeter
     * @example
     * // Get one TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDetailKwhMeterFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDetailKwhMeterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDetailKwhMeters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailKwhMeters
     * const taskDetailKwhMeters = await prisma.taskDetailKwhMeter.findMany()
     * 
     * // Get first 10 TaskDetailKwhMeters
     * const taskDetailKwhMeters = await prisma.taskDetailKwhMeter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailKwhMeterWithIdOnly = await prisma.taskDetailKwhMeter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDetailKwhMeterFindManyArgs>(args?: SelectSubset<T, TaskDetailKwhMeterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDetailKwhMeter.
     * @param {TaskDetailKwhMeterCreateArgs} args - Arguments to create a TaskDetailKwhMeter.
     * @example
     * // Create one TaskDetailKwhMeter
     * const TaskDetailKwhMeter = await prisma.taskDetailKwhMeter.create({
     *   data: {
     *     // ... data to create a TaskDetailKwhMeter
     *   }
     * })
     * 
     */
    create<T extends TaskDetailKwhMeterCreateArgs>(args: SelectSubset<T, TaskDetailKwhMeterCreateArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDetailKwhMeters.
     * @param {TaskDetailKwhMeterCreateManyArgs} args - Arguments to create many TaskDetailKwhMeters.
     * @example
     * // Create many TaskDetailKwhMeters
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDetailKwhMeterCreateManyArgs>(args?: SelectSubset<T, TaskDetailKwhMeterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDetailKwhMeters and returns the data saved in the database.
     * @param {TaskDetailKwhMeterCreateManyAndReturnArgs} args - Arguments to create many TaskDetailKwhMeters.
     * @example
     * // Create many TaskDetailKwhMeters
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDetailKwhMeters and only return the `id`
     * const taskDetailKwhMeterWithIdOnly = await prisma.taskDetailKwhMeter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDetailKwhMeterCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDetailKwhMeterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDetailKwhMeter.
     * @param {TaskDetailKwhMeterDeleteArgs} args - Arguments to delete one TaskDetailKwhMeter.
     * @example
     * // Delete one TaskDetailKwhMeter
     * const TaskDetailKwhMeter = await prisma.taskDetailKwhMeter.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailKwhMeter
     *   }
     * })
     * 
     */
    delete<T extends TaskDetailKwhMeterDeleteArgs>(args: SelectSubset<T, TaskDetailKwhMeterDeleteArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDetailKwhMeter.
     * @param {TaskDetailKwhMeterUpdateArgs} args - Arguments to update one TaskDetailKwhMeter.
     * @example
     * // Update one TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDetailKwhMeterUpdateArgs>(args: SelectSubset<T, TaskDetailKwhMeterUpdateArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDetailKwhMeters.
     * @param {TaskDetailKwhMeterDeleteManyArgs} args - Arguments to filter TaskDetailKwhMeters to delete.
     * @example
     * // Delete a few TaskDetailKwhMeters
     * const { count } = await prisma.taskDetailKwhMeter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDetailKwhMeterDeleteManyArgs>(args?: SelectSubset<T, TaskDetailKwhMeterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailKwhMeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailKwhMeters
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDetailKwhMeterUpdateManyArgs>(args: SelectSubset<T, TaskDetailKwhMeterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailKwhMeter.
     * @param {TaskDetailKwhMeterUpsertArgs} args - Arguments to update or create a TaskDetailKwhMeter.
     * @example
     * // Update or create a TaskDetailKwhMeter
     * const taskDetailKwhMeter = await prisma.taskDetailKwhMeter.upsert({
     *   create: {
     *     // ... data to create a TaskDetailKwhMeter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailKwhMeter we want to update
     *   }
     * })
     */
    upsert<T extends TaskDetailKwhMeterUpsertArgs>(args: SelectSubset<T, TaskDetailKwhMeterUpsertArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDetailKwhMeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterCountArgs} args - Arguments to filter TaskDetailKwhMeters to count.
     * @example
     * // Count the number of TaskDetailKwhMeters
     * const count = await prisma.taskDetailKwhMeter.count({
     *   where: {
     *     // ... the filter for the TaskDetailKwhMeters we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailKwhMeterCountArgs>(
      args?: Subset<T, TaskDetailKwhMeterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailKwhMeterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailKwhMeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailKwhMeterAggregateArgs>(args: Subset<T, TaskDetailKwhMeterAggregateArgs>): Prisma.PrismaPromise<GetTaskDetailKwhMeterAggregateType<T>>

    /**
     * Group by TaskDetailKwhMeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailKwhMeterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailKwhMeterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailKwhMeterGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailKwhMeterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailKwhMeterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailKwhMeterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDetailKwhMeter model
   */
  readonly fields: TaskDetailKwhMeterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailKwhMeter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDetailKwhMeterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen_incharge<T extends TaskDetailKwhMeter$linemen_inchargeArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailKwhMeter$linemen_inchargeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meter_brand<T extends MeterBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeterBrandDefaultArgs<ExtArgs>>): Prisma__MeterBrandClient<$Result.GetResult<Prisma.$MeterBrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDetailKwhMeter model
   */ 
  interface TaskDetailKwhMeterFieldRefs {
    readonly id: FieldRef<"TaskDetailKwhMeter", 'Int'>
    readonly task_id: FieldRef<"TaskDetailKwhMeter", 'Int'>
    readonly meter_number: FieldRef<"TaskDetailKwhMeter", 'String'>
    readonly meter_brand_id: FieldRef<"TaskDetailKwhMeter", 'String'>
    readonly last_reading: FieldRef<"TaskDetailKwhMeter", 'String'>
    readonly initial_reading: FieldRef<"TaskDetailKwhMeter", 'String'>
    readonly meter_class: FieldRef<"TaskDetailKwhMeter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskDetailKwhMeter findUnique
   */
  export type TaskDetailKwhMeterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailKwhMeter to fetch.
     */
    where: TaskDetailKwhMeterWhereUniqueInput
  }

  /**
   * TaskDetailKwhMeter findUniqueOrThrow
   */
  export type TaskDetailKwhMeterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailKwhMeter to fetch.
     */
    where: TaskDetailKwhMeterWhereUniqueInput
  }

  /**
   * TaskDetailKwhMeter findFirst
   */
  export type TaskDetailKwhMeterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailKwhMeter to fetch.
     */
    where?: TaskDetailKwhMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailKwhMeters to fetch.
     */
    orderBy?: TaskDetailKwhMeterOrderByWithRelationInput | TaskDetailKwhMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailKwhMeters.
     */
    cursor?: TaskDetailKwhMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailKwhMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailKwhMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailKwhMeters.
     */
    distinct?: TaskDetailKwhMeterScalarFieldEnum | TaskDetailKwhMeterScalarFieldEnum[]
  }

  /**
   * TaskDetailKwhMeter findFirstOrThrow
   */
  export type TaskDetailKwhMeterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailKwhMeter to fetch.
     */
    where?: TaskDetailKwhMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailKwhMeters to fetch.
     */
    orderBy?: TaskDetailKwhMeterOrderByWithRelationInput | TaskDetailKwhMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailKwhMeters.
     */
    cursor?: TaskDetailKwhMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailKwhMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailKwhMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailKwhMeters.
     */
    distinct?: TaskDetailKwhMeterScalarFieldEnum | TaskDetailKwhMeterScalarFieldEnum[]
  }

  /**
   * TaskDetailKwhMeter findMany
   */
  export type TaskDetailKwhMeterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailKwhMeters to fetch.
     */
    where?: TaskDetailKwhMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailKwhMeters to fetch.
     */
    orderBy?: TaskDetailKwhMeterOrderByWithRelationInput | TaskDetailKwhMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailKwhMeters.
     */
    cursor?: TaskDetailKwhMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailKwhMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailKwhMeters.
     */
    skip?: number
    distinct?: TaskDetailKwhMeterScalarFieldEnum | TaskDetailKwhMeterScalarFieldEnum[]
  }

  /**
   * TaskDetailKwhMeter create
   */
  export type TaskDetailKwhMeterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDetailKwhMeter.
     */
    data: XOR<TaskDetailKwhMeterCreateInput, TaskDetailKwhMeterUncheckedCreateInput>
  }

  /**
   * TaskDetailKwhMeter createMany
   */
  export type TaskDetailKwhMeterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDetailKwhMeters.
     */
    data: TaskDetailKwhMeterCreateManyInput | TaskDetailKwhMeterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDetailKwhMeter createManyAndReturn
   */
  export type TaskDetailKwhMeterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDetailKwhMeters.
     */
    data: TaskDetailKwhMeterCreateManyInput | TaskDetailKwhMeterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDetailKwhMeter update
   */
  export type TaskDetailKwhMeterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDetailKwhMeter.
     */
    data: XOR<TaskDetailKwhMeterUpdateInput, TaskDetailKwhMeterUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailKwhMeter to update.
     */
    where: TaskDetailKwhMeterWhereUniqueInput
  }

  /**
   * TaskDetailKwhMeter updateMany
   */
  export type TaskDetailKwhMeterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDetailKwhMeters.
     */
    data: XOR<TaskDetailKwhMeterUpdateManyMutationInput, TaskDetailKwhMeterUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailKwhMeters to update
     */
    where?: TaskDetailKwhMeterWhereInput
    limit?: number
  }

  /**
   * TaskDetailKwhMeter upsert
   */
  export type TaskDetailKwhMeterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDetailKwhMeter to update in case it exists.
     */
    where: TaskDetailKwhMeterWhereUniqueInput
    /**
     * In case the TaskDetailKwhMeter found by the `where` argument doesn't exist, create a new TaskDetailKwhMeter with this data.
     */
    create: XOR<TaskDetailKwhMeterCreateInput, TaskDetailKwhMeterUncheckedCreateInput>
    /**
     * In case the TaskDetailKwhMeter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDetailKwhMeterUpdateInput, TaskDetailKwhMeterUncheckedUpdateInput>
  }

  /**
   * TaskDetailKwhMeter delete
   */
  export type TaskDetailKwhMeterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
    /**
     * Filter which TaskDetailKwhMeter to delete.
     */
    where: TaskDetailKwhMeterWhereUniqueInput
  }

  /**
   * TaskDetailKwhMeter deleteMany
   */
  export type TaskDetailKwhMeterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailKwhMeters to delete
     */
    where?: TaskDetailKwhMeterWhereInput
    limit?: number
  }

  /**
   * TaskDetailKwhMeter.linemen_incharge
   */
  export type TaskDetailKwhMeter$linemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    where?: KwhMeterLinemanWhereInput
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    cursor?: KwhMeterLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KwhMeterLinemanScalarFieldEnum | KwhMeterLinemanScalarFieldEnum[]
  }

  /**
   * TaskDetailKwhMeter without action
   */
  export type TaskDetailKwhMeterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailKwhMeter
     */
    select?: TaskDetailKwhMeterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailKwhMeterInclude<ExtArgs> | null
  }


  /**
   * Model KwhMeterLineman
   */

  export type AggregateKwhMeterLineman = {
    _count: KwhMeterLinemanCountAggregateOutputType | null
    _avg: KwhMeterLinemanAvgAggregateOutputType | null
    _sum: KwhMeterLinemanSumAggregateOutputType | null
    _min: KwhMeterLinemanMinAggregateOutputType | null
    _max: KwhMeterLinemanMaxAggregateOutputType | null
  }

  export type KwhMeterLinemanAvgAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type KwhMeterLinemanSumAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type KwhMeterLinemanMinAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type KwhMeterLinemanMaxAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type KwhMeterLinemanCountAggregateOutputType = {
    id: number
    task_detail_id: number
    lineman_id: number
    _all: number
  }


  export type KwhMeterLinemanAvgAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type KwhMeterLinemanSumAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type KwhMeterLinemanMinAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type KwhMeterLinemanMaxAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type KwhMeterLinemanCountAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
    _all?: true
  }

  export type KwhMeterLinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KwhMeterLineman to aggregate.
     */
    where?: KwhMeterLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KwhMeterLinemen to fetch.
     */
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KwhMeterLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KwhMeterLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KwhMeterLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KwhMeterLinemen
    **/
    _count?: true | KwhMeterLinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KwhMeterLinemanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KwhMeterLinemanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KwhMeterLinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KwhMeterLinemanMaxAggregateInputType
  }

  export type GetKwhMeterLinemanAggregateType<T extends KwhMeterLinemanAggregateArgs> = {
        [P in keyof T & keyof AggregateKwhMeterLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKwhMeterLineman[P]>
      : GetScalarType<T[P], AggregateKwhMeterLineman[P]>
  }




  export type KwhMeterLinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KwhMeterLinemanWhereInput
    orderBy?: KwhMeterLinemanOrderByWithAggregationInput | KwhMeterLinemanOrderByWithAggregationInput[]
    by: KwhMeterLinemanScalarFieldEnum[] | KwhMeterLinemanScalarFieldEnum
    having?: KwhMeterLinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KwhMeterLinemanCountAggregateInputType | true
    _avg?: KwhMeterLinemanAvgAggregateInputType
    _sum?: KwhMeterLinemanSumAggregateInputType
    _min?: KwhMeterLinemanMinAggregateInputType
    _max?: KwhMeterLinemanMaxAggregateInputType
  }

  export type KwhMeterLinemanGroupByOutputType = {
    id: number
    task_detail_id: number
    lineman_id: string
    _count: KwhMeterLinemanCountAggregateOutputType | null
    _avg: KwhMeterLinemanAvgAggregateOutputType | null
    _sum: KwhMeterLinemanSumAggregateOutputType | null
    _min: KwhMeterLinemanMinAggregateOutputType | null
    _max: KwhMeterLinemanMaxAggregateOutputType | null
  }

  type GetKwhMeterLinemanGroupByPayload<T extends KwhMeterLinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KwhMeterLinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KwhMeterLinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KwhMeterLinemanGroupByOutputType[P]>
            : GetScalarType<T[P], KwhMeterLinemanGroupByOutputType[P]>
        }
      >
    >


  export type KwhMeterLinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailKwhMeterDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kwhMeterLineman"]>

  export type KwhMeterLinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailKwhMeterDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kwhMeterLineman"]>

  export type KwhMeterLinemanSelectScalar = {
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
  }

  export type KwhMeterLinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailKwhMeterDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }
  export type KwhMeterLinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailKwhMeterDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }

  export type $KwhMeterLinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KwhMeterLineman"
    objects: {
      task_detail: Prisma.$TaskDetailKwhMeterPayload<ExtArgs>
      lineman: Prisma.$LinemanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_detail_id: number
      lineman_id: string
    }, ExtArgs["result"]["kwhMeterLineman"]>
    composites: {}
  }

  type KwhMeterLinemanGetPayload<S extends boolean | null | undefined | KwhMeterLinemanDefaultArgs> = $Result.GetResult<Prisma.$KwhMeterLinemanPayload, S>

  type KwhMeterLinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KwhMeterLinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KwhMeterLinemanCountAggregateInputType | true
    }

  export interface KwhMeterLinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KwhMeterLineman'], meta: { name: 'KwhMeterLineman' } }
    /**
     * Find zero or one KwhMeterLineman that matches the filter.
     * @param {KwhMeterLinemanFindUniqueArgs} args - Arguments to find a KwhMeterLineman
     * @example
     * // Get one KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KwhMeterLinemanFindUniqueArgs>(args: SelectSubset<T, KwhMeterLinemanFindUniqueArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KwhMeterLineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KwhMeterLinemanFindUniqueOrThrowArgs} args - Arguments to find a KwhMeterLineman
     * @example
     * // Get one KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KwhMeterLinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, KwhMeterLinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KwhMeterLineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanFindFirstArgs} args - Arguments to find a KwhMeterLineman
     * @example
     * // Get one KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KwhMeterLinemanFindFirstArgs>(args?: SelectSubset<T, KwhMeterLinemanFindFirstArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KwhMeterLineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanFindFirstOrThrowArgs} args - Arguments to find a KwhMeterLineman
     * @example
     * // Get one KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KwhMeterLinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, KwhMeterLinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KwhMeterLinemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KwhMeterLinemen
     * const kwhMeterLinemen = await prisma.kwhMeterLineman.findMany()
     * 
     * // Get first 10 KwhMeterLinemen
     * const kwhMeterLinemen = await prisma.kwhMeterLineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kwhMeterLinemanWithIdOnly = await prisma.kwhMeterLineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KwhMeterLinemanFindManyArgs>(args?: SelectSubset<T, KwhMeterLinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KwhMeterLineman.
     * @param {KwhMeterLinemanCreateArgs} args - Arguments to create a KwhMeterLineman.
     * @example
     * // Create one KwhMeterLineman
     * const KwhMeterLineman = await prisma.kwhMeterLineman.create({
     *   data: {
     *     // ... data to create a KwhMeterLineman
     *   }
     * })
     * 
     */
    create<T extends KwhMeterLinemanCreateArgs>(args: SelectSubset<T, KwhMeterLinemanCreateArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KwhMeterLinemen.
     * @param {KwhMeterLinemanCreateManyArgs} args - Arguments to create many KwhMeterLinemen.
     * @example
     * // Create many KwhMeterLinemen
     * const kwhMeterLineman = await prisma.kwhMeterLineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KwhMeterLinemanCreateManyArgs>(args?: SelectSubset<T, KwhMeterLinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KwhMeterLinemen and returns the data saved in the database.
     * @param {KwhMeterLinemanCreateManyAndReturnArgs} args - Arguments to create many KwhMeterLinemen.
     * @example
     * // Create many KwhMeterLinemen
     * const kwhMeterLineman = await prisma.kwhMeterLineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KwhMeterLinemen and only return the `id`
     * const kwhMeterLinemanWithIdOnly = await prisma.kwhMeterLineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KwhMeterLinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, KwhMeterLinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KwhMeterLineman.
     * @param {KwhMeterLinemanDeleteArgs} args - Arguments to delete one KwhMeterLineman.
     * @example
     * // Delete one KwhMeterLineman
     * const KwhMeterLineman = await prisma.kwhMeterLineman.delete({
     *   where: {
     *     // ... filter to delete one KwhMeterLineman
     *   }
     * })
     * 
     */
    delete<T extends KwhMeterLinemanDeleteArgs>(args: SelectSubset<T, KwhMeterLinemanDeleteArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KwhMeterLineman.
     * @param {KwhMeterLinemanUpdateArgs} args - Arguments to update one KwhMeterLineman.
     * @example
     * // Update one KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KwhMeterLinemanUpdateArgs>(args: SelectSubset<T, KwhMeterLinemanUpdateArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KwhMeterLinemen.
     * @param {KwhMeterLinemanDeleteManyArgs} args - Arguments to filter KwhMeterLinemen to delete.
     * @example
     * // Delete a few KwhMeterLinemen
     * const { count } = await prisma.kwhMeterLineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KwhMeterLinemanDeleteManyArgs>(args?: SelectSubset<T, KwhMeterLinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KwhMeterLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KwhMeterLinemen
     * const kwhMeterLineman = await prisma.kwhMeterLineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KwhMeterLinemanUpdateManyArgs>(args: SelectSubset<T, KwhMeterLinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KwhMeterLineman.
     * @param {KwhMeterLinemanUpsertArgs} args - Arguments to update or create a KwhMeterLineman.
     * @example
     * // Update or create a KwhMeterLineman
     * const kwhMeterLineman = await prisma.kwhMeterLineman.upsert({
     *   create: {
     *     // ... data to create a KwhMeterLineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KwhMeterLineman we want to update
     *   }
     * })
     */
    upsert<T extends KwhMeterLinemanUpsertArgs>(args: SelectSubset<T, KwhMeterLinemanUpsertArgs<ExtArgs>>): Prisma__KwhMeterLinemanClient<$Result.GetResult<Prisma.$KwhMeterLinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KwhMeterLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanCountArgs} args - Arguments to filter KwhMeterLinemen to count.
     * @example
     * // Count the number of KwhMeterLinemen
     * const count = await prisma.kwhMeterLineman.count({
     *   where: {
     *     // ... the filter for the KwhMeterLinemen we want to count
     *   }
     * })
    **/
    count<T extends KwhMeterLinemanCountArgs>(
      args?: Subset<T, KwhMeterLinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KwhMeterLinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KwhMeterLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KwhMeterLinemanAggregateArgs>(args: Subset<T, KwhMeterLinemanAggregateArgs>): Prisma.PrismaPromise<GetKwhMeterLinemanAggregateType<T>>

    /**
     * Group by KwhMeterLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KwhMeterLinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KwhMeterLinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KwhMeterLinemanGroupByArgs['orderBy'] }
        : { orderBy?: KwhMeterLinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KwhMeterLinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKwhMeterLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KwhMeterLineman model
   */
  readonly fields: KwhMeterLinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KwhMeterLineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KwhMeterLinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_detail<T extends TaskDetailKwhMeterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailKwhMeterDefaultArgs<ExtArgs>>): Prisma__TaskDetailKwhMeterClient<$Result.GetResult<Prisma.$TaskDetailKwhMeterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineman<T extends LinemanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinemanDefaultArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KwhMeterLineman model
   */ 
  interface KwhMeterLinemanFieldRefs {
    readonly id: FieldRef<"KwhMeterLineman", 'Int'>
    readonly task_detail_id: FieldRef<"KwhMeterLineman", 'Int'>
    readonly lineman_id: FieldRef<"KwhMeterLineman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KwhMeterLineman findUnique
   */
  export type KwhMeterLinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter, which KwhMeterLineman to fetch.
     */
    where: KwhMeterLinemanWhereUniqueInput
  }

  /**
   * KwhMeterLineman findUniqueOrThrow
   */
  export type KwhMeterLinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter, which KwhMeterLineman to fetch.
     */
    where: KwhMeterLinemanWhereUniqueInput
  }

  /**
   * KwhMeterLineman findFirst
   */
  export type KwhMeterLinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter, which KwhMeterLineman to fetch.
     */
    where?: KwhMeterLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KwhMeterLinemen to fetch.
     */
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KwhMeterLinemen.
     */
    cursor?: KwhMeterLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KwhMeterLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KwhMeterLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KwhMeterLinemen.
     */
    distinct?: KwhMeterLinemanScalarFieldEnum | KwhMeterLinemanScalarFieldEnum[]
  }

  /**
   * KwhMeterLineman findFirstOrThrow
   */
  export type KwhMeterLinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter, which KwhMeterLineman to fetch.
     */
    where?: KwhMeterLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KwhMeterLinemen to fetch.
     */
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KwhMeterLinemen.
     */
    cursor?: KwhMeterLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KwhMeterLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KwhMeterLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KwhMeterLinemen.
     */
    distinct?: KwhMeterLinemanScalarFieldEnum | KwhMeterLinemanScalarFieldEnum[]
  }

  /**
   * KwhMeterLineman findMany
   */
  export type KwhMeterLinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter, which KwhMeterLinemen to fetch.
     */
    where?: KwhMeterLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KwhMeterLinemen to fetch.
     */
    orderBy?: KwhMeterLinemanOrderByWithRelationInput | KwhMeterLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KwhMeterLinemen.
     */
    cursor?: KwhMeterLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KwhMeterLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KwhMeterLinemen.
     */
    skip?: number
    distinct?: KwhMeterLinemanScalarFieldEnum | KwhMeterLinemanScalarFieldEnum[]
  }

  /**
   * KwhMeterLineman create
   */
  export type KwhMeterLinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a KwhMeterLineman.
     */
    data: XOR<KwhMeterLinemanCreateInput, KwhMeterLinemanUncheckedCreateInput>
  }

  /**
   * KwhMeterLineman createMany
   */
  export type KwhMeterLinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KwhMeterLinemen.
     */
    data: KwhMeterLinemanCreateManyInput | KwhMeterLinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KwhMeterLineman createManyAndReturn
   */
  export type KwhMeterLinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KwhMeterLinemen.
     */
    data: KwhMeterLinemanCreateManyInput | KwhMeterLinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KwhMeterLineman update
   */
  export type KwhMeterLinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a KwhMeterLineman.
     */
    data: XOR<KwhMeterLinemanUpdateInput, KwhMeterLinemanUncheckedUpdateInput>
    /**
     * Choose, which KwhMeterLineman to update.
     */
    where: KwhMeterLinemanWhereUniqueInput
  }

  /**
   * KwhMeterLineman updateMany
   */
  export type KwhMeterLinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KwhMeterLinemen.
     */
    data: XOR<KwhMeterLinemanUpdateManyMutationInput, KwhMeterLinemanUncheckedUpdateManyInput>
    /**
     * Filter which KwhMeterLinemen to update
     */
    where?: KwhMeterLinemanWhereInput
    limit?: number
  }

  /**
   * KwhMeterLineman upsert
   */
  export type KwhMeterLinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the KwhMeterLineman to update in case it exists.
     */
    where: KwhMeterLinemanWhereUniqueInput
    /**
     * In case the KwhMeterLineman found by the `where` argument doesn't exist, create a new KwhMeterLineman with this data.
     */
    create: XOR<KwhMeterLinemanCreateInput, KwhMeterLinemanUncheckedCreateInput>
    /**
     * In case the KwhMeterLineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KwhMeterLinemanUpdateInput, KwhMeterLinemanUncheckedUpdateInput>
  }

  /**
   * KwhMeterLineman delete
   */
  export type KwhMeterLinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
    /**
     * Filter which KwhMeterLineman to delete.
     */
    where: KwhMeterLinemanWhereUniqueInput
  }

  /**
   * KwhMeterLineman deleteMany
   */
  export type KwhMeterLinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KwhMeterLinemen to delete
     */
    where?: KwhMeterLinemanWhereInput
    limit?: number
  }

  /**
   * KwhMeterLineman without action
   */
  export type KwhMeterLinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KwhMeterLineman
     */
    select?: KwhMeterLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KwhMeterLinemanInclude<ExtArgs> | null
  }


  /**
   * Model TaskDetailLineServices
   */

  export type AggregateTaskDetailLineServices = {
    _count: TaskDetailLineServicesCountAggregateOutputType | null
    _avg: TaskDetailLineServicesAvgAggregateOutputType | null
    _sum: TaskDetailLineServicesSumAggregateOutputType | null
    _min: TaskDetailLineServicesMinAggregateOutputType | null
    _max: TaskDetailLineServicesMaxAggregateOutputType | null
  }

  export type TaskDetailLineServicesAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailLineServicesSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailLineServicesMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    order_number: string | null
    cause: string | null
    mrv_number: string | null
    seriv_number: string | null
    mst_number: string | null
    mcrt_number: string | null
  }

  export type TaskDetailLineServicesMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    order_number: string | null
    cause: string | null
    mrv_number: string | null
    seriv_number: string | null
    mst_number: string | null
    mcrt_number: string | null
  }

  export type TaskDetailLineServicesCountAggregateOutputType = {
    id: number
    task_id: number
    order_number: number
    cause: number
    mrv_number: number
    seriv_number: number
    mst_number: number
    mcrt_number: number
    _all: number
  }


  export type TaskDetailLineServicesAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailLineServicesSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailLineServicesMinAggregateInputType = {
    id?: true
    task_id?: true
    order_number?: true
    cause?: true
    mrv_number?: true
    seriv_number?: true
    mst_number?: true
    mcrt_number?: true
  }

  export type TaskDetailLineServicesMaxAggregateInputType = {
    id?: true
    task_id?: true
    order_number?: true
    cause?: true
    mrv_number?: true
    seriv_number?: true
    mst_number?: true
    mcrt_number?: true
  }

  export type TaskDetailLineServicesCountAggregateInputType = {
    id?: true
    task_id?: true
    order_number?: true
    cause?: true
    mrv_number?: true
    seriv_number?: true
    mst_number?: true
    mcrt_number?: true
    _all?: true
  }

  export type TaskDetailLineServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailLineServices to aggregate.
     */
    where?: TaskDetailLineServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLineServices to fetch.
     */
    orderBy?: TaskDetailLineServicesOrderByWithRelationInput | TaskDetailLineServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDetailLineServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLineServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLineServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailLineServices
    **/
    _count?: true | TaskDetailLineServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailLineServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailLineServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailLineServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailLineServicesMaxAggregateInputType
  }

  export type GetTaskDetailLineServicesAggregateType<T extends TaskDetailLineServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailLineServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailLineServices[P]>
      : GetScalarType<T[P], AggregateTaskDetailLineServices[P]>
  }




  export type TaskDetailLineServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailLineServicesWhereInput
    orderBy?: TaskDetailLineServicesOrderByWithAggregationInput | TaskDetailLineServicesOrderByWithAggregationInput[]
    by: TaskDetailLineServicesScalarFieldEnum[] | TaskDetailLineServicesScalarFieldEnum
    having?: TaskDetailLineServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailLineServicesCountAggregateInputType | true
    _avg?: TaskDetailLineServicesAvgAggregateInputType
    _sum?: TaskDetailLineServicesSumAggregateInputType
    _min?: TaskDetailLineServicesMinAggregateInputType
    _max?: TaskDetailLineServicesMaxAggregateInputType
  }

  export type TaskDetailLineServicesGroupByOutputType = {
    id: number
    task_id: number
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    _count: TaskDetailLineServicesCountAggregateOutputType | null
    _avg: TaskDetailLineServicesAvgAggregateOutputType | null
    _sum: TaskDetailLineServicesSumAggregateOutputType | null
    _min: TaskDetailLineServicesMinAggregateOutputType | null
    _max: TaskDetailLineServicesMaxAggregateOutputType | null
  }

  type GetTaskDetailLineServicesGroupByPayload<T extends TaskDetailLineServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDetailLineServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailLineServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailLineServicesGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailLineServicesGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailLineServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    order_number?: boolean
    cause?: boolean
    mrv_number?: boolean
    seriv_number?: boolean
    mst_number?: boolean
    mcrt_number?: boolean
    linemen_incharge?: boolean | TaskDetailLineServices$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailLineServicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailLineServices"]>

  export type TaskDetailLineServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    order_number?: boolean
    cause?: boolean
    mrv_number?: boolean
    seriv_number?: boolean
    mst_number?: boolean
    mcrt_number?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailLineServices"]>

  export type TaskDetailLineServicesSelectScalar = {
    id?: boolean
    task_id?: boolean
    order_number?: boolean
    cause?: boolean
    mrv_number?: boolean
    seriv_number?: boolean
    mst_number?: boolean
    mcrt_number?: boolean
  }

  export type TaskDetailLineServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailLineServices$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailLineServicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskDetailLineServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDetailLineServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDetailLineServices"
    objects: {
      linemen_incharge: Prisma.$LineServicesLinemanPayload<ExtArgs>[]
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      order_number: string
      cause: string
      mrv_number: string
      seriv_number: string
      mst_number: string
      mcrt_number: string
    }, ExtArgs["result"]["taskDetailLineServices"]>
    composites: {}
  }

  type TaskDetailLineServicesGetPayload<S extends boolean | null | undefined | TaskDetailLineServicesDefaultArgs> = $Result.GetResult<Prisma.$TaskDetailLineServicesPayload, S>

  type TaskDetailLineServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDetailLineServicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDetailLineServicesCountAggregateInputType | true
    }

  export interface TaskDetailLineServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDetailLineServices'], meta: { name: 'TaskDetailLineServices' } }
    /**
     * Find zero or one TaskDetailLineServices that matches the filter.
     * @param {TaskDetailLineServicesFindUniqueArgs} args - Arguments to find a TaskDetailLineServices
     * @example
     * // Get one TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDetailLineServicesFindUniqueArgs>(args: SelectSubset<T, TaskDetailLineServicesFindUniqueArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDetailLineServices that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDetailLineServicesFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailLineServices
     * @example
     * // Get one TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDetailLineServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDetailLineServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDetailLineServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesFindFirstArgs} args - Arguments to find a TaskDetailLineServices
     * @example
     * // Get one TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDetailLineServicesFindFirstArgs>(args?: SelectSubset<T, TaskDetailLineServicesFindFirstArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDetailLineServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesFindFirstOrThrowArgs} args - Arguments to find a TaskDetailLineServices
     * @example
     * // Get one TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDetailLineServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDetailLineServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDetailLineServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findMany()
     * 
     * // Get first 10 TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailLineServicesWithIdOnly = await prisma.taskDetailLineServices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDetailLineServicesFindManyArgs>(args?: SelectSubset<T, TaskDetailLineServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDetailLineServices.
     * @param {TaskDetailLineServicesCreateArgs} args - Arguments to create a TaskDetailLineServices.
     * @example
     * // Create one TaskDetailLineServices
     * const TaskDetailLineServices = await prisma.taskDetailLineServices.create({
     *   data: {
     *     // ... data to create a TaskDetailLineServices
     *   }
     * })
     * 
     */
    create<T extends TaskDetailLineServicesCreateArgs>(args: SelectSubset<T, TaskDetailLineServicesCreateArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDetailLineServices.
     * @param {TaskDetailLineServicesCreateManyArgs} args - Arguments to create many TaskDetailLineServices.
     * @example
     * // Create many TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDetailLineServicesCreateManyArgs>(args?: SelectSubset<T, TaskDetailLineServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDetailLineServices and returns the data saved in the database.
     * @param {TaskDetailLineServicesCreateManyAndReturnArgs} args - Arguments to create many TaskDetailLineServices.
     * @example
     * // Create many TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDetailLineServices and only return the `id`
     * const taskDetailLineServicesWithIdOnly = await prisma.taskDetailLineServices.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDetailLineServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDetailLineServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDetailLineServices.
     * @param {TaskDetailLineServicesDeleteArgs} args - Arguments to delete one TaskDetailLineServices.
     * @example
     * // Delete one TaskDetailLineServices
     * const TaskDetailLineServices = await prisma.taskDetailLineServices.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailLineServices
     *   }
     * })
     * 
     */
    delete<T extends TaskDetailLineServicesDeleteArgs>(args: SelectSubset<T, TaskDetailLineServicesDeleteArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDetailLineServices.
     * @param {TaskDetailLineServicesUpdateArgs} args - Arguments to update one TaskDetailLineServices.
     * @example
     * // Update one TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDetailLineServicesUpdateArgs>(args: SelectSubset<T, TaskDetailLineServicesUpdateArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDetailLineServices.
     * @param {TaskDetailLineServicesDeleteManyArgs} args - Arguments to filter TaskDetailLineServices to delete.
     * @example
     * // Delete a few TaskDetailLineServices
     * const { count } = await prisma.taskDetailLineServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDetailLineServicesDeleteManyArgs>(args?: SelectSubset<T, TaskDetailLineServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailLineServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDetailLineServicesUpdateManyArgs>(args: SelectSubset<T, TaskDetailLineServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailLineServices.
     * @param {TaskDetailLineServicesUpsertArgs} args - Arguments to update or create a TaskDetailLineServices.
     * @example
     * // Update or create a TaskDetailLineServices
     * const taskDetailLineServices = await prisma.taskDetailLineServices.upsert({
     *   create: {
     *     // ... data to create a TaskDetailLineServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailLineServices we want to update
     *   }
     * })
     */
    upsert<T extends TaskDetailLineServicesUpsertArgs>(args: SelectSubset<T, TaskDetailLineServicesUpsertArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDetailLineServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesCountArgs} args - Arguments to filter TaskDetailLineServices to count.
     * @example
     * // Count the number of TaskDetailLineServices
     * const count = await prisma.taskDetailLineServices.count({
     *   where: {
     *     // ... the filter for the TaskDetailLineServices we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailLineServicesCountArgs>(
      args?: Subset<T, TaskDetailLineServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailLineServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailLineServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailLineServicesAggregateArgs>(args: Subset<T, TaskDetailLineServicesAggregateArgs>): Prisma.PrismaPromise<GetTaskDetailLineServicesAggregateType<T>>

    /**
     * Group by TaskDetailLineServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLineServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailLineServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailLineServicesGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailLineServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailLineServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailLineServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDetailLineServices model
   */
  readonly fields: TaskDetailLineServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailLineServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDetailLineServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen_incharge<T extends TaskDetailLineServices$linemen_inchargeArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailLineServices$linemen_inchargeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDetailLineServices model
   */ 
  interface TaskDetailLineServicesFieldRefs {
    readonly id: FieldRef<"TaskDetailLineServices", 'Int'>
    readonly task_id: FieldRef<"TaskDetailLineServices", 'Int'>
    readonly order_number: FieldRef<"TaskDetailLineServices", 'String'>
    readonly cause: FieldRef<"TaskDetailLineServices", 'String'>
    readonly mrv_number: FieldRef<"TaskDetailLineServices", 'String'>
    readonly seriv_number: FieldRef<"TaskDetailLineServices", 'String'>
    readonly mst_number: FieldRef<"TaskDetailLineServices", 'String'>
    readonly mcrt_number: FieldRef<"TaskDetailLineServices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskDetailLineServices findUnique
   */
  export type TaskDetailLineServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLineServices to fetch.
     */
    where: TaskDetailLineServicesWhereUniqueInput
  }

  /**
   * TaskDetailLineServices findUniqueOrThrow
   */
  export type TaskDetailLineServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLineServices to fetch.
     */
    where: TaskDetailLineServicesWhereUniqueInput
  }

  /**
   * TaskDetailLineServices findFirst
   */
  export type TaskDetailLineServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLineServices to fetch.
     */
    where?: TaskDetailLineServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLineServices to fetch.
     */
    orderBy?: TaskDetailLineServicesOrderByWithRelationInput | TaskDetailLineServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailLineServices.
     */
    cursor?: TaskDetailLineServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLineServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLineServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailLineServices.
     */
    distinct?: TaskDetailLineServicesScalarFieldEnum | TaskDetailLineServicesScalarFieldEnum[]
  }

  /**
   * TaskDetailLineServices findFirstOrThrow
   */
  export type TaskDetailLineServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLineServices to fetch.
     */
    where?: TaskDetailLineServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLineServices to fetch.
     */
    orderBy?: TaskDetailLineServicesOrderByWithRelationInput | TaskDetailLineServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailLineServices.
     */
    cursor?: TaskDetailLineServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLineServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLineServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailLineServices.
     */
    distinct?: TaskDetailLineServicesScalarFieldEnum | TaskDetailLineServicesScalarFieldEnum[]
  }

  /**
   * TaskDetailLineServices findMany
   */
  export type TaskDetailLineServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLineServices to fetch.
     */
    where?: TaskDetailLineServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLineServices to fetch.
     */
    orderBy?: TaskDetailLineServicesOrderByWithRelationInput | TaskDetailLineServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailLineServices.
     */
    cursor?: TaskDetailLineServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLineServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLineServices.
     */
    skip?: number
    distinct?: TaskDetailLineServicesScalarFieldEnum | TaskDetailLineServicesScalarFieldEnum[]
  }

  /**
   * TaskDetailLineServices create
   */
  export type TaskDetailLineServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDetailLineServices.
     */
    data: XOR<TaskDetailLineServicesCreateInput, TaskDetailLineServicesUncheckedCreateInput>
  }

  /**
   * TaskDetailLineServices createMany
   */
  export type TaskDetailLineServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDetailLineServices.
     */
    data: TaskDetailLineServicesCreateManyInput | TaskDetailLineServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDetailLineServices createManyAndReturn
   */
  export type TaskDetailLineServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDetailLineServices.
     */
    data: TaskDetailLineServicesCreateManyInput | TaskDetailLineServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDetailLineServices update
   */
  export type TaskDetailLineServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDetailLineServices.
     */
    data: XOR<TaskDetailLineServicesUpdateInput, TaskDetailLineServicesUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailLineServices to update.
     */
    where: TaskDetailLineServicesWhereUniqueInput
  }

  /**
   * TaskDetailLineServices updateMany
   */
  export type TaskDetailLineServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDetailLineServices.
     */
    data: XOR<TaskDetailLineServicesUpdateManyMutationInput, TaskDetailLineServicesUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailLineServices to update
     */
    where?: TaskDetailLineServicesWhereInput
    limit?: number
  }

  /**
   * TaskDetailLineServices upsert
   */
  export type TaskDetailLineServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDetailLineServices to update in case it exists.
     */
    where: TaskDetailLineServicesWhereUniqueInput
    /**
     * In case the TaskDetailLineServices found by the `where` argument doesn't exist, create a new TaskDetailLineServices with this data.
     */
    create: XOR<TaskDetailLineServicesCreateInput, TaskDetailLineServicesUncheckedCreateInput>
    /**
     * In case the TaskDetailLineServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDetailLineServicesUpdateInput, TaskDetailLineServicesUncheckedUpdateInput>
  }

  /**
   * TaskDetailLineServices delete
   */
  export type TaskDetailLineServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
    /**
     * Filter which TaskDetailLineServices to delete.
     */
    where: TaskDetailLineServicesWhereUniqueInput
  }

  /**
   * TaskDetailLineServices deleteMany
   */
  export type TaskDetailLineServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailLineServices to delete
     */
    where?: TaskDetailLineServicesWhereInput
    limit?: number
  }

  /**
   * TaskDetailLineServices.linemen_incharge
   */
  export type TaskDetailLineServices$linemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    where?: LineServicesLinemanWhereInput
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    cursor?: LineServicesLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineServicesLinemanScalarFieldEnum | LineServicesLinemanScalarFieldEnum[]
  }

  /**
   * TaskDetailLineServices without action
   */
  export type TaskDetailLineServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLineServices
     */
    select?: TaskDetailLineServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLineServicesInclude<ExtArgs> | null
  }


  /**
   * Model LineServicesLineman
   */

  export type AggregateLineServicesLineman = {
    _count: LineServicesLinemanCountAggregateOutputType | null
    _avg: LineServicesLinemanAvgAggregateOutputType | null
    _sum: LineServicesLinemanSumAggregateOutputType | null
    _min: LineServicesLinemanMinAggregateOutputType | null
    _max: LineServicesLinemanMaxAggregateOutputType | null
  }

  export type LineServicesLinemanAvgAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type LineServicesLinemanSumAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type LineServicesLinemanMinAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type LineServicesLinemanMaxAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type LineServicesLinemanCountAggregateOutputType = {
    id: number
    task_detail_id: number
    lineman_id: number
    _all: number
  }


  export type LineServicesLinemanAvgAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type LineServicesLinemanSumAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type LineServicesLinemanMinAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type LineServicesLinemanMaxAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type LineServicesLinemanCountAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
    _all?: true
  }

  export type LineServicesLinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineServicesLineman to aggregate.
     */
    where?: LineServicesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineServicesLinemen to fetch.
     */
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineServicesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineServicesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineServicesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineServicesLinemen
    **/
    _count?: true | LineServicesLinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineServicesLinemanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineServicesLinemanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineServicesLinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineServicesLinemanMaxAggregateInputType
  }

  export type GetLineServicesLinemanAggregateType<T extends LineServicesLinemanAggregateArgs> = {
        [P in keyof T & keyof AggregateLineServicesLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineServicesLineman[P]>
      : GetScalarType<T[P], AggregateLineServicesLineman[P]>
  }




  export type LineServicesLinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineServicesLinemanWhereInput
    orderBy?: LineServicesLinemanOrderByWithAggregationInput | LineServicesLinemanOrderByWithAggregationInput[]
    by: LineServicesLinemanScalarFieldEnum[] | LineServicesLinemanScalarFieldEnum
    having?: LineServicesLinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineServicesLinemanCountAggregateInputType | true
    _avg?: LineServicesLinemanAvgAggregateInputType
    _sum?: LineServicesLinemanSumAggregateInputType
    _min?: LineServicesLinemanMinAggregateInputType
    _max?: LineServicesLinemanMaxAggregateInputType
  }

  export type LineServicesLinemanGroupByOutputType = {
    id: number
    task_detail_id: number
    lineman_id: string
    _count: LineServicesLinemanCountAggregateOutputType | null
    _avg: LineServicesLinemanAvgAggregateOutputType | null
    _sum: LineServicesLinemanSumAggregateOutputType | null
    _min: LineServicesLinemanMinAggregateOutputType | null
    _max: LineServicesLinemanMaxAggregateOutputType | null
  }

  type GetLineServicesLinemanGroupByPayload<T extends LineServicesLinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineServicesLinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineServicesLinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineServicesLinemanGroupByOutputType[P]>
            : GetScalarType<T[P], LineServicesLinemanGroupByOutputType[P]>
        }
      >
    >


  export type LineServicesLinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailLineServicesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineServicesLineman"]>

  export type LineServicesLinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailLineServicesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineServicesLineman"]>

  export type LineServicesLinemanSelectScalar = {
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
  }

  export type LineServicesLinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailLineServicesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }
  export type LineServicesLinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailLineServicesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }

  export type $LineServicesLinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LineServicesLineman"
    objects: {
      task_detail: Prisma.$TaskDetailLineServicesPayload<ExtArgs>
      lineman: Prisma.$LinemanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_detail_id: number
      lineman_id: string
    }, ExtArgs["result"]["lineServicesLineman"]>
    composites: {}
  }

  type LineServicesLinemanGetPayload<S extends boolean | null | undefined | LineServicesLinemanDefaultArgs> = $Result.GetResult<Prisma.$LineServicesLinemanPayload, S>

  type LineServicesLinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LineServicesLinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LineServicesLinemanCountAggregateInputType | true
    }

  export interface LineServicesLinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LineServicesLineman'], meta: { name: 'LineServicesLineman' } }
    /**
     * Find zero or one LineServicesLineman that matches the filter.
     * @param {LineServicesLinemanFindUniqueArgs} args - Arguments to find a LineServicesLineman
     * @example
     * // Get one LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineServicesLinemanFindUniqueArgs>(args: SelectSubset<T, LineServicesLinemanFindUniqueArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LineServicesLineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LineServicesLinemanFindUniqueOrThrowArgs} args - Arguments to find a LineServicesLineman
     * @example
     * // Get one LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineServicesLinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, LineServicesLinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LineServicesLineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanFindFirstArgs} args - Arguments to find a LineServicesLineman
     * @example
     * // Get one LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineServicesLinemanFindFirstArgs>(args?: SelectSubset<T, LineServicesLinemanFindFirstArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LineServicesLineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanFindFirstOrThrowArgs} args - Arguments to find a LineServicesLineman
     * @example
     * // Get one LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineServicesLinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, LineServicesLinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LineServicesLinemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineServicesLinemen
     * const lineServicesLinemen = await prisma.lineServicesLineman.findMany()
     * 
     * // Get first 10 LineServicesLinemen
     * const lineServicesLinemen = await prisma.lineServicesLineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineServicesLinemanWithIdOnly = await prisma.lineServicesLineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineServicesLinemanFindManyArgs>(args?: SelectSubset<T, LineServicesLinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LineServicesLineman.
     * @param {LineServicesLinemanCreateArgs} args - Arguments to create a LineServicesLineman.
     * @example
     * // Create one LineServicesLineman
     * const LineServicesLineman = await prisma.lineServicesLineman.create({
     *   data: {
     *     // ... data to create a LineServicesLineman
     *   }
     * })
     * 
     */
    create<T extends LineServicesLinemanCreateArgs>(args: SelectSubset<T, LineServicesLinemanCreateArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LineServicesLinemen.
     * @param {LineServicesLinemanCreateManyArgs} args - Arguments to create many LineServicesLinemen.
     * @example
     * // Create many LineServicesLinemen
     * const lineServicesLineman = await prisma.lineServicesLineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineServicesLinemanCreateManyArgs>(args?: SelectSubset<T, LineServicesLinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LineServicesLinemen and returns the data saved in the database.
     * @param {LineServicesLinemanCreateManyAndReturnArgs} args - Arguments to create many LineServicesLinemen.
     * @example
     * // Create many LineServicesLinemen
     * const lineServicesLineman = await prisma.lineServicesLineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LineServicesLinemen and only return the `id`
     * const lineServicesLinemanWithIdOnly = await prisma.lineServicesLineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineServicesLinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, LineServicesLinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LineServicesLineman.
     * @param {LineServicesLinemanDeleteArgs} args - Arguments to delete one LineServicesLineman.
     * @example
     * // Delete one LineServicesLineman
     * const LineServicesLineman = await prisma.lineServicesLineman.delete({
     *   where: {
     *     // ... filter to delete one LineServicesLineman
     *   }
     * })
     * 
     */
    delete<T extends LineServicesLinemanDeleteArgs>(args: SelectSubset<T, LineServicesLinemanDeleteArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LineServicesLineman.
     * @param {LineServicesLinemanUpdateArgs} args - Arguments to update one LineServicesLineman.
     * @example
     * // Update one LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineServicesLinemanUpdateArgs>(args: SelectSubset<T, LineServicesLinemanUpdateArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LineServicesLinemen.
     * @param {LineServicesLinemanDeleteManyArgs} args - Arguments to filter LineServicesLinemen to delete.
     * @example
     * // Delete a few LineServicesLinemen
     * const { count } = await prisma.lineServicesLineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineServicesLinemanDeleteManyArgs>(args?: SelectSubset<T, LineServicesLinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineServicesLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineServicesLinemen
     * const lineServicesLineman = await prisma.lineServicesLineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineServicesLinemanUpdateManyArgs>(args: SelectSubset<T, LineServicesLinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LineServicesLineman.
     * @param {LineServicesLinemanUpsertArgs} args - Arguments to update or create a LineServicesLineman.
     * @example
     * // Update or create a LineServicesLineman
     * const lineServicesLineman = await prisma.lineServicesLineman.upsert({
     *   create: {
     *     // ... data to create a LineServicesLineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineServicesLineman we want to update
     *   }
     * })
     */
    upsert<T extends LineServicesLinemanUpsertArgs>(args: SelectSubset<T, LineServicesLinemanUpsertArgs<ExtArgs>>): Prisma__LineServicesLinemanClient<$Result.GetResult<Prisma.$LineServicesLinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LineServicesLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanCountArgs} args - Arguments to filter LineServicesLinemen to count.
     * @example
     * // Count the number of LineServicesLinemen
     * const count = await prisma.lineServicesLineman.count({
     *   where: {
     *     // ... the filter for the LineServicesLinemen we want to count
     *   }
     * })
    **/
    count<T extends LineServicesLinemanCountArgs>(
      args?: Subset<T, LineServicesLinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineServicesLinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineServicesLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineServicesLinemanAggregateArgs>(args: Subset<T, LineServicesLinemanAggregateArgs>): Prisma.PrismaPromise<GetLineServicesLinemanAggregateType<T>>

    /**
     * Group by LineServicesLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineServicesLinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineServicesLinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineServicesLinemanGroupByArgs['orderBy'] }
        : { orderBy?: LineServicesLinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineServicesLinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineServicesLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LineServicesLineman model
   */
  readonly fields: LineServicesLinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineServicesLineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineServicesLinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_detail<T extends TaskDetailLineServicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailLineServicesDefaultArgs<ExtArgs>>): Prisma__TaskDetailLineServicesClient<$Result.GetResult<Prisma.$TaskDetailLineServicesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineman<T extends LinemanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinemanDefaultArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LineServicesLineman model
   */ 
  interface LineServicesLinemanFieldRefs {
    readonly id: FieldRef<"LineServicesLineman", 'Int'>
    readonly task_detail_id: FieldRef<"LineServicesLineman", 'Int'>
    readonly lineman_id: FieldRef<"LineServicesLineman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LineServicesLineman findUnique
   */
  export type LineServicesLinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LineServicesLineman to fetch.
     */
    where: LineServicesLinemanWhereUniqueInput
  }

  /**
   * LineServicesLineman findUniqueOrThrow
   */
  export type LineServicesLinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LineServicesLineman to fetch.
     */
    where: LineServicesLinemanWhereUniqueInput
  }

  /**
   * LineServicesLineman findFirst
   */
  export type LineServicesLinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LineServicesLineman to fetch.
     */
    where?: LineServicesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineServicesLinemen to fetch.
     */
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineServicesLinemen.
     */
    cursor?: LineServicesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineServicesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineServicesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineServicesLinemen.
     */
    distinct?: LineServicesLinemanScalarFieldEnum | LineServicesLinemanScalarFieldEnum[]
  }

  /**
   * LineServicesLineman findFirstOrThrow
   */
  export type LineServicesLinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LineServicesLineman to fetch.
     */
    where?: LineServicesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineServicesLinemen to fetch.
     */
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineServicesLinemen.
     */
    cursor?: LineServicesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineServicesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineServicesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineServicesLinemen.
     */
    distinct?: LineServicesLinemanScalarFieldEnum | LineServicesLinemanScalarFieldEnum[]
  }

  /**
   * LineServicesLineman findMany
   */
  export type LineServicesLinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LineServicesLinemen to fetch.
     */
    where?: LineServicesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineServicesLinemen to fetch.
     */
    orderBy?: LineServicesLinemanOrderByWithRelationInput | LineServicesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineServicesLinemen.
     */
    cursor?: LineServicesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineServicesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineServicesLinemen.
     */
    skip?: number
    distinct?: LineServicesLinemanScalarFieldEnum | LineServicesLinemanScalarFieldEnum[]
  }

  /**
   * LineServicesLineman create
   */
  export type LineServicesLinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a LineServicesLineman.
     */
    data: XOR<LineServicesLinemanCreateInput, LineServicesLinemanUncheckedCreateInput>
  }

  /**
   * LineServicesLineman createMany
   */
  export type LineServicesLinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LineServicesLinemen.
     */
    data: LineServicesLinemanCreateManyInput | LineServicesLinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineServicesLineman createManyAndReturn
   */
  export type LineServicesLinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LineServicesLinemen.
     */
    data: LineServicesLinemanCreateManyInput | LineServicesLinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineServicesLineman update
   */
  export type LineServicesLinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a LineServicesLineman.
     */
    data: XOR<LineServicesLinemanUpdateInput, LineServicesLinemanUncheckedUpdateInput>
    /**
     * Choose, which LineServicesLineman to update.
     */
    where: LineServicesLinemanWhereUniqueInput
  }

  /**
   * LineServicesLineman updateMany
   */
  export type LineServicesLinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LineServicesLinemen.
     */
    data: XOR<LineServicesLinemanUpdateManyMutationInput, LineServicesLinemanUncheckedUpdateManyInput>
    /**
     * Filter which LineServicesLinemen to update
     */
    where?: LineServicesLinemanWhereInput
    limit?: number
  }

  /**
   * LineServicesLineman upsert
   */
  export type LineServicesLinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the LineServicesLineman to update in case it exists.
     */
    where: LineServicesLinemanWhereUniqueInput
    /**
     * In case the LineServicesLineman found by the `where` argument doesn't exist, create a new LineServicesLineman with this data.
     */
    create: XOR<LineServicesLinemanCreateInput, LineServicesLinemanUncheckedCreateInput>
    /**
     * In case the LineServicesLineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineServicesLinemanUpdateInput, LineServicesLinemanUncheckedUpdateInput>
  }

  /**
   * LineServicesLineman delete
   */
  export type LineServicesLinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
    /**
     * Filter which LineServicesLineman to delete.
     */
    where: LineServicesLinemanWhereUniqueInput
  }

  /**
   * LineServicesLineman deleteMany
   */
  export type LineServicesLinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineServicesLinemen to delete
     */
    where?: LineServicesLinemanWhereInput
    limit?: number
  }

  /**
   * LineServicesLineman without action
   */
  export type LineServicesLinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineServicesLineman
     */
    select?: LineServicesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineServicesLinemanInclude<ExtArgs> | null
  }


  /**
   * Model TaskDetailDles
   */

  export type AggregateTaskDetailDles = {
    _count: TaskDetailDlesCountAggregateOutputType | null
    _avg: TaskDetailDlesAvgAggregateOutputType | null
    _sum: TaskDetailDlesSumAggregateOutputType | null
    _min: TaskDetailDlesMinAggregateOutputType | null
    _max: TaskDetailDlesMaxAggregateOutputType | null
  }

  export type TaskDetailDlesAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailDlesSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailDlesMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    sco_number: string | null
    old_serial_number: string | null
    new_serial_number: string | null
    seriv_number: string | null
    kva_rating: string | null
    cause: string | null
  }

  export type TaskDetailDlesMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    sco_number: string | null
    old_serial_number: string | null
    new_serial_number: string | null
    seriv_number: string | null
    kva_rating: string | null
    cause: string | null
  }

  export type TaskDetailDlesCountAggregateOutputType = {
    id: number
    task_id: number
    sco_number: number
    old_serial_number: number
    new_serial_number: number
    seriv_number: number
    kva_rating: number
    cause: number
    _all: number
  }


  export type TaskDetailDlesAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailDlesSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailDlesMinAggregateInputType = {
    id?: true
    task_id?: true
    sco_number?: true
    old_serial_number?: true
    new_serial_number?: true
    seriv_number?: true
    kva_rating?: true
    cause?: true
  }

  export type TaskDetailDlesMaxAggregateInputType = {
    id?: true
    task_id?: true
    sco_number?: true
    old_serial_number?: true
    new_serial_number?: true
    seriv_number?: true
    kva_rating?: true
    cause?: true
  }

  export type TaskDetailDlesCountAggregateInputType = {
    id?: true
    task_id?: true
    sco_number?: true
    old_serial_number?: true
    new_serial_number?: true
    seriv_number?: true
    kva_rating?: true
    cause?: true
    _all?: true
  }

  export type TaskDetailDlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailDles to aggregate.
     */
    where?: TaskDetailDlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailDles to fetch.
     */
    orderBy?: TaskDetailDlesOrderByWithRelationInput | TaskDetailDlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDetailDlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailDles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailDles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailDles
    **/
    _count?: true | TaskDetailDlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailDlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailDlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailDlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailDlesMaxAggregateInputType
  }

  export type GetTaskDetailDlesAggregateType<T extends TaskDetailDlesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailDles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailDles[P]>
      : GetScalarType<T[P], AggregateTaskDetailDles[P]>
  }




  export type TaskDetailDlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailDlesWhereInput
    orderBy?: TaskDetailDlesOrderByWithAggregationInput | TaskDetailDlesOrderByWithAggregationInput[]
    by: TaskDetailDlesScalarFieldEnum[] | TaskDetailDlesScalarFieldEnum
    having?: TaskDetailDlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailDlesCountAggregateInputType | true
    _avg?: TaskDetailDlesAvgAggregateInputType
    _sum?: TaskDetailDlesSumAggregateInputType
    _min?: TaskDetailDlesMinAggregateInputType
    _max?: TaskDetailDlesMaxAggregateInputType
  }

  export type TaskDetailDlesGroupByOutputType = {
    id: number
    task_id: number
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    _count: TaskDetailDlesCountAggregateOutputType | null
    _avg: TaskDetailDlesAvgAggregateOutputType | null
    _sum: TaskDetailDlesSumAggregateOutputType | null
    _min: TaskDetailDlesMinAggregateOutputType | null
    _max: TaskDetailDlesMaxAggregateOutputType | null
  }

  type GetTaskDetailDlesGroupByPayload<T extends TaskDetailDlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDetailDlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailDlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailDlesGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailDlesGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailDlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    sco_number?: boolean
    old_serial_number?: boolean
    new_serial_number?: boolean
    seriv_number?: boolean
    kva_rating?: boolean
    cause?: boolean
    linemen_incharge?: boolean | TaskDetailDles$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailDlesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailDles"]>

  export type TaskDetailDlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    sco_number?: boolean
    old_serial_number?: boolean
    new_serial_number?: boolean
    seriv_number?: boolean
    kva_rating?: boolean
    cause?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailDles"]>

  export type TaskDetailDlesSelectScalar = {
    id?: boolean
    task_id?: boolean
    sco_number?: boolean
    old_serial_number?: boolean
    new_serial_number?: boolean
    seriv_number?: boolean
    kva_rating?: boolean
    cause?: boolean
  }

  export type TaskDetailDlesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailDles$linemen_inchargeArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailDlesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskDetailDlesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDetailDlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDetailDles"
    objects: {
      linemen_incharge: Prisma.$DlesLinemanPayload<ExtArgs>[]
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      sco_number: string
      old_serial_number: string
      new_serial_number: string
      seriv_number: string
      kva_rating: string
      cause: string
    }, ExtArgs["result"]["taskDetailDles"]>
    composites: {}
  }

  type TaskDetailDlesGetPayload<S extends boolean | null | undefined | TaskDetailDlesDefaultArgs> = $Result.GetResult<Prisma.$TaskDetailDlesPayload, S>

  type TaskDetailDlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDetailDlesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDetailDlesCountAggregateInputType | true
    }

  export interface TaskDetailDlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDetailDles'], meta: { name: 'TaskDetailDles' } }
    /**
     * Find zero or one TaskDetailDles that matches the filter.
     * @param {TaskDetailDlesFindUniqueArgs} args - Arguments to find a TaskDetailDles
     * @example
     * // Get one TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDetailDlesFindUniqueArgs>(args: SelectSubset<T, TaskDetailDlesFindUniqueArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDetailDles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDetailDlesFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailDles
     * @example
     * // Get one TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDetailDlesFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDetailDlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDetailDles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesFindFirstArgs} args - Arguments to find a TaskDetailDles
     * @example
     * // Get one TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDetailDlesFindFirstArgs>(args?: SelectSubset<T, TaskDetailDlesFindFirstArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDetailDles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesFindFirstOrThrowArgs} args - Arguments to find a TaskDetailDles
     * @example
     * // Get one TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDetailDlesFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDetailDlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDetailDles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findMany()
     * 
     * // Get first 10 TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailDlesWithIdOnly = await prisma.taskDetailDles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDetailDlesFindManyArgs>(args?: SelectSubset<T, TaskDetailDlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDetailDles.
     * @param {TaskDetailDlesCreateArgs} args - Arguments to create a TaskDetailDles.
     * @example
     * // Create one TaskDetailDles
     * const TaskDetailDles = await prisma.taskDetailDles.create({
     *   data: {
     *     // ... data to create a TaskDetailDles
     *   }
     * })
     * 
     */
    create<T extends TaskDetailDlesCreateArgs>(args: SelectSubset<T, TaskDetailDlesCreateArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDetailDles.
     * @param {TaskDetailDlesCreateManyArgs} args - Arguments to create many TaskDetailDles.
     * @example
     * // Create many TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDetailDlesCreateManyArgs>(args?: SelectSubset<T, TaskDetailDlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDetailDles and returns the data saved in the database.
     * @param {TaskDetailDlesCreateManyAndReturnArgs} args - Arguments to create many TaskDetailDles.
     * @example
     * // Create many TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDetailDles and only return the `id`
     * const taskDetailDlesWithIdOnly = await prisma.taskDetailDles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDetailDlesCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDetailDlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDetailDles.
     * @param {TaskDetailDlesDeleteArgs} args - Arguments to delete one TaskDetailDles.
     * @example
     * // Delete one TaskDetailDles
     * const TaskDetailDles = await prisma.taskDetailDles.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailDles
     *   }
     * })
     * 
     */
    delete<T extends TaskDetailDlesDeleteArgs>(args: SelectSubset<T, TaskDetailDlesDeleteArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDetailDles.
     * @param {TaskDetailDlesUpdateArgs} args - Arguments to update one TaskDetailDles.
     * @example
     * // Update one TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDetailDlesUpdateArgs>(args: SelectSubset<T, TaskDetailDlesUpdateArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDetailDles.
     * @param {TaskDetailDlesDeleteManyArgs} args - Arguments to filter TaskDetailDles to delete.
     * @example
     * // Delete a few TaskDetailDles
     * const { count } = await prisma.taskDetailDles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDetailDlesDeleteManyArgs>(args?: SelectSubset<T, TaskDetailDlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailDles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDetailDlesUpdateManyArgs>(args: SelectSubset<T, TaskDetailDlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailDles.
     * @param {TaskDetailDlesUpsertArgs} args - Arguments to update or create a TaskDetailDles.
     * @example
     * // Update or create a TaskDetailDles
     * const taskDetailDles = await prisma.taskDetailDles.upsert({
     *   create: {
     *     // ... data to create a TaskDetailDles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailDles we want to update
     *   }
     * })
     */
    upsert<T extends TaskDetailDlesUpsertArgs>(args: SelectSubset<T, TaskDetailDlesUpsertArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDetailDles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesCountArgs} args - Arguments to filter TaskDetailDles to count.
     * @example
     * // Count the number of TaskDetailDles
     * const count = await prisma.taskDetailDles.count({
     *   where: {
     *     // ... the filter for the TaskDetailDles we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailDlesCountArgs>(
      args?: Subset<T, TaskDetailDlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailDlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailDles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailDlesAggregateArgs>(args: Subset<T, TaskDetailDlesAggregateArgs>): Prisma.PrismaPromise<GetTaskDetailDlesAggregateType<T>>

    /**
     * Group by TaskDetailDles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailDlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailDlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailDlesGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailDlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailDlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailDlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDetailDles model
   */
  readonly fields: TaskDetailDlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailDles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDetailDlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen_incharge<T extends TaskDetailDles$linemen_inchargeArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailDles$linemen_inchargeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDetailDles model
   */ 
  interface TaskDetailDlesFieldRefs {
    readonly id: FieldRef<"TaskDetailDles", 'Int'>
    readonly task_id: FieldRef<"TaskDetailDles", 'Int'>
    readonly sco_number: FieldRef<"TaskDetailDles", 'String'>
    readonly old_serial_number: FieldRef<"TaskDetailDles", 'String'>
    readonly new_serial_number: FieldRef<"TaskDetailDles", 'String'>
    readonly seriv_number: FieldRef<"TaskDetailDles", 'String'>
    readonly kva_rating: FieldRef<"TaskDetailDles", 'String'>
    readonly cause: FieldRef<"TaskDetailDles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskDetailDles findUnique
   */
  export type TaskDetailDlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailDles to fetch.
     */
    where: TaskDetailDlesWhereUniqueInput
  }

  /**
   * TaskDetailDles findUniqueOrThrow
   */
  export type TaskDetailDlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailDles to fetch.
     */
    where: TaskDetailDlesWhereUniqueInput
  }

  /**
   * TaskDetailDles findFirst
   */
  export type TaskDetailDlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailDles to fetch.
     */
    where?: TaskDetailDlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailDles to fetch.
     */
    orderBy?: TaskDetailDlesOrderByWithRelationInput | TaskDetailDlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailDles.
     */
    cursor?: TaskDetailDlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailDles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailDles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailDles.
     */
    distinct?: TaskDetailDlesScalarFieldEnum | TaskDetailDlesScalarFieldEnum[]
  }

  /**
   * TaskDetailDles findFirstOrThrow
   */
  export type TaskDetailDlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailDles to fetch.
     */
    where?: TaskDetailDlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailDles to fetch.
     */
    orderBy?: TaskDetailDlesOrderByWithRelationInput | TaskDetailDlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailDles.
     */
    cursor?: TaskDetailDlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailDles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailDles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailDles.
     */
    distinct?: TaskDetailDlesScalarFieldEnum | TaskDetailDlesScalarFieldEnum[]
  }

  /**
   * TaskDetailDles findMany
   */
  export type TaskDetailDlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailDles to fetch.
     */
    where?: TaskDetailDlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailDles to fetch.
     */
    orderBy?: TaskDetailDlesOrderByWithRelationInput | TaskDetailDlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailDles.
     */
    cursor?: TaskDetailDlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailDles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailDles.
     */
    skip?: number
    distinct?: TaskDetailDlesScalarFieldEnum | TaskDetailDlesScalarFieldEnum[]
  }

  /**
   * TaskDetailDles create
   */
  export type TaskDetailDlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDetailDles.
     */
    data: XOR<TaskDetailDlesCreateInput, TaskDetailDlesUncheckedCreateInput>
  }

  /**
   * TaskDetailDles createMany
   */
  export type TaskDetailDlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDetailDles.
     */
    data: TaskDetailDlesCreateManyInput | TaskDetailDlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDetailDles createManyAndReturn
   */
  export type TaskDetailDlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDetailDles.
     */
    data: TaskDetailDlesCreateManyInput | TaskDetailDlesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDetailDles update
   */
  export type TaskDetailDlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDetailDles.
     */
    data: XOR<TaskDetailDlesUpdateInput, TaskDetailDlesUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailDles to update.
     */
    where: TaskDetailDlesWhereUniqueInput
  }

  /**
   * TaskDetailDles updateMany
   */
  export type TaskDetailDlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDetailDles.
     */
    data: XOR<TaskDetailDlesUpdateManyMutationInput, TaskDetailDlesUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailDles to update
     */
    where?: TaskDetailDlesWhereInput
    limit?: number
  }

  /**
   * TaskDetailDles upsert
   */
  export type TaskDetailDlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDetailDles to update in case it exists.
     */
    where: TaskDetailDlesWhereUniqueInput
    /**
     * In case the TaskDetailDles found by the `where` argument doesn't exist, create a new TaskDetailDles with this data.
     */
    create: XOR<TaskDetailDlesCreateInput, TaskDetailDlesUncheckedCreateInput>
    /**
     * In case the TaskDetailDles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDetailDlesUpdateInput, TaskDetailDlesUncheckedUpdateInput>
  }

  /**
   * TaskDetailDles delete
   */
  export type TaskDetailDlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
    /**
     * Filter which TaskDetailDles to delete.
     */
    where: TaskDetailDlesWhereUniqueInput
  }

  /**
   * TaskDetailDles deleteMany
   */
  export type TaskDetailDlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailDles to delete
     */
    where?: TaskDetailDlesWhereInput
    limit?: number
  }

  /**
   * TaskDetailDles.linemen_incharge
   */
  export type TaskDetailDles$linemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    where?: DlesLinemanWhereInput
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    cursor?: DlesLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DlesLinemanScalarFieldEnum | DlesLinemanScalarFieldEnum[]
  }

  /**
   * TaskDetailDles without action
   */
  export type TaskDetailDlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailDles
     */
    select?: TaskDetailDlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailDlesInclude<ExtArgs> | null
  }


  /**
   * Model DlesLineman
   */

  export type AggregateDlesLineman = {
    _count: DlesLinemanCountAggregateOutputType | null
    _avg: DlesLinemanAvgAggregateOutputType | null
    _sum: DlesLinemanSumAggregateOutputType | null
    _min: DlesLinemanMinAggregateOutputType | null
    _max: DlesLinemanMaxAggregateOutputType | null
  }

  export type DlesLinemanAvgAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type DlesLinemanSumAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type DlesLinemanMinAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type DlesLinemanMaxAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type DlesLinemanCountAggregateOutputType = {
    id: number
    task_detail_id: number
    lineman_id: number
    _all: number
  }


  export type DlesLinemanAvgAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type DlesLinemanSumAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type DlesLinemanMinAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type DlesLinemanMaxAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type DlesLinemanCountAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
    _all?: true
  }

  export type DlesLinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DlesLineman to aggregate.
     */
    where?: DlesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DlesLinemen to fetch.
     */
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DlesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DlesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DlesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DlesLinemen
    **/
    _count?: true | DlesLinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DlesLinemanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DlesLinemanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DlesLinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DlesLinemanMaxAggregateInputType
  }

  export type GetDlesLinemanAggregateType<T extends DlesLinemanAggregateArgs> = {
        [P in keyof T & keyof AggregateDlesLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDlesLineman[P]>
      : GetScalarType<T[P], AggregateDlesLineman[P]>
  }




  export type DlesLinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DlesLinemanWhereInput
    orderBy?: DlesLinemanOrderByWithAggregationInput | DlesLinemanOrderByWithAggregationInput[]
    by: DlesLinemanScalarFieldEnum[] | DlesLinemanScalarFieldEnum
    having?: DlesLinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DlesLinemanCountAggregateInputType | true
    _avg?: DlesLinemanAvgAggregateInputType
    _sum?: DlesLinemanSumAggregateInputType
    _min?: DlesLinemanMinAggregateInputType
    _max?: DlesLinemanMaxAggregateInputType
  }

  export type DlesLinemanGroupByOutputType = {
    id: number
    task_detail_id: number
    lineman_id: string
    _count: DlesLinemanCountAggregateOutputType | null
    _avg: DlesLinemanAvgAggregateOutputType | null
    _sum: DlesLinemanSumAggregateOutputType | null
    _min: DlesLinemanMinAggregateOutputType | null
    _max: DlesLinemanMaxAggregateOutputType | null
  }

  type GetDlesLinemanGroupByPayload<T extends DlesLinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DlesLinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DlesLinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DlesLinemanGroupByOutputType[P]>
            : GetScalarType<T[P], DlesLinemanGroupByOutputType[P]>
        }
      >
    >


  export type DlesLinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailDlesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dlesLineman"]>

  export type DlesLinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailDlesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dlesLineman"]>

  export type DlesLinemanSelectScalar = {
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
  }

  export type DlesLinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailDlesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }
  export type DlesLinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailDlesDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }

  export type $DlesLinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DlesLineman"
    objects: {
      task_detail: Prisma.$TaskDetailDlesPayload<ExtArgs>
      lineman: Prisma.$LinemanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_detail_id: number
      lineman_id: string
    }, ExtArgs["result"]["dlesLineman"]>
    composites: {}
  }

  type DlesLinemanGetPayload<S extends boolean | null | undefined | DlesLinemanDefaultArgs> = $Result.GetResult<Prisma.$DlesLinemanPayload, S>

  type DlesLinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DlesLinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DlesLinemanCountAggregateInputType | true
    }

  export interface DlesLinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DlesLineman'], meta: { name: 'DlesLineman' } }
    /**
     * Find zero or one DlesLineman that matches the filter.
     * @param {DlesLinemanFindUniqueArgs} args - Arguments to find a DlesLineman
     * @example
     * // Get one DlesLineman
     * const dlesLineman = await prisma.dlesLineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DlesLinemanFindUniqueArgs>(args: SelectSubset<T, DlesLinemanFindUniqueArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DlesLineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DlesLinemanFindUniqueOrThrowArgs} args - Arguments to find a DlesLineman
     * @example
     * // Get one DlesLineman
     * const dlesLineman = await prisma.dlesLineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DlesLinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, DlesLinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DlesLineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanFindFirstArgs} args - Arguments to find a DlesLineman
     * @example
     * // Get one DlesLineman
     * const dlesLineman = await prisma.dlesLineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DlesLinemanFindFirstArgs>(args?: SelectSubset<T, DlesLinemanFindFirstArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DlesLineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanFindFirstOrThrowArgs} args - Arguments to find a DlesLineman
     * @example
     * // Get one DlesLineman
     * const dlesLineman = await prisma.dlesLineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DlesLinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, DlesLinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DlesLinemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DlesLinemen
     * const dlesLinemen = await prisma.dlesLineman.findMany()
     * 
     * // Get first 10 DlesLinemen
     * const dlesLinemen = await prisma.dlesLineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dlesLinemanWithIdOnly = await prisma.dlesLineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DlesLinemanFindManyArgs>(args?: SelectSubset<T, DlesLinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DlesLineman.
     * @param {DlesLinemanCreateArgs} args - Arguments to create a DlesLineman.
     * @example
     * // Create one DlesLineman
     * const DlesLineman = await prisma.dlesLineman.create({
     *   data: {
     *     // ... data to create a DlesLineman
     *   }
     * })
     * 
     */
    create<T extends DlesLinemanCreateArgs>(args: SelectSubset<T, DlesLinemanCreateArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DlesLinemen.
     * @param {DlesLinemanCreateManyArgs} args - Arguments to create many DlesLinemen.
     * @example
     * // Create many DlesLinemen
     * const dlesLineman = await prisma.dlesLineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DlesLinemanCreateManyArgs>(args?: SelectSubset<T, DlesLinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DlesLinemen and returns the data saved in the database.
     * @param {DlesLinemanCreateManyAndReturnArgs} args - Arguments to create many DlesLinemen.
     * @example
     * // Create many DlesLinemen
     * const dlesLineman = await prisma.dlesLineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DlesLinemen and only return the `id`
     * const dlesLinemanWithIdOnly = await prisma.dlesLineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DlesLinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, DlesLinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DlesLineman.
     * @param {DlesLinemanDeleteArgs} args - Arguments to delete one DlesLineman.
     * @example
     * // Delete one DlesLineman
     * const DlesLineman = await prisma.dlesLineman.delete({
     *   where: {
     *     // ... filter to delete one DlesLineman
     *   }
     * })
     * 
     */
    delete<T extends DlesLinemanDeleteArgs>(args: SelectSubset<T, DlesLinemanDeleteArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DlesLineman.
     * @param {DlesLinemanUpdateArgs} args - Arguments to update one DlesLineman.
     * @example
     * // Update one DlesLineman
     * const dlesLineman = await prisma.dlesLineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DlesLinemanUpdateArgs>(args: SelectSubset<T, DlesLinemanUpdateArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DlesLinemen.
     * @param {DlesLinemanDeleteManyArgs} args - Arguments to filter DlesLinemen to delete.
     * @example
     * // Delete a few DlesLinemen
     * const { count } = await prisma.dlesLineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DlesLinemanDeleteManyArgs>(args?: SelectSubset<T, DlesLinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DlesLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DlesLinemen
     * const dlesLineman = await prisma.dlesLineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DlesLinemanUpdateManyArgs>(args: SelectSubset<T, DlesLinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DlesLineman.
     * @param {DlesLinemanUpsertArgs} args - Arguments to update or create a DlesLineman.
     * @example
     * // Update or create a DlesLineman
     * const dlesLineman = await prisma.dlesLineman.upsert({
     *   create: {
     *     // ... data to create a DlesLineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DlesLineman we want to update
     *   }
     * })
     */
    upsert<T extends DlesLinemanUpsertArgs>(args: SelectSubset<T, DlesLinemanUpsertArgs<ExtArgs>>): Prisma__DlesLinemanClient<$Result.GetResult<Prisma.$DlesLinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DlesLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanCountArgs} args - Arguments to filter DlesLinemen to count.
     * @example
     * // Count the number of DlesLinemen
     * const count = await prisma.dlesLineman.count({
     *   where: {
     *     // ... the filter for the DlesLinemen we want to count
     *   }
     * })
    **/
    count<T extends DlesLinemanCountArgs>(
      args?: Subset<T, DlesLinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DlesLinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DlesLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DlesLinemanAggregateArgs>(args: Subset<T, DlesLinemanAggregateArgs>): Prisma.PrismaPromise<GetDlesLinemanAggregateType<T>>

    /**
     * Group by DlesLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DlesLinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DlesLinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DlesLinemanGroupByArgs['orderBy'] }
        : { orderBy?: DlesLinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DlesLinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDlesLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DlesLineman model
   */
  readonly fields: DlesLinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DlesLineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DlesLinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_detail<T extends TaskDetailDlesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailDlesDefaultArgs<ExtArgs>>): Prisma__TaskDetailDlesClient<$Result.GetResult<Prisma.$TaskDetailDlesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineman<T extends LinemanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinemanDefaultArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DlesLineman model
   */ 
  interface DlesLinemanFieldRefs {
    readonly id: FieldRef<"DlesLineman", 'Int'>
    readonly task_detail_id: FieldRef<"DlesLineman", 'Int'>
    readonly lineman_id: FieldRef<"DlesLineman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DlesLineman findUnique
   */
  export type DlesLinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which DlesLineman to fetch.
     */
    where: DlesLinemanWhereUniqueInput
  }

  /**
   * DlesLineman findUniqueOrThrow
   */
  export type DlesLinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which DlesLineman to fetch.
     */
    where: DlesLinemanWhereUniqueInput
  }

  /**
   * DlesLineman findFirst
   */
  export type DlesLinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which DlesLineman to fetch.
     */
    where?: DlesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DlesLinemen to fetch.
     */
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DlesLinemen.
     */
    cursor?: DlesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DlesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DlesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DlesLinemen.
     */
    distinct?: DlesLinemanScalarFieldEnum | DlesLinemanScalarFieldEnum[]
  }

  /**
   * DlesLineman findFirstOrThrow
   */
  export type DlesLinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which DlesLineman to fetch.
     */
    where?: DlesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DlesLinemen to fetch.
     */
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DlesLinemen.
     */
    cursor?: DlesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DlesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DlesLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DlesLinemen.
     */
    distinct?: DlesLinemanScalarFieldEnum | DlesLinemanScalarFieldEnum[]
  }

  /**
   * DlesLineman findMany
   */
  export type DlesLinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter, which DlesLinemen to fetch.
     */
    where?: DlesLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DlesLinemen to fetch.
     */
    orderBy?: DlesLinemanOrderByWithRelationInput | DlesLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DlesLinemen.
     */
    cursor?: DlesLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DlesLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DlesLinemen.
     */
    skip?: number
    distinct?: DlesLinemanScalarFieldEnum | DlesLinemanScalarFieldEnum[]
  }

  /**
   * DlesLineman create
   */
  export type DlesLinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a DlesLineman.
     */
    data: XOR<DlesLinemanCreateInput, DlesLinemanUncheckedCreateInput>
  }

  /**
   * DlesLineman createMany
   */
  export type DlesLinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DlesLinemen.
     */
    data: DlesLinemanCreateManyInput | DlesLinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DlesLineman createManyAndReturn
   */
  export type DlesLinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DlesLinemen.
     */
    data: DlesLinemanCreateManyInput | DlesLinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DlesLineman update
   */
  export type DlesLinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a DlesLineman.
     */
    data: XOR<DlesLinemanUpdateInput, DlesLinemanUncheckedUpdateInput>
    /**
     * Choose, which DlesLineman to update.
     */
    where: DlesLinemanWhereUniqueInput
  }

  /**
   * DlesLineman updateMany
   */
  export type DlesLinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DlesLinemen.
     */
    data: XOR<DlesLinemanUpdateManyMutationInput, DlesLinemanUncheckedUpdateManyInput>
    /**
     * Filter which DlesLinemen to update
     */
    where?: DlesLinemanWhereInput
    limit?: number
  }

  /**
   * DlesLineman upsert
   */
  export type DlesLinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the DlesLineman to update in case it exists.
     */
    where: DlesLinemanWhereUniqueInput
    /**
     * In case the DlesLineman found by the `where` argument doesn't exist, create a new DlesLineman with this data.
     */
    create: XOR<DlesLinemanCreateInput, DlesLinemanUncheckedCreateInput>
    /**
     * In case the DlesLineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DlesLinemanUpdateInput, DlesLinemanUncheckedUpdateInput>
  }

  /**
   * DlesLineman delete
   */
  export type DlesLinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
    /**
     * Filter which DlesLineman to delete.
     */
    where: DlesLinemanWhereUniqueInput
  }

  /**
   * DlesLineman deleteMany
   */
  export type DlesLinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DlesLinemen to delete
     */
    where?: DlesLinemanWhereInput
    limit?: number
  }

  /**
   * DlesLineman without action
   */
  export type DlesLinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DlesLineman
     */
    select?: DlesLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DlesLinemanInclude<ExtArgs> | null
  }


  /**
   * Model TaskDetailLmdga
   */

  export type AggregateTaskDetailLmdga = {
    _count: TaskDetailLmdgaCountAggregateOutputType | null
    _avg: TaskDetailLmdgaAvgAggregateOutputType | null
    _sum: TaskDetailLmdgaSumAggregateOutputType | null
    _min: TaskDetailLmdgaMinAggregateOutputType | null
    _max: TaskDetailLmdgaMaxAggregateOutputType | null
  }

  export type TaskDetailLmdgaAvgAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailLmdgaSumAggregateOutputType = {
    id: number | null
    task_id: number | null
  }

  export type TaskDetailLmdgaMinAggregateOutputType = {
    id: number | null
    task_id: number | null
    kva_rating: string | null
    substation_id: string | null
    dt_location: string | null
    feeder_id: string | null
    phase_number: string | null
    number_of_hc: string | null
    number_of_spans: string | null
    copper_aluminum_primary: string | null
    copper_aluminum_secondary: string | null
    copper_aluminum_ground: string | null
    size_primary: string | null
    size_secondary: string | null
    size_ground: string | null
    terminal_connector_primary: string | null
    terminal_connector_secondary: string | null
    terminal_connector_ground: string | null
    tap_position: string | null
    brand: string | null
    number_of_bushing_primary: string | null
    number_of_bushing_secondary: string | null
    protective_device: string | null
    load_current_sec_bushing: string | null
    load_current_neutral: string | null
    load_current_one: string | null
    load_current_two: string | null
    voltage_level_one: string | null
    voltage_level_two: string | null
    sec_line_conductor_size_one: string | null
    sec_line_conductor_size_two: string | null
  }

  export type TaskDetailLmdgaMaxAggregateOutputType = {
    id: number | null
    task_id: number | null
    kva_rating: string | null
    substation_id: string | null
    dt_location: string | null
    feeder_id: string | null
    phase_number: string | null
    number_of_hc: string | null
    number_of_spans: string | null
    copper_aluminum_primary: string | null
    copper_aluminum_secondary: string | null
    copper_aluminum_ground: string | null
    size_primary: string | null
    size_secondary: string | null
    size_ground: string | null
    terminal_connector_primary: string | null
    terminal_connector_secondary: string | null
    terminal_connector_ground: string | null
    tap_position: string | null
    brand: string | null
    number_of_bushing_primary: string | null
    number_of_bushing_secondary: string | null
    protective_device: string | null
    load_current_sec_bushing: string | null
    load_current_neutral: string | null
    load_current_one: string | null
    load_current_two: string | null
    voltage_level_one: string | null
    voltage_level_two: string | null
    sec_line_conductor_size_one: string | null
    sec_line_conductor_size_two: string | null
  }

  export type TaskDetailLmdgaCountAggregateOutputType = {
    id: number
    task_id: number
    kva_rating: number
    substation_id: number
    dt_location: number
    feeder_id: number
    phase_number: number
    number_of_hc: number
    number_of_spans: number
    copper_aluminum_primary: number
    copper_aluminum_secondary: number
    copper_aluminum_ground: number
    size_primary: number
    size_secondary: number
    size_ground: number
    terminal_connector_primary: number
    terminal_connector_secondary: number
    terminal_connector_ground: number
    tap_position: number
    brand: number
    number_of_bushing_primary: number
    number_of_bushing_secondary: number
    protective_device: number
    load_current_sec_bushing: number
    load_current_neutral: number
    load_current_one: number
    load_current_two: number
    voltage_level_one: number
    voltage_level_two: number
    sec_line_conductor_size_one: number
    sec_line_conductor_size_two: number
    _all: number
  }


  export type TaskDetailLmdgaAvgAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailLmdgaSumAggregateInputType = {
    id?: true
    task_id?: true
  }

  export type TaskDetailLmdgaMinAggregateInputType = {
    id?: true
    task_id?: true
    kva_rating?: true
    substation_id?: true
    dt_location?: true
    feeder_id?: true
    phase_number?: true
    number_of_hc?: true
    number_of_spans?: true
    copper_aluminum_primary?: true
    copper_aluminum_secondary?: true
    copper_aluminum_ground?: true
    size_primary?: true
    size_secondary?: true
    size_ground?: true
    terminal_connector_primary?: true
    terminal_connector_secondary?: true
    terminal_connector_ground?: true
    tap_position?: true
    brand?: true
    number_of_bushing_primary?: true
    number_of_bushing_secondary?: true
    protective_device?: true
    load_current_sec_bushing?: true
    load_current_neutral?: true
    load_current_one?: true
    load_current_two?: true
    voltage_level_one?: true
    voltage_level_two?: true
    sec_line_conductor_size_one?: true
    sec_line_conductor_size_two?: true
  }

  export type TaskDetailLmdgaMaxAggregateInputType = {
    id?: true
    task_id?: true
    kva_rating?: true
    substation_id?: true
    dt_location?: true
    feeder_id?: true
    phase_number?: true
    number_of_hc?: true
    number_of_spans?: true
    copper_aluminum_primary?: true
    copper_aluminum_secondary?: true
    copper_aluminum_ground?: true
    size_primary?: true
    size_secondary?: true
    size_ground?: true
    terminal_connector_primary?: true
    terminal_connector_secondary?: true
    terminal_connector_ground?: true
    tap_position?: true
    brand?: true
    number_of_bushing_primary?: true
    number_of_bushing_secondary?: true
    protective_device?: true
    load_current_sec_bushing?: true
    load_current_neutral?: true
    load_current_one?: true
    load_current_two?: true
    voltage_level_one?: true
    voltage_level_two?: true
    sec_line_conductor_size_one?: true
    sec_line_conductor_size_two?: true
  }

  export type TaskDetailLmdgaCountAggregateInputType = {
    id?: true
    task_id?: true
    kva_rating?: true
    substation_id?: true
    dt_location?: true
    feeder_id?: true
    phase_number?: true
    number_of_hc?: true
    number_of_spans?: true
    copper_aluminum_primary?: true
    copper_aluminum_secondary?: true
    copper_aluminum_ground?: true
    size_primary?: true
    size_secondary?: true
    size_ground?: true
    terminal_connector_primary?: true
    terminal_connector_secondary?: true
    terminal_connector_ground?: true
    tap_position?: true
    brand?: true
    number_of_bushing_primary?: true
    number_of_bushing_secondary?: true
    protective_device?: true
    load_current_sec_bushing?: true
    load_current_neutral?: true
    load_current_one?: true
    load_current_two?: true
    voltage_level_one?: true
    voltage_level_two?: true
    sec_line_conductor_size_one?: true
    sec_line_conductor_size_two?: true
    _all?: true
  }

  export type TaskDetailLmdgaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailLmdga to aggregate.
     */
    where?: TaskDetailLmdgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLmdgas to fetch.
     */
    orderBy?: TaskDetailLmdgaOrderByWithRelationInput | TaskDetailLmdgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDetailLmdgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLmdgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLmdgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailLmdgas
    **/
    _count?: true | TaskDetailLmdgaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailLmdgaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailLmdgaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailLmdgaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailLmdgaMaxAggregateInputType
  }

  export type GetTaskDetailLmdgaAggregateType<T extends TaskDetailLmdgaAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailLmdga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailLmdga[P]>
      : GetScalarType<T[P], AggregateTaskDetailLmdga[P]>
  }




  export type TaskDetailLmdgaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDetailLmdgaWhereInput
    orderBy?: TaskDetailLmdgaOrderByWithAggregationInput | TaskDetailLmdgaOrderByWithAggregationInput[]
    by: TaskDetailLmdgaScalarFieldEnum[] | TaskDetailLmdgaScalarFieldEnum
    having?: TaskDetailLmdgaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailLmdgaCountAggregateInputType | true
    _avg?: TaskDetailLmdgaAvgAggregateInputType
    _sum?: TaskDetailLmdgaSumAggregateInputType
    _min?: TaskDetailLmdgaMinAggregateInputType
    _max?: TaskDetailLmdgaMaxAggregateInputType
  }

  export type TaskDetailLmdgaGroupByOutputType = {
    id: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    feeder_id: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    _count: TaskDetailLmdgaCountAggregateOutputType | null
    _avg: TaskDetailLmdgaAvgAggregateOutputType | null
    _sum: TaskDetailLmdgaSumAggregateOutputType | null
    _min: TaskDetailLmdgaMinAggregateOutputType | null
    _max: TaskDetailLmdgaMaxAggregateOutputType | null
  }

  type GetTaskDetailLmdgaGroupByPayload<T extends TaskDetailLmdgaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDetailLmdgaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailLmdgaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailLmdgaGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailLmdgaGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailLmdgaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    kva_rating?: boolean
    substation_id?: boolean
    dt_location?: boolean
    feeder_id?: boolean
    phase_number?: boolean
    number_of_hc?: boolean
    number_of_spans?: boolean
    copper_aluminum_primary?: boolean
    copper_aluminum_secondary?: boolean
    copper_aluminum_ground?: boolean
    size_primary?: boolean
    size_secondary?: boolean
    size_ground?: boolean
    terminal_connector_primary?: boolean
    terminal_connector_secondary?: boolean
    terminal_connector_ground?: boolean
    tap_position?: boolean
    brand?: boolean
    number_of_bushing_primary?: boolean
    number_of_bushing_secondary?: boolean
    protective_device?: boolean
    load_current_sec_bushing?: boolean
    load_current_neutral?: boolean
    load_current_one?: boolean
    load_current_two?: boolean
    voltage_level_one?: boolean
    voltage_level_two?: boolean
    sec_line_conductor_size_one?: boolean
    sec_line_conductor_size_two?: boolean
    linemen_incharge?: boolean | TaskDetailLmdga$linemen_inchargeArgs<ExtArgs>
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailLmdgaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailLmdga"]>

  export type TaskDetailLmdgaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    kva_rating?: boolean
    substation_id?: boolean
    dt_location?: boolean
    feeder_id?: boolean
    phase_number?: boolean
    number_of_hc?: boolean
    number_of_spans?: boolean
    copper_aluminum_primary?: boolean
    copper_aluminum_secondary?: boolean
    copper_aluminum_ground?: boolean
    size_primary?: boolean
    size_secondary?: boolean
    size_ground?: boolean
    terminal_connector_primary?: boolean
    terminal_connector_secondary?: boolean
    terminal_connector_ground?: boolean
    tap_position?: boolean
    brand?: boolean
    number_of_bushing_primary?: boolean
    number_of_bushing_secondary?: boolean
    protective_device?: boolean
    load_current_sec_bushing?: boolean
    load_current_neutral?: boolean
    load_current_one?: boolean
    load_current_two?: boolean
    voltage_level_one?: boolean
    voltage_level_two?: boolean
    sec_line_conductor_size_one?: boolean
    sec_line_conductor_size_two?: boolean
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDetailLmdga"]>

  export type TaskDetailLmdgaSelectScalar = {
    id?: boolean
    task_id?: boolean
    kva_rating?: boolean
    substation_id?: boolean
    dt_location?: boolean
    feeder_id?: boolean
    phase_number?: boolean
    number_of_hc?: boolean
    number_of_spans?: boolean
    copper_aluminum_primary?: boolean
    copper_aluminum_secondary?: boolean
    copper_aluminum_ground?: boolean
    size_primary?: boolean
    size_secondary?: boolean
    size_ground?: boolean
    terminal_connector_primary?: boolean
    terminal_connector_secondary?: boolean
    terminal_connector_ground?: boolean
    tap_position?: boolean
    brand?: boolean
    number_of_bushing_primary?: boolean
    number_of_bushing_secondary?: boolean
    protective_device?: boolean
    load_current_sec_bushing?: boolean
    load_current_neutral?: boolean
    load_current_one?: boolean
    load_current_two?: boolean
    voltage_level_one?: boolean
    voltage_level_two?: boolean
    sec_line_conductor_size_one?: boolean
    sec_line_conductor_size_two?: boolean
  }

  export type TaskDetailLmdgaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linemen_incharge?: boolean | TaskDetailLmdga$linemen_inchargeArgs<ExtArgs>
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    _count?: boolean | TaskDetailLmdgaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskDetailLmdgaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeder?: boolean | FeederDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDetailLmdgaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDetailLmdga"
    objects: {
      linemen_incharge: Prisma.$LmdgaLinemanPayload<ExtArgs>[]
      feeder: Prisma.$FeederPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_id: number
      kva_rating: string
      substation_id: string
      dt_location: string
      feeder_id: string
      phase_number: string
      number_of_hc: string
      number_of_spans: string
      copper_aluminum_primary: string
      copper_aluminum_secondary: string
      copper_aluminum_ground: string
      size_primary: string
      size_secondary: string
      size_ground: string
      terminal_connector_primary: string
      terminal_connector_secondary: string
      terminal_connector_ground: string
      tap_position: string
      brand: string
      number_of_bushing_primary: string
      number_of_bushing_secondary: string
      protective_device: string
      load_current_sec_bushing: string
      load_current_neutral: string
      load_current_one: string
      load_current_two: string
      voltage_level_one: string
      voltage_level_two: string
      sec_line_conductor_size_one: string
      sec_line_conductor_size_two: string
    }, ExtArgs["result"]["taskDetailLmdga"]>
    composites: {}
  }

  type TaskDetailLmdgaGetPayload<S extends boolean | null | undefined | TaskDetailLmdgaDefaultArgs> = $Result.GetResult<Prisma.$TaskDetailLmdgaPayload, S>

  type TaskDetailLmdgaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDetailLmdgaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDetailLmdgaCountAggregateInputType | true
    }

  export interface TaskDetailLmdgaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDetailLmdga'], meta: { name: 'TaskDetailLmdga' } }
    /**
     * Find zero or one TaskDetailLmdga that matches the filter.
     * @param {TaskDetailLmdgaFindUniqueArgs} args - Arguments to find a TaskDetailLmdga
     * @example
     * // Get one TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDetailLmdgaFindUniqueArgs>(args: SelectSubset<T, TaskDetailLmdgaFindUniqueArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDetailLmdga that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDetailLmdgaFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailLmdga
     * @example
     * // Get one TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDetailLmdgaFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDetailLmdgaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDetailLmdga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaFindFirstArgs} args - Arguments to find a TaskDetailLmdga
     * @example
     * // Get one TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDetailLmdgaFindFirstArgs>(args?: SelectSubset<T, TaskDetailLmdgaFindFirstArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDetailLmdga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaFindFirstOrThrowArgs} args - Arguments to find a TaskDetailLmdga
     * @example
     * // Get one TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDetailLmdgaFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDetailLmdgaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDetailLmdgas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailLmdgas
     * const taskDetailLmdgas = await prisma.taskDetailLmdga.findMany()
     * 
     * // Get first 10 TaskDetailLmdgas
     * const taskDetailLmdgas = await prisma.taskDetailLmdga.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailLmdgaWithIdOnly = await prisma.taskDetailLmdga.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDetailLmdgaFindManyArgs>(args?: SelectSubset<T, TaskDetailLmdgaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDetailLmdga.
     * @param {TaskDetailLmdgaCreateArgs} args - Arguments to create a TaskDetailLmdga.
     * @example
     * // Create one TaskDetailLmdga
     * const TaskDetailLmdga = await prisma.taskDetailLmdga.create({
     *   data: {
     *     // ... data to create a TaskDetailLmdga
     *   }
     * })
     * 
     */
    create<T extends TaskDetailLmdgaCreateArgs>(args: SelectSubset<T, TaskDetailLmdgaCreateArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDetailLmdgas.
     * @param {TaskDetailLmdgaCreateManyArgs} args - Arguments to create many TaskDetailLmdgas.
     * @example
     * // Create many TaskDetailLmdgas
     * const taskDetailLmdga = await prisma.taskDetailLmdga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDetailLmdgaCreateManyArgs>(args?: SelectSubset<T, TaskDetailLmdgaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDetailLmdgas and returns the data saved in the database.
     * @param {TaskDetailLmdgaCreateManyAndReturnArgs} args - Arguments to create many TaskDetailLmdgas.
     * @example
     * // Create many TaskDetailLmdgas
     * const taskDetailLmdga = await prisma.taskDetailLmdga.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDetailLmdgas and only return the `id`
     * const taskDetailLmdgaWithIdOnly = await prisma.taskDetailLmdga.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDetailLmdgaCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDetailLmdgaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDetailLmdga.
     * @param {TaskDetailLmdgaDeleteArgs} args - Arguments to delete one TaskDetailLmdga.
     * @example
     * // Delete one TaskDetailLmdga
     * const TaskDetailLmdga = await prisma.taskDetailLmdga.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailLmdga
     *   }
     * })
     * 
     */
    delete<T extends TaskDetailLmdgaDeleteArgs>(args: SelectSubset<T, TaskDetailLmdgaDeleteArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDetailLmdga.
     * @param {TaskDetailLmdgaUpdateArgs} args - Arguments to update one TaskDetailLmdga.
     * @example
     * // Update one TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDetailLmdgaUpdateArgs>(args: SelectSubset<T, TaskDetailLmdgaUpdateArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDetailLmdgas.
     * @param {TaskDetailLmdgaDeleteManyArgs} args - Arguments to filter TaskDetailLmdgas to delete.
     * @example
     * // Delete a few TaskDetailLmdgas
     * const { count } = await prisma.taskDetailLmdga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDetailLmdgaDeleteManyArgs>(args?: SelectSubset<T, TaskDetailLmdgaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailLmdgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailLmdgas
     * const taskDetailLmdga = await prisma.taskDetailLmdga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDetailLmdgaUpdateManyArgs>(args: SelectSubset<T, TaskDetailLmdgaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailLmdga.
     * @param {TaskDetailLmdgaUpsertArgs} args - Arguments to update or create a TaskDetailLmdga.
     * @example
     * // Update or create a TaskDetailLmdga
     * const taskDetailLmdga = await prisma.taskDetailLmdga.upsert({
     *   create: {
     *     // ... data to create a TaskDetailLmdga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailLmdga we want to update
     *   }
     * })
     */
    upsert<T extends TaskDetailLmdgaUpsertArgs>(args: SelectSubset<T, TaskDetailLmdgaUpsertArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDetailLmdgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaCountArgs} args - Arguments to filter TaskDetailLmdgas to count.
     * @example
     * // Count the number of TaskDetailLmdgas
     * const count = await prisma.taskDetailLmdga.count({
     *   where: {
     *     // ... the filter for the TaskDetailLmdgas we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailLmdgaCountArgs>(
      args?: Subset<T, TaskDetailLmdgaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailLmdgaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailLmdga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailLmdgaAggregateArgs>(args: Subset<T, TaskDetailLmdgaAggregateArgs>): Prisma.PrismaPromise<GetTaskDetailLmdgaAggregateType<T>>

    /**
     * Group by TaskDetailLmdga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailLmdgaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailLmdgaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailLmdgaGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailLmdgaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailLmdgaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailLmdgaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDetailLmdga model
   */
  readonly fields: TaskDetailLmdgaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailLmdga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDetailLmdgaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    linemen_incharge<T extends TaskDetailLmdga$linemen_inchargeArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailLmdga$linemen_inchargeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findMany"> | Null>
    feeder<T extends FeederDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeederDefaultArgs<ExtArgs>>): Prisma__FeederClient<$Result.GetResult<Prisma.$FeederPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDetailLmdga model
   */ 
  interface TaskDetailLmdgaFieldRefs {
    readonly id: FieldRef<"TaskDetailLmdga", 'Int'>
    readonly task_id: FieldRef<"TaskDetailLmdga", 'Int'>
    readonly kva_rating: FieldRef<"TaskDetailLmdga", 'String'>
    readonly substation_id: FieldRef<"TaskDetailLmdga", 'String'>
    readonly dt_location: FieldRef<"TaskDetailLmdga", 'String'>
    readonly feeder_id: FieldRef<"TaskDetailLmdga", 'String'>
    readonly phase_number: FieldRef<"TaskDetailLmdga", 'String'>
    readonly number_of_hc: FieldRef<"TaskDetailLmdga", 'String'>
    readonly number_of_spans: FieldRef<"TaskDetailLmdga", 'String'>
    readonly copper_aluminum_primary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly copper_aluminum_secondary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly copper_aluminum_ground: FieldRef<"TaskDetailLmdga", 'String'>
    readonly size_primary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly size_secondary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly size_ground: FieldRef<"TaskDetailLmdga", 'String'>
    readonly terminal_connector_primary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly terminal_connector_secondary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly terminal_connector_ground: FieldRef<"TaskDetailLmdga", 'String'>
    readonly tap_position: FieldRef<"TaskDetailLmdga", 'String'>
    readonly brand: FieldRef<"TaskDetailLmdga", 'String'>
    readonly number_of_bushing_primary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly number_of_bushing_secondary: FieldRef<"TaskDetailLmdga", 'String'>
    readonly protective_device: FieldRef<"TaskDetailLmdga", 'String'>
    readonly load_current_sec_bushing: FieldRef<"TaskDetailLmdga", 'String'>
    readonly load_current_neutral: FieldRef<"TaskDetailLmdga", 'String'>
    readonly load_current_one: FieldRef<"TaskDetailLmdga", 'String'>
    readonly load_current_two: FieldRef<"TaskDetailLmdga", 'String'>
    readonly voltage_level_one: FieldRef<"TaskDetailLmdga", 'String'>
    readonly voltage_level_two: FieldRef<"TaskDetailLmdga", 'String'>
    readonly sec_line_conductor_size_one: FieldRef<"TaskDetailLmdga", 'String'>
    readonly sec_line_conductor_size_two: FieldRef<"TaskDetailLmdga", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskDetailLmdga findUnique
   */
  export type TaskDetailLmdgaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLmdga to fetch.
     */
    where: TaskDetailLmdgaWhereUniqueInput
  }

  /**
   * TaskDetailLmdga findUniqueOrThrow
   */
  export type TaskDetailLmdgaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLmdga to fetch.
     */
    where: TaskDetailLmdgaWhereUniqueInput
  }

  /**
   * TaskDetailLmdga findFirst
   */
  export type TaskDetailLmdgaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLmdga to fetch.
     */
    where?: TaskDetailLmdgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLmdgas to fetch.
     */
    orderBy?: TaskDetailLmdgaOrderByWithRelationInput | TaskDetailLmdgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailLmdgas.
     */
    cursor?: TaskDetailLmdgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLmdgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLmdgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailLmdgas.
     */
    distinct?: TaskDetailLmdgaScalarFieldEnum | TaskDetailLmdgaScalarFieldEnum[]
  }

  /**
   * TaskDetailLmdga findFirstOrThrow
   */
  export type TaskDetailLmdgaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLmdga to fetch.
     */
    where?: TaskDetailLmdgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLmdgas to fetch.
     */
    orderBy?: TaskDetailLmdgaOrderByWithRelationInput | TaskDetailLmdgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailLmdgas.
     */
    cursor?: TaskDetailLmdgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLmdgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLmdgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailLmdgas.
     */
    distinct?: TaskDetailLmdgaScalarFieldEnum | TaskDetailLmdgaScalarFieldEnum[]
  }

  /**
   * TaskDetailLmdga findMany
   */
  export type TaskDetailLmdgaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter, which TaskDetailLmdgas to fetch.
     */
    where?: TaskDetailLmdgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailLmdgas to fetch.
     */
    orderBy?: TaskDetailLmdgaOrderByWithRelationInput | TaskDetailLmdgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailLmdgas.
     */
    cursor?: TaskDetailLmdgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailLmdgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailLmdgas.
     */
    skip?: number
    distinct?: TaskDetailLmdgaScalarFieldEnum | TaskDetailLmdgaScalarFieldEnum[]
  }

  /**
   * TaskDetailLmdga create
   */
  export type TaskDetailLmdgaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDetailLmdga.
     */
    data: XOR<TaskDetailLmdgaCreateInput, TaskDetailLmdgaUncheckedCreateInput>
  }

  /**
   * TaskDetailLmdga createMany
   */
  export type TaskDetailLmdgaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDetailLmdgas.
     */
    data: TaskDetailLmdgaCreateManyInput | TaskDetailLmdgaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDetailLmdga createManyAndReturn
   */
  export type TaskDetailLmdgaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDetailLmdgas.
     */
    data: TaskDetailLmdgaCreateManyInput | TaskDetailLmdgaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDetailLmdga update
   */
  export type TaskDetailLmdgaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDetailLmdga.
     */
    data: XOR<TaskDetailLmdgaUpdateInput, TaskDetailLmdgaUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailLmdga to update.
     */
    where: TaskDetailLmdgaWhereUniqueInput
  }

  /**
   * TaskDetailLmdga updateMany
   */
  export type TaskDetailLmdgaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDetailLmdgas.
     */
    data: XOR<TaskDetailLmdgaUpdateManyMutationInput, TaskDetailLmdgaUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailLmdgas to update
     */
    where?: TaskDetailLmdgaWhereInput
    limit?: number
  }

  /**
   * TaskDetailLmdga upsert
   */
  export type TaskDetailLmdgaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDetailLmdga to update in case it exists.
     */
    where: TaskDetailLmdgaWhereUniqueInput
    /**
     * In case the TaskDetailLmdga found by the `where` argument doesn't exist, create a new TaskDetailLmdga with this data.
     */
    create: XOR<TaskDetailLmdgaCreateInput, TaskDetailLmdgaUncheckedCreateInput>
    /**
     * In case the TaskDetailLmdga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDetailLmdgaUpdateInput, TaskDetailLmdgaUncheckedUpdateInput>
  }

  /**
   * TaskDetailLmdga delete
   */
  export type TaskDetailLmdgaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
    /**
     * Filter which TaskDetailLmdga to delete.
     */
    where: TaskDetailLmdgaWhereUniqueInput
  }

  /**
   * TaskDetailLmdga deleteMany
   */
  export type TaskDetailLmdgaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDetailLmdgas to delete
     */
    where?: TaskDetailLmdgaWhereInput
    limit?: number
  }

  /**
   * TaskDetailLmdga.linemen_incharge
   */
  export type TaskDetailLmdga$linemen_inchargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    where?: LmdgaLinemanWhereInput
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    cursor?: LmdgaLinemanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LmdgaLinemanScalarFieldEnum | LmdgaLinemanScalarFieldEnum[]
  }

  /**
   * TaskDetailLmdga without action
   */
  export type TaskDetailLmdgaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDetailLmdga
     */
    select?: TaskDetailLmdgaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDetailLmdgaInclude<ExtArgs> | null
  }


  /**
   * Model LmdgaLineman
   */

  export type AggregateLmdgaLineman = {
    _count: LmdgaLinemanCountAggregateOutputType | null
    _avg: LmdgaLinemanAvgAggregateOutputType | null
    _sum: LmdgaLinemanSumAggregateOutputType | null
    _min: LmdgaLinemanMinAggregateOutputType | null
    _max: LmdgaLinemanMaxAggregateOutputType | null
  }

  export type LmdgaLinemanAvgAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type LmdgaLinemanSumAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
  }

  export type LmdgaLinemanMinAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type LmdgaLinemanMaxAggregateOutputType = {
    id: number | null
    task_detail_id: number | null
    lineman_id: string | null
  }

  export type LmdgaLinemanCountAggregateOutputType = {
    id: number
    task_detail_id: number
    lineman_id: number
    _all: number
  }


  export type LmdgaLinemanAvgAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type LmdgaLinemanSumAggregateInputType = {
    id?: true
    task_detail_id?: true
  }

  export type LmdgaLinemanMinAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type LmdgaLinemanMaxAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
  }

  export type LmdgaLinemanCountAggregateInputType = {
    id?: true
    task_detail_id?: true
    lineman_id?: true
    _all?: true
  }

  export type LmdgaLinemanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LmdgaLineman to aggregate.
     */
    where?: LmdgaLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LmdgaLinemen to fetch.
     */
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LmdgaLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LmdgaLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LmdgaLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LmdgaLinemen
    **/
    _count?: true | LmdgaLinemanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LmdgaLinemanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LmdgaLinemanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LmdgaLinemanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LmdgaLinemanMaxAggregateInputType
  }

  export type GetLmdgaLinemanAggregateType<T extends LmdgaLinemanAggregateArgs> = {
        [P in keyof T & keyof AggregateLmdgaLineman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLmdgaLineman[P]>
      : GetScalarType<T[P], AggregateLmdgaLineman[P]>
  }




  export type LmdgaLinemanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LmdgaLinemanWhereInput
    orderBy?: LmdgaLinemanOrderByWithAggregationInput | LmdgaLinemanOrderByWithAggregationInput[]
    by: LmdgaLinemanScalarFieldEnum[] | LmdgaLinemanScalarFieldEnum
    having?: LmdgaLinemanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LmdgaLinemanCountAggregateInputType | true
    _avg?: LmdgaLinemanAvgAggregateInputType
    _sum?: LmdgaLinemanSumAggregateInputType
    _min?: LmdgaLinemanMinAggregateInputType
    _max?: LmdgaLinemanMaxAggregateInputType
  }

  export type LmdgaLinemanGroupByOutputType = {
    id: number
    task_detail_id: number
    lineman_id: string
    _count: LmdgaLinemanCountAggregateOutputType | null
    _avg: LmdgaLinemanAvgAggregateOutputType | null
    _sum: LmdgaLinemanSumAggregateOutputType | null
    _min: LmdgaLinemanMinAggregateOutputType | null
    _max: LmdgaLinemanMaxAggregateOutputType | null
  }

  type GetLmdgaLinemanGroupByPayload<T extends LmdgaLinemanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LmdgaLinemanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LmdgaLinemanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LmdgaLinemanGroupByOutputType[P]>
            : GetScalarType<T[P], LmdgaLinemanGroupByOutputType[P]>
        }
      >
    >


  export type LmdgaLinemanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailLmdgaDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lmdgaLineman"]>

  export type LmdgaLinemanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
    task_detail?: boolean | TaskDetailLmdgaDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lmdgaLineman"]>

  export type LmdgaLinemanSelectScalar = {
    id?: boolean
    task_detail_id?: boolean
    lineman_id?: boolean
  }

  export type LmdgaLinemanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailLmdgaDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }
  export type LmdgaLinemanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_detail?: boolean | TaskDetailLmdgaDefaultArgs<ExtArgs>
    lineman?: boolean | LinemanDefaultArgs<ExtArgs>
  }

  export type $LmdgaLinemanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LmdgaLineman"
    objects: {
      task_detail: Prisma.$TaskDetailLmdgaPayload<ExtArgs>
      lineman: Prisma.$LinemanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      task_detail_id: number
      lineman_id: string
    }, ExtArgs["result"]["lmdgaLineman"]>
    composites: {}
  }

  type LmdgaLinemanGetPayload<S extends boolean | null | undefined | LmdgaLinemanDefaultArgs> = $Result.GetResult<Prisma.$LmdgaLinemanPayload, S>

  type LmdgaLinemanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LmdgaLinemanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LmdgaLinemanCountAggregateInputType | true
    }

  export interface LmdgaLinemanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LmdgaLineman'], meta: { name: 'LmdgaLineman' } }
    /**
     * Find zero or one LmdgaLineman that matches the filter.
     * @param {LmdgaLinemanFindUniqueArgs} args - Arguments to find a LmdgaLineman
     * @example
     * // Get one LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LmdgaLinemanFindUniqueArgs>(args: SelectSubset<T, LmdgaLinemanFindUniqueArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LmdgaLineman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LmdgaLinemanFindUniqueOrThrowArgs} args - Arguments to find a LmdgaLineman
     * @example
     * // Get one LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LmdgaLinemanFindUniqueOrThrowArgs>(args: SelectSubset<T, LmdgaLinemanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LmdgaLineman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanFindFirstArgs} args - Arguments to find a LmdgaLineman
     * @example
     * // Get one LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LmdgaLinemanFindFirstArgs>(args?: SelectSubset<T, LmdgaLinemanFindFirstArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LmdgaLineman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanFindFirstOrThrowArgs} args - Arguments to find a LmdgaLineman
     * @example
     * // Get one LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LmdgaLinemanFindFirstOrThrowArgs>(args?: SelectSubset<T, LmdgaLinemanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LmdgaLinemen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LmdgaLinemen
     * const lmdgaLinemen = await prisma.lmdgaLineman.findMany()
     * 
     * // Get first 10 LmdgaLinemen
     * const lmdgaLinemen = await prisma.lmdgaLineman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lmdgaLinemanWithIdOnly = await prisma.lmdgaLineman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LmdgaLinemanFindManyArgs>(args?: SelectSubset<T, LmdgaLinemanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LmdgaLineman.
     * @param {LmdgaLinemanCreateArgs} args - Arguments to create a LmdgaLineman.
     * @example
     * // Create one LmdgaLineman
     * const LmdgaLineman = await prisma.lmdgaLineman.create({
     *   data: {
     *     // ... data to create a LmdgaLineman
     *   }
     * })
     * 
     */
    create<T extends LmdgaLinemanCreateArgs>(args: SelectSubset<T, LmdgaLinemanCreateArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LmdgaLinemen.
     * @param {LmdgaLinemanCreateManyArgs} args - Arguments to create many LmdgaLinemen.
     * @example
     * // Create many LmdgaLinemen
     * const lmdgaLineman = await prisma.lmdgaLineman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LmdgaLinemanCreateManyArgs>(args?: SelectSubset<T, LmdgaLinemanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LmdgaLinemen and returns the data saved in the database.
     * @param {LmdgaLinemanCreateManyAndReturnArgs} args - Arguments to create many LmdgaLinemen.
     * @example
     * // Create many LmdgaLinemen
     * const lmdgaLineman = await prisma.lmdgaLineman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LmdgaLinemen and only return the `id`
     * const lmdgaLinemanWithIdOnly = await prisma.lmdgaLineman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LmdgaLinemanCreateManyAndReturnArgs>(args?: SelectSubset<T, LmdgaLinemanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LmdgaLineman.
     * @param {LmdgaLinemanDeleteArgs} args - Arguments to delete one LmdgaLineman.
     * @example
     * // Delete one LmdgaLineman
     * const LmdgaLineman = await prisma.lmdgaLineman.delete({
     *   where: {
     *     // ... filter to delete one LmdgaLineman
     *   }
     * })
     * 
     */
    delete<T extends LmdgaLinemanDeleteArgs>(args: SelectSubset<T, LmdgaLinemanDeleteArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LmdgaLineman.
     * @param {LmdgaLinemanUpdateArgs} args - Arguments to update one LmdgaLineman.
     * @example
     * // Update one LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LmdgaLinemanUpdateArgs>(args: SelectSubset<T, LmdgaLinemanUpdateArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LmdgaLinemen.
     * @param {LmdgaLinemanDeleteManyArgs} args - Arguments to filter LmdgaLinemen to delete.
     * @example
     * // Delete a few LmdgaLinemen
     * const { count } = await prisma.lmdgaLineman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LmdgaLinemanDeleteManyArgs>(args?: SelectSubset<T, LmdgaLinemanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LmdgaLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LmdgaLinemen
     * const lmdgaLineman = await prisma.lmdgaLineman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LmdgaLinemanUpdateManyArgs>(args: SelectSubset<T, LmdgaLinemanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LmdgaLineman.
     * @param {LmdgaLinemanUpsertArgs} args - Arguments to update or create a LmdgaLineman.
     * @example
     * // Update or create a LmdgaLineman
     * const lmdgaLineman = await prisma.lmdgaLineman.upsert({
     *   create: {
     *     // ... data to create a LmdgaLineman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LmdgaLineman we want to update
     *   }
     * })
     */
    upsert<T extends LmdgaLinemanUpsertArgs>(args: SelectSubset<T, LmdgaLinemanUpsertArgs<ExtArgs>>): Prisma__LmdgaLinemanClient<$Result.GetResult<Prisma.$LmdgaLinemanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LmdgaLinemen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanCountArgs} args - Arguments to filter LmdgaLinemen to count.
     * @example
     * // Count the number of LmdgaLinemen
     * const count = await prisma.lmdgaLineman.count({
     *   where: {
     *     // ... the filter for the LmdgaLinemen we want to count
     *   }
     * })
    **/
    count<T extends LmdgaLinemanCountArgs>(
      args?: Subset<T, LmdgaLinemanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LmdgaLinemanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LmdgaLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LmdgaLinemanAggregateArgs>(args: Subset<T, LmdgaLinemanAggregateArgs>): Prisma.PrismaPromise<GetLmdgaLinemanAggregateType<T>>

    /**
     * Group by LmdgaLineman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LmdgaLinemanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LmdgaLinemanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LmdgaLinemanGroupByArgs['orderBy'] }
        : { orderBy?: LmdgaLinemanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LmdgaLinemanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLmdgaLinemanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LmdgaLineman model
   */
  readonly fields: LmdgaLinemanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LmdgaLineman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LmdgaLinemanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_detail<T extends TaskDetailLmdgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDetailLmdgaDefaultArgs<ExtArgs>>): Prisma__TaskDetailLmdgaClient<$Result.GetResult<Prisma.$TaskDetailLmdgaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineman<T extends LinemanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinemanDefaultArgs<ExtArgs>>): Prisma__LinemanClient<$Result.GetResult<Prisma.$LinemanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LmdgaLineman model
   */ 
  interface LmdgaLinemanFieldRefs {
    readonly id: FieldRef<"LmdgaLineman", 'Int'>
    readonly task_detail_id: FieldRef<"LmdgaLineman", 'Int'>
    readonly lineman_id: FieldRef<"LmdgaLineman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LmdgaLineman findUnique
   */
  export type LmdgaLinemanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LmdgaLineman to fetch.
     */
    where: LmdgaLinemanWhereUniqueInput
  }

  /**
   * LmdgaLineman findUniqueOrThrow
   */
  export type LmdgaLinemanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LmdgaLineman to fetch.
     */
    where: LmdgaLinemanWhereUniqueInput
  }

  /**
   * LmdgaLineman findFirst
   */
  export type LmdgaLinemanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LmdgaLineman to fetch.
     */
    where?: LmdgaLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LmdgaLinemen to fetch.
     */
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LmdgaLinemen.
     */
    cursor?: LmdgaLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LmdgaLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LmdgaLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LmdgaLinemen.
     */
    distinct?: LmdgaLinemanScalarFieldEnum | LmdgaLinemanScalarFieldEnum[]
  }

  /**
   * LmdgaLineman findFirstOrThrow
   */
  export type LmdgaLinemanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LmdgaLineman to fetch.
     */
    where?: LmdgaLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LmdgaLinemen to fetch.
     */
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LmdgaLinemen.
     */
    cursor?: LmdgaLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LmdgaLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LmdgaLinemen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LmdgaLinemen.
     */
    distinct?: LmdgaLinemanScalarFieldEnum | LmdgaLinemanScalarFieldEnum[]
  }

  /**
   * LmdgaLineman findMany
   */
  export type LmdgaLinemanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter, which LmdgaLinemen to fetch.
     */
    where?: LmdgaLinemanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LmdgaLinemen to fetch.
     */
    orderBy?: LmdgaLinemanOrderByWithRelationInput | LmdgaLinemanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LmdgaLinemen.
     */
    cursor?: LmdgaLinemanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LmdgaLinemen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LmdgaLinemen.
     */
    skip?: number
    distinct?: LmdgaLinemanScalarFieldEnum | LmdgaLinemanScalarFieldEnum[]
  }

  /**
   * LmdgaLineman create
   */
  export type LmdgaLinemanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * The data needed to create a LmdgaLineman.
     */
    data: XOR<LmdgaLinemanCreateInput, LmdgaLinemanUncheckedCreateInput>
  }

  /**
   * LmdgaLineman createMany
   */
  export type LmdgaLinemanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LmdgaLinemen.
     */
    data: LmdgaLinemanCreateManyInput | LmdgaLinemanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LmdgaLineman createManyAndReturn
   */
  export type LmdgaLinemanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LmdgaLinemen.
     */
    data: LmdgaLinemanCreateManyInput | LmdgaLinemanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LmdgaLineman update
   */
  export type LmdgaLinemanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * The data needed to update a LmdgaLineman.
     */
    data: XOR<LmdgaLinemanUpdateInput, LmdgaLinemanUncheckedUpdateInput>
    /**
     * Choose, which LmdgaLineman to update.
     */
    where: LmdgaLinemanWhereUniqueInput
  }

  /**
   * LmdgaLineman updateMany
   */
  export type LmdgaLinemanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LmdgaLinemen.
     */
    data: XOR<LmdgaLinemanUpdateManyMutationInput, LmdgaLinemanUncheckedUpdateManyInput>
    /**
     * Filter which LmdgaLinemen to update
     */
    where?: LmdgaLinemanWhereInput
    limit?: number
  }

  /**
   * LmdgaLineman upsert
   */
  export type LmdgaLinemanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * The filter to search for the LmdgaLineman to update in case it exists.
     */
    where: LmdgaLinemanWhereUniqueInput
    /**
     * In case the LmdgaLineman found by the `where` argument doesn't exist, create a new LmdgaLineman with this data.
     */
    create: XOR<LmdgaLinemanCreateInput, LmdgaLinemanUncheckedCreateInput>
    /**
     * In case the LmdgaLineman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LmdgaLinemanUpdateInput, LmdgaLinemanUncheckedUpdateInput>
  }

  /**
   * LmdgaLineman delete
   */
  export type LmdgaLinemanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
    /**
     * Filter which LmdgaLineman to delete.
     */
    where: LmdgaLinemanWhereUniqueInput
  }

  /**
   * LmdgaLineman deleteMany
   */
  export type LmdgaLinemanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LmdgaLinemen to delete
     */
    where?: LmdgaLinemanWhereInput
    limit?: number
  }

  /**
   * LmdgaLineman without action
   */
  export type LmdgaLinemanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LmdgaLineman
     */
    select?: LmdgaLinemanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LmdgaLinemanInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditScalarFieldEnum: {
    id: 'id',
    username: 'username',
    table: 'table',
    action: 'action',
    reference_id: 'reference_id',
    metadata: 'metadata',
    ip_address: 'ip_address',
    device_info: 'device_info',
    created_at: 'created_at',
    notes: 'notes'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const LinemanScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    area_id: 'area_id',
    supervisor_id: 'supervisor_id',
    status: 'status'
  };

  export type LinemanScalarFieldEnum = (typeof LinemanScalarFieldEnum)[keyof typeof LinemanScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    oic_id: 'oic_id',
    name: 'name'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const MunicipalityScalarFieldEnum: {
    id: 'id',
    area_id: 'area_id',
    name: 'name'
  };

  export type MunicipalityScalarFieldEnum = (typeof MunicipalityScalarFieldEnum)[keyof typeof MunicipalityScalarFieldEnum]


  export const BarangayScalarFieldEnum: {
    id: 'id',
    municipality_id: 'municipality_id',
    name: 'name'
  };

  export type BarangayScalarFieldEnum = (typeof BarangayScalarFieldEnum)[keyof typeof BarangayScalarFieldEnum]


  export const SitioScalarFieldEnum: {
    id: 'id',
    barangay_id: 'barangay_id',
    name: 'name'
  };

  export type SitioScalarFieldEnum = (typeof SitioScalarFieldEnum)[keyof typeof SitioScalarFieldEnum]


  export const FeederScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FeederScalarFieldEnum = (typeof FeederScalarFieldEnum)[keyof typeof FeederScalarFieldEnum]


  export const WeatherConditionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WeatherConditionScalarFieldEnum = (typeof WeatherConditionScalarFieldEnum)[keyof typeof WeatherConditionScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const MeterBrandScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MeterBrandScalarFieldEnum = (typeof MeterBrandScalarFieldEnum)[keyof typeof MeterBrandScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ActivityCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ActivityCategoryScalarFieldEnum = (typeof ActivityCategoryScalarFieldEnum)[keyof typeof ActivityCategoryScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    report_type_id: 'report_type_id',
    complaint_status_id: 'complaint_status_id',
    assigned_group_id: 'assigned_group_id',
    assigned_group_type: 'assigned_group_type',
    ref_number: 'ref_number',
    complainant_name: 'complainant_name',
    complainant_contact_no: 'complainant_contact_no',
    description: 'description',
    remarks: 'remarks',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const ComplaintDetailScalarFieldEnum: {
    id: 'id',
    complaint_id: 'complaint_id',
    consumer_id: 'consumer_id',
    barangay_id: 'barangay_id',
    sitio_id: 'sitio_id',
    landmark: 'landmark',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComplaintDetailScalarFieldEnum = (typeof ComplaintDetailScalarFieldEnum)[keyof typeof ComplaintDetailScalarFieldEnum]


  export const ComplaintStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color_class: 'color_class',
    description: 'description'
  };

  export type ComplaintStatusScalarFieldEnum = (typeof ComplaintStatusScalarFieldEnum)[keyof typeof ComplaintStatusScalarFieldEnum]


  export const ComplaintReportTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ComplaintReportTypeScalarFieldEnum = (typeof ComplaintReportTypeScalarFieldEnum)[keyof typeof ComplaintReportTypeScalarFieldEnum]


  export const ComplaintLogScalarFieldEnum: {
    id: 'id',
    complaint_id: 'complaint_id',
    complaint_status_id: 'complaint_status_id',
    remarks: 'remarks',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ComplaintLogScalarFieldEnum = (typeof ComplaintLogScalarFieldEnum)[keyof typeof ComplaintLogScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    ref_number: 'ref_number',
    complaint_id: 'complaint_id',
    assignee_id: 'assignee_id',
    task_status_id: 'task_status_id',
    activity_id: 'activity_id',
    description: 'description',
    remarks: 'remarks',
    accomplishment: 'accomplishment',
    action_taken: 'action_taken',
    acted_at: 'acted_at',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskAssignmentScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    area_id: 'area_id',
    department_id: 'department_id',
    division_id: 'division_id',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type TaskAssignmentScalarFieldEnum = (typeof TaskAssignmentScalarFieldEnum)[keyof typeof TaskAssignmentScalarFieldEnum]


  export const TaskLogScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    task_status_id: 'task_status_id',
    remarks: 'remarks',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type TaskLogScalarFieldEnum = (typeof TaskLogScalarFieldEnum)[keyof typeof TaskLogScalarFieldEnum]


  export const TaskFileScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    filename: 'filename',
    source_path: 'source_path'
  };

  export type TaskFileScalarFieldEnum = (typeof TaskFileScalarFieldEnum)[keyof typeof TaskFileScalarFieldEnum]


  export const TaskStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color_class: 'color_class',
    description: 'description'
  };

  export type TaskStatusScalarFieldEnum = (typeof TaskStatusScalarFieldEnum)[keyof typeof TaskStatusScalarFieldEnum]


  export const TaskDetailPowerInterruptionScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    feeder_id: 'feeder_id',
    weather_condition_id: 'weather_condition_id',
    device_id: 'device_id',
    affected_area: 'affected_area',
    cause: 'cause',
    equipment_failed: 'equipment_failed',
    fuse_rating: 'fuse_rating'
  };

  export type TaskDetailPowerInterruptionScalarFieldEnum = (typeof TaskDetailPowerInterruptionScalarFieldEnum)[keyof typeof TaskDetailPowerInterruptionScalarFieldEnum]


  export const PowerInterruptionLinemanScalarFieldEnum: {
    id: 'id',
    task_detail_id: 'task_detail_id',
    lineman_id: 'lineman_id'
  };

  export type PowerInterruptionLinemanScalarFieldEnum = (typeof PowerInterruptionLinemanScalarFieldEnum)[keyof typeof PowerInterruptionLinemanScalarFieldEnum]


  export const TaskDetailKwhMeterScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    meter_number: 'meter_number',
    meter_brand_id: 'meter_brand_id',
    last_reading: 'last_reading',
    initial_reading: 'initial_reading',
    meter_class: 'meter_class'
  };

  export type TaskDetailKwhMeterScalarFieldEnum = (typeof TaskDetailKwhMeterScalarFieldEnum)[keyof typeof TaskDetailKwhMeterScalarFieldEnum]


  export const KwhMeterLinemanScalarFieldEnum: {
    id: 'id',
    task_detail_id: 'task_detail_id',
    lineman_id: 'lineman_id'
  };

  export type KwhMeterLinemanScalarFieldEnum = (typeof KwhMeterLinemanScalarFieldEnum)[keyof typeof KwhMeterLinemanScalarFieldEnum]


  export const TaskDetailLineServicesScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    order_number: 'order_number',
    cause: 'cause',
    mrv_number: 'mrv_number',
    seriv_number: 'seriv_number',
    mst_number: 'mst_number',
    mcrt_number: 'mcrt_number'
  };

  export type TaskDetailLineServicesScalarFieldEnum = (typeof TaskDetailLineServicesScalarFieldEnum)[keyof typeof TaskDetailLineServicesScalarFieldEnum]


  export const LineServicesLinemanScalarFieldEnum: {
    id: 'id',
    task_detail_id: 'task_detail_id',
    lineman_id: 'lineman_id'
  };

  export type LineServicesLinemanScalarFieldEnum = (typeof LineServicesLinemanScalarFieldEnum)[keyof typeof LineServicesLinemanScalarFieldEnum]


  export const TaskDetailDlesScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    sco_number: 'sco_number',
    old_serial_number: 'old_serial_number',
    new_serial_number: 'new_serial_number',
    seriv_number: 'seriv_number',
    kva_rating: 'kva_rating',
    cause: 'cause'
  };

  export type TaskDetailDlesScalarFieldEnum = (typeof TaskDetailDlesScalarFieldEnum)[keyof typeof TaskDetailDlesScalarFieldEnum]


  export const DlesLinemanScalarFieldEnum: {
    id: 'id',
    task_detail_id: 'task_detail_id',
    lineman_id: 'lineman_id'
  };

  export type DlesLinemanScalarFieldEnum = (typeof DlesLinemanScalarFieldEnum)[keyof typeof DlesLinemanScalarFieldEnum]


  export const TaskDetailLmdgaScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    kva_rating: 'kva_rating',
    substation_id: 'substation_id',
    dt_location: 'dt_location',
    feeder_id: 'feeder_id',
    phase_number: 'phase_number',
    number_of_hc: 'number_of_hc',
    number_of_spans: 'number_of_spans',
    copper_aluminum_primary: 'copper_aluminum_primary',
    copper_aluminum_secondary: 'copper_aluminum_secondary',
    copper_aluminum_ground: 'copper_aluminum_ground',
    size_primary: 'size_primary',
    size_secondary: 'size_secondary',
    size_ground: 'size_ground',
    terminal_connector_primary: 'terminal_connector_primary',
    terminal_connector_secondary: 'terminal_connector_secondary',
    terminal_connector_ground: 'terminal_connector_ground',
    tap_position: 'tap_position',
    brand: 'brand',
    number_of_bushing_primary: 'number_of_bushing_primary',
    number_of_bushing_secondary: 'number_of_bushing_secondary',
    protective_device: 'protective_device',
    load_current_sec_bushing: 'load_current_sec_bushing',
    load_current_neutral: 'load_current_neutral',
    load_current_one: 'load_current_one',
    load_current_two: 'load_current_two',
    voltage_level_one: 'voltage_level_one',
    voltage_level_two: 'voltage_level_two',
    sec_line_conductor_size_one: 'sec_line_conductor_size_one',
    sec_line_conductor_size_two: 'sec_line_conductor_size_two'
  };

  export type TaskDetailLmdgaScalarFieldEnum = (typeof TaskDetailLmdgaScalarFieldEnum)[keyof typeof TaskDetailLmdgaScalarFieldEnum]


  export const LmdgaLinemanScalarFieldEnum: {
    id: 'id',
    task_detail_id: 'task_detail_id',
    lineman_id: 'lineman_id'
  };

  export type LmdgaLinemanScalarFieldEnum = (typeof LmdgaLinemanScalarFieldEnum)[keyof typeof LmdgaLinemanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'LinemanStatus'
   */
  export type EnumLinemanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LinemanStatus'>
    


  /**
   * Reference to a field of type 'LinemanStatus[]'
   */
  export type ListEnumLinemanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LinemanStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AuditWhereInput = {
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    id?: StringFilter<"Audit"> | string
    username?: StringFilter<"Audit"> | string
    table?: StringFilter<"Audit"> | string
    action?: StringFilter<"Audit"> | string
    reference_id?: StringNullableFilter<"Audit"> | string | null
    metadata?: JsonNullableFilter<"Audit">
    ip_address?: StringNullableFilter<"Audit"> | string | null
    device_info?: JsonNullableFilter<"Audit">
    created_at?: DateTimeFilter<"Audit"> | Date | string
    notes?: StringNullableFilter<"Audit"> | string | null
  }

  export type AuditOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    table?: SortOrder
    action?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    device_info?: SortOrderInput | SortOrder
    created_at?: SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type AuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    username?: StringFilter<"Audit"> | string
    table?: StringFilter<"Audit"> | string
    action?: StringFilter<"Audit"> | string
    reference_id?: StringNullableFilter<"Audit"> | string | null
    metadata?: JsonNullableFilter<"Audit">
    ip_address?: StringNullableFilter<"Audit"> | string | null
    device_info?: JsonNullableFilter<"Audit">
    created_at?: DateTimeFilter<"Audit"> | Date | string
    notes?: StringNullableFilter<"Audit"> | string | null
  }, "id">

  export type AuditOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    table?: SortOrder
    action?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    device_info?: SortOrderInput | SortOrder
    created_at?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AuditCountOrderByAggregateInput
    _max?: AuditMaxOrderByAggregateInput
    _min?: AuditMinOrderByAggregateInput
  }

  export type AuditScalarWhereWithAggregatesInput = {
    AND?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    OR?: AuditScalarWhereWithAggregatesInput[]
    NOT?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Audit"> | string
    username?: StringWithAggregatesFilter<"Audit"> | string
    table?: StringWithAggregatesFilter<"Audit"> | string
    action?: StringWithAggregatesFilter<"Audit"> | string
    reference_id?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Audit">
    ip_address?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    device_info?: JsonNullableWithAggregatesFilter<"Audit">
    created_at?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Audit"> | string | null
  }

  export type LinemanWhereInput = {
    AND?: LinemanWhereInput | LinemanWhereInput[]
    OR?: LinemanWhereInput[]
    NOT?: LinemanWhereInput | LinemanWhereInput[]
    id?: StringFilter<"Lineman"> | string
    employee_id?: StringFilter<"Lineman"> | string
    area_id?: StringFilter<"Lineman"> | string
    supervisor_id?: StringFilter<"Lineman"> | string
    status?: EnumLinemanStatusFilter<"Lineman"> | $Enums.LinemanStatus
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    power_interruptions?: PowerInterruptionLinemanListRelationFilter
    kwh_meters?: KwhMeterLinemanListRelationFilter
    line_services?: LineServicesLinemanListRelationFilter
    dles?: DlesLinemanListRelationFilter
    lmdgas?: LmdgaLinemanListRelationFilter
  }

  export type LinemanOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    area_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    area?: AreaOrderByWithRelationInput
    power_interruptions?: PowerInterruptionLinemanOrderByRelationAggregateInput
    kwh_meters?: KwhMeterLinemanOrderByRelationAggregateInput
    line_services?: LineServicesLinemanOrderByRelationAggregateInput
    dles?: DlesLinemanOrderByRelationAggregateInput
    lmdgas?: LmdgaLinemanOrderByRelationAggregateInput
  }

  export type LinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinemanWhereInput | LinemanWhereInput[]
    OR?: LinemanWhereInput[]
    NOT?: LinemanWhereInput | LinemanWhereInput[]
    employee_id?: StringFilter<"Lineman"> | string
    area_id?: StringFilter<"Lineman"> | string
    supervisor_id?: StringFilter<"Lineman"> | string
    status?: EnumLinemanStatusFilter<"Lineman"> | $Enums.LinemanStatus
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    power_interruptions?: PowerInterruptionLinemanListRelationFilter
    kwh_meters?: KwhMeterLinemanListRelationFilter
    line_services?: LineServicesLinemanListRelationFilter
    dles?: DlesLinemanListRelationFilter
    lmdgas?: LmdgaLinemanListRelationFilter
  }, "id">

  export type LinemanOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    area_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    _count?: LinemanCountOrderByAggregateInput
    _max?: LinemanMaxOrderByAggregateInput
    _min?: LinemanMinOrderByAggregateInput
  }

  export type LinemanScalarWhereWithAggregatesInput = {
    AND?: LinemanScalarWhereWithAggregatesInput | LinemanScalarWhereWithAggregatesInput[]
    OR?: LinemanScalarWhereWithAggregatesInput[]
    NOT?: LinemanScalarWhereWithAggregatesInput | LinemanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lineman"> | string
    employee_id?: StringWithAggregatesFilter<"Lineman"> | string
    area_id?: StringWithAggregatesFilter<"Lineman"> | string
    supervisor_id?: StringWithAggregatesFilter<"Lineman"> | string
    status?: EnumLinemanStatusWithAggregatesFilter<"Lineman"> | $Enums.LinemanStatus
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: StringFilter<"Area"> | string
    oic_id?: StringFilter<"Area"> | string
    name?: StringFilter<"Area"> | string
    linemen?: LinemanListRelationFilter
    municipalities?: MunicipalityListRelationFilter
    task_assignments?: TaskAssignmentListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    oic_id?: SortOrder
    name?: SortOrder
    linemen?: LinemanOrderByRelationAggregateInput
    municipalities?: MunicipalityOrderByRelationAggregateInput
    task_assignments?: TaskAssignmentOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    oic_id?: string
    name?: string
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    linemen?: LinemanListRelationFilter
    municipalities?: MunicipalityListRelationFilter
    task_assignments?: TaskAssignmentListRelationFilter
  }, "id" | "oic_id" | "name">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    oic_id?: SortOrder
    name?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Area"> | string
    oic_id?: StringWithAggregatesFilter<"Area"> | string
    name?: StringWithAggregatesFilter<"Area"> | string
  }

  export type MunicipalityWhereInput = {
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    id?: StringFilter<"Municipality"> | string
    area_id?: StringFilter<"Municipality"> | string
    name?: StringFilter<"Municipality"> | string
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    barangays?: BarangayListRelationFilter
  }

  export type MunicipalityOrderByWithRelationInput = {
    id?: SortOrder
    area_id?: SortOrder
    name?: SortOrder
    area?: AreaOrderByWithRelationInput
    barangays?: BarangayOrderByRelationAggregateInput
  }

  export type MunicipalityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    area_id?: StringFilter<"Municipality"> | string
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    barangays?: BarangayListRelationFilter
  }, "id" | "name">

  export type MunicipalityOrderByWithAggregationInput = {
    id?: SortOrder
    area_id?: SortOrder
    name?: SortOrder
    _count?: MunicipalityCountOrderByAggregateInput
    _max?: MunicipalityMaxOrderByAggregateInput
    _min?: MunicipalityMinOrderByAggregateInput
  }

  export type MunicipalityScalarWhereWithAggregatesInput = {
    AND?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    OR?: MunicipalityScalarWhereWithAggregatesInput[]
    NOT?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Municipality"> | string
    area_id?: StringWithAggregatesFilter<"Municipality"> | string
    name?: StringWithAggregatesFilter<"Municipality"> | string
  }

  export type BarangayWhereInput = {
    AND?: BarangayWhereInput | BarangayWhereInput[]
    OR?: BarangayWhereInput[]
    NOT?: BarangayWhereInput | BarangayWhereInput[]
    id?: StringFilter<"Barangay"> | string
    municipality_id?: StringFilter<"Barangay"> | string
    name?: StringFilter<"Barangay"> | string
    municipality?: XOR<MunicipalityScalarRelationFilter, MunicipalityWhereInput>
    sitios?: SitioListRelationFilter
    complaint_details?: ComplaintDetailListRelationFilter
  }

  export type BarangayOrderByWithRelationInput = {
    id?: SortOrder
    municipality_id?: SortOrder
    name?: SortOrder
    municipality?: MunicipalityOrderByWithRelationInput
    sitios?: SitioOrderByRelationAggregateInput
    complaint_details?: ComplaintDetailOrderByRelationAggregateInput
  }

  export type BarangayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BarangayWhereInput | BarangayWhereInput[]
    OR?: BarangayWhereInput[]
    NOT?: BarangayWhereInput | BarangayWhereInput[]
    municipality_id?: StringFilter<"Barangay"> | string
    municipality?: XOR<MunicipalityScalarRelationFilter, MunicipalityWhereInput>
    sitios?: SitioListRelationFilter
    complaint_details?: ComplaintDetailListRelationFilter
  }, "id" | "name">

  export type BarangayOrderByWithAggregationInput = {
    id?: SortOrder
    municipality_id?: SortOrder
    name?: SortOrder
    _count?: BarangayCountOrderByAggregateInput
    _max?: BarangayMaxOrderByAggregateInput
    _min?: BarangayMinOrderByAggregateInput
  }

  export type BarangayScalarWhereWithAggregatesInput = {
    AND?: BarangayScalarWhereWithAggregatesInput | BarangayScalarWhereWithAggregatesInput[]
    OR?: BarangayScalarWhereWithAggregatesInput[]
    NOT?: BarangayScalarWhereWithAggregatesInput | BarangayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Barangay"> | string
    municipality_id?: StringWithAggregatesFilter<"Barangay"> | string
    name?: StringWithAggregatesFilter<"Barangay"> | string
  }

  export type SitioWhereInput = {
    AND?: SitioWhereInput | SitioWhereInput[]
    OR?: SitioWhereInput[]
    NOT?: SitioWhereInput | SitioWhereInput[]
    id?: StringFilter<"Sitio"> | string
    barangay_id?: StringFilter<"Sitio"> | string
    name?: StringFilter<"Sitio"> | string
    barangay?: XOR<BarangayScalarRelationFilter, BarangayWhereInput>
    complaint_details?: ComplaintDetailListRelationFilter
  }

  export type SitioOrderByWithRelationInput = {
    id?: SortOrder
    barangay_id?: SortOrder
    name?: SortOrder
    barangay?: BarangayOrderByWithRelationInput
    complaint_details?: ComplaintDetailOrderByRelationAggregateInput
  }

  export type SitioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_barangay_id?: SitioNameBarangay_idCompoundUniqueInput
    AND?: SitioWhereInput | SitioWhereInput[]
    OR?: SitioWhereInput[]
    NOT?: SitioWhereInput | SitioWhereInput[]
    barangay_id?: StringFilter<"Sitio"> | string
    name?: StringFilter<"Sitio"> | string
    barangay?: XOR<BarangayScalarRelationFilter, BarangayWhereInput>
    complaint_details?: ComplaintDetailListRelationFilter
  }, "id" | "name_barangay_id">

  export type SitioOrderByWithAggregationInput = {
    id?: SortOrder
    barangay_id?: SortOrder
    name?: SortOrder
    _count?: SitioCountOrderByAggregateInput
    _max?: SitioMaxOrderByAggregateInput
    _min?: SitioMinOrderByAggregateInput
  }

  export type SitioScalarWhereWithAggregatesInput = {
    AND?: SitioScalarWhereWithAggregatesInput | SitioScalarWhereWithAggregatesInput[]
    OR?: SitioScalarWhereWithAggregatesInput[]
    NOT?: SitioScalarWhereWithAggregatesInput | SitioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sitio"> | string
    barangay_id?: StringWithAggregatesFilter<"Sitio"> | string
    name?: StringWithAggregatesFilter<"Sitio"> | string
  }

  export type FeederWhereInput = {
    AND?: FeederWhereInput | FeederWhereInput[]
    OR?: FeederWhereInput[]
    NOT?: FeederWhereInput | FeederWhereInput[]
    id?: StringFilter<"Feeder"> | string
    name?: StringFilter<"Feeder"> | string
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
    lmdga_tasks?: TaskDetailLmdgaListRelationFilter
  }

  export type FeederOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    power_interruption_tasks?: TaskDetailPowerInterruptionOrderByRelationAggregateInput
    lmdga_tasks?: TaskDetailLmdgaOrderByRelationAggregateInput
  }

  export type FeederWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FeederWhereInput | FeederWhereInput[]
    OR?: FeederWhereInput[]
    NOT?: FeederWhereInput | FeederWhereInput[]
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
    lmdga_tasks?: TaskDetailLmdgaListRelationFilter
  }, "id" | "name">

  export type FeederOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FeederCountOrderByAggregateInput
    _max?: FeederMaxOrderByAggregateInput
    _min?: FeederMinOrderByAggregateInput
  }

  export type FeederScalarWhereWithAggregatesInput = {
    AND?: FeederScalarWhereWithAggregatesInput | FeederScalarWhereWithAggregatesInput[]
    OR?: FeederScalarWhereWithAggregatesInput[]
    NOT?: FeederScalarWhereWithAggregatesInput | FeederScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feeder"> | string
    name?: StringWithAggregatesFilter<"Feeder"> | string
  }

  export type WeatherConditionWhereInput = {
    AND?: WeatherConditionWhereInput | WeatherConditionWhereInput[]
    OR?: WeatherConditionWhereInput[]
    NOT?: WeatherConditionWhereInput | WeatherConditionWhereInput[]
    id?: StringFilter<"WeatherCondition"> | string
    name?: StringFilter<"WeatherCondition"> | string
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
  }

  export type WeatherConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    power_interruption_tasks?: TaskDetailPowerInterruptionOrderByRelationAggregateInput
  }

  export type WeatherConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WeatherConditionWhereInput | WeatherConditionWhereInput[]
    OR?: WeatherConditionWhereInput[]
    NOT?: WeatherConditionWhereInput | WeatherConditionWhereInput[]
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
  }, "id" | "name">

  export type WeatherConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WeatherConditionCountOrderByAggregateInput
    _max?: WeatherConditionMaxOrderByAggregateInput
    _min?: WeatherConditionMinOrderByAggregateInput
  }

  export type WeatherConditionScalarWhereWithAggregatesInput = {
    AND?: WeatherConditionScalarWhereWithAggregatesInput | WeatherConditionScalarWhereWithAggregatesInput[]
    OR?: WeatherConditionScalarWhereWithAggregatesInput[]
    NOT?: WeatherConditionScalarWhereWithAggregatesInput | WeatherConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeatherCondition"> | string
    name?: StringWithAggregatesFilter<"WeatherCondition"> | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    name?: StringFilter<"Device"> | string
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    power_interruption_tasks?: TaskDetailPowerInterruptionOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    power_interruption_tasks?: TaskDetailPowerInterruptionListRelationFilter
  }, "id" | "name">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    name?: StringWithAggregatesFilter<"Device"> | string
  }

  export type MeterBrandWhereInput = {
    AND?: MeterBrandWhereInput | MeterBrandWhereInput[]
    OR?: MeterBrandWhereInput[]
    NOT?: MeterBrandWhereInput | MeterBrandWhereInput[]
    id?: StringFilter<"MeterBrand"> | string
    name?: StringFilter<"MeterBrand"> | string
    kwh_meter_tasks?: TaskDetailKwhMeterListRelationFilter
  }

  export type MeterBrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    kwh_meter_tasks?: TaskDetailKwhMeterOrderByRelationAggregateInput
  }

  export type MeterBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MeterBrandWhereInput | MeterBrandWhereInput[]
    OR?: MeterBrandWhereInput[]
    NOT?: MeterBrandWhereInput | MeterBrandWhereInput[]
    kwh_meter_tasks?: TaskDetailKwhMeterListRelationFilter
  }, "id" | "name">

  export type MeterBrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MeterBrandCountOrderByAggregateInput
    _max?: MeterBrandMaxOrderByAggregateInput
    _min?: MeterBrandMinOrderByAggregateInput
  }

  export type MeterBrandScalarWhereWithAggregatesInput = {
    AND?: MeterBrandScalarWhereWithAggregatesInput | MeterBrandScalarWhereWithAggregatesInput[]
    OR?: MeterBrandScalarWhereWithAggregatesInput[]
    NOT?: MeterBrandScalarWhereWithAggregatesInput | MeterBrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeterBrand"> | string
    name?: StringWithAggregatesFilter<"MeterBrand"> | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    category_id?: IntFilter<"Activity"> | number
    name?: StringFilter<"Activity"> | string
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
    category?: XOR<ActivityCategoryNullableScalarRelationFilter, ActivityCategoryWhereInput> | null
    tasks?: TaskListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category?: ActivityCategoryOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    category_id?: IntFilter<"Activity"> | number
    name?: StringFilter<"Activity"> | string
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
    category?: XOR<ActivityCategoryNullableScalarRelationFilter, ActivityCategoryWhereInput> | null
    tasks?: TaskListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    category_id?: IntWithAggregatesFilter<"Activity"> | number
    name?: StringWithAggregatesFilter<"Activity"> | string
    created_at?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type ActivityCategoryWhereInput = {
    AND?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    OR?: ActivityCategoryWhereInput[]
    NOT?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    id?: IntFilter<"ActivityCategory"> | number
    name?: StringFilter<"ActivityCategory"> | string
    activities?: ActivityListRelationFilter
  }

  export type ActivityCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type ActivityCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    OR?: ActivityCategoryWhereInput[]
    NOT?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    name?: StringFilter<"ActivityCategory"> | string
    activities?: ActivityListRelationFilter
  }, "id">

  export type ActivityCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ActivityCategoryCountOrderByAggregateInput
    _avg?: ActivityCategoryAvgOrderByAggregateInput
    _max?: ActivityCategoryMaxOrderByAggregateInput
    _min?: ActivityCategoryMinOrderByAggregateInput
    _sum?: ActivityCategorySumOrderByAggregateInput
  }

  export type ActivityCategoryScalarWhereWithAggregatesInput = {
    AND?: ActivityCategoryScalarWhereWithAggregatesInput | ActivityCategoryScalarWhereWithAggregatesInput[]
    OR?: ActivityCategoryScalarWhereWithAggregatesInput[]
    NOT?: ActivityCategoryScalarWhereWithAggregatesInput | ActivityCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityCategory"> | number
    name?: StringWithAggregatesFilter<"ActivityCategory"> | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    report_type_id?: IntFilter<"Complaint"> | number
    complaint_status_id?: IntFilter<"Complaint"> | number
    assigned_group_id?: StringFilter<"Complaint"> | string
    assigned_group_type?: IntFilter<"Complaint"> | number
    ref_number?: StringFilter<"Complaint"> | string
    complainant_name?: StringFilter<"Complaint"> | string
    complainant_contact_no?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    remarks?: StringNullableFilter<"Complaint"> | string | null
    created_by?: StringFilter<"Complaint"> | string
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    complaint_detail?: XOR<ComplaintDetailNullableScalarRelationFilter, ComplaintDetailWhereInput> | null
    logs?: ComplaintLogListRelationFilter
    tasks?: TaskListRelationFilter
    report_type?: XOR<ComplaintReportTypeScalarRelationFilter, ComplaintReportTypeWhereInput>
    status?: XOR<ComplaintStatusScalarRelationFilter, ComplaintStatusWhereInput>
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_id?: SortOrder
    assigned_group_type?: SortOrder
    ref_number?: SortOrder
    complainant_name?: SortOrder
    complainant_contact_no?: SortOrder
    description?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    complaint_detail?: ComplaintDetailOrderByWithRelationInput
    logs?: ComplaintLogOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    report_type?: ComplaintReportTypeOrderByWithRelationInput
    status?: ComplaintStatusOrderByWithRelationInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ref_number?: string
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    report_type_id?: IntFilter<"Complaint"> | number
    complaint_status_id?: IntFilter<"Complaint"> | number
    assigned_group_id?: StringFilter<"Complaint"> | string
    assigned_group_type?: IntFilter<"Complaint"> | number
    complainant_name?: StringFilter<"Complaint"> | string
    complainant_contact_no?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    remarks?: StringNullableFilter<"Complaint"> | string | null
    created_by?: StringFilter<"Complaint"> | string
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    complaint_detail?: XOR<ComplaintDetailNullableScalarRelationFilter, ComplaintDetailWhereInput> | null
    logs?: ComplaintLogListRelationFilter
    tasks?: TaskListRelationFilter
    report_type?: XOR<ComplaintReportTypeScalarRelationFilter, ComplaintReportTypeWhereInput>
    status?: XOR<ComplaintStatusScalarRelationFilter, ComplaintStatusWhereInput>
  }, "id" | "ref_number">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_id?: SortOrder
    assigned_group_type?: SortOrder
    ref_number?: SortOrder
    complainant_name?: SortOrder
    complainant_contact_no?: SortOrder
    description?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    report_type_id?: IntWithAggregatesFilter<"Complaint"> | number
    complaint_status_id?: IntWithAggregatesFilter<"Complaint"> | number
    assigned_group_id?: StringWithAggregatesFilter<"Complaint"> | string
    assigned_group_type?: IntWithAggregatesFilter<"Complaint"> | number
    ref_number?: StringWithAggregatesFilter<"Complaint"> | string
    complainant_name?: StringWithAggregatesFilter<"Complaint"> | string
    complainant_contact_no?: StringWithAggregatesFilter<"Complaint"> | string
    description?: StringWithAggregatesFilter<"Complaint"> | string
    remarks?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    created_by?: StringWithAggregatesFilter<"Complaint"> | string
    created_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type ComplaintDetailWhereInput = {
    AND?: ComplaintDetailWhereInput | ComplaintDetailWhereInput[]
    OR?: ComplaintDetailWhereInput[]
    NOT?: ComplaintDetailWhereInput | ComplaintDetailWhereInput[]
    id?: IntFilter<"ComplaintDetail"> | number
    complaint_id?: IntFilter<"ComplaintDetail"> | number
    consumer_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    barangay_id?: StringFilter<"ComplaintDetail"> | string
    sitio_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    landmark?: StringNullableFilter<"ComplaintDetail"> | string | null
    created_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
    updated_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    barangay?: XOR<BarangayScalarRelationFilter, BarangayWhereInput>
    sitio?: XOR<SitioNullableScalarRelationFilter, SitioWhereInput> | null
  }

  export type ComplaintDetailOrderByWithRelationInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    consumer_id?: SortOrderInput | SortOrder
    barangay_id?: SortOrder
    sitio_id?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    complaint?: ComplaintOrderByWithRelationInput
    barangay?: BarangayOrderByWithRelationInput
    sitio?: SitioOrderByWithRelationInput
  }

  export type ComplaintDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    complaint_id?: number
    AND?: ComplaintDetailWhereInput | ComplaintDetailWhereInput[]
    OR?: ComplaintDetailWhereInput[]
    NOT?: ComplaintDetailWhereInput | ComplaintDetailWhereInput[]
    consumer_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    barangay_id?: StringFilter<"ComplaintDetail"> | string
    sitio_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    landmark?: StringNullableFilter<"ComplaintDetail"> | string | null
    created_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
    updated_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    barangay?: XOR<BarangayScalarRelationFilter, BarangayWhereInput>
    sitio?: XOR<SitioNullableScalarRelationFilter, SitioWhereInput> | null
  }, "id" | "complaint_id">

  export type ComplaintDetailOrderByWithAggregationInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    consumer_id?: SortOrderInput | SortOrder
    barangay_id?: SortOrder
    sitio_id?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ComplaintDetailCountOrderByAggregateInput
    _avg?: ComplaintDetailAvgOrderByAggregateInput
    _max?: ComplaintDetailMaxOrderByAggregateInput
    _min?: ComplaintDetailMinOrderByAggregateInput
    _sum?: ComplaintDetailSumOrderByAggregateInput
  }

  export type ComplaintDetailScalarWhereWithAggregatesInput = {
    AND?: ComplaintDetailScalarWhereWithAggregatesInput | ComplaintDetailScalarWhereWithAggregatesInput[]
    OR?: ComplaintDetailScalarWhereWithAggregatesInput[]
    NOT?: ComplaintDetailScalarWhereWithAggregatesInput | ComplaintDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintDetail"> | number
    complaint_id?: IntWithAggregatesFilter<"ComplaintDetail"> | number
    consumer_id?: StringNullableWithAggregatesFilter<"ComplaintDetail"> | string | null
    barangay_id?: StringWithAggregatesFilter<"ComplaintDetail"> | string
    sitio_id?: StringNullableWithAggregatesFilter<"ComplaintDetail"> | string | null
    landmark?: StringNullableWithAggregatesFilter<"ComplaintDetail"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ComplaintDetail"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ComplaintDetail"> | Date | string
  }

  export type ComplaintStatusWhereInput = {
    AND?: ComplaintStatusWhereInput | ComplaintStatusWhereInput[]
    OR?: ComplaintStatusWhereInput[]
    NOT?: ComplaintStatusWhereInput | ComplaintStatusWhereInput[]
    id?: IntFilter<"ComplaintStatus"> | number
    name?: StringFilter<"ComplaintStatus"> | string
    color_class?: StringFilter<"ComplaintStatus"> | string
    description?: StringFilter<"ComplaintStatus"> | string
    complaints?: ComplaintListRelationFilter
    logs?: ComplaintLogListRelationFilter
  }

  export type ComplaintStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
    complaints?: ComplaintOrderByRelationAggregateInput
    logs?: ComplaintLogOrderByRelationAggregateInput
  }

  export type ComplaintStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ComplaintStatusWhereInput | ComplaintStatusWhereInput[]
    OR?: ComplaintStatusWhereInput[]
    NOT?: ComplaintStatusWhereInput | ComplaintStatusWhereInput[]
    color_class?: StringFilter<"ComplaintStatus"> | string
    description?: StringFilter<"ComplaintStatus"> | string
    complaints?: ComplaintListRelationFilter
    logs?: ComplaintLogListRelationFilter
  }, "id" | "name">

  export type ComplaintStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
    _count?: ComplaintStatusCountOrderByAggregateInput
    _avg?: ComplaintStatusAvgOrderByAggregateInput
    _max?: ComplaintStatusMaxOrderByAggregateInput
    _min?: ComplaintStatusMinOrderByAggregateInput
    _sum?: ComplaintStatusSumOrderByAggregateInput
  }

  export type ComplaintStatusScalarWhereWithAggregatesInput = {
    AND?: ComplaintStatusScalarWhereWithAggregatesInput | ComplaintStatusScalarWhereWithAggregatesInput[]
    OR?: ComplaintStatusScalarWhereWithAggregatesInput[]
    NOT?: ComplaintStatusScalarWhereWithAggregatesInput | ComplaintStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintStatus"> | number
    name?: StringWithAggregatesFilter<"ComplaintStatus"> | string
    color_class?: StringWithAggregatesFilter<"ComplaintStatus"> | string
    description?: StringWithAggregatesFilter<"ComplaintStatus"> | string
  }

  export type ComplaintReportTypeWhereInput = {
    AND?: ComplaintReportTypeWhereInput | ComplaintReportTypeWhereInput[]
    OR?: ComplaintReportTypeWhereInput[]
    NOT?: ComplaintReportTypeWhereInput | ComplaintReportTypeWhereInput[]
    id?: IntFilter<"ComplaintReportType"> | number
    name?: StringFilter<"ComplaintReportType"> | string
    complaints?: ComplaintListRelationFilter
  }

  export type ComplaintReportTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    complaints?: ComplaintOrderByRelationAggregateInput
  }

  export type ComplaintReportTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ComplaintReportTypeWhereInput | ComplaintReportTypeWhereInput[]
    OR?: ComplaintReportTypeWhereInput[]
    NOT?: ComplaintReportTypeWhereInput | ComplaintReportTypeWhereInput[]
    complaints?: ComplaintListRelationFilter
  }, "id" | "name">

  export type ComplaintReportTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ComplaintReportTypeCountOrderByAggregateInput
    _avg?: ComplaintReportTypeAvgOrderByAggregateInput
    _max?: ComplaintReportTypeMaxOrderByAggregateInput
    _min?: ComplaintReportTypeMinOrderByAggregateInput
    _sum?: ComplaintReportTypeSumOrderByAggregateInput
  }

  export type ComplaintReportTypeScalarWhereWithAggregatesInput = {
    AND?: ComplaintReportTypeScalarWhereWithAggregatesInput | ComplaintReportTypeScalarWhereWithAggregatesInput[]
    OR?: ComplaintReportTypeScalarWhereWithAggregatesInput[]
    NOT?: ComplaintReportTypeScalarWhereWithAggregatesInput | ComplaintReportTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintReportType"> | number
    name?: StringWithAggregatesFilter<"ComplaintReportType"> | string
  }

  export type ComplaintLogWhereInput = {
    AND?: ComplaintLogWhereInput | ComplaintLogWhereInput[]
    OR?: ComplaintLogWhereInput[]
    NOT?: ComplaintLogWhereInput | ComplaintLogWhereInput[]
    id?: IntFilter<"ComplaintLog"> | number
    complaint_id?: IntFilter<"ComplaintLog"> | number
    complaint_status_id?: IntFilter<"ComplaintLog"> | number
    remarks?: StringNullableFilter<"ComplaintLog"> | string | null
    created_by?: StringFilter<"ComplaintLog"> | string
    created_at?: DateTimeFilter<"ComplaintLog"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    status?: XOR<ComplaintStatusScalarRelationFilter, ComplaintStatusWhereInput>
  }

  export type ComplaintLogOrderByWithRelationInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    complaint?: ComplaintOrderByWithRelationInput
    status?: ComplaintStatusOrderByWithRelationInput
  }

  export type ComplaintLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintLogWhereInput | ComplaintLogWhereInput[]
    OR?: ComplaintLogWhereInput[]
    NOT?: ComplaintLogWhereInput | ComplaintLogWhereInput[]
    complaint_id?: IntFilter<"ComplaintLog"> | number
    complaint_status_id?: IntFilter<"ComplaintLog"> | number
    remarks?: StringNullableFilter<"ComplaintLog"> | string | null
    created_by?: StringFilter<"ComplaintLog"> | string
    created_at?: DateTimeFilter<"ComplaintLog"> | Date | string
    complaint?: XOR<ComplaintScalarRelationFilter, ComplaintWhereInput>
    status?: XOR<ComplaintStatusScalarRelationFilter, ComplaintStatusWhereInput>
  }, "id">

  export type ComplaintLogOrderByWithAggregationInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ComplaintLogCountOrderByAggregateInput
    _avg?: ComplaintLogAvgOrderByAggregateInput
    _max?: ComplaintLogMaxOrderByAggregateInput
    _min?: ComplaintLogMinOrderByAggregateInput
    _sum?: ComplaintLogSumOrderByAggregateInput
  }

  export type ComplaintLogScalarWhereWithAggregatesInput = {
    AND?: ComplaintLogScalarWhereWithAggregatesInput | ComplaintLogScalarWhereWithAggregatesInput[]
    OR?: ComplaintLogScalarWhereWithAggregatesInput[]
    NOT?: ComplaintLogScalarWhereWithAggregatesInput | ComplaintLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplaintLog"> | number
    complaint_id?: IntWithAggregatesFilter<"ComplaintLog"> | number
    complaint_status_id?: IntWithAggregatesFilter<"ComplaintLog"> | number
    remarks?: StringNullableWithAggregatesFilter<"ComplaintLog"> | string | null
    created_by?: StringWithAggregatesFilter<"ComplaintLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"ComplaintLog"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    ref_number?: StringFilter<"Task"> | string
    complaint_id?: IntNullableFilter<"Task"> | number | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    task_status_id?: IntFilter<"Task"> | number
    activity_id?: StringNullableFilter<"Task"> | string | null
    description?: StringFilter<"Task"> | string
    remarks?: StringFilter<"Task"> | string
    accomplishment?: StringFilter<"Task"> | string
    action_taken?: StringFilter<"Task"> | string
    acted_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    created_by?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    task_assignment?: XOR<TaskAssignmentNullableScalarRelationFilter, TaskAssignmentWhereInput> | null
    logs?: TaskLogListRelationFilter
    files?: TaskFileListRelationFilter
    complaint?: XOR<ComplaintNullableScalarRelationFilter, ComplaintWhereInput> | null
    status?: XOR<TaskStatusScalarRelationFilter, TaskStatusWhereInput>
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    task_detail_power_interruption?: XOR<TaskDetailPowerInterruptionNullableScalarRelationFilter, TaskDetailPowerInterruptionWhereInput> | null
    task_detail_kwh_meter?: XOR<TaskDetailKwhMeterNullableScalarRelationFilter, TaskDetailKwhMeterWhereInput> | null
    task_detail_line_services?: XOR<TaskDetailLineServicesNullableScalarRelationFilter, TaskDetailLineServicesWhereInput> | null
    task_detail_dles?: XOR<TaskDetailDlesNullableScalarRelationFilter, TaskDetailDlesWhereInput> | null
    task_detail_lmdga?: XOR<TaskDetailLmdgaNullableScalarRelationFilter, TaskDetailLmdgaWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    ref_number?: SortOrder
    complaint_id?: SortOrderInput | SortOrder
    assignee_id?: SortOrderInput | SortOrder
    task_status_id?: SortOrder
    activity_id?: SortOrderInput | SortOrder
    description?: SortOrder
    remarks?: SortOrder
    accomplishment?: SortOrder
    action_taken?: SortOrder
    acted_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    task_assignment?: TaskAssignmentOrderByWithRelationInput
    logs?: TaskLogOrderByRelationAggregateInput
    files?: TaskFileOrderByRelationAggregateInput
    complaint?: ComplaintOrderByWithRelationInput
    status?: TaskStatusOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionOrderByWithRelationInput
    task_detail_kwh_meter?: TaskDetailKwhMeterOrderByWithRelationInput
    task_detail_line_services?: TaskDetailLineServicesOrderByWithRelationInput
    task_detail_dles?: TaskDetailDlesOrderByWithRelationInput
    task_detail_lmdga?: TaskDetailLmdgaOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ref_number?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    complaint_id?: IntNullableFilter<"Task"> | number | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    task_status_id?: IntFilter<"Task"> | number
    activity_id?: StringNullableFilter<"Task"> | string | null
    description?: StringFilter<"Task"> | string
    remarks?: StringFilter<"Task"> | string
    accomplishment?: StringFilter<"Task"> | string
    action_taken?: StringFilter<"Task"> | string
    acted_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    created_by?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    task_assignment?: XOR<TaskAssignmentNullableScalarRelationFilter, TaskAssignmentWhereInput> | null
    logs?: TaskLogListRelationFilter
    files?: TaskFileListRelationFilter
    complaint?: XOR<ComplaintNullableScalarRelationFilter, ComplaintWhereInput> | null
    status?: XOR<TaskStatusScalarRelationFilter, TaskStatusWhereInput>
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    task_detail_power_interruption?: XOR<TaskDetailPowerInterruptionNullableScalarRelationFilter, TaskDetailPowerInterruptionWhereInput> | null
    task_detail_kwh_meter?: XOR<TaskDetailKwhMeterNullableScalarRelationFilter, TaskDetailKwhMeterWhereInput> | null
    task_detail_line_services?: XOR<TaskDetailLineServicesNullableScalarRelationFilter, TaskDetailLineServicesWhereInput> | null
    task_detail_dles?: XOR<TaskDetailDlesNullableScalarRelationFilter, TaskDetailDlesWhereInput> | null
    task_detail_lmdga?: XOR<TaskDetailLmdgaNullableScalarRelationFilter, TaskDetailLmdgaWhereInput> | null
  }, "id" | "ref_number">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    ref_number?: SortOrder
    complaint_id?: SortOrderInput | SortOrder
    assignee_id?: SortOrderInput | SortOrder
    task_status_id?: SortOrder
    activity_id?: SortOrderInput | SortOrder
    description?: SortOrder
    remarks?: SortOrder
    accomplishment?: SortOrder
    action_taken?: SortOrder
    acted_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    ref_number?: StringWithAggregatesFilter<"Task"> | string
    complaint_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    assignee_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    task_status_id?: IntWithAggregatesFilter<"Task"> | number
    activity_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    description?: StringWithAggregatesFilter<"Task"> | string
    remarks?: StringWithAggregatesFilter<"Task"> | string
    accomplishment?: StringWithAggregatesFilter<"Task"> | string
    action_taken?: StringWithAggregatesFilter<"Task"> | string
    acted_at?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    created_by?: StringWithAggregatesFilter<"Task"> | string
    created_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskAssignmentWhereInput = {
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    id?: IntFilter<"TaskAssignment"> | number
    task_id?: IntFilter<"TaskAssignment"> | number
    area_id?: StringNullableFilter<"TaskAssignment"> | string | null
    department_id?: StringNullableFilter<"TaskAssignment"> | string | null
    division_id?: StringNullableFilter<"TaskAssignment"> | string | null
    created_by?: StringFilter<"TaskAssignment"> | string
    created_at?: DateTimeFilter<"TaskAssignment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    area?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
  }

  export type TaskAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    area_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    division_id?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    task?: TaskOrderByWithRelationInput
    area?: AreaOrderByWithRelationInput
  }

  export type TaskAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    area_id?: StringNullableFilter<"TaskAssignment"> | string | null
    department_id?: StringNullableFilter<"TaskAssignment"> | string | null
    division_id?: StringNullableFilter<"TaskAssignment"> | string | null
    created_by?: StringFilter<"TaskAssignment"> | string
    created_at?: DateTimeFilter<"TaskAssignment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    area?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
  }, "id" | "task_id">

  export type TaskAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    area_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    division_id?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: TaskAssignmentCountOrderByAggregateInput
    _avg?: TaskAssignmentAvgOrderByAggregateInput
    _max?: TaskAssignmentMaxOrderByAggregateInput
    _min?: TaskAssignmentMinOrderByAggregateInput
    _sum?: TaskAssignmentSumOrderByAggregateInput
  }

  export type TaskAssignmentScalarWhereWithAggregatesInput = {
    AND?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    OR?: TaskAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskAssignment"> | number
    task_id?: IntWithAggregatesFilter<"TaskAssignment"> | number
    area_id?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    department_id?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    division_id?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    created_by?: StringWithAggregatesFilter<"TaskAssignment"> | string
    created_at?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
  }

  export type TaskLogWhereInput = {
    AND?: TaskLogWhereInput | TaskLogWhereInput[]
    OR?: TaskLogWhereInput[]
    NOT?: TaskLogWhereInput | TaskLogWhereInput[]
    id?: IntFilter<"TaskLog"> | number
    task_id?: IntFilter<"TaskLog"> | number
    task_status_id?: IntFilter<"TaskLog"> | number
    remarks?: StringNullableFilter<"TaskLog"> | string | null
    created_by?: StringFilter<"TaskLog"> | string
    created_at?: DateTimeFilter<"TaskLog"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    status?: XOR<TaskStatusScalarRelationFilter, TaskStatusWhereInput>
  }

  export type TaskLogOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    task?: TaskOrderByWithRelationInput
    status?: TaskStatusOrderByWithRelationInput
  }

  export type TaskLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskLogWhereInput | TaskLogWhereInput[]
    OR?: TaskLogWhereInput[]
    NOT?: TaskLogWhereInput | TaskLogWhereInput[]
    task_id?: IntFilter<"TaskLog"> | number
    task_status_id?: IntFilter<"TaskLog"> | number
    remarks?: StringNullableFilter<"TaskLog"> | string | null
    created_by?: StringFilter<"TaskLog"> | string
    created_at?: DateTimeFilter<"TaskLog"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    status?: XOR<TaskStatusScalarRelationFilter, TaskStatusWhereInput>
  }, "id">

  export type TaskLogOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: TaskLogCountOrderByAggregateInput
    _avg?: TaskLogAvgOrderByAggregateInput
    _max?: TaskLogMaxOrderByAggregateInput
    _min?: TaskLogMinOrderByAggregateInput
    _sum?: TaskLogSumOrderByAggregateInput
  }

  export type TaskLogScalarWhereWithAggregatesInput = {
    AND?: TaskLogScalarWhereWithAggregatesInput | TaskLogScalarWhereWithAggregatesInput[]
    OR?: TaskLogScalarWhereWithAggregatesInput[]
    NOT?: TaskLogScalarWhereWithAggregatesInput | TaskLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskLog"> | number
    task_id?: IntWithAggregatesFilter<"TaskLog"> | number
    task_status_id?: IntWithAggregatesFilter<"TaskLog"> | number
    remarks?: StringNullableWithAggregatesFilter<"TaskLog"> | string | null
    created_by?: StringWithAggregatesFilter<"TaskLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"TaskLog"> | Date | string
  }

  export type TaskFileWhereInput = {
    AND?: TaskFileWhereInput | TaskFileWhereInput[]
    OR?: TaskFileWhereInput[]
    NOT?: TaskFileWhereInput | TaskFileWhereInput[]
    id?: IntFilter<"TaskFile"> | number
    task_id?: IntFilter<"TaskFile"> | number
    filename?: StringFilter<"TaskFile"> | string
    source_path?: StringFilter<"TaskFile"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskFileOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    filename?: SortOrder
    source_path?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskFileWhereInput | TaskFileWhereInput[]
    OR?: TaskFileWhereInput[]
    NOT?: TaskFileWhereInput | TaskFileWhereInput[]
    task_id?: IntFilter<"TaskFile"> | number
    filename?: StringFilter<"TaskFile"> | string
    source_path?: StringFilter<"TaskFile"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskFileOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    filename?: SortOrder
    source_path?: SortOrder
    _count?: TaskFileCountOrderByAggregateInput
    _avg?: TaskFileAvgOrderByAggregateInput
    _max?: TaskFileMaxOrderByAggregateInput
    _min?: TaskFileMinOrderByAggregateInput
    _sum?: TaskFileSumOrderByAggregateInput
  }

  export type TaskFileScalarWhereWithAggregatesInput = {
    AND?: TaskFileScalarWhereWithAggregatesInput | TaskFileScalarWhereWithAggregatesInput[]
    OR?: TaskFileScalarWhereWithAggregatesInput[]
    NOT?: TaskFileScalarWhereWithAggregatesInput | TaskFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskFile"> | number
    task_id?: IntWithAggregatesFilter<"TaskFile"> | number
    filename?: StringWithAggregatesFilter<"TaskFile"> | string
    source_path?: StringWithAggregatesFilter<"TaskFile"> | string
  }

  export type TaskStatusWhereInput = {
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    id?: IntFilter<"TaskStatus"> | number
    name?: StringFilter<"TaskStatus"> | string
    color_class?: StringFilter<"TaskStatus"> | string
    description?: StringFilter<"TaskStatus"> | string
    tasks?: TaskListRelationFilter
    logs?: TaskLogListRelationFilter
  }

  export type TaskStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
    logs?: TaskLogOrderByRelationAggregateInput
  }

  export type TaskStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    color_class?: StringFilter<"TaskStatus"> | string
    description?: StringFilter<"TaskStatus"> | string
    tasks?: TaskListRelationFilter
    logs?: TaskLogListRelationFilter
  }, "id" | "name">

  export type TaskStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
    _count?: TaskStatusCountOrderByAggregateInput
    _avg?: TaskStatusAvgOrderByAggregateInput
    _max?: TaskStatusMaxOrderByAggregateInput
    _min?: TaskStatusMinOrderByAggregateInput
    _sum?: TaskStatusSumOrderByAggregateInput
  }

  export type TaskStatusScalarWhereWithAggregatesInput = {
    AND?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    OR?: TaskStatusScalarWhereWithAggregatesInput[]
    NOT?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskStatus"> | number
    name?: StringWithAggregatesFilter<"TaskStatus"> | string
    color_class?: StringWithAggregatesFilter<"TaskStatus"> | string
    description?: StringWithAggregatesFilter<"TaskStatus"> | string
  }

  export type TaskDetailPowerInterruptionWhereInput = {
    AND?: TaskDetailPowerInterruptionWhereInput | TaskDetailPowerInterruptionWhereInput[]
    OR?: TaskDetailPowerInterruptionWhereInput[]
    NOT?: TaskDetailPowerInterruptionWhereInput | TaskDetailPowerInterruptionWhereInput[]
    id?: IntFilter<"TaskDetailPowerInterruption"> | number
    task_id?: IntFilter<"TaskDetailPowerInterruption"> | number
    feeder_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    weather_condition_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    device_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    affected_area?: StringFilter<"TaskDetailPowerInterruption"> | string
    cause?: StringFilter<"TaskDetailPowerInterruption"> | string
    equipment_failed?: StringFilter<"TaskDetailPowerInterruption"> | string
    fuse_rating?: StringFilter<"TaskDetailPowerInterruption"> | string
    linemen_incharge?: PowerInterruptionLinemanListRelationFilter
    feeder?: XOR<FeederScalarRelationFilter, FeederWhereInput>
    weather_condition?: XOR<WeatherConditionScalarRelationFilter, WeatherConditionWhereInput>
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskDetailPowerInterruptionOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    feeder_id?: SortOrder
    weather_condition_id?: SortOrder
    device_id?: SortOrder
    affected_area?: SortOrder
    cause?: SortOrder
    equipment_failed?: SortOrder
    fuse_rating?: SortOrder
    linemen_incharge?: PowerInterruptionLinemanOrderByRelationAggregateInput
    feeder?: FeederOrderByWithRelationInput
    weather_condition?: WeatherConditionOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskDetailPowerInterruptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskDetailPowerInterruptionWhereInput | TaskDetailPowerInterruptionWhereInput[]
    OR?: TaskDetailPowerInterruptionWhereInput[]
    NOT?: TaskDetailPowerInterruptionWhereInput | TaskDetailPowerInterruptionWhereInput[]
    feeder_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    weather_condition_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    device_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    affected_area?: StringFilter<"TaskDetailPowerInterruption"> | string
    cause?: StringFilter<"TaskDetailPowerInterruption"> | string
    equipment_failed?: StringFilter<"TaskDetailPowerInterruption"> | string
    fuse_rating?: StringFilter<"TaskDetailPowerInterruption"> | string
    linemen_incharge?: PowerInterruptionLinemanListRelationFilter
    feeder?: XOR<FeederScalarRelationFilter, FeederWhereInput>
    weather_condition?: XOR<WeatherConditionScalarRelationFilter, WeatherConditionWhereInput>
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "task_id">

  export type TaskDetailPowerInterruptionOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    feeder_id?: SortOrder
    weather_condition_id?: SortOrder
    device_id?: SortOrder
    affected_area?: SortOrder
    cause?: SortOrder
    equipment_failed?: SortOrder
    fuse_rating?: SortOrder
    _count?: TaskDetailPowerInterruptionCountOrderByAggregateInput
    _avg?: TaskDetailPowerInterruptionAvgOrderByAggregateInput
    _max?: TaskDetailPowerInterruptionMaxOrderByAggregateInput
    _min?: TaskDetailPowerInterruptionMinOrderByAggregateInput
    _sum?: TaskDetailPowerInterruptionSumOrderByAggregateInput
  }

  export type TaskDetailPowerInterruptionScalarWhereWithAggregatesInput = {
    AND?: TaskDetailPowerInterruptionScalarWhereWithAggregatesInput | TaskDetailPowerInterruptionScalarWhereWithAggregatesInput[]
    OR?: TaskDetailPowerInterruptionScalarWhereWithAggregatesInput[]
    NOT?: TaskDetailPowerInterruptionScalarWhereWithAggregatesInput | TaskDetailPowerInterruptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskDetailPowerInterruption"> | number
    task_id?: IntWithAggregatesFilter<"TaskDetailPowerInterruption"> | number
    feeder_id?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    weather_condition_id?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    device_id?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    affected_area?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    cause?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    equipment_failed?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
    fuse_rating?: StringWithAggregatesFilter<"TaskDetailPowerInterruption"> | string
  }

  export type PowerInterruptionLinemanWhereInput = {
    AND?: PowerInterruptionLinemanWhereInput | PowerInterruptionLinemanWhereInput[]
    OR?: PowerInterruptionLinemanWhereInput[]
    NOT?: PowerInterruptionLinemanWhereInput | PowerInterruptionLinemanWhereInput[]
    id?: IntFilter<"PowerInterruptionLineman"> | number
    task_detail_id?: IntFilter<"PowerInterruptionLineman"> | number
    lineman_id?: StringFilter<"PowerInterruptionLineman"> | string
    task_detail?: XOR<TaskDetailPowerInterruptionScalarRelationFilter, TaskDetailPowerInterruptionWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }

  export type PowerInterruptionLinemanOrderByWithRelationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    task_detail?: TaskDetailPowerInterruptionOrderByWithRelationInput
    lineman?: LinemanOrderByWithRelationInput
  }

  export type PowerInterruptionLinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PowerInterruptionLinemanWhereInput | PowerInterruptionLinemanWhereInput[]
    OR?: PowerInterruptionLinemanWhereInput[]
    NOT?: PowerInterruptionLinemanWhereInput | PowerInterruptionLinemanWhereInput[]
    task_detail_id?: IntFilter<"PowerInterruptionLineman"> | number
    lineman_id?: StringFilter<"PowerInterruptionLineman"> | string
    task_detail?: XOR<TaskDetailPowerInterruptionScalarRelationFilter, TaskDetailPowerInterruptionWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }, "id">

  export type PowerInterruptionLinemanOrderByWithAggregationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    _count?: PowerInterruptionLinemanCountOrderByAggregateInput
    _avg?: PowerInterruptionLinemanAvgOrderByAggregateInput
    _max?: PowerInterruptionLinemanMaxOrderByAggregateInput
    _min?: PowerInterruptionLinemanMinOrderByAggregateInput
    _sum?: PowerInterruptionLinemanSumOrderByAggregateInput
  }

  export type PowerInterruptionLinemanScalarWhereWithAggregatesInput = {
    AND?: PowerInterruptionLinemanScalarWhereWithAggregatesInput | PowerInterruptionLinemanScalarWhereWithAggregatesInput[]
    OR?: PowerInterruptionLinemanScalarWhereWithAggregatesInput[]
    NOT?: PowerInterruptionLinemanScalarWhereWithAggregatesInput | PowerInterruptionLinemanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PowerInterruptionLineman"> | number
    task_detail_id?: IntWithAggregatesFilter<"PowerInterruptionLineman"> | number
    lineman_id?: StringWithAggregatesFilter<"PowerInterruptionLineman"> | string
  }

  export type TaskDetailKwhMeterWhereInput = {
    AND?: TaskDetailKwhMeterWhereInput | TaskDetailKwhMeterWhereInput[]
    OR?: TaskDetailKwhMeterWhereInput[]
    NOT?: TaskDetailKwhMeterWhereInput | TaskDetailKwhMeterWhereInput[]
    id?: IntFilter<"TaskDetailKwhMeter"> | number
    task_id?: IntFilter<"TaskDetailKwhMeter"> | number
    meter_number?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_brand_id?: StringFilter<"TaskDetailKwhMeter"> | string
    last_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    initial_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_class?: StringFilter<"TaskDetailKwhMeter"> | string
    linemen_incharge?: KwhMeterLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    meter_brand?: XOR<MeterBrandScalarRelationFilter, MeterBrandWhereInput>
  }

  export type TaskDetailKwhMeterOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    meter_number?: SortOrder
    meter_brand_id?: SortOrder
    last_reading?: SortOrder
    initial_reading?: SortOrder
    meter_class?: SortOrder
    linemen_incharge?: KwhMeterLinemanOrderByRelationAggregateInput
    task?: TaskOrderByWithRelationInput
    meter_brand?: MeterBrandOrderByWithRelationInput
  }

  export type TaskDetailKwhMeterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskDetailKwhMeterWhereInput | TaskDetailKwhMeterWhereInput[]
    OR?: TaskDetailKwhMeterWhereInput[]
    NOT?: TaskDetailKwhMeterWhereInput | TaskDetailKwhMeterWhereInput[]
    meter_number?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_brand_id?: StringFilter<"TaskDetailKwhMeter"> | string
    last_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    initial_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_class?: StringFilter<"TaskDetailKwhMeter"> | string
    linemen_incharge?: KwhMeterLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    meter_brand?: XOR<MeterBrandScalarRelationFilter, MeterBrandWhereInput>
  }, "id" | "task_id">

  export type TaskDetailKwhMeterOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    meter_number?: SortOrder
    meter_brand_id?: SortOrder
    last_reading?: SortOrder
    initial_reading?: SortOrder
    meter_class?: SortOrder
    _count?: TaskDetailKwhMeterCountOrderByAggregateInput
    _avg?: TaskDetailKwhMeterAvgOrderByAggregateInput
    _max?: TaskDetailKwhMeterMaxOrderByAggregateInput
    _min?: TaskDetailKwhMeterMinOrderByAggregateInput
    _sum?: TaskDetailKwhMeterSumOrderByAggregateInput
  }

  export type TaskDetailKwhMeterScalarWhereWithAggregatesInput = {
    AND?: TaskDetailKwhMeterScalarWhereWithAggregatesInput | TaskDetailKwhMeterScalarWhereWithAggregatesInput[]
    OR?: TaskDetailKwhMeterScalarWhereWithAggregatesInput[]
    NOT?: TaskDetailKwhMeterScalarWhereWithAggregatesInput | TaskDetailKwhMeterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskDetailKwhMeter"> | number
    task_id?: IntWithAggregatesFilter<"TaskDetailKwhMeter"> | number
    meter_number?: StringWithAggregatesFilter<"TaskDetailKwhMeter"> | string
    meter_brand_id?: StringWithAggregatesFilter<"TaskDetailKwhMeter"> | string
    last_reading?: StringWithAggregatesFilter<"TaskDetailKwhMeter"> | string
    initial_reading?: StringWithAggregatesFilter<"TaskDetailKwhMeter"> | string
    meter_class?: StringWithAggregatesFilter<"TaskDetailKwhMeter"> | string
  }

  export type KwhMeterLinemanWhereInput = {
    AND?: KwhMeterLinemanWhereInput | KwhMeterLinemanWhereInput[]
    OR?: KwhMeterLinemanWhereInput[]
    NOT?: KwhMeterLinemanWhereInput | KwhMeterLinemanWhereInput[]
    id?: IntFilter<"KwhMeterLineman"> | number
    task_detail_id?: IntFilter<"KwhMeterLineman"> | number
    lineman_id?: StringFilter<"KwhMeterLineman"> | string
    task_detail?: XOR<TaskDetailKwhMeterScalarRelationFilter, TaskDetailKwhMeterWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }

  export type KwhMeterLinemanOrderByWithRelationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    task_detail?: TaskDetailKwhMeterOrderByWithRelationInput
    lineman?: LinemanOrderByWithRelationInput
  }

  export type KwhMeterLinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KwhMeterLinemanWhereInput | KwhMeterLinemanWhereInput[]
    OR?: KwhMeterLinemanWhereInput[]
    NOT?: KwhMeterLinemanWhereInput | KwhMeterLinemanWhereInput[]
    task_detail_id?: IntFilter<"KwhMeterLineman"> | number
    lineman_id?: StringFilter<"KwhMeterLineman"> | string
    task_detail?: XOR<TaskDetailKwhMeterScalarRelationFilter, TaskDetailKwhMeterWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }, "id">

  export type KwhMeterLinemanOrderByWithAggregationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    _count?: KwhMeterLinemanCountOrderByAggregateInput
    _avg?: KwhMeterLinemanAvgOrderByAggregateInput
    _max?: KwhMeterLinemanMaxOrderByAggregateInput
    _min?: KwhMeterLinemanMinOrderByAggregateInput
    _sum?: KwhMeterLinemanSumOrderByAggregateInput
  }

  export type KwhMeterLinemanScalarWhereWithAggregatesInput = {
    AND?: KwhMeterLinemanScalarWhereWithAggregatesInput | KwhMeterLinemanScalarWhereWithAggregatesInput[]
    OR?: KwhMeterLinemanScalarWhereWithAggregatesInput[]
    NOT?: KwhMeterLinemanScalarWhereWithAggregatesInput | KwhMeterLinemanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KwhMeterLineman"> | number
    task_detail_id?: IntWithAggregatesFilter<"KwhMeterLineman"> | number
    lineman_id?: StringWithAggregatesFilter<"KwhMeterLineman"> | string
  }

  export type TaskDetailLineServicesWhereInput = {
    AND?: TaskDetailLineServicesWhereInput | TaskDetailLineServicesWhereInput[]
    OR?: TaskDetailLineServicesWhereInput[]
    NOT?: TaskDetailLineServicesWhereInput | TaskDetailLineServicesWhereInput[]
    id?: IntFilter<"TaskDetailLineServices"> | number
    task_id?: IntFilter<"TaskDetailLineServices"> | number
    order_number?: StringFilter<"TaskDetailLineServices"> | string
    cause?: StringFilter<"TaskDetailLineServices"> | string
    mrv_number?: StringFilter<"TaskDetailLineServices"> | string
    seriv_number?: StringFilter<"TaskDetailLineServices"> | string
    mst_number?: StringFilter<"TaskDetailLineServices"> | string
    mcrt_number?: StringFilter<"TaskDetailLineServices"> | string
    linemen_incharge?: LineServicesLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskDetailLineServicesOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    order_number?: SortOrder
    cause?: SortOrder
    mrv_number?: SortOrder
    seriv_number?: SortOrder
    mst_number?: SortOrder
    mcrt_number?: SortOrder
    linemen_incharge?: LineServicesLinemanOrderByRelationAggregateInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskDetailLineServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskDetailLineServicesWhereInput | TaskDetailLineServicesWhereInput[]
    OR?: TaskDetailLineServicesWhereInput[]
    NOT?: TaskDetailLineServicesWhereInput | TaskDetailLineServicesWhereInput[]
    order_number?: StringFilter<"TaskDetailLineServices"> | string
    cause?: StringFilter<"TaskDetailLineServices"> | string
    mrv_number?: StringFilter<"TaskDetailLineServices"> | string
    seriv_number?: StringFilter<"TaskDetailLineServices"> | string
    mst_number?: StringFilter<"TaskDetailLineServices"> | string
    mcrt_number?: StringFilter<"TaskDetailLineServices"> | string
    linemen_incharge?: LineServicesLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "task_id">

  export type TaskDetailLineServicesOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    order_number?: SortOrder
    cause?: SortOrder
    mrv_number?: SortOrder
    seriv_number?: SortOrder
    mst_number?: SortOrder
    mcrt_number?: SortOrder
    _count?: TaskDetailLineServicesCountOrderByAggregateInput
    _avg?: TaskDetailLineServicesAvgOrderByAggregateInput
    _max?: TaskDetailLineServicesMaxOrderByAggregateInput
    _min?: TaskDetailLineServicesMinOrderByAggregateInput
    _sum?: TaskDetailLineServicesSumOrderByAggregateInput
  }

  export type TaskDetailLineServicesScalarWhereWithAggregatesInput = {
    AND?: TaskDetailLineServicesScalarWhereWithAggregatesInput | TaskDetailLineServicesScalarWhereWithAggregatesInput[]
    OR?: TaskDetailLineServicesScalarWhereWithAggregatesInput[]
    NOT?: TaskDetailLineServicesScalarWhereWithAggregatesInput | TaskDetailLineServicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskDetailLineServices"> | number
    task_id?: IntWithAggregatesFilter<"TaskDetailLineServices"> | number
    order_number?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
    cause?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
    mrv_number?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
    seriv_number?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
    mst_number?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
    mcrt_number?: StringWithAggregatesFilter<"TaskDetailLineServices"> | string
  }

  export type LineServicesLinemanWhereInput = {
    AND?: LineServicesLinemanWhereInput | LineServicesLinemanWhereInput[]
    OR?: LineServicesLinemanWhereInput[]
    NOT?: LineServicesLinemanWhereInput | LineServicesLinemanWhereInput[]
    id?: IntFilter<"LineServicesLineman"> | number
    task_detail_id?: IntFilter<"LineServicesLineman"> | number
    lineman_id?: StringFilter<"LineServicesLineman"> | string
    task_detail?: XOR<TaskDetailLineServicesScalarRelationFilter, TaskDetailLineServicesWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }

  export type LineServicesLinemanOrderByWithRelationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    task_detail?: TaskDetailLineServicesOrderByWithRelationInput
    lineman?: LinemanOrderByWithRelationInput
  }

  export type LineServicesLinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LineServicesLinemanWhereInput | LineServicesLinemanWhereInput[]
    OR?: LineServicesLinemanWhereInput[]
    NOT?: LineServicesLinemanWhereInput | LineServicesLinemanWhereInput[]
    task_detail_id?: IntFilter<"LineServicesLineman"> | number
    lineman_id?: StringFilter<"LineServicesLineman"> | string
    task_detail?: XOR<TaskDetailLineServicesScalarRelationFilter, TaskDetailLineServicesWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }, "id">

  export type LineServicesLinemanOrderByWithAggregationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    _count?: LineServicesLinemanCountOrderByAggregateInput
    _avg?: LineServicesLinemanAvgOrderByAggregateInput
    _max?: LineServicesLinemanMaxOrderByAggregateInput
    _min?: LineServicesLinemanMinOrderByAggregateInput
    _sum?: LineServicesLinemanSumOrderByAggregateInput
  }

  export type LineServicesLinemanScalarWhereWithAggregatesInput = {
    AND?: LineServicesLinemanScalarWhereWithAggregatesInput | LineServicesLinemanScalarWhereWithAggregatesInput[]
    OR?: LineServicesLinemanScalarWhereWithAggregatesInput[]
    NOT?: LineServicesLinemanScalarWhereWithAggregatesInput | LineServicesLinemanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LineServicesLineman"> | number
    task_detail_id?: IntWithAggregatesFilter<"LineServicesLineman"> | number
    lineman_id?: StringWithAggregatesFilter<"LineServicesLineman"> | string
  }

  export type TaskDetailDlesWhereInput = {
    AND?: TaskDetailDlesWhereInput | TaskDetailDlesWhereInput[]
    OR?: TaskDetailDlesWhereInput[]
    NOT?: TaskDetailDlesWhereInput | TaskDetailDlesWhereInput[]
    id?: IntFilter<"TaskDetailDles"> | number
    task_id?: IntFilter<"TaskDetailDles"> | number
    sco_number?: StringFilter<"TaskDetailDles"> | string
    old_serial_number?: StringFilter<"TaskDetailDles"> | string
    new_serial_number?: StringFilter<"TaskDetailDles"> | string
    seriv_number?: StringFilter<"TaskDetailDles"> | string
    kva_rating?: StringFilter<"TaskDetailDles"> | string
    cause?: StringFilter<"TaskDetailDles"> | string
    linemen_incharge?: DlesLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskDetailDlesOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    sco_number?: SortOrder
    old_serial_number?: SortOrder
    new_serial_number?: SortOrder
    seriv_number?: SortOrder
    kva_rating?: SortOrder
    cause?: SortOrder
    linemen_incharge?: DlesLinemanOrderByRelationAggregateInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskDetailDlesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskDetailDlesWhereInput | TaskDetailDlesWhereInput[]
    OR?: TaskDetailDlesWhereInput[]
    NOT?: TaskDetailDlesWhereInput | TaskDetailDlesWhereInput[]
    sco_number?: StringFilter<"TaskDetailDles"> | string
    old_serial_number?: StringFilter<"TaskDetailDles"> | string
    new_serial_number?: StringFilter<"TaskDetailDles"> | string
    seriv_number?: StringFilter<"TaskDetailDles"> | string
    kva_rating?: StringFilter<"TaskDetailDles"> | string
    cause?: StringFilter<"TaskDetailDles"> | string
    linemen_incharge?: DlesLinemanListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "task_id">

  export type TaskDetailDlesOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    sco_number?: SortOrder
    old_serial_number?: SortOrder
    new_serial_number?: SortOrder
    seriv_number?: SortOrder
    kva_rating?: SortOrder
    cause?: SortOrder
    _count?: TaskDetailDlesCountOrderByAggregateInput
    _avg?: TaskDetailDlesAvgOrderByAggregateInput
    _max?: TaskDetailDlesMaxOrderByAggregateInput
    _min?: TaskDetailDlesMinOrderByAggregateInput
    _sum?: TaskDetailDlesSumOrderByAggregateInput
  }

  export type TaskDetailDlesScalarWhereWithAggregatesInput = {
    AND?: TaskDetailDlesScalarWhereWithAggregatesInput | TaskDetailDlesScalarWhereWithAggregatesInput[]
    OR?: TaskDetailDlesScalarWhereWithAggregatesInput[]
    NOT?: TaskDetailDlesScalarWhereWithAggregatesInput | TaskDetailDlesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskDetailDles"> | number
    task_id?: IntWithAggregatesFilter<"TaskDetailDles"> | number
    sco_number?: StringWithAggregatesFilter<"TaskDetailDles"> | string
    old_serial_number?: StringWithAggregatesFilter<"TaskDetailDles"> | string
    new_serial_number?: StringWithAggregatesFilter<"TaskDetailDles"> | string
    seriv_number?: StringWithAggregatesFilter<"TaskDetailDles"> | string
    kva_rating?: StringWithAggregatesFilter<"TaskDetailDles"> | string
    cause?: StringWithAggregatesFilter<"TaskDetailDles"> | string
  }

  export type DlesLinemanWhereInput = {
    AND?: DlesLinemanWhereInput | DlesLinemanWhereInput[]
    OR?: DlesLinemanWhereInput[]
    NOT?: DlesLinemanWhereInput | DlesLinemanWhereInput[]
    id?: IntFilter<"DlesLineman"> | number
    task_detail_id?: IntFilter<"DlesLineman"> | number
    lineman_id?: StringFilter<"DlesLineman"> | string
    task_detail?: XOR<TaskDetailDlesScalarRelationFilter, TaskDetailDlesWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }

  export type DlesLinemanOrderByWithRelationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    task_detail?: TaskDetailDlesOrderByWithRelationInput
    lineman?: LinemanOrderByWithRelationInput
  }

  export type DlesLinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DlesLinemanWhereInput | DlesLinemanWhereInput[]
    OR?: DlesLinemanWhereInput[]
    NOT?: DlesLinemanWhereInput | DlesLinemanWhereInput[]
    task_detail_id?: IntFilter<"DlesLineman"> | number
    lineman_id?: StringFilter<"DlesLineman"> | string
    task_detail?: XOR<TaskDetailDlesScalarRelationFilter, TaskDetailDlesWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }, "id">

  export type DlesLinemanOrderByWithAggregationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    _count?: DlesLinemanCountOrderByAggregateInput
    _avg?: DlesLinemanAvgOrderByAggregateInput
    _max?: DlesLinemanMaxOrderByAggregateInput
    _min?: DlesLinemanMinOrderByAggregateInput
    _sum?: DlesLinemanSumOrderByAggregateInput
  }

  export type DlesLinemanScalarWhereWithAggregatesInput = {
    AND?: DlesLinemanScalarWhereWithAggregatesInput | DlesLinemanScalarWhereWithAggregatesInput[]
    OR?: DlesLinemanScalarWhereWithAggregatesInput[]
    NOT?: DlesLinemanScalarWhereWithAggregatesInput | DlesLinemanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DlesLineman"> | number
    task_detail_id?: IntWithAggregatesFilter<"DlesLineman"> | number
    lineman_id?: StringWithAggregatesFilter<"DlesLineman"> | string
  }

  export type TaskDetailLmdgaWhereInput = {
    AND?: TaskDetailLmdgaWhereInput | TaskDetailLmdgaWhereInput[]
    OR?: TaskDetailLmdgaWhereInput[]
    NOT?: TaskDetailLmdgaWhereInput | TaskDetailLmdgaWhereInput[]
    id?: IntFilter<"TaskDetailLmdga"> | number
    task_id?: IntFilter<"TaskDetailLmdga"> | number
    kva_rating?: StringFilter<"TaskDetailLmdga"> | string
    substation_id?: StringFilter<"TaskDetailLmdga"> | string
    dt_location?: StringFilter<"TaskDetailLmdga"> | string
    feeder_id?: StringFilter<"TaskDetailLmdga"> | string
    phase_number?: StringFilter<"TaskDetailLmdga"> | string
    number_of_hc?: StringFilter<"TaskDetailLmdga"> | string
    number_of_spans?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_primary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_secondary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_ground?: StringFilter<"TaskDetailLmdga"> | string
    size_primary?: StringFilter<"TaskDetailLmdga"> | string
    size_secondary?: StringFilter<"TaskDetailLmdga"> | string
    size_ground?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_primary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_secondary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_ground?: StringFilter<"TaskDetailLmdga"> | string
    tap_position?: StringFilter<"TaskDetailLmdga"> | string
    brand?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_primary?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_secondary?: StringFilter<"TaskDetailLmdga"> | string
    protective_device?: StringFilter<"TaskDetailLmdga"> | string
    load_current_sec_bushing?: StringFilter<"TaskDetailLmdga"> | string
    load_current_neutral?: StringFilter<"TaskDetailLmdga"> | string
    load_current_one?: StringFilter<"TaskDetailLmdga"> | string
    load_current_two?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_one?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_two?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_one?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_two?: StringFilter<"TaskDetailLmdga"> | string
    linemen_incharge?: LmdgaLinemanListRelationFilter
    feeder?: XOR<FeederScalarRelationFilter, FeederWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskDetailLmdgaOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    kva_rating?: SortOrder
    substation_id?: SortOrder
    dt_location?: SortOrder
    feeder_id?: SortOrder
    phase_number?: SortOrder
    number_of_hc?: SortOrder
    number_of_spans?: SortOrder
    copper_aluminum_primary?: SortOrder
    copper_aluminum_secondary?: SortOrder
    copper_aluminum_ground?: SortOrder
    size_primary?: SortOrder
    size_secondary?: SortOrder
    size_ground?: SortOrder
    terminal_connector_primary?: SortOrder
    terminal_connector_secondary?: SortOrder
    terminal_connector_ground?: SortOrder
    tap_position?: SortOrder
    brand?: SortOrder
    number_of_bushing_primary?: SortOrder
    number_of_bushing_secondary?: SortOrder
    protective_device?: SortOrder
    load_current_sec_bushing?: SortOrder
    load_current_neutral?: SortOrder
    load_current_one?: SortOrder
    load_current_two?: SortOrder
    voltage_level_one?: SortOrder
    voltage_level_two?: SortOrder
    sec_line_conductor_size_one?: SortOrder
    sec_line_conductor_size_two?: SortOrder
    linemen_incharge?: LmdgaLinemanOrderByRelationAggregateInput
    feeder?: FeederOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskDetailLmdgaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    task_id?: number
    AND?: TaskDetailLmdgaWhereInput | TaskDetailLmdgaWhereInput[]
    OR?: TaskDetailLmdgaWhereInput[]
    NOT?: TaskDetailLmdgaWhereInput | TaskDetailLmdgaWhereInput[]
    kva_rating?: StringFilter<"TaskDetailLmdga"> | string
    substation_id?: StringFilter<"TaskDetailLmdga"> | string
    dt_location?: StringFilter<"TaskDetailLmdga"> | string
    feeder_id?: StringFilter<"TaskDetailLmdga"> | string
    phase_number?: StringFilter<"TaskDetailLmdga"> | string
    number_of_hc?: StringFilter<"TaskDetailLmdga"> | string
    number_of_spans?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_primary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_secondary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_ground?: StringFilter<"TaskDetailLmdga"> | string
    size_primary?: StringFilter<"TaskDetailLmdga"> | string
    size_secondary?: StringFilter<"TaskDetailLmdga"> | string
    size_ground?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_primary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_secondary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_ground?: StringFilter<"TaskDetailLmdga"> | string
    tap_position?: StringFilter<"TaskDetailLmdga"> | string
    brand?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_primary?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_secondary?: StringFilter<"TaskDetailLmdga"> | string
    protective_device?: StringFilter<"TaskDetailLmdga"> | string
    load_current_sec_bushing?: StringFilter<"TaskDetailLmdga"> | string
    load_current_neutral?: StringFilter<"TaskDetailLmdga"> | string
    load_current_one?: StringFilter<"TaskDetailLmdga"> | string
    load_current_two?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_one?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_two?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_one?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_two?: StringFilter<"TaskDetailLmdga"> | string
    linemen_incharge?: LmdgaLinemanListRelationFilter
    feeder?: XOR<FeederScalarRelationFilter, FeederWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "task_id">

  export type TaskDetailLmdgaOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    kva_rating?: SortOrder
    substation_id?: SortOrder
    dt_location?: SortOrder
    feeder_id?: SortOrder
    phase_number?: SortOrder
    number_of_hc?: SortOrder
    number_of_spans?: SortOrder
    copper_aluminum_primary?: SortOrder
    copper_aluminum_secondary?: SortOrder
    copper_aluminum_ground?: SortOrder
    size_primary?: SortOrder
    size_secondary?: SortOrder
    size_ground?: SortOrder
    terminal_connector_primary?: SortOrder
    terminal_connector_secondary?: SortOrder
    terminal_connector_ground?: SortOrder
    tap_position?: SortOrder
    brand?: SortOrder
    number_of_bushing_primary?: SortOrder
    number_of_bushing_secondary?: SortOrder
    protective_device?: SortOrder
    load_current_sec_bushing?: SortOrder
    load_current_neutral?: SortOrder
    load_current_one?: SortOrder
    load_current_two?: SortOrder
    voltage_level_one?: SortOrder
    voltage_level_two?: SortOrder
    sec_line_conductor_size_one?: SortOrder
    sec_line_conductor_size_two?: SortOrder
    _count?: TaskDetailLmdgaCountOrderByAggregateInput
    _avg?: TaskDetailLmdgaAvgOrderByAggregateInput
    _max?: TaskDetailLmdgaMaxOrderByAggregateInput
    _min?: TaskDetailLmdgaMinOrderByAggregateInput
    _sum?: TaskDetailLmdgaSumOrderByAggregateInput
  }

  export type TaskDetailLmdgaScalarWhereWithAggregatesInput = {
    AND?: TaskDetailLmdgaScalarWhereWithAggregatesInput | TaskDetailLmdgaScalarWhereWithAggregatesInput[]
    OR?: TaskDetailLmdgaScalarWhereWithAggregatesInput[]
    NOT?: TaskDetailLmdgaScalarWhereWithAggregatesInput | TaskDetailLmdgaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskDetailLmdga"> | number
    task_id?: IntWithAggregatesFilter<"TaskDetailLmdga"> | number
    kva_rating?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    substation_id?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    dt_location?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    feeder_id?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    phase_number?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    number_of_hc?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    number_of_spans?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    copper_aluminum_primary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    copper_aluminum_secondary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    copper_aluminum_ground?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    size_primary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    size_secondary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    size_ground?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    terminal_connector_primary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    terminal_connector_secondary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    terminal_connector_ground?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    tap_position?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    brand?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    number_of_bushing_primary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    number_of_bushing_secondary?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    protective_device?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    load_current_sec_bushing?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    load_current_neutral?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    load_current_one?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    load_current_two?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    voltage_level_one?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    voltage_level_two?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_one?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_two?: StringWithAggregatesFilter<"TaskDetailLmdga"> | string
  }

  export type LmdgaLinemanWhereInput = {
    AND?: LmdgaLinemanWhereInput | LmdgaLinemanWhereInput[]
    OR?: LmdgaLinemanWhereInput[]
    NOT?: LmdgaLinemanWhereInput | LmdgaLinemanWhereInput[]
    id?: IntFilter<"LmdgaLineman"> | number
    task_detail_id?: IntFilter<"LmdgaLineman"> | number
    lineman_id?: StringFilter<"LmdgaLineman"> | string
    task_detail?: XOR<TaskDetailLmdgaScalarRelationFilter, TaskDetailLmdgaWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }

  export type LmdgaLinemanOrderByWithRelationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    task_detail?: TaskDetailLmdgaOrderByWithRelationInput
    lineman?: LinemanOrderByWithRelationInput
  }

  export type LmdgaLinemanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LmdgaLinemanWhereInput | LmdgaLinemanWhereInput[]
    OR?: LmdgaLinemanWhereInput[]
    NOT?: LmdgaLinemanWhereInput | LmdgaLinemanWhereInput[]
    task_detail_id?: IntFilter<"LmdgaLineman"> | number
    lineman_id?: StringFilter<"LmdgaLineman"> | string
    task_detail?: XOR<TaskDetailLmdgaScalarRelationFilter, TaskDetailLmdgaWhereInput>
    lineman?: XOR<LinemanScalarRelationFilter, LinemanWhereInput>
  }, "id">

  export type LmdgaLinemanOrderByWithAggregationInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
    _count?: LmdgaLinemanCountOrderByAggregateInput
    _avg?: LmdgaLinemanAvgOrderByAggregateInput
    _max?: LmdgaLinemanMaxOrderByAggregateInput
    _min?: LmdgaLinemanMinOrderByAggregateInput
    _sum?: LmdgaLinemanSumOrderByAggregateInput
  }

  export type LmdgaLinemanScalarWhereWithAggregatesInput = {
    AND?: LmdgaLinemanScalarWhereWithAggregatesInput | LmdgaLinemanScalarWhereWithAggregatesInput[]
    OR?: LmdgaLinemanScalarWhereWithAggregatesInput[]
    NOT?: LmdgaLinemanScalarWhereWithAggregatesInput | LmdgaLinemanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LmdgaLineman"> | number
    task_detail_id?: IntWithAggregatesFilter<"LmdgaLineman"> | number
    lineman_id?: StringWithAggregatesFilter<"LmdgaLineman"> | string
  }

  export type AuditCreateInput = {
    id?: string
    username: string
    table: string
    action: string
    reference_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    notes?: string | null
  }

  export type AuditUncheckedCreateInput = {
    id?: string
    username: string
    table: string
    action: string
    reference_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    notes?: string | null
  }

  export type AuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditCreateManyInput = {
    id?: string
    username: string
    table: string
    action: string
    reference_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    notes?: string | null
  }

  export type AuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    device_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinemanCreateInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanCreateManyInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
  }

  export type LinemanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
  }

  export type LinemanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
  }

  export type AreaCreateInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanCreateNestedManyWithoutAreaInput
    municipalities?: MunicipalityCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanUncheckedCreateNestedManyWithoutAreaInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUpdateManyWithoutAreaNestedInput
    municipalities?: MunicipalityUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUncheckedUpdateManyWithoutAreaNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: string
    oic_id: string
    name: string
  }

  export type AreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityCreateInput = {
    id?: string
    name: string
    area: AreaCreateNestedOneWithoutMunicipalitiesInput
    barangays?: BarangayCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateInput = {
    id?: string
    area_id: string
    name: string
    barangays?: BarangayUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    area?: AreaUpdateOneRequiredWithoutMunicipalitiesNestedInput
    barangays?: BarangayUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barangays?: BarangayUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityCreateManyInput = {
    id?: string
    area_id: string
    name: string
  }

  export type MunicipalityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BarangayCreateInput = {
    id?: string
    name: string
    municipality: MunicipalityCreateNestedOneWithoutBarangaysInput
    sitios?: SitioCreateNestedManyWithoutBarangayInput
    complaint_details?: ComplaintDetailCreateNestedManyWithoutBarangayInput
  }

  export type BarangayUncheckedCreateInput = {
    id?: string
    municipality_id: string
    name: string
    sitios?: SitioUncheckedCreateNestedManyWithoutBarangayInput
    complaint_details?: ComplaintDetailUncheckedCreateNestedManyWithoutBarangayInput
  }

  export type BarangayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipality?: MunicipalityUpdateOneRequiredWithoutBarangaysNestedInput
    sitios?: SitioUpdateManyWithoutBarangayNestedInput
    complaint_details?: ComplaintDetailUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    municipality_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sitios?: SitioUncheckedUpdateManyWithoutBarangayNestedInput
    complaint_details?: ComplaintDetailUncheckedUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayCreateManyInput = {
    id?: string
    municipality_id: string
    name: string
  }

  export type BarangayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BarangayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    municipality_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SitioCreateInput = {
    id?: string
    name: string
    barangay: BarangayCreateNestedOneWithoutSitiosInput
    complaint_details?: ComplaintDetailCreateNestedManyWithoutSitioInput
  }

  export type SitioUncheckedCreateInput = {
    id?: string
    barangay_id: string
    name: string
    complaint_details?: ComplaintDetailUncheckedCreateNestedManyWithoutSitioInput
  }

  export type SitioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barangay?: BarangayUpdateOneRequiredWithoutSitiosNestedInput
    complaint_details?: ComplaintDetailUpdateManyWithoutSitioNestedInput
  }

  export type SitioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barangay_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    complaint_details?: ComplaintDetailUncheckedUpdateManyWithoutSitioNestedInput
  }

  export type SitioCreateManyInput = {
    id?: string
    barangay_id: string
    name: string
  }

  export type SitioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SitioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barangay_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FeederCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionCreateNestedManyWithoutFeederInput
    lmdga_tasks?: TaskDetailLmdgaCreateNestedManyWithoutFeederInput
  }

  export type FeederUncheckedCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutFeederInput
    lmdga_tasks?: TaskDetailLmdgaUncheckedCreateNestedManyWithoutFeederInput
  }

  export type FeederUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUpdateManyWithoutFeederNestedInput
    lmdga_tasks?: TaskDetailLmdgaUpdateManyWithoutFeederNestedInput
  }

  export type FeederUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedUpdateManyWithoutFeederNestedInput
    lmdga_tasks?: TaskDetailLmdgaUncheckedUpdateManyWithoutFeederNestedInput
  }

  export type FeederCreateManyInput = {
    id?: string
    name: string
  }

  export type FeederUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FeederUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherConditionCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionCreateNestedManyWithoutWeather_conditionInput
  }

  export type WeatherConditionUncheckedCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutWeather_conditionInput
  }

  export type WeatherConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUpdateManyWithoutWeather_conditionNestedInput
  }

  export type WeatherConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedUpdateManyWithoutWeather_conditionNestedInput
  }

  export type WeatherConditionCreateManyInput = {
    id?: string
    name: string
  }

  export type WeatherConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    name: string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MeterBrandCreateInput = {
    id?: string
    name: string
    kwh_meter_tasks?: TaskDetailKwhMeterCreateNestedManyWithoutMeter_brandInput
  }

  export type MeterBrandUncheckedCreateInput = {
    id?: string
    name: string
    kwh_meter_tasks?: TaskDetailKwhMeterUncheckedCreateNestedManyWithoutMeter_brandInput
  }

  export type MeterBrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kwh_meter_tasks?: TaskDetailKwhMeterUpdateManyWithoutMeter_brandNestedInput
  }

  export type MeterBrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kwh_meter_tasks?: TaskDetailKwhMeterUncheckedUpdateManyWithoutMeter_brandNestedInput
  }

  export type MeterBrandCreateManyInput = {
    id?: string
    name: string
  }

  export type MeterBrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MeterBrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    category?: ActivityCategoryCreateNestedOneWithoutActivitiesInput
    tasks?: TaskCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    category_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ActivityCategoryUpdateOneWithoutActivitiesNestedInput
    tasks?: TaskUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    category_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCategoryCreateInput = {
    id: number
    name: string
    activities?: ActivityCreateNestedManyWithoutCategoryInput
  }

  export type ActivityCategoryUncheckedCreateInput = {
    id: number
    name: string
    activities?: ActivityUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ActivityCategoryUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    activities?: ActivityUpdateManyWithoutCategoryNestedInput
  }

  export type ActivityCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    activities?: ActivityUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ActivityCategoryCreateManyInput = {
    id: number
    name: string
  }

  export type ActivityCategoryUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintCreateInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogCreateNestedManyWithoutComplaintInput
    tasks?: TaskCreateNestedManyWithoutComplaintInput
    report_type: ComplaintReportTypeCreateNestedOneWithoutComplaintsInput
    status: ComplaintStatusCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintUpdateInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUpdateManyWithoutComplaintNestedInput
    report_type?: ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintCreateManyInput = {
    id?: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailCreateInput = {
    consumer_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    complaint: ComplaintCreateNestedOneWithoutComplaint_detailInput
    barangay: BarangayCreateNestedOneWithoutComplaint_detailsInput
    sitio?: SitioCreateNestedOneWithoutComplaint_detailsInput
  }

  export type ComplaintDetailUncheckedCreateInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    barangay_id: string
    sitio_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailUpdateInput = {
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutComplaint_detailNestedInput
    barangay?: BarangayUpdateOneRequiredWithoutComplaint_detailsNestedInput
    sitio?: SitioUpdateOneWithoutComplaint_detailsNestedInput
  }

  export type ComplaintDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    barangay_id?: StringFieldUpdateOperationsInput | string
    sitio_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailCreateManyInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    barangay_id: string
    sitio_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailUpdateManyMutationInput = {
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    barangay_id?: StringFieldUpdateOperationsInput | string
    sitio_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusCreateInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    complaints?: ComplaintCreateNestedManyWithoutStatusInput
    logs?: ComplaintLogCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusUncheckedCreateInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStatusInput
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUpdateManyWithoutStatusNestedInput
    logs?: ComplaintLogUpdateManyWithoutStatusNestedInput
  }

  export type ComplaintStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUncheckedUpdateManyWithoutStatusNestedInput
    logs?: ComplaintLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type ComplaintStatusCreateManyInput = {
    id: number
    name: string
    color_class?: string
    description?: string
  }

  export type ComplaintStatusUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintReportTypeCreateInput = {
    id: number
    name: string
    complaints?: ComplaintCreateNestedManyWithoutReport_typeInput
  }

  export type ComplaintReportTypeUncheckedCreateInput = {
    id: number
    name: string
    complaints?: ComplaintUncheckedCreateNestedManyWithoutReport_typeInput
  }

  export type ComplaintReportTypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUpdateManyWithoutReport_typeNestedInput
  }

  export type ComplaintReportTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUncheckedUpdateManyWithoutReport_typeNestedInput
  }

  export type ComplaintReportTypeCreateManyInput = {
    id: number
    name: string
  }

  export type ComplaintReportTypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintReportTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintLogCreateInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    complaint: ComplaintCreateNestedOneWithoutLogsInput
    status: ComplaintStatusCreateNestedOneWithoutLogsInput
  }

  export type ComplaintLogUncheckedCreateInput = {
    id?: number
    complaint_id: number
    complaint_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ComplaintLogUpdateInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutLogsNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ComplaintLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogCreateManyInput = {
    id?: number
    complaint_id: number
    complaint_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ComplaintLogUpdateManyMutationInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskUpdateInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateInput = {
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
    task: TaskCreateNestedOneWithoutTask_assignmentInput
    area?: AreaCreateNestedOneWithoutTask_assignmentsInput
  }

  export type TaskAssignmentUncheckedCreateInput = {
    id?: number
    task_id: number
    area_id?: string | null
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskAssignmentUpdateInput = {
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTask_assignmentNestedInput
    area?: AreaUpdateOneWithoutTask_assignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    area_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyInput = {
    id?: number
    task_id: number
    area_id?: string | null
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskAssignmentUpdateManyMutationInput = {
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    area_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogCreateInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    task: TaskCreateNestedOneWithoutLogsInput
    status: TaskStatusCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateInput = {
    id?: number
    task_id: number
    task_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskLogUpdateInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLogsNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    task_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogCreateManyInput = {
    id?: number
    task_id: number
    task_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskLogUpdateManyMutationInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    task_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskFileCreateInput = {
    filename: string
    source_path: string
    task: TaskCreateNestedOneWithoutFilesInput
  }

  export type TaskFileUncheckedCreateInput = {
    id?: number
    task_id: number
    filename: string
    source_path: string
  }

  export type TaskFileUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutFilesNestedInput
  }

  export type TaskFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFileCreateManyInput = {
    id?: number
    task_id: number
    filename: string
    source_path: string
  }

  export type TaskFileUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskStatusCreateInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    tasks?: TaskCreateNestedManyWithoutStatusInput
    logs?: TaskLogCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusUncheckedCreateInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutStatusInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUpdateManyWithoutStatusNestedInput
    logs?: TaskLogUpdateManyWithoutStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutStatusNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type TaskStatusCreateManyInput = {
    id: number
    name: string
    color_class?: string
    description?: string
  }

  export type TaskStatusUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type TaskStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailPowerInterruptionCreateInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutPower_interruption_tasksInput
    weather_condition: WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput
    device: DeviceCreateNestedOneWithoutPower_interruption_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_power_interruptionInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateInput = {
    id?: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailPowerInterruptionUpdateInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    weather_condition?: WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    device?: DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailPowerInterruptionCreateManyInput = {
    id?: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
  }

  export type TaskDetailPowerInterruptionUpdateManyMutationInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type PowerInterruptionLinemanCreateInput = {
    task_detail: TaskDetailPowerInterruptionCreateNestedOneWithoutLinemen_inchargeInput
    lineman: LinemanCreateNestedOneWithoutPower_interruptionsInput
  }

  export type PowerInterruptionLinemanUncheckedCreateInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type PowerInterruptionLinemanUpdateInput = {
    task_detail?: TaskDetailPowerInterruptionUpdateOneRequiredWithoutLinemen_inchargeNestedInput
    lineman?: LinemanUpdateOneRequiredWithoutPower_interruptionsNestedInput
  }

  export type PowerInterruptionLinemanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type PowerInterruptionLinemanCreateManyInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type PowerInterruptionLinemanUpdateManyMutationInput = {

  }

  export type PowerInterruptionLinemanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailKwhMeterCreateInput = {
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanCreateNestedManyWithoutTask_detailInput
    task: TaskCreateNestedOneWithoutTask_detail_kwh_meterInput
    meter_brand: MeterBrandCreateNestedOneWithoutKwh_meter_tasksInput
  }

  export type TaskDetailKwhMeterUncheckedCreateInput = {
    id?: number
    task_id: number
    meter_number: string
    meter_brand_id: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailKwhMeterUpdateInput = {
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUpdateManyWithoutTask_detailNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_kwh_meterNestedInput
    meter_brand?: MeterBrandUpdateOneRequiredWithoutKwh_meter_tasksNestedInput
  }

  export type TaskDetailKwhMeterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    meter_brand_id?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailKwhMeterCreateManyInput = {
    id?: number
    task_id: number
    meter_number: string
    meter_brand_id: string
    last_reading: string
    initial_reading: string
    meter_class: string
  }

  export type TaskDetailKwhMeterUpdateManyMutationInput = {
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailKwhMeterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    meter_brand_id?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
  }

  export type KwhMeterLinemanCreateInput = {
    task_detail: TaskDetailKwhMeterCreateNestedOneWithoutLinemen_inchargeInput
    lineman: LinemanCreateNestedOneWithoutKwh_metersInput
  }

  export type KwhMeterLinemanUncheckedCreateInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type KwhMeterLinemanUpdateInput = {
    task_detail?: TaskDetailKwhMeterUpdateOneRequiredWithoutLinemen_inchargeNestedInput
    lineman?: LinemanUpdateOneRequiredWithoutKwh_metersNestedInput
  }

  export type KwhMeterLinemanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type KwhMeterLinemanCreateManyInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type KwhMeterLinemanUpdateManyMutationInput = {

  }

  export type KwhMeterLinemanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailLineServicesCreateInput = {
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    linemen_incharge?: LineServicesLinemanCreateNestedManyWithoutTask_detailInput
    task: TaskCreateNestedOneWithoutTask_detail_line_servicesInput
  }

  export type TaskDetailLineServicesUncheckedCreateInput = {
    id?: number
    task_id: number
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    linemen_incharge?: LineServicesLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLineServicesUpdateInput = {
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LineServicesLinemanUpdateManyWithoutTask_detailNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_line_servicesNestedInput
  }

  export type TaskDetailLineServicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LineServicesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLineServicesCreateManyInput = {
    id?: number
    task_id: number
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
  }

  export type TaskDetailLineServicesUpdateManyMutationInput = {
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailLineServicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
  }

  export type LineServicesLinemanCreateInput = {
    task_detail: TaskDetailLineServicesCreateNestedOneWithoutLinemen_inchargeInput
    lineman: LinemanCreateNestedOneWithoutLine_servicesInput
  }

  export type LineServicesLinemanUncheckedCreateInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type LineServicesLinemanUpdateInput = {
    task_detail?: TaskDetailLineServicesUpdateOneRequiredWithoutLinemen_inchargeNestedInput
    lineman?: LinemanUpdateOneRequiredWithoutLine_servicesNestedInput
  }

  export type LineServicesLinemanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LineServicesLinemanCreateManyInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type LineServicesLinemanUpdateManyMutationInput = {

  }

  export type LineServicesLinemanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailDlesCreateInput = {
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    linemen_incharge?: DlesLinemanCreateNestedManyWithoutTask_detailInput
    task: TaskCreateNestedOneWithoutTask_detail_dlesInput
  }

  export type TaskDetailDlesUncheckedCreateInput = {
    id?: number
    task_id: number
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    linemen_incharge?: DlesLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailDlesUpdateInput = {
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: DlesLinemanUpdateManyWithoutTask_detailNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_dlesNestedInput
  }

  export type TaskDetailDlesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: DlesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailDlesCreateManyInput = {
    id?: number
    task_id: number
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
  }

  export type TaskDetailDlesUpdateManyMutationInput = {
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailDlesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
  }

  export type DlesLinemanCreateInput = {
    task_detail: TaskDetailDlesCreateNestedOneWithoutLinemen_inchargeInput
    lineman: LinemanCreateNestedOneWithoutDlesInput
  }

  export type DlesLinemanUncheckedCreateInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type DlesLinemanUpdateInput = {
    task_detail?: TaskDetailDlesUpdateOneRequiredWithoutLinemen_inchargeNestedInput
    lineman?: LinemanUpdateOneRequiredWithoutDlesNestedInput
  }

  export type DlesLinemanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type DlesLinemanCreateManyInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type DlesLinemanUpdateManyMutationInput = {

  }

  export type DlesLinemanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailLmdgaCreateInput = {
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutLmdga_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_lmdgaInput
  }

  export type TaskDetailLmdgaUncheckedCreateInput = {
    id?: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    feeder_id: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLmdgaUpdateInput = {
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutLmdga_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_lmdgaNestedInput
  }

  export type TaskDetailLmdgaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    feeder_id?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLmdgaCreateManyInput = {
    id?: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    feeder_id: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
  }

  export type TaskDetailLmdgaUpdateManyMutationInput = {
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailLmdgaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    feeder_id?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
  }

  export type LmdgaLinemanCreateInput = {
    task_detail: TaskDetailLmdgaCreateNestedOneWithoutLinemen_inchargeInput
    lineman: LinemanCreateNestedOneWithoutLmdgasInput
  }

  export type LmdgaLinemanUncheckedCreateInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type LmdgaLinemanUpdateInput = {
    task_detail?: TaskDetailLmdgaUpdateOneRequiredWithoutLinemen_inchargeNestedInput
    lineman?: LinemanUpdateOneRequiredWithoutLmdgasNestedInput
  }

  export type LmdgaLinemanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LmdgaLinemanCreateManyInput = {
    id?: number
    task_detail_id: number
    lineman_id: string
  }

  export type LmdgaLinemanUpdateManyMutationInput = {

  }

  export type LmdgaLinemanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    table?: SortOrder
    action?: SortOrder
    reference_id?: SortOrder
    metadata?: SortOrder
    ip_address?: SortOrder
    device_info?: SortOrder
    created_at?: SortOrder
    notes?: SortOrder
  }

  export type AuditMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    table?: SortOrder
    action?: SortOrder
    reference_id?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    notes?: SortOrder
  }

  export type AuditMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    table?: SortOrder
    action?: SortOrder
    reference_id?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    notes?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumLinemanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LinemanStatus | EnumLinemanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLinemanStatusFilter<$PrismaModel> | $Enums.LinemanStatus
  }

  export type AreaScalarRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type PowerInterruptionLinemanListRelationFilter = {
    every?: PowerInterruptionLinemanWhereInput
    some?: PowerInterruptionLinemanWhereInput
    none?: PowerInterruptionLinemanWhereInput
  }

  export type KwhMeterLinemanListRelationFilter = {
    every?: KwhMeterLinemanWhereInput
    some?: KwhMeterLinemanWhereInput
    none?: KwhMeterLinemanWhereInput
  }

  export type LineServicesLinemanListRelationFilter = {
    every?: LineServicesLinemanWhereInput
    some?: LineServicesLinemanWhereInput
    none?: LineServicesLinemanWhereInput
  }

  export type DlesLinemanListRelationFilter = {
    every?: DlesLinemanWhereInput
    some?: DlesLinemanWhereInput
    none?: DlesLinemanWhereInput
  }

  export type LmdgaLinemanListRelationFilter = {
    every?: LmdgaLinemanWhereInput
    some?: LmdgaLinemanWhereInput
    none?: LmdgaLinemanWhereInput
  }

  export type PowerInterruptionLinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KwhMeterLinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineServicesLinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DlesLinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LmdgaLinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinemanCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    area_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
  }

  export type LinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    area_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
  }

  export type LinemanMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    area_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
  }

  export type EnumLinemanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinemanStatus | EnumLinemanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLinemanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LinemanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLinemanStatusFilter<$PrismaModel>
    _max?: NestedEnumLinemanStatusFilter<$PrismaModel>
  }

  export type LinemanListRelationFilter = {
    every?: LinemanWhereInput
    some?: LinemanWhereInput
    none?: LinemanWhereInput
  }

  export type MunicipalityListRelationFilter = {
    every?: MunicipalityWhereInput
    some?: MunicipalityWhereInput
    none?: MunicipalityWhereInput
  }

  export type TaskAssignmentListRelationFilter = {
    every?: TaskAssignmentWhereInput
    some?: TaskAssignmentWhereInput
    none?: TaskAssignmentWhereInput
  }

  export type LinemanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    oic_id?: SortOrder
    name?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    oic_id?: SortOrder
    name?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    oic_id?: SortOrder
    name?: SortOrder
  }

  export type BarangayListRelationFilter = {
    every?: BarangayWhereInput
    some?: BarangayWhereInput
    none?: BarangayWhereInput
  }

  export type BarangayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityCountOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalityMaxOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalityMinOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalityScalarRelationFilter = {
    is?: MunicipalityWhereInput
    isNot?: MunicipalityWhereInput
  }

  export type SitioListRelationFilter = {
    every?: SitioWhereInput
    some?: SitioWhereInput
    none?: SitioWhereInput
  }

  export type ComplaintDetailListRelationFilter = {
    every?: ComplaintDetailWhereInput
    some?: ComplaintDetailWhereInput
    none?: ComplaintDetailWhereInput
  }

  export type SitioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarangayCountOrderByAggregateInput = {
    id?: SortOrder
    municipality_id?: SortOrder
    name?: SortOrder
  }

  export type BarangayMaxOrderByAggregateInput = {
    id?: SortOrder
    municipality_id?: SortOrder
    name?: SortOrder
  }

  export type BarangayMinOrderByAggregateInput = {
    id?: SortOrder
    municipality_id?: SortOrder
    name?: SortOrder
  }

  export type BarangayScalarRelationFilter = {
    is?: BarangayWhereInput
    isNot?: BarangayWhereInput
  }

  export type SitioNameBarangay_idCompoundUniqueInput = {
    name: string
    barangay_id: string
  }

  export type SitioCountOrderByAggregateInput = {
    id?: SortOrder
    barangay_id?: SortOrder
    name?: SortOrder
  }

  export type SitioMaxOrderByAggregateInput = {
    id?: SortOrder
    barangay_id?: SortOrder
    name?: SortOrder
  }

  export type SitioMinOrderByAggregateInput = {
    id?: SortOrder
    barangay_id?: SortOrder
    name?: SortOrder
  }

  export type TaskDetailPowerInterruptionListRelationFilter = {
    every?: TaskDetailPowerInterruptionWhereInput
    some?: TaskDetailPowerInterruptionWhereInput
    none?: TaskDetailPowerInterruptionWhereInput
  }

  export type TaskDetailLmdgaListRelationFilter = {
    every?: TaskDetailLmdgaWhereInput
    some?: TaskDetailLmdgaWhereInput
    none?: TaskDetailLmdgaWhereInput
  }

  export type TaskDetailPowerInterruptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskDetailLmdgaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeederCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FeederMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FeederMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeatherConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeatherConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeatherConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TaskDetailKwhMeterListRelationFilter = {
    every?: TaskDetailKwhMeterWhereInput
    some?: TaskDetailKwhMeterWhereInput
    none?: TaskDetailKwhMeterWhereInput
  }

  export type TaskDetailKwhMeterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeterBrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MeterBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MeterBrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ActivityCategoryNullableScalarRelationFilter = {
    is?: ActivityCategoryWhereInput | null
    isNot?: ActivityCategoryWhereInput | null
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivityCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivityCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivityCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComplaintDetailNullableScalarRelationFilter = {
    is?: ComplaintDetailWhereInput | null
    isNot?: ComplaintDetailWhereInput | null
  }

  export type ComplaintLogListRelationFilter = {
    every?: ComplaintLogWhereInput
    some?: ComplaintLogWhereInput
    none?: ComplaintLogWhereInput
  }

  export type ComplaintReportTypeScalarRelationFilter = {
    is?: ComplaintReportTypeWhereInput
    isNot?: ComplaintReportTypeWhereInput
  }

  export type ComplaintStatusScalarRelationFilter = {
    is?: ComplaintStatusWhereInput
    isNot?: ComplaintStatusWhereInput
  }

  export type ComplaintLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_id?: SortOrder
    assigned_group_type?: SortOrder
    ref_number?: SortOrder
    complainant_name?: SortOrder
    complainant_contact_no?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_type?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_id?: SortOrder
    assigned_group_type?: SortOrder
    ref_number?: SortOrder
    complainant_name?: SortOrder
    complainant_contact_no?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_id?: SortOrder
    assigned_group_type?: SortOrder
    ref_number?: SortOrder
    complainant_name?: SortOrder
    complainant_contact_no?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    report_type_id?: SortOrder
    complaint_status_id?: SortOrder
    assigned_group_type?: SortOrder
  }

  export type ComplaintScalarRelationFilter = {
    is?: ComplaintWhereInput
    isNot?: ComplaintWhereInput
  }

  export type SitioNullableScalarRelationFilter = {
    is?: SitioWhereInput | null
    isNot?: SitioWhereInput | null
  }

  export type ComplaintDetailCountOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    consumer_id?: SortOrder
    barangay_id?: SortOrder
    sitio_id?: SortOrder
    landmark?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
  }

  export type ComplaintDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    consumer_id?: SortOrder
    barangay_id?: SortOrder
    sitio_id?: SortOrder
    landmark?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintDetailMinOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    consumer_id?: SortOrder
    barangay_id?: SortOrder
    sitio_id?: SortOrder
    landmark?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintDetailSumOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type ComplaintStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComplaintStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type ComplaintStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type ComplaintStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComplaintReportTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ComplaintReportTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComplaintReportTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ComplaintReportTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ComplaintReportTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComplaintLogCountOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ComplaintLogAvgOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
  }

  export type ComplaintLogMaxOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ComplaintLogMinOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ComplaintLogSumOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    complaint_status_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TaskAssignmentNullableScalarRelationFilter = {
    is?: TaskAssignmentWhereInput | null
    isNot?: TaskAssignmentWhereInput | null
  }

  export type TaskLogListRelationFilter = {
    every?: TaskLogWhereInput
    some?: TaskLogWhereInput
    none?: TaskLogWhereInput
  }

  export type TaskFileListRelationFilter = {
    every?: TaskFileWhereInput
    some?: TaskFileWhereInput
    none?: TaskFileWhereInput
  }

  export type ComplaintNullableScalarRelationFilter = {
    is?: ComplaintWhereInput | null
    isNot?: ComplaintWhereInput | null
  }

  export type TaskStatusScalarRelationFilter = {
    is?: TaskStatusWhereInput
    isNot?: TaskStatusWhereInput
  }

  export type ActivityNullableScalarRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type TaskDetailPowerInterruptionNullableScalarRelationFilter = {
    is?: TaskDetailPowerInterruptionWhereInput | null
    isNot?: TaskDetailPowerInterruptionWhereInput | null
  }

  export type TaskDetailKwhMeterNullableScalarRelationFilter = {
    is?: TaskDetailKwhMeterWhereInput | null
    isNot?: TaskDetailKwhMeterWhereInput | null
  }

  export type TaskDetailLineServicesNullableScalarRelationFilter = {
    is?: TaskDetailLineServicesWhereInput | null
    isNot?: TaskDetailLineServicesWhereInput | null
  }

  export type TaskDetailDlesNullableScalarRelationFilter = {
    is?: TaskDetailDlesWhereInput | null
    isNot?: TaskDetailDlesWhereInput | null
  }

  export type TaskDetailLmdgaNullableScalarRelationFilter = {
    is?: TaskDetailLmdgaWhereInput | null
    isNot?: TaskDetailLmdgaWhereInput | null
  }

  export type TaskLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    ref_number?: SortOrder
    complaint_id?: SortOrder
    assignee_id?: SortOrder
    task_status_id?: SortOrder
    activity_id?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    accomplishment?: SortOrder
    action_taken?: SortOrder
    acted_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    task_status_id?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    ref_number?: SortOrder
    complaint_id?: SortOrder
    assignee_id?: SortOrder
    task_status_id?: SortOrder
    activity_id?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    accomplishment?: SortOrder
    action_taken?: SortOrder
    acted_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    ref_number?: SortOrder
    complaint_id?: SortOrder
    assignee_id?: SortOrder
    task_status_id?: SortOrder
    activity_id?: SortOrder
    description?: SortOrder
    remarks?: SortOrder
    accomplishment?: SortOrder
    action_taken?: SortOrder
    acted_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    complaint_id?: SortOrder
    task_status_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type AreaNullableScalarRelationFilter = {
    is?: AreaWhereInput | null
    isNot?: AreaWhereInput | null
  }

  export type TaskAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    area_id?: SortOrder
    department_id?: SortOrder
    division_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    area_id?: SortOrder
    department_id?: SortOrder
    division_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    area_id?: SortOrder
    department_id?: SortOrder
    division_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskLogCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskLogAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
  }

  export type TaskLogMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskLogMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
    remarks?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type TaskLogSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    task_status_id?: SortOrder
  }

  export type TaskFileCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    filename?: SortOrder
    source_path?: SortOrder
  }

  export type TaskFileAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskFileMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    filename?: SortOrder
    source_path?: SortOrder
  }

  export type TaskFileMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    filename?: SortOrder
    source_path?: SortOrder
  }

  export type TaskFileSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type TaskStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TaskStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type TaskStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color_class?: SortOrder
    description?: SortOrder
  }

  export type TaskStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeederScalarRelationFilter = {
    is?: FeederWhereInput
    isNot?: FeederWhereInput
  }

  export type WeatherConditionScalarRelationFilter = {
    is?: WeatherConditionWhereInput
    isNot?: WeatherConditionWhereInput
  }

  export type DeviceScalarRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type TaskDetailPowerInterruptionCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    feeder_id?: SortOrder
    weather_condition_id?: SortOrder
    device_id?: SortOrder
    affected_area?: SortOrder
    cause?: SortOrder
    equipment_failed?: SortOrder
    fuse_rating?: SortOrder
  }

  export type TaskDetailPowerInterruptionAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailPowerInterruptionMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    feeder_id?: SortOrder
    weather_condition_id?: SortOrder
    device_id?: SortOrder
    affected_area?: SortOrder
    cause?: SortOrder
    equipment_failed?: SortOrder
    fuse_rating?: SortOrder
  }

  export type TaskDetailPowerInterruptionMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    feeder_id?: SortOrder
    weather_condition_id?: SortOrder
    device_id?: SortOrder
    affected_area?: SortOrder
    cause?: SortOrder
    equipment_failed?: SortOrder
    fuse_rating?: SortOrder
  }

  export type TaskDetailPowerInterruptionSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailPowerInterruptionScalarRelationFilter = {
    is?: TaskDetailPowerInterruptionWhereInput
    isNot?: TaskDetailPowerInterruptionWhereInput
  }

  export type LinemanScalarRelationFilter = {
    is?: LinemanWhereInput
    isNot?: LinemanWhereInput
  }

  export type PowerInterruptionLinemanCountOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type PowerInterruptionLinemanAvgOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type PowerInterruptionLinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type PowerInterruptionLinemanMinOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type PowerInterruptionLinemanSumOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type MeterBrandScalarRelationFilter = {
    is?: MeterBrandWhereInput
    isNot?: MeterBrandWhereInput
  }

  export type TaskDetailKwhMeterCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    meter_number?: SortOrder
    meter_brand_id?: SortOrder
    last_reading?: SortOrder
    initial_reading?: SortOrder
    meter_class?: SortOrder
  }

  export type TaskDetailKwhMeterAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailKwhMeterMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    meter_number?: SortOrder
    meter_brand_id?: SortOrder
    last_reading?: SortOrder
    initial_reading?: SortOrder
    meter_class?: SortOrder
  }

  export type TaskDetailKwhMeterMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    meter_number?: SortOrder
    meter_brand_id?: SortOrder
    last_reading?: SortOrder
    initial_reading?: SortOrder
    meter_class?: SortOrder
  }

  export type TaskDetailKwhMeterSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailKwhMeterScalarRelationFilter = {
    is?: TaskDetailKwhMeterWhereInput
    isNot?: TaskDetailKwhMeterWhereInput
  }

  export type KwhMeterLinemanCountOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type KwhMeterLinemanAvgOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type KwhMeterLinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type KwhMeterLinemanMinOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type KwhMeterLinemanSumOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type TaskDetailLineServicesCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    order_number?: SortOrder
    cause?: SortOrder
    mrv_number?: SortOrder
    seriv_number?: SortOrder
    mst_number?: SortOrder
    mcrt_number?: SortOrder
  }

  export type TaskDetailLineServicesAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailLineServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    order_number?: SortOrder
    cause?: SortOrder
    mrv_number?: SortOrder
    seriv_number?: SortOrder
    mst_number?: SortOrder
    mcrt_number?: SortOrder
  }

  export type TaskDetailLineServicesMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    order_number?: SortOrder
    cause?: SortOrder
    mrv_number?: SortOrder
    seriv_number?: SortOrder
    mst_number?: SortOrder
    mcrt_number?: SortOrder
  }

  export type TaskDetailLineServicesSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailLineServicesScalarRelationFilter = {
    is?: TaskDetailLineServicesWhereInput
    isNot?: TaskDetailLineServicesWhereInput
  }

  export type LineServicesLinemanCountOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LineServicesLinemanAvgOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type LineServicesLinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LineServicesLinemanMinOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LineServicesLinemanSumOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type TaskDetailDlesCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    sco_number?: SortOrder
    old_serial_number?: SortOrder
    new_serial_number?: SortOrder
    seriv_number?: SortOrder
    kva_rating?: SortOrder
    cause?: SortOrder
  }

  export type TaskDetailDlesAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailDlesMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    sco_number?: SortOrder
    old_serial_number?: SortOrder
    new_serial_number?: SortOrder
    seriv_number?: SortOrder
    kva_rating?: SortOrder
    cause?: SortOrder
  }

  export type TaskDetailDlesMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    sco_number?: SortOrder
    old_serial_number?: SortOrder
    new_serial_number?: SortOrder
    seriv_number?: SortOrder
    kva_rating?: SortOrder
    cause?: SortOrder
  }

  export type TaskDetailDlesSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailDlesScalarRelationFilter = {
    is?: TaskDetailDlesWhereInput
    isNot?: TaskDetailDlesWhereInput
  }

  export type DlesLinemanCountOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type DlesLinemanAvgOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type DlesLinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type DlesLinemanMinOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type DlesLinemanSumOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type TaskDetailLmdgaCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    kva_rating?: SortOrder
    substation_id?: SortOrder
    dt_location?: SortOrder
    feeder_id?: SortOrder
    phase_number?: SortOrder
    number_of_hc?: SortOrder
    number_of_spans?: SortOrder
    copper_aluminum_primary?: SortOrder
    copper_aluminum_secondary?: SortOrder
    copper_aluminum_ground?: SortOrder
    size_primary?: SortOrder
    size_secondary?: SortOrder
    size_ground?: SortOrder
    terminal_connector_primary?: SortOrder
    terminal_connector_secondary?: SortOrder
    terminal_connector_ground?: SortOrder
    tap_position?: SortOrder
    brand?: SortOrder
    number_of_bushing_primary?: SortOrder
    number_of_bushing_secondary?: SortOrder
    protective_device?: SortOrder
    load_current_sec_bushing?: SortOrder
    load_current_neutral?: SortOrder
    load_current_one?: SortOrder
    load_current_two?: SortOrder
    voltage_level_one?: SortOrder
    voltage_level_two?: SortOrder
    sec_line_conductor_size_one?: SortOrder
    sec_line_conductor_size_two?: SortOrder
  }

  export type TaskDetailLmdgaAvgOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailLmdgaMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    kva_rating?: SortOrder
    substation_id?: SortOrder
    dt_location?: SortOrder
    feeder_id?: SortOrder
    phase_number?: SortOrder
    number_of_hc?: SortOrder
    number_of_spans?: SortOrder
    copper_aluminum_primary?: SortOrder
    copper_aluminum_secondary?: SortOrder
    copper_aluminum_ground?: SortOrder
    size_primary?: SortOrder
    size_secondary?: SortOrder
    size_ground?: SortOrder
    terminal_connector_primary?: SortOrder
    terminal_connector_secondary?: SortOrder
    terminal_connector_ground?: SortOrder
    tap_position?: SortOrder
    brand?: SortOrder
    number_of_bushing_primary?: SortOrder
    number_of_bushing_secondary?: SortOrder
    protective_device?: SortOrder
    load_current_sec_bushing?: SortOrder
    load_current_neutral?: SortOrder
    load_current_one?: SortOrder
    load_current_two?: SortOrder
    voltage_level_one?: SortOrder
    voltage_level_two?: SortOrder
    sec_line_conductor_size_one?: SortOrder
    sec_line_conductor_size_two?: SortOrder
  }

  export type TaskDetailLmdgaMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    kva_rating?: SortOrder
    substation_id?: SortOrder
    dt_location?: SortOrder
    feeder_id?: SortOrder
    phase_number?: SortOrder
    number_of_hc?: SortOrder
    number_of_spans?: SortOrder
    copper_aluminum_primary?: SortOrder
    copper_aluminum_secondary?: SortOrder
    copper_aluminum_ground?: SortOrder
    size_primary?: SortOrder
    size_secondary?: SortOrder
    size_ground?: SortOrder
    terminal_connector_primary?: SortOrder
    terminal_connector_secondary?: SortOrder
    terminal_connector_ground?: SortOrder
    tap_position?: SortOrder
    brand?: SortOrder
    number_of_bushing_primary?: SortOrder
    number_of_bushing_secondary?: SortOrder
    protective_device?: SortOrder
    load_current_sec_bushing?: SortOrder
    load_current_neutral?: SortOrder
    load_current_one?: SortOrder
    load_current_two?: SortOrder
    voltage_level_one?: SortOrder
    voltage_level_two?: SortOrder
    sec_line_conductor_size_one?: SortOrder
    sec_line_conductor_size_two?: SortOrder
  }

  export type TaskDetailLmdgaSumOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
  }

  export type TaskDetailLmdgaScalarRelationFilter = {
    is?: TaskDetailLmdgaWhereInput
    isNot?: TaskDetailLmdgaWhereInput
  }

  export type LmdgaLinemanCountOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LmdgaLinemanAvgOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type LmdgaLinemanMaxOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LmdgaLinemanMinOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
    lineman_id?: SortOrder
  }

  export type LmdgaLinemanSumOrderByAggregateInput = {
    id?: SortOrder
    task_detail_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AreaCreateNestedOneWithoutLinemenInput = {
    create?: XOR<AreaCreateWithoutLinemenInput, AreaUncheckedCreateWithoutLinemenInput>
    connectOrCreate?: AreaCreateOrConnectWithoutLinemenInput
    connect?: AreaWhereUniqueInput
  }

  export type PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput> | PowerInterruptionLinemanCreateWithoutLinemanInput[] | PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput | PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: PowerInterruptionLinemanCreateManyLinemanInputEnvelope
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
  }

  export type KwhMeterLinemanCreateNestedManyWithoutLinemanInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput> | KwhMeterLinemanCreateWithoutLinemanInput[] | KwhMeterLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutLinemanInput | KwhMeterLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: KwhMeterLinemanCreateManyLinemanInputEnvelope
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
  }

  export type LineServicesLinemanCreateNestedManyWithoutLinemanInput = {
    create?: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput> | LineServicesLinemanCreateWithoutLinemanInput[] | LineServicesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutLinemanInput | LineServicesLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: LineServicesLinemanCreateManyLinemanInputEnvelope
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
  }

  export type DlesLinemanCreateNestedManyWithoutLinemanInput = {
    create?: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput> | DlesLinemanCreateWithoutLinemanInput[] | DlesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutLinemanInput | DlesLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: DlesLinemanCreateManyLinemanInputEnvelope
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
  }

  export type LmdgaLinemanCreateNestedManyWithoutLinemanInput = {
    create?: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput> | LmdgaLinemanCreateWithoutLinemanInput[] | LmdgaLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutLinemanInput | LmdgaLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: LmdgaLinemanCreateManyLinemanInputEnvelope
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
  }

  export type PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput> | PowerInterruptionLinemanCreateWithoutLinemanInput[] | PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput | PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: PowerInterruptionLinemanCreateManyLinemanInputEnvelope
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
  }

  export type KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput> | KwhMeterLinemanCreateWithoutLinemanInput[] | KwhMeterLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutLinemanInput | KwhMeterLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: KwhMeterLinemanCreateManyLinemanInputEnvelope
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
  }

  export type LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput = {
    create?: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput> | LineServicesLinemanCreateWithoutLinemanInput[] | LineServicesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutLinemanInput | LineServicesLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: LineServicesLinemanCreateManyLinemanInputEnvelope
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
  }

  export type DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput = {
    create?: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput> | DlesLinemanCreateWithoutLinemanInput[] | DlesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutLinemanInput | DlesLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: DlesLinemanCreateManyLinemanInputEnvelope
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
  }

  export type LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput = {
    create?: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput> | LmdgaLinemanCreateWithoutLinemanInput[] | LmdgaLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutLinemanInput | LmdgaLinemanCreateOrConnectWithoutLinemanInput[]
    createMany?: LmdgaLinemanCreateManyLinemanInputEnvelope
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
  }

  export type EnumLinemanStatusFieldUpdateOperationsInput = {
    set?: $Enums.LinemanStatus
  }

  export type AreaUpdateOneRequiredWithoutLinemenNestedInput = {
    create?: XOR<AreaCreateWithoutLinemenInput, AreaUncheckedCreateWithoutLinemenInput>
    connectOrCreate?: AreaCreateOrConnectWithoutLinemenInput
    upsert?: AreaUpsertWithoutLinemenInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutLinemenInput, AreaUpdateWithoutLinemenInput>, AreaUncheckedUpdateWithoutLinemenInput>
  }

  export type PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput> | PowerInterruptionLinemanCreateWithoutLinemanInput[] | PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput | PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: PowerInterruptionLinemanUpsertWithWhereUniqueWithoutLinemanInput | PowerInterruptionLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: PowerInterruptionLinemanCreateManyLinemanInputEnvelope
    set?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    disconnect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    delete?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    update?: PowerInterruptionLinemanUpdateWithWhereUniqueWithoutLinemanInput | PowerInterruptionLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: PowerInterruptionLinemanUpdateManyWithWhereWithoutLinemanInput | PowerInterruptionLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
  }

  export type KwhMeterLinemanUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput> | KwhMeterLinemanCreateWithoutLinemanInput[] | KwhMeterLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutLinemanInput | KwhMeterLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: KwhMeterLinemanUpsertWithWhereUniqueWithoutLinemanInput | KwhMeterLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: KwhMeterLinemanCreateManyLinemanInputEnvelope
    set?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    disconnect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    delete?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    update?: KwhMeterLinemanUpdateWithWhereUniqueWithoutLinemanInput | KwhMeterLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: KwhMeterLinemanUpdateManyWithWhereWithoutLinemanInput | KwhMeterLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
  }

  export type LineServicesLinemanUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput> | LineServicesLinemanCreateWithoutLinemanInput[] | LineServicesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutLinemanInput | LineServicesLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: LineServicesLinemanUpsertWithWhereUniqueWithoutLinemanInput | LineServicesLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: LineServicesLinemanCreateManyLinemanInputEnvelope
    set?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    disconnect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    delete?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    update?: LineServicesLinemanUpdateWithWhereUniqueWithoutLinemanInput | LineServicesLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: LineServicesLinemanUpdateManyWithWhereWithoutLinemanInput | LineServicesLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
  }

  export type DlesLinemanUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput> | DlesLinemanCreateWithoutLinemanInput[] | DlesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutLinemanInput | DlesLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: DlesLinemanUpsertWithWhereUniqueWithoutLinemanInput | DlesLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: DlesLinemanCreateManyLinemanInputEnvelope
    set?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    disconnect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    delete?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    update?: DlesLinemanUpdateWithWhereUniqueWithoutLinemanInput | DlesLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: DlesLinemanUpdateManyWithWhereWithoutLinemanInput | DlesLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
  }

  export type LmdgaLinemanUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput> | LmdgaLinemanCreateWithoutLinemanInput[] | LmdgaLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutLinemanInput | LmdgaLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: LmdgaLinemanUpsertWithWhereUniqueWithoutLinemanInput | LmdgaLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: LmdgaLinemanCreateManyLinemanInputEnvelope
    set?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    disconnect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    delete?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    update?: LmdgaLinemanUpdateWithWhereUniqueWithoutLinemanInput | LmdgaLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: LmdgaLinemanUpdateManyWithWhereWithoutLinemanInput | LmdgaLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
  }

  export type PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput> | PowerInterruptionLinemanCreateWithoutLinemanInput[] | PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput | PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: PowerInterruptionLinemanUpsertWithWhereUniqueWithoutLinemanInput | PowerInterruptionLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: PowerInterruptionLinemanCreateManyLinemanInputEnvelope
    set?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    disconnect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    delete?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    update?: PowerInterruptionLinemanUpdateWithWhereUniqueWithoutLinemanInput | PowerInterruptionLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: PowerInterruptionLinemanUpdateManyWithWhereWithoutLinemanInput | PowerInterruptionLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
  }

  export type KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput> | KwhMeterLinemanCreateWithoutLinemanInput[] | KwhMeterLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutLinemanInput | KwhMeterLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: KwhMeterLinemanUpsertWithWhereUniqueWithoutLinemanInput | KwhMeterLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: KwhMeterLinemanCreateManyLinemanInputEnvelope
    set?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    disconnect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    delete?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    update?: KwhMeterLinemanUpdateWithWhereUniqueWithoutLinemanInput | KwhMeterLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: KwhMeterLinemanUpdateManyWithWhereWithoutLinemanInput | KwhMeterLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
  }

  export type LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput> | LineServicesLinemanCreateWithoutLinemanInput[] | LineServicesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutLinemanInput | LineServicesLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: LineServicesLinemanUpsertWithWhereUniqueWithoutLinemanInput | LineServicesLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: LineServicesLinemanCreateManyLinemanInputEnvelope
    set?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    disconnect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    delete?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    update?: LineServicesLinemanUpdateWithWhereUniqueWithoutLinemanInput | LineServicesLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: LineServicesLinemanUpdateManyWithWhereWithoutLinemanInput | LineServicesLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
  }

  export type DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput> | DlesLinemanCreateWithoutLinemanInput[] | DlesLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutLinemanInput | DlesLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: DlesLinemanUpsertWithWhereUniqueWithoutLinemanInput | DlesLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: DlesLinemanCreateManyLinemanInputEnvelope
    set?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    disconnect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    delete?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    update?: DlesLinemanUpdateWithWhereUniqueWithoutLinemanInput | DlesLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: DlesLinemanUpdateManyWithWhereWithoutLinemanInput | DlesLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
  }

  export type LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput = {
    create?: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput> | LmdgaLinemanCreateWithoutLinemanInput[] | LmdgaLinemanUncheckedCreateWithoutLinemanInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutLinemanInput | LmdgaLinemanCreateOrConnectWithoutLinemanInput[]
    upsert?: LmdgaLinemanUpsertWithWhereUniqueWithoutLinemanInput | LmdgaLinemanUpsertWithWhereUniqueWithoutLinemanInput[]
    createMany?: LmdgaLinemanCreateManyLinemanInputEnvelope
    set?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    disconnect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    delete?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    update?: LmdgaLinemanUpdateWithWhereUniqueWithoutLinemanInput | LmdgaLinemanUpdateWithWhereUniqueWithoutLinemanInput[]
    updateMany?: LmdgaLinemanUpdateManyWithWhereWithoutLinemanInput | LmdgaLinemanUpdateManyWithWhereWithoutLinemanInput[]
    deleteMany?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
  }

  export type LinemanCreateNestedManyWithoutAreaInput = {
    create?: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput> | LinemanCreateWithoutAreaInput[] | LinemanUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LinemanCreateOrConnectWithoutAreaInput | LinemanCreateOrConnectWithoutAreaInput[]
    createMany?: LinemanCreateManyAreaInputEnvelope
    connect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
  }

  export type MunicipalityCreateNestedManyWithoutAreaInput = {
    create?: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput> | MunicipalityCreateWithoutAreaInput[] | MunicipalityUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAreaInput | MunicipalityCreateOrConnectWithoutAreaInput[]
    createMany?: MunicipalityCreateManyAreaInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type TaskAssignmentCreateNestedManyWithoutAreaInput = {
    create?: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput> | TaskAssignmentCreateWithoutAreaInput[] | TaskAssignmentUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAreaInput | TaskAssignmentCreateOrConnectWithoutAreaInput[]
    createMany?: TaskAssignmentCreateManyAreaInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type LinemanUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput> | LinemanCreateWithoutAreaInput[] | LinemanUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LinemanCreateOrConnectWithoutAreaInput | LinemanCreateOrConnectWithoutAreaInput[]
    createMany?: LinemanCreateManyAreaInputEnvelope
    connect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
  }

  export type MunicipalityUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput> | MunicipalityCreateWithoutAreaInput[] | MunicipalityUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAreaInput | MunicipalityCreateOrConnectWithoutAreaInput[]
    createMany?: MunicipalityCreateManyAreaInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput> | TaskAssignmentCreateWithoutAreaInput[] | TaskAssignmentUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAreaInput | TaskAssignmentCreateOrConnectWithoutAreaInput[]
    createMany?: TaskAssignmentCreateManyAreaInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type LinemanUpdateManyWithoutAreaNestedInput = {
    create?: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput> | LinemanCreateWithoutAreaInput[] | LinemanUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LinemanCreateOrConnectWithoutAreaInput | LinemanCreateOrConnectWithoutAreaInput[]
    upsert?: LinemanUpsertWithWhereUniqueWithoutAreaInput | LinemanUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: LinemanCreateManyAreaInputEnvelope
    set?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    disconnect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    delete?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    connect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    update?: LinemanUpdateWithWhereUniqueWithoutAreaInput | LinemanUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: LinemanUpdateManyWithWhereWithoutAreaInput | LinemanUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: LinemanScalarWhereInput | LinemanScalarWhereInput[]
  }

  export type MunicipalityUpdateManyWithoutAreaNestedInput = {
    create?: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput> | MunicipalityCreateWithoutAreaInput[] | MunicipalityUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAreaInput | MunicipalityCreateOrConnectWithoutAreaInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutAreaInput | MunicipalityUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: MunicipalityCreateManyAreaInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutAreaInput | MunicipalityUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutAreaInput | MunicipalityUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type TaskAssignmentUpdateManyWithoutAreaNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput> | TaskAssignmentCreateWithoutAreaInput[] | TaskAssignmentUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAreaInput | TaskAssignmentCreateOrConnectWithoutAreaInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutAreaInput | TaskAssignmentUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: TaskAssignmentCreateManyAreaInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutAreaInput | TaskAssignmentUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutAreaInput | TaskAssignmentUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type LinemanUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput> | LinemanCreateWithoutAreaInput[] | LinemanUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LinemanCreateOrConnectWithoutAreaInput | LinemanCreateOrConnectWithoutAreaInput[]
    upsert?: LinemanUpsertWithWhereUniqueWithoutAreaInput | LinemanUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: LinemanCreateManyAreaInputEnvelope
    set?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    disconnect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    delete?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    connect?: LinemanWhereUniqueInput | LinemanWhereUniqueInput[]
    update?: LinemanUpdateWithWhereUniqueWithoutAreaInput | LinemanUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: LinemanUpdateManyWithWhereWithoutAreaInput | LinemanUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: LinemanScalarWhereInput | LinemanScalarWhereInput[]
  }

  export type MunicipalityUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput> | MunicipalityCreateWithoutAreaInput[] | MunicipalityUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutAreaInput | MunicipalityCreateOrConnectWithoutAreaInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutAreaInput | MunicipalityUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: MunicipalityCreateManyAreaInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutAreaInput | MunicipalityUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutAreaInput | MunicipalityUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput> | TaskAssignmentCreateWithoutAreaInput[] | TaskAssignmentUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAreaInput | TaskAssignmentCreateOrConnectWithoutAreaInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutAreaInput | TaskAssignmentUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: TaskAssignmentCreateManyAreaInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutAreaInput | TaskAssignmentUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutAreaInput | TaskAssignmentUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type AreaCreateNestedOneWithoutMunicipalitiesInput = {
    create?: XOR<AreaCreateWithoutMunicipalitiesInput, AreaUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: AreaCreateOrConnectWithoutMunicipalitiesInput
    connect?: AreaWhereUniqueInput
  }

  export type BarangayCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput> | BarangayCreateWithoutMunicipalityInput[] | BarangayUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: BarangayCreateOrConnectWithoutMunicipalityInput | BarangayCreateOrConnectWithoutMunicipalityInput[]
    createMany?: BarangayCreateManyMunicipalityInputEnvelope
    connect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
  }

  export type BarangayUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput> | BarangayCreateWithoutMunicipalityInput[] | BarangayUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: BarangayCreateOrConnectWithoutMunicipalityInput | BarangayCreateOrConnectWithoutMunicipalityInput[]
    createMany?: BarangayCreateManyMunicipalityInputEnvelope
    connect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
  }

  export type AreaUpdateOneRequiredWithoutMunicipalitiesNestedInput = {
    create?: XOR<AreaCreateWithoutMunicipalitiesInput, AreaUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: AreaCreateOrConnectWithoutMunicipalitiesInput
    upsert?: AreaUpsertWithoutMunicipalitiesInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutMunicipalitiesInput, AreaUpdateWithoutMunicipalitiesInput>, AreaUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type BarangayUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput> | BarangayCreateWithoutMunicipalityInput[] | BarangayUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: BarangayCreateOrConnectWithoutMunicipalityInput | BarangayCreateOrConnectWithoutMunicipalityInput[]
    upsert?: BarangayUpsertWithWhereUniqueWithoutMunicipalityInput | BarangayUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: BarangayCreateManyMunicipalityInputEnvelope
    set?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    disconnect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    delete?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    connect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    update?: BarangayUpdateWithWhereUniqueWithoutMunicipalityInput | BarangayUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: BarangayUpdateManyWithWhereWithoutMunicipalityInput | BarangayUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: BarangayScalarWhereInput | BarangayScalarWhereInput[]
  }

  export type BarangayUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput> | BarangayCreateWithoutMunicipalityInput[] | BarangayUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: BarangayCreateOrConnectWithoutMunicipalityInput | BarangayCreateOrConnectWithoutMunicipalityInput[]
    upsert?: BarangayUpsertWithWhereUniqueWithoutMunicipalityInput | BarangayUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: BarangayCreateManyMunicipalityInputEnvelope
    set?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    disconnect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    delete?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    connect?: BarangayWhereUniqueInput | BarangayWhereUniqueInput[]
    update?: BarangayUpdateWithWhereUniqueWithoutMunicipalityInput | BarangayUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: BarangayUpdateManyWithWhereWithoutMunicipalityInput | BarangayUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: BarangayScalarWhereInput | BarangayScalarWhereInput[]
  }

  export type MunicipalityCreateNestedOneWithoutBarangaysInput = {
    create?: XOR<MunicipalityCreateWithoutBarangaysInput, MunicipalityUncheckedCreateWithoutBarangaysInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutBarangaysInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type SitioCreateNestedManyWithoutBarangayInput = {
    create?: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput> | SitioCreateWithoutBarangayInput[] | SitioUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: SitioCreateOrConnectWithoutBarangayInput | SitioCreateOrConnectWithoutBarangayInput[]
    createMany?: SitioCreateManyBarangayInputEnvelope
    connect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
  }

  export type ComplaintDetailCreateNestedManyWithoutBarangayInput = {
    create?: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput> | ComplaintDetailCreateWithoutBarangayInput[] | ComplaintDetailUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutBarangayInput | ComplaintDetailCreateOrConnectWithoutBarangayInput[]
    createMany?: ComplaintDetailCreateManyBarangayInputEnvelope
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
  }

  export type SitioUncheckedCreateNestedManyWithoutBarangayInput = {
    create?: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput> | SitioCreateWithoutBarangayInput[] | SitioUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: SitioCreateOrConnectWithoutBarangayInput | SitioCreateOrConnectWithoutBarangayInput[]
    createMany?: SitioCreateManyBarangayInputEnvelope
    connect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
  }

  export type ComplaintDetailUncheckedCreateNestedManyWithoutBarangayInput = {
    create?: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput> | ComplaintDetailCreateWithoutBarangayInput[] | ComplaintDetailUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutBarangayInput | ComplaintDetailCreateOrConnectWithoutBarangayInput[]
    createMany?: ComplaintDetailCreateManyBarangayInputEnvelope
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
  }

  export type MunicipalityUpdateOneRequiredWithoutBarangaysNestedInput = {
    create?: XOR<MunicipalityCreateWithoutBarangaysInput, MunicipalityUncheckedCreateWithoutBarangaysInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutBarangaysInput
    upsert?: MunicipalityUpsertWithoutBarangaysInput
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutBarangaysInput, MunicipalityUpdateWithoutBarangaysInput>, MunicipalityUncheckedUpdateWithoutBarangaysInput>
  }

  export type SitioUpdateManyWithoutBarangayNestedInput = {
    create?: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput> | SitioCreateWithoutBarangayInput[] | SitioUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: SitioCreateOrConnectWithoutBarangayInput | SitioCreateOrConnectWithoutBarangayInput[]
    upsert?: SitioUpsertWithWhereUniqueWithoutBarangayInput | SitioUpsertWithWhereUniqueWithoutBarangayInput[]
    createMany?: SitioCreateManyBarangayInputEnvelope
    set?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    disconnect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    delete?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    connect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    update?: SitioUpdateWithWhereUniqueWithoutBarangayInput | SitioUpdateWithWhereUniqueWithoutBarangayInput[]
    updateMany?: SitioUpdateManyWithWhereWithoutBarangayInput | SitioUpdateManyWithWhereWithoutBarangayInput[]
    deleteMany?: SitioScalarWhereInput | SitioScalarWhereInput[]
  }

  export type ComplaintDetailUpdateManyWithoutBarangayNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput> | ComplaintDetailCreateWithoutBarangayInput[] | ComplaintDetailUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutBarangayInput | ComplaintDetailCreateOrConnectWithoutBarangayInput[]
    upsert?: ComplaintDetailUpsertWithWhereUniqueWithoutBarangayInput | ComplaintDetailUpsertWithWhereUniqueWithoutBarangayInput[]
    createMany?: ComplaintDetailCreateManyBarangayInputEnvelope
    set?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    disconnect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    delete?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    update?: ComplaintDetailUpdateWithWhereUniqueWithoutBarangayInput | ComplaintDetailUpdateWithWhereUniqueWithoutBarangayInput[]
    updateMany?: ComplaintDetailUpdateManyWithWhereWithoutBarangayInput | ComplaintDetailUpdateManyWithWhereWithoutBarangayInput[]
    deleteMany?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
  }

  export type SitioUncheckedUpdateManyWithoutBarangayNestedInput = {
    create?: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput> | SitioCreateWithoutBarangayInput[] | SitioUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: SitioCreateOrConnectWithoutBarangayInput | SitioCreateOrConnectWithoutBarangayInput[]
    upsert?: SitioUpsertWithWhereUniqueWithoutBarangayInput | SitioUpsertWithWhereUniqueWithoutBarangayInput[]
    createMany?: SitioCreateManyBarangayInputEnvelope
    set?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    disconnect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    delete?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    connect?: SitioWhereUniqueInput | SitioWhereUniqueInput[]
    update?: SitioUpdateWithWhereUniqueWithoutBarangayInput | SitioUpdateWithWhereUniqueWithoutBarangayInput[]
    updateMany?: SitioUpdateManyWithWhereWithoutBarangayInput | SitioUpdateManyWithWhereWithoutBarangayInput[]
    deleteMany?: SitioScalarWhereInput | SitioScalarWhereInput[]
  }

  export type ComplaintDetailUncheckedUpdateManyWithoutBarangayNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput> | ComplaintDetailCreateWithoutBarangayInput[] | ComplaintDetailUncheckedCreateWithoutBarangayInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutBarangayInput | ComplaintDetailCreateOrConnectWithoutBarangayInput[]
    upsert?: ComplaintDetailUpsertWithWhereUniqueWithoutBarangayInput | ComplaintDetailUpsertWithWhereUniqueWithoutBarangayInput[]
    createMany?: ComplaintDetailCreateManyBarangayInputEnvelope
    set?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    disconnect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    delete?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    update?: ComplaintDetailUpdateWithWhereUniqueWithoutBarangayInput | ComplaintDetailUpdateWithWhereUniqueWithoutBarangayInput[]
    updateMany?: ComplaintDetailUpdateManyWithWhereWithoutBarangayInput | ComplaintDetailUpdateManyWithWhereWithoutBarangayInput[]
    deleteMany?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
  }

  export type BarangayCreateNestedOneWithoutSitiosInput = {
    create?: XOR<BarangayCreateWithoutSitiosInput, BarangayUncheckedCreateWithoutSitiosInput>
    connectOrCreate?: BarangayCreateOrConnectWithoutSitiosInput
    connect?: BarangayWhereUniqueInput
  }

  export type ComplaintDetailCreateNestedManyWithoutSitioInput = {
    create?: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput> | ComplaintDetailCreateWithoutSitioInput[] | ComplaintDetailUncheckedCreateWithoutSitioInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutSitioInput | ComplaintDetailCreateOrConnectWithoutSitioInput[]
    createMany?: ComplaintDetailCreateManySitioInputEnvelope
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
  }

  export type ComplaintDetailUncheckedCreateNestedManyWithoutSitioInput = {
    create?: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput> | ComplaintDetailCreateWithoutSitioInput[] | ComplaintDetailUncheckedCreateWithoutSitioInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutSitioInput | ComplaintDetailCreateOrConnectWithoutSitioInput[]
    createMany?: ComplaintDetailCreateManySitioInputEnvelope
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
  }

  export type BarangayUpdateOneRequiredWithoutSitiosNestedInput = {
    create?: XOR<BarangayCreateWithoutSitiosInput, BarangayUncheckedCreateWithoutSitiosInput>
    connectOrCreate?: BarangayCreateOrConnectWithoutSitiosInput
    upsert?: BarangayUpsertWithoutSitiosInput
    connect?: BarangayWhereUniqueInput
    update?: XOR<XOR<BarangayUpdateToOneWithWhereWithoutSitiosInput, BarangayUpdateWithoutSitiosInput>, BarangayUncheckedUpdateWithoutSitiosInput>
  }

  export type ComplaintDetailUpdateManyWithoutSitioNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput> | ComplaintDetailCreateWithoutSitioInput[] | ComplaintDetailUncheckedCreateWithoutSitioInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutSitioInput | ComplaintDetailCreateOrConnectWithoutSitioInput[]
    upsert?: ComplaintDetailUpsertWithWhereUniqueWithoutSitioInput | ComplaintDetailUpsertWithWhereUniqueWithoutSitioInput[]
    createMany?: ComplaintDetailCreateManySitioInputEnvelope
    set?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    disconnect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    delete?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    update?: ComplaintDetailUpdateWithWhereUniqueWithoutSitioInput | ComplaintDetailUpdateWithWhereUniqueWithoutSitioInput[]
    updateMany?: ComplaintDetailUpdateManyWithWhereWithoutSitioInput | ComplaintDetailUpdateManyWithWhereWithoutSitioInput[]
    deleteMany?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
  }

  export type ComplaintDetailUncheckedUpdateManyWithoutSitioNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput> | ComplaintDetailCreateWithoutSitioInput[] | ComplaintDetailUncheckedCreateWithoutSitioInput[]
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutSitioInput | ComplaintDetailCreateOrConnectWithoutSitioInput[]
    upsert?: ComplaintDetailUpsertWithWhereUniqueWithoutSitioInput | ComplaintDetailUpsertWithWhereUniqueWithoutSitioInput[]
    createMany?: ComplaintDetailCreateManySitioInputEnvelope
    set?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    disconnect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    delete?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    connect?: ComplaintDetailWhereUniqueInput | ComplaintDetailWhereUniqueInput[]
    update?: ComplaintDetailUpdateWithWhereUniqueWithoutSitioInput | ComplaintDetailUpdateWithWhereUniqueWithoutSitioInput[]
    updateMany?: ComplaintDetailUpdateManyWithWhereWithoutSitioInput | ComplaintDetailUpdateManyWithWhereWithoutSitioInput[]
    deleteMany?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionCreateNestedManyWithoutFeederInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput> | TaskDetailPowerInterruptionCreateWithoutFeederInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput | TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyFeederInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailLmdgaCreateNestedManyWithoutFeederInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput> | TaskDetailLmdgaCreateWithoutFeederInput[] | TaskDetailLmdgaUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutFeederInput | TaskDetailLmdgaCreateOrConnectWithoutFeederInput[]
    createMany?: TaskDetailLmdgaCreateManyFeederInputEnvelope
    connect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutFeederInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput> | TaskDetailPowerInterruptionCreateWithoutFeederInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput | TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyFeederInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailLmdgaUncheckedCreateNestedManyWithoutFeederInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput> | TaskDetailLmdgaCreateWithoutFeederInput[] | TaskDetailLmdgaUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutFeederInput | TaskDetailLmdgaCreateOrConnectWithoutFeederInput[]
    createMany?: TaskDetailLmdgaCreateManyFeederInputEnvelope
    connect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUpdateManyWithoutFeederNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput> | TaskDetailPowerInterruptionCreateWithoutFeederInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput | TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutFeederInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutFeederInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyFeederInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutFeederInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutFeederInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutFeederInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutFeederInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailLmdgaUpdateManyWithoutFeederNestedInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput> | TaskDetailLmdgaCreateWithoutFeederInput[] | TaskDetailLmdgaUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutFeederInput | TaskDetailLmdgaCreateOrConnectWithoutFeederInput[]
    upsert?: TaskDetailLmdgaUpsertWithWhereUniqueWithoutFeederInput | TaskDetailLmdgaUpsertWithWhereUniqueWithoutFeederInput[]
    createMany?: TaskDetailLmdgaCreateManyFeederInputEnvelope
    set?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    disconnect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    delete?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    connect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    update?: TaskDetailLmdgaUpdateWithWhereUniqueWithoutFeederInput | TaskDetailLmdgaUpdateWithWhereUniqueWithoutFeederInput[]
    updateMany?: TaskDetailLmdgaUpdateManyWithWhereWithoutFeederInput | TaskDetailLmdgaUpdateManyWithWhereWithoutFeederInput[]
    deleteMany?: TaskDetailLmdgaScalarWhereInput | TaskDetailLmdgaScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutFeederNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput> | TaskDetailPowerInterruptionCreateWithoutFeederInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput | TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutFeederInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutFeederInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyFeederInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutFeederInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutFeederInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutFeederInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutFeederInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailLmdgaUncheckedUpdateManyWithoutFeederNestedInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput> | TaskDetailLmdgaCreateWithoutFeederInput[] | TaskDetailLmdgaUncheckedCreateWithoutFeederInput[]
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutFeederInput | TaskDetailLmdgaCreateOrConnectWithoutFeederInput[]
    upsert?: TaskDetailLmdgaUpsertWithWhereUniqueWithoutFeederInput | TaskDetailLmdgaUpsertWithWhereUniqueWithoutFeederInput[]
    createMany?: TaskDetailLmdgaCreateManyFeederInputEnvelope
    set?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    disconnect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    delete?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    connect?: TaskDetailLmdgaWhereUniqueInput | TaskDetailLmdgaWhereUniqueInput[]
    update?: TaskDetailLmdgaUpdateWithWhereUniqueWithoutFeederInput | TaskDetailLmdgaUpdateWithWhereUniqueWithoutFeederInput[]
    updateMany?: TaskDetailLmdgaUpdateManyWithWhereWithoutFeederInput | TaskDetailLmdgaUpdateManyWithWhereWithoutFeederInput[]
    deleteMany?: TaskDetailLmdgaScalarWhereInput | TaskDetailLmdgaScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionCreateNestedManyWithoutWeather_conditionInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput> | TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput | TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyWeather_conditionInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutWeather_conditionInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput> | TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput | TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyWeather_conditionInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUpdateManyWithoutWeather_conditionNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput> | TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput | TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutWeather_conditionInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyWeather_conditionInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutWeather_conditionInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutWeather_conditionInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutWeather_conditionNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput> | TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput | TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutWeather_conditionInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyWeather_conditionInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutWeather_conditionInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutWeather_conditionInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutWeather_conditionInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput> | TaskDetailPowerInterruptionCreateWithoutDeviceInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput | TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyDeviceInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput> | TaskDetailPowerInterruptionCreateWithoutDeviceInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput | TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyDeviceInputEnvelope
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput> | TaskDetailPowerInterruptionCreateWithoutDeviceInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput | TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutDeviceInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyDeviceInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutDeviceInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutDeviceInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput> | TaskDetailPowerInterruptionCreateWithoutDeviceInput[] | TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput | TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput[]
    upsert?: TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutDeviceInput | TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TaskDetailPowerInterruptionCreateManyDeviceInputEnvelope
    set?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    disconnect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    delete?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    connect?: TaskDetailPowerInterruptionWhereUniqueInput | TaskDetailPowerInterruptionWhereUniqueInput[]
    update?: TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutDeviceInput | TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TaskDetailPowerInterruptionUpdateManyWithWhereWithoutDeviceInput | TaskDetailPowerInterruptionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
  }

  export type TaskDetailKwhMeterCreateNestedManyWithoutMeter_brandInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput> | TaskDetailKwhMeterCreateWithoutMeter_brandInput[] | TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput[]
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput | TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput[]
    createMany?: TaskDetailKwhMeterCreateManyMeter_brandInputEnvelope
    connect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
  }

  export type TaskDetailKwhMeterUncheckedCreateNestedManyWithoutMeter_brandInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput> | TaskDetailKwhMeterCreateWithoutMeter_brandInput[] | TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput[]
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput | TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput[]
    createMany?: TaskDetailKwhMeterCreateManyMeter_brandInputEnvelope
    connect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
  }

  export type TaskDetailKwhMeterUpdateManyWithoutMeter_brandNestedInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput> | TaskDetailKwhMeterCreateWithoutMeter_brandInput[] | TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput[]
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput | TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput[]
    upsert?: TaskDetailKwhMeterUpsertWithWhereUniqueWithoutMeter_brandInput | TaskDetailKwhMeterUpsertWithWhereUniqueWithoutMeter_brandInput[]
    createMany?: TaskDetailKwhMeterCreateManyMeter_brandInputEnvelope
    set?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    disconnect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    delete?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    connect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    update?: TaskDetailKwhMeterUpdateWithWhereUniqueWithoutMeter_brandInput | TaskDetailKwhMeterUpdateWithWhereUniqueWithoutMeter_brandInput[]
    updateMany?: TaskDetailKwhMeterUpdateManyWithWhereWithoutMeter_brandInput | TaskDetailKwhMeterUpdateManyWithWhereWithoutMeter_brandInput[]
    deleteMany?: TaskDetailKwhMeterScalarWhereInput | TaskDetailKwhMeterScalarWhereInput[]
  }

  export type TaskDetailKwhMeterUncheckedUpdateManyWithoutMeter_brandNestedInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput> | TaskDetailKwhMeterCreateWithoutMeter_brandInput[] | TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput[]
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput | TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput[]
    upsert?: TaskDetailKwhMeterUpsertWithWhereUniqueWithoutMeter_brandInput | TaskDetailKwhMeterUpsertWithWhereUniqueWithoutMeter_brandInput[]
    createMany?: TaskDetailKwhMeterCreateManyMeter_brandInputEnvelope
    set?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    disconnect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    delete?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    connect?: TaskDetailKwhMeterWhereUniqueInput | TaskDetailKwhMeterWhereUniqueInput[]
    update?: TaskDetailKwhMeterUpdateWithWhereUniqueWithoutMeter_brandInput | TaskDetailKwhMeterUpdateWithWhereUniqueWithoutMeter_brandInput[]
    updateMany?: TaskDetailKwhMeterUpdateManyWithWhereWithoutMeter_brandInput | TaskDetailKwhMeterUpdateManyWithWhereWithoutMeter_brandInput[]
    deleteMany?: TaskDetailKwhMeterScalarWhereInput | TaskDetailKwhMeterScalarWhereInput[]
  }

  export type ActivityCategoryCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ActivityCategoryCreateWithoutActivitiesInput, ActivityCategoryUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityCategoryCreateOrConnectWithoutActivitiesInput
    connect?: ActivityCategoryWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutActivityInput = {
    create?: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput> | TaskCreateWithoutActivityInput[] | TaskUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutActivityInput | TaskCreateOrConnectWithoutActivityInput[]
    createMany?: TaskCreateManyActivityInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput> | TaskCreateWithoutActivityInput[] | TaskUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutActivityInput | TaskCreateOrConnectWithoutActivityInput[]
    createMany?: TaskCreateManyActivityInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityCategoryUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ActivityCategoryCreateWithoutActivitiesInput, ActivityCategoryUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityCategoryCreateOrConnectWithoutActivitiesInput
    upsert?: ActivityCategoryUpsertWithoutActivitiesInput
    disconnect?: ActivityCategoryWhereInput | boolean
    delete?: ActivityCategoryWhereInput | boolean
    connect?: ActivityCategoryWhereUniqueInput
    update?: XOR<XOR<ActivityCategoryUpdateToOneWithWhereWithoutActivitiesInput, ActivityCategoryUpdateWithoutActivitiesInput>, ActivityCategoryUncheckedUpdateWithoutActivitiesInput>
  }

  export type TaskUpdateManyWithoutActivityNestedInput = {
    create?: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput> | TaskCreateWithoutActivityInput[] | TaskUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutActivityInput | TaskCreateOrConnectWithoutActivityInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutActivityInput | TaskUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: TaskCreateManyActivityInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutActivityInput | TaskUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutActivityInput | TaskUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput> | TaskCreateWithoutActivityInput[] | TaskUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutActivityInput | TaskCreateOrConnectWithoutActivityInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutActivityInput | TaskUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: TaskCreateManyActivityInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutActivityInput | TaskUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutActivityInput | TaskUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput> | ActivityCreateWithoutCategoryInput[] | ActivityUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCategoryInput | ActivityCreateOrConnectWithoutCategoryInput[]
    createMany?: ActivityCreateManyCategoryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput> | ActivityCreateWithoutCategoryInput[] | ActivityUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCategoryInput | ActivityCreateOrConnectWithoutCategoryInput[]
    createMany?: ActivityCreateManyCategoryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput> | ActivityCreateWithoutCategoryInput[] | ActivityUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCategoryInput | ActivityCreateOrConnectWithoutCategoryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCategoryInput | ActivityUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ActivityCreateManyCategoryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCategoryInput | ActivityUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCategoryInput | ActivityUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput> | ActivityCreateWithoutCategoryInput[] | ActivityUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCategoryInput | ActivityCreateOrConnectWithoutCategoryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCategoryInput | ActivityUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ActivityCreateManyCategoryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCategoryInput | ActivityUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCategoryInput | ActivityUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ComplaintDetailCreateNestedOneWithoutComplaintInput = {
    create?: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutComplaintInput
    connect?: ComplaintDetailWhereUniqueInput
  }

  export type ComplaintLogCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput> | ComplaintLogCreateWithoutComplaintInput[] | ComplaintLogUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutComplaintInput | ComplaintLogCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintLogCreateManyComplaintInputEnvelope
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutComplaintInput = {
    create?: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput> | TaskCreateWithoutComplaintInput[] | TaskUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutComplaintInput | TaskCreateOrConnectWithoutComplaintInput[]
    createMany?: TaskCreateManyComplaintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ComplaintReportTypeCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<ComplaintReportTypeCreateWithoutComplaintsInput, ComplaintReportTypeUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ComplaintReportTypeCreateOrConnectWithoutComplaintsInput
    connect?: ComplaintReportTypeWhereUniqueInput
  }

  export type ComplaintStatusCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<ComplaintStatusCreateWithoutComplaintsInput, ComplaintStatusUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ComplaintStatusCreateOrConnectWithoutComplaintsInput
    connect?: ComplaintStatusWhereUniqueInput
  }

  export type ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput = {
    create?: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutComplaintInput
    connect?: ComplaintDetailWhereUniqueInput
  }

  export type ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput> | ComplaintLogCreateWithoutComplaintInput[] | ComplaintLogUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutComplaintInput | ComplaintLogCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintLogCreateManyComplaintInputEnvelope
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput> | TaskCreateWithoutComplaintInput[] | TaskUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutComplaintInput | TaskCreateOrConnectWithoutComplaintInput[]
    createMany?: TaskCreateManyComplaintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ComplaintDetailUpdateOneWithoutComplaintNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutComplaintInput
    upsert?: ComplaintDetailUpsertWithoutComplaintInput
    disconnect?: ComplaintDetailWhereInput | boolean
    delete?: ComplaintDetailWhereInput | boolean
    connect?: ComplaintDetailWhereUniqueInput
    update?: XOR<XOR<ComplaintDetailUpdateToOneWithWhereWithoutComplaintInput, ComplaintDetailUpdateWithoutComplaintInput>, ComplaintDetailUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintLogUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput> | ComplaintLogCreateWithoutComplaintInput[] | ComplaintLogUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutComplaintInput | ComplaintLogCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintLogUpsertWithWhereUniqueWithoutComplaintInput | ComplaintLogUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintLogCreateManyComplaintInputEnvelope
    set?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    disconnect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    delete?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    update?: ComplaintLogUpdateWithWhereUniqueWithoutComplaintInput | ComplaintLogUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintLogUpdateManyWithWhereWithoutComplaintInput | ComplaintLogUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput> | TaskCreateWithoutComplaintInput[] | TaskUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutComplaintInput | TaskCreateOrConnectWithoutComplaintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutComplaintInput | TaskUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: TaskCreateManyComplaintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutComplaintInput | TaskUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutComplaintInput | TaskUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<ComplaintReportTypeCreateWithoutComplaintsInput, ComplaintReportTypeUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ComplaintReportTypeCreateOrConnectWithoutComplaintsInput
    upsert?: ComplaintReportTypeUpsertWithoutComplaintsInput
    connect?: ComplaintReportTypeWhereUniqueInput
    update?: XOR<XOR<ComplaintReportTypeUpdateToOneWithWhereWithoutComplaintsInput, ComplaintReportTypeUpdateWithoutComplaintsInput>, ComplaintReportTypeUncheckedUpdateWithoutComplaintsInput>
  }

  export type ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<ComplaintStatusCreateWithoutComplaintsInput, ComplaintStatusUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ComplaintStatusCreateOrConnectWithoutComplaintsInput
    upsert?: ComplaintStatusUpsertWithoutComplaintsInput
    connect?: ComplaintStatusWhereUniqueInput
    update?: XOR<XOR<ComplaintStatusUpdateToOneWithWhereWithoutComplaintsInput, ComplaintStatusUpdateWithoutComplaintsInput>, ComplaintStatusUncheckedUpdateWithoutComplaintsInput>
  }

  export type ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput = {
    create?: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: ComplaintDetailCreateOrConnectWithoutComplaintInput
    upsert?: ComplaintDetailUpsertWithoutComplaintInput
    disconnect?: ComplaintDetailWhereInput | boolean
    delete?: ComplaintDetailWhereInput | boolean
    connect?: ComplaintDetailWhereUniqueInput
    update?: XOR<XOR<ComplaintDetailUpdateToOneWithWhereWithoutComplaintInput, ComplaintDetailUpdateWithoutComplaintInput>, ComplaintDetailUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput> | ComplaintLogCreateWithoutComplaintInput[] | ComplaintLogUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutComplaintInput | ComplaintLogCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintLogUpsertWithWhereUniqueWithoutComplaintInput | ComplaintLogUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintLogCreateManyComplaintInputEnvelope
    set?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    disconnect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    delete?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    update?: ComplaintLogUpdateWithWhereUniqueWithoutComplaintInput | ComplaintLogUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintLogUpdateManyWithWhereWithoutComplaintInput | ComplaintLogUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput> | TaskCreateWithoutComplaintInput[] | TaskUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutComplaintInput | TaskCreateOrConnectWithoutComplaintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutComplaintInput | TaskUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: TaskCreateManyComplaintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutComplaintInput | TaskUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutComplaintInput | TaskUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ComplaintCreateNestedOneWithoutComplaint_detailInput = {
    create?: XOR<ComplaintCreateWithoutComplaint_detailInput, ComplaintUncheckedCreateWithoutComplaint_detailInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutComplaint_detailInput
    connect?: ComplaintWhereUniqueInput
  }

  export type BarangayCreateNestedOneWithoutComplaint_detailsInput = {
    create?: XOR<BarangayCreateWithoutComplaint_detailsInput, BarangayUncheckedCreateWithoutComplaint_detailsInput>
    connectOrCreate?: BarangayCreateOrConnectWithoutComplaint_detailsInput
    connect?: BarangayWhereUniqueInput
  }

  export type SitioCreateNestedOneWithoutComplaint_detailsInput = {
    create?: XOR<SitioCreateWithoutComplaint_detailsInput, SitioUncheckedCreateWithoutComplaint_detailsInput>
    connectOrCreate?: SitioCreateOrConnectWithoutComplaint_detailsInput
    connect?: SitioWhereUniqueInput
  }

  export type ComplaintUpdateOneRequiredWithoutComplaint_detailNestedInput = {
    create?: XOR<ComplaintCreateWithoutComplaint_detailInput, ComplaintUncheckedCreateWithoutComplaint_detailInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutComplaint_detailInput
    upsert?: ComplaintUpsertWithoutComplaint_detailInput
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutComplaint_detailInput, ComplaintUpdateWithoutComplaint_detailInput>, ComplaintUncheckedUpdateWithoutComplaint_detailInput>
  }

  export type BarangayUpdateOneRequiredWithoutComplaint_detailsNestedInput = {
    create?: XOR<BarangayCreateWithoutComplaint_detailsInput, BarangayUncheckedCreateWithoutComplaint_detailsInput>
    connectOrCreate?: BarangayCreateOrConnectWithoutComplaint_detailsInput
    upsert?: BarangayUpsertWithoutComplaint_detailsInput
    connect?: BarangayWhereUniqueInput
    update?: XOR<XOR<BarangayUpdateToOneWithWhereWithoutComplaint_detailsInput, BarangayUpdateWithoutComplaint_detailsInput>, BarangayUncheckedUpdateWithoutComplaint_detailsInput>
  }

  export type SitioUpdateOneWithoutComplaint_detailsNestedInput = {
    create?: XOR<SitioCreateWithoutComplaint_detailsInput, SitioUncheckedCreateWithoutComplaint_detailsInput>
    connectOrCreate?: SitioCreateOrConnectWithoutComplaint_detailsInput
    upsert?: SitioUpsertWithoutComplaint_detailsInput
    disconnect?: SitioWhereInput | boolean
    delete?: SitioWhereInput | boolean
    connect?: SitioWhereUniqueInput
    update?: XOR<XOR<SitioUpdateToOneWithWhereWithoutComplaint_detailsInput, SitioUpdateWithoutComplaint_detailsInput>, SitioUncheckedUpdateWithoutComplaint_detailsInput>
  }

  export type ComplaintCreateNestedManyWithoutStatusInput = {
    create?: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput> | ComplaintCreateWithoutStatusInput[] | ComplaintUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStatusInput | ComplaintCreateOrConnectWithoutStatusInput[]
    createMany?: ComplaintCreateManyStatusInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintLogCreateNestedManyWithoutStatusInput = {
    create?: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput> | ComplaintLogCreateWithoutStatusInput[] | ComplaintLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutStatusInput | ComplaintLogCreateOrConnectWithoutStatusInput[]
    createMany?: ComplaintLogCreateManyStatusInputEnvelope
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput> | ComplaintCreateWithoutStatusInput[] | ComplaintUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStatusInput | ComplaintCreateOrConnectWithoutStatusInput[]
    createMany?: ComplaintCreateManyStatusInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintLogUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput> | ComplaintLogCreateWithoutStatusInput[] | ComplaintLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutStatusInput | ComplaintLogCreateOrConnectWithoutStatusInput[]
    createMany?: ComplaintLogCreateManyStatusInputEnvelope
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
  }

  export type ComplaintUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput> | ComplaintCreateWithoutStatusInput[] | ComplaintUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStatusInput | ComplaintCreateOrConnectWithoutStatusInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutStatusInput | ComplaintUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ComplaintCreateManyStatusInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutStatusInput | ComplaintUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutStatusInput | ComplaintUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintLogUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput> | ComplaintLogCreateWithoutStatusInput[] | ComplaintLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutStatusInput | ComplaintLogCreateOrConnectWithoutStatusInput[]
    upsert?: ComplaintLogUpsertWithWhereUniqueWithoutStatusInput | ComplaintLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ComplaintLogCreateManyStatusInputEnvelope
    set?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    disconnect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    delete?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    update?: ComplaintLogUpdateWithWhereUniqueWithoutStatusInput | ComplaintLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ComplaintLogUpdateManyWithWhereWithoutStatusInput | ComplaintLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput> | ComplaintCreateWithoutStatusInput[] | ComplaintUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStatusInput | ComplaintCreateOrConnectWithoutStatusInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutStatusInput | ComplaintUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ComplaintCreateManyStatusInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutStatusInput | ComplaintUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutStatusInput | ComplaintUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintLogUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput> | ComplaintLogCreateWithoutStatusInput[] | ComplaintLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ComplaintLogCreateOrConnectWithoutStatusInput | ComplaintLogCreateOrConnectWithoutStatusInput[]
    upsert?: ComplaintLogUpsertWithWhereUniqueWithoutStatusInput | ComplaintLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ComplaintLogCreateManyStatusInputEnvelope
    set?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    disconnect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    delete?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    connect?: ComplaintLogWhereUniqueInput | ComplaintLogWhereUniqueInput[]
    update?: ComplaintLogUpdateWithWhereUniqueWithoutStatusInput | ComplaintLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ComplaintLogUpdateManyWithWhereWithoutStatusInput | ComplaintLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
  }

  export type ComplaintCreateNestedManyWithoutReport_typeInput = {
    create?: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput> | ComplaintCreateWithoutReport_typeInput[] | ComplaintUncheckedCreateWithoutReport_typeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReport_typeInput | ComplaintCreateOrConnectWithoutReport_typeInput[]
    createMany?: ComplaintCreateManyReport_typeInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutReport_typeInput = {
    create?: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput> | ComplaintCreateWithoutReport_typeInput[] | ComplaintUncheckedCreateWithoutReport_typeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReport_typeInput | ComplaintCreateOrConnectWithoutReport_typeInput[]
    createMany?: ComplaintCreateManyReport_typeInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type ComplaintUpdateManyWithoutReport_typeNestedInput = {
    create?: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput> | ComplaintCreateWithoutReport_typeInput[] | ComplaintUncheckedCreateWithoutReport_typeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReport_typeInput | ComplaintCreateOrConnectWithoutReport_typeInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReport_typeInput | ComplaintUpsertWithWhereUniqueWithoutReport_typeInput[]
    createMany?: ComplaintCreateManyReport_typeInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReport_typeInput | ComplaintUpdateWithWhereUniqueWithoutReport_typeInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReport_typeInput | ComplaintUpdateManyWithWhereWithoutReport_typeInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutReport_typeNestedInput = {
    create?: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput> | ComplaintCreateWithoutReport_typeInput[] | ComplaintUncheckedCreateWithoutReport_typeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutReport_typeInput | ComplaintCreateOrConnectWithoutReport_typeInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutReport_typeInput | ComplaintUpsertWithWhereUniqueWithoutReport_typeInput[]
    createMany?: ComplaintCreateManyReport_typeInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutReport_typeInput | ComplaintUpdateWithWhereUniqueWithoutReport_typeInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutReport_typeInput | ComplaintUpdateManyWithWhereWithoutReport_typeInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type ComplaintCreateNestedOneWithoutLogsInput = {
    create?: XOR<ComplaintCreateWithoutLogsInput, ComplaintUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutLogsInput
    connect?: ComplaintWhereUniqueInput
  }

  export type ComplaintStatusCreateNestedOneWithoutLogsInput = {
    create?: XOR<ComplaintStatusCreateWithoutLogsInput, ComplaintStatusUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComplaintStatusCreateOrConnectWithoutLogsInput
    connect?: ComplaintStatusWhereUniqueInput
  }

  export type ComplaintUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ComplaintCreateWithoutLogsInput, ComplaintUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutLogsInput
    upsert?: ComplaintUpsertWithoutLogsInput
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutLogsInput, ComplaintUpdateWithoutLogsInput>, ComplaintUncheckedUpdateWithoutLogsInput>
  }

  export type ComplaintStatusUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ComplaintStatusCreateWithoutLogsInput, ComplaintStatusUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComplaintStatusCreateOrConnectWithoutLogsInput
    upsert?: ComplaintStatusUpsertWithoutLogsInput
    connect?: ComplaintStatusWhereUniqueInput
    update?: XOR<XOR<ComplaintStatusUpdateToOneWithWhereWithoutLogsInput, ComplaintStatusUpdateWithoutLogsInput>, ComplaintStatusUncheckedUpdateWithoutLogsInput>
  }

  export type TaskAssignmentCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput
    connect?: TaskAssignmentWhereUniqueInput
  }

  export type TaskLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type TaskFileCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput> | TaskFileCreateWithoutTaskInput[] | TaskFileUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFileCreateOrConnectWithoutTaskInput | TaskFileCreateOrConnectWithoutTaskInput[]
    createMany?: TaskFileCreateManyTaskInputEnvelope
    connect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
  }

  export type ComplaintCreateNestedOneWithoutTasksInput = {
    create?: XOR<ComplaintCreateWithoutTasksInput, ComplaintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutTasksInput
    connect?: ComplaintWhereUniqueInput
  }

  export type TaskStatusCreateNestedOneWithoutTasksInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    connect?: TaskStatusWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutTasksInput = {
    create?: XOR<ActivityCreateWithoutTasksInput, ActivityUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutTasksInput
    connect?: ActivityWhereUniqueInput
  }

  export type TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutTaskInput
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
  }

  export type TaskDetailKwhMeterCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutTaskInput
    connect?: TaskDetailKwhMeterWhereUniqueInput
  }

  export type TaskDetailLineServicesCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutTaskInput
    connect?: TaskDetailLineServicesWhereUniqueInput
  }

  export type TaskDetailDlesCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutTaskInput
    connect?: TaskDetailDlesWhereUniqueInput
  }

  export type TaskDetailLmdgaCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutTaskInput
    connect?: TaskDetailLmdgaWhereUniqueInput
  }

  export type TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput
    connect?: TaskAssignmentWhereUniqueInput
  }

  export type TaskLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type TaskFileUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput> | TaskFileCreateWithoutTaskInput[] | TaskFileUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFileCreateOrConnectWithoutTaskInput | TaskFileCreateOrConnectWithoutTaskInput[]
    createMany?: TaskFileCreateManyTaskInputEnvelope
    connect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutTaskInput
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
  }

  export type TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutTaskInput
    connect?: TaskDetailKwhMeterWhereUniqueInput
  }

  export type TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutTaskInput
    connect?: TaskDetailLineServicesWhereUniqueInput
  }

  export type TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutTaskInput
    connect?: TaskDetailDlesWhereUniqueInput
  }

  export type TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutTaskInput
    connect?: TaskDetailLmdgaWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TaskAssignmentUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput
    upsert?: TaskAssignmentUpsertWithoutTaskInput
    disconnect?: TaskAssignmentWhereInput | boolean
    delete?: TaskAssignmentWhereInput | boolean
    connect?: TaskAssignmentWhereUniqueInput
    update?: XOR<XOR<TaskAssignmentUpdateToOneWithWhereWithoutTaskInput, TaskAssignmentUpdateWithoutTaskInput>, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutTaskInput | TaskLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutTaskInput | TaskLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutTaskInput | TaskLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type TaskFileUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput> | TaskFileCreateWithoutTaskInput[] | TaskFileUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFileCreateOrConnectWithoutTaskInput | TaskFileCreateOrConnectWithoutTaskInput[]
    upsert?: TaskFileUpsertWithWhereUniqueWithoutTaskInput | TaskFileUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskFileCreateManyTaskInputEnvelope
    set?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    disconnect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    delete?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    connect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    update?: TaskFileUpdateWithWhereUniqueWithoutTaskInput | TaskFileUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskFileUpdateManyWithWhereWithoutTaskInput | TaskFileUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskFileScalarWhereInput | TaskFileScalarWhereInput[]
  }

  export type ComplaintUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ComplaintCreateWithoutTasksInput, ComplaintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ComplaintCreateOrConnectWithoutTasksInput
    upsert?: ComplaintUpsertWithoutTasksInput
    disconnect?: ComplaintWhereInput | boolean
    delete?: ComplaintWhereInput | boolean
    connect?: ComplaintWhereUniqueInput
    update?: XOR<XOR<ComplaintUpdateToOneWithWhereWithoutTasksInput, ComplaintUpdateWithoutTasksInput>, ComplaintUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    upsert?: TaskStatusUpsertWithoutTasksInput
    connect?: TaskStatusWhereUniqueInput
    update?: XOR<XOR<TaskStatusUpdateToOneWithWhereWithoutTasksInput, TaskStatusUpdateWithoutTasksInput>, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type ActivityUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ActivityCreateWithoutTasksInput, ActivityUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutTasksInput
    upsert?: ActivityUpsertWithoutTasksInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutTasksInput, ActivityUpdateWithoutTasksInput>, ActivityUncheckedUpdateWithoutTasksInput>
  }

  export type TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailPowerInterruptionUpsertWithoutTaskInput
    disconnect?: TaskDetailPowerInterruptionWhereInput | boolean
    delete?: TaskDetailPowerInterruptionWhereInput | boolean
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
    update?: XOR<XOR<TaskDetailPowerInterruptionUpdateToOneWithWhereWithoutTaskInput, TaskDetailPowerInterruptionUpdateWithoutTaskInput>, TaskDetailPowerInterruptionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailKwhMeterUpsertWithoutTaskInput
    disconnect?: TaskDetailKwhMeterWhereInput | boolean
    delete?: TaskDetailKwhMeterWhereInput | boolean
    connect?: TaskDetailKwhMeterWhereUniqueInput
    update?: XOR<XOR<TaskDetailKwhMeterUpdateToOneWithWhereWithoutTaskInput, TaskDetailKwhMeterUpdateWithoutTaskInput>, TaskDetailKwhMeterUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLineServicesUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailLineServicesUpsertWithoutTaskInput
    disconnect?: TaskDetailLineServicesWhereInput | boolean
    delete?: TaskDetailLineServicesWhereInput | boolean
    connect?: TaskDetailLineServicesWhereUniqueInput
    update?: XOR<XOR<TaskDetailLineServicesUpdateToOneWithWhereWithoutTaskInput, TaskDetailLineServicesUpdateWithoutTaskInput>, TaskDetailLineServicesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailDlesUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailDlesUpsertWithoutTaskInput
    disconnect?: TaskDetailDlesWhereInput | boolean
    delete?: TaskDetailDlesWhereInput | boolean
    connect?: TaskDetailDlesWhereUniqueInput
    update?: XOR<XOR<TaskDetailDlesUpdateToOneWithWhereWithoutTaskInput, TaskDetailDlesUpdateWithoutTaskInput>, TaskDetailDlesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLmdgaUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailLmdgaUpsertWithoutTaskInput
    disconnect?: TaskDetailLmdgaWhereInput | boolean
    delete?: TaskDetailLmdgaWhereInput | boolean
    connect?: TaskDetailLmdgaWhereUniqueInput
    update?: XOR<XOR<TaskDetailLmdgaUpdateToOneWithWhereWithoutTaskInput, TaskDetailLmdgaUpdateWithoutTaskInput>, TaskDetailLmdgaUncheckedUpdateWithoutTaskInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutTaskInput
    upsert?: TaskAssignmentUpsertWithoutTaskInput
    disconnect?: TaskAssignmentWhereInput | boolean
    delete?: TaskAssignmentWhereInput | boolean
    connect?: TaskAssignmentWhereUniqueInput
    update?: XOR<XOR<TaskAssignmentUpdateToOneWithWhereWithoutTaskInput, TaskAssignmentUpdateWithoutTaskInput>, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutTaskInput | TaskLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutTaskInput | TaskLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutTaskInput | TaskLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type TaskFileUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput> | TaskFileCreateWithoutTaskInput[] | TaskFileUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFileCreateOrConnectWithoutTaskInput | TaskFileCreateOrConnectWithoutTaskInput[]
    upsert?: TaskFileUpsertWithWhereUniqueWithoutTaskInput | TaskFileUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskFileCreateManyTaskInputEnvelope
    set?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    disconnect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    delete?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    connect?: TaskFileWhereUniqueInput | TaskFileWhereUniqueInput[]
    update?: TaskFileUpdateWithWhereUniqueWithoutTaskInput | TaskFileUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskFileUpdateManyWithWhereWithoutTaskInput | TaskFileUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskFileScalarWhereInput | TaskFileScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailPowerInterruptionUpsertWithoutTaskInput
    disconnect?: TaskDetailPowerInterruptionWhereInput | boolean
    delete?: TaskDetailPowerInterruptionWhereInput | boolean
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
    update?: XOR<XOR<TaskDetailPowerInterruptionUpdateToOneWithWhereWithoutTaskInput, TaskDetailPowerInterruptionUpdateWithoutTaskInput>, TaskDetailPowerInterruptionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailKwhMeterUpsertWithoutTaskInput
    disconnect?: TaskDetailKwhMeterWhereInput | boolean
    delete?: TaskDetailKwhMeterWhereInput | boolean
    connect?: TaskDetailKwhMeterWhereUniqueInput
    update?: XOR<XOR<TaskDetailKwhMeterUpdateToOneWithWhereWithoutTaskInput, TaskDetailKwhMeterUpdateWithoutTaskInput>, TaskDetailKwhMeterUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailLineServicesUpsertWithoutTaskInput
    disconnect?: TaskDetailLineServicesWhereInput | boolean
    delete?: TaskDetailLineServicesWhereInput | boolean
    connect?: TaskDetailLineServicesWhereUniqueInput
    update?: XOR<XOR<TaskDetailLineServicesUpdateToOneWithWhereWithoutTaskInput, TaskDetailLineServicesUpdateWithoutTaskInput>, TaskDetailLineServicesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailDlesUpsertWithoutTaskInput
    disconnect?: TaskDetailDlesWhereInput | boolean
    delete?: TaskDetailDlesWhereInput | boolean
    connect?: TaskDetailDlesWhereUniqueInput
    update?: XOR<XOR<TaskDetailDlesUpdateToOneWithWhereWithoutTaskInput, TaskDetailDlesUpdateWithoutTaskInput>, TaskDetailDlesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutTaskInput
    upsert?: TaskDetailLmdgaUpsertWithoutTaskInput
    disconnect?: TaskDetailLmdgaWhereInput | boolean
    delete?: TaskDetailLmdgaWhereInput | boolean
    connect?: TaskDetailLmdgaWhereUniqueInput
    update?: XOR<XOR<TaskDetailLmdgaUpdateToOneWithWhereWithoutTaskInput, TaskDetailLmdgaUpdateWithoutTaskInput>, TaskDetailLmdgaUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCreateNestedOneWithoutTask_assignmentInput = {
    create?: XOR<TaskCreateWithoutTask_assignmentInput, TaskUncheckedCreateWithoutTask_assignmentInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_assignmentInput
    connect?: TaskWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutTask_assignmentsInput = {
    create?: XOR<AreaCreateWithoutTask_assignmentsInput, AreaUncheckedCreateWithoutTask_assignmentsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutTask_assignmentsInput
    connect?: AreaWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTask_assignmentNestedInput = {
    create?: XOR<TaskCreateWithoutTask_assignmentInput, TaskUncheckedCreateWithoutTask_assignmentInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_assignmentInput
    upsert?: TaskUpsertWithoutTask_assignmentInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_assignmentInput, TaskUpdateWithoutTask_assignmentInput>, TaskUncheckedUpdateWithoutTask_assignmentInput>
  }

  export type AreaUpdateOneWithoutTask_assignmentsNestedInput = {
    create?: XOR<AreaCreateWithoutTask_assignmentsInput, AreaUncheckedCreateWithoutTask_assignmentsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutTask_assignmentsInput
    upsert?: AreaUpsertWithoutTask_assignmentsInput
    disconnect?: AreaWhereInput | boolean
    delete?: AreaWhereInput | boolean
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutTask_assignmentsInput, AreaUpdateWithoutTask_assignmentsInput>, AreaUncheckedUpdateWithoutTask_assignmentsInput>
  }

  export type TaskCreateNestedOneWithoutLogsInput = {
    create?: XOR<TaskCreateWithoutLogsInput, TaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskStatusCreateNestedOneWithoutLogsInput = {
    create?: XOR<TaskStatusCreateWithoutLogsInput, TaskStatusUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutLogsInput
    connect?: TaskStatusWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<TaskCreateWithoutLogsInput, TaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLogsInput
    upsert?: TaskUpsertWithoutLogsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLogsInput, TaskUpdateWithoutLogsInput>, TaskUncheckedUpdateWithoutLogsInput>
  }

  export type TaskStatusUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<TaskStatusCreateWithoutLogsInput, TaskStatusUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutLogsInput
    upsert?: TaskStatusUpsertWithoutLogsInput
    connect?: TaskStatusWhereUniqueInput
    update?: XOR<XOR<TaskStatusUpdateToOneWithWhereWithoutLogsInput, TaskStatusUpdateWithoutLogsInput>, TaskStatusUncheckedUpdateWithoutLogsInput>
  }

  export type TaskCreateNestedOneWithoutFilesInput = {
    create?: XOR<TaskCreateWithoutFilesInput, TaskUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutFilesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<TaskCreateWithoutFilesInput, TaskUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutFilesInput
    upsert?: TaskUpsertWithoutFilesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutFilesInput, TaskUpdateWithoutFilesInput>, TaskUncheckedUpdateWithoutFilesInput>
  }

  export type TaskCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskLogCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput> | TaskLogCreateWithoutStatusInput[] | TaskLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutStatusInput | TaskLogCreateOrConnectWithoutStatusInput[]
    createMany?: TaskLogCreateManyStatusInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskLogUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput> | TaskLogCreateWithoutStatusInput[] | TaskLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutStatusInput | TaskLogCreateOrConnectWithoutStatusInput[]
    createMany?: TaskLogCreateManyStatusInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStatusInput | TaskUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStatusInput | TaskUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStatusInput | TaskUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskLogUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput> | TaskLogCreateWithoutStatusInput[] | TaskLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutStatusInput | TaskLogCreateOrConnectWithoutStatusInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutStatusInput | TaskLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskLogCreateManyStatusInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutStatusInput | TaskLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutStatusInput | TaskLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput> | TaskCreateWithoutStatusInput[] | TaskUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStatusInput | TaskCreateOrConnectWithoutStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStatusInput | TaskUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskCreateManyStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStatusInput | TaskUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStatusInput | TaskUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskLogUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput> | TaskLogCreateWithoutStatusInput[] | TaskLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutStatusInput | TaskLogCreateOrConnectWithoutStatusInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutStatusInput | TaskLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TaskLogCreateManyStatusInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutStatusInput | TaskLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutStatusInput | TaskLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput> | PowerInterruptionLinemanCreateWithoutTask_detailInput[] | PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput | PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: PowerInterruptionLinemanCreateManyTask_detailInputEnvelope
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
  }

  export type FeederCreateNestedOneWithoutPower_interruption_tasksInput = {
    create?: XOR<FeederCreateWithoutPower_interruption_tasksInput, FeederUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: FeederCreateOrConnectWithoutPower_interruption_tasksInput
    connect?: FeederWhereUniqueInput
  }

  export type WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput = {
    create?: XOR<WeatherConditionCreateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: WeatherConditionCreateOrConnectWithoutPower_interruption_tasksInput
    connect?: WeatherConditionWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutPower_interruption_tasksInput = {
    create?: XOR<DeviceCreateWithoutPower_interruption_tasksInput, DeviceUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPower_interruption_tasksInput
    connect?: DeviceWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTask_detail_power_interruptionInput = {
    create?: XOR<TaskCreateWithoutTask_detail_power_interruptionInput, TaskUncheckedCreateWithoutTask_detail_power_interruptionInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_power_interruptionInput
    connect?: TaskWhereUniqueInput
  }

  export type PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput> | PowerInterruptionLinemanCreateWithoutTask_detailInput[] | PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput | PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: PowerInterruptionLinemanCreateManyTask_detailInputEnvelope
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
  }

  export type PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput> | PowerInterruptionLinemanCreateWithoutTask_detailInput[] | PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput | PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: PowerInterruptionLinemanUpsertWithWhereUniqueWithoutTask_detailInput | PowerInterruptionLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: PowerInterruptionLinemanCreateManyTask_detailInputEnvelope
    set?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    disconnect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    delete?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    update?: PowerInterruptionLinemanUpdateWithWhereUniqueWithoutTask_detailInput | PowerInterruptionLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: PowerInterruptionLinemanUpdateManyWithWhereWithoutTask_detailInput | PowerInterruptionLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
  }

  export type FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput = {
    create?: XOR<FeederCreateWithoutPower_interruption_tasksInput, FeederUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: FeederCreateOrConnectWithoutPower_interruption_tasksInput
    upsert?: FeederUpsertWithoutPower_interruption_tasksInput
    connect?: FeederWhereUniqueInput
    update?: XOR<XOR<FeederUpdateToOneWithWhereWithoutPower_interruption_tasksInput, FeederUpdateWithoutPower_interruption_tasksInput>, FeederUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput = {
    create?: XOR<WeatherConditionCreateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: WeatherConditionCreateOrConnectWithoutPower_interruption_tasksInput
    upsert?: WeatherConditionUpsertWithoutPower_interruption_tasksInput
    connect?: WeatherConditionWhereUniqueInput
    update?: XOR<XOR<WeatherConditionUpdateToOneWithWhereWithoutPower_interruption_tasksInput, WeatherConditionUpdateWithoutPower_interruption_tasksInput>, WeatherConditionUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput = {
    create?: XOR<DeviceCreateWithoutPower_interruption_tasksInput, DeviceUncheckedCreateWithoutPower_interruption_tasksInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPower_interruption_tasksInput
    upsert?: DeviceUpsertWithoutPower_interruption_tasksInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutPower_interruption_tasksInput, DeviceUpdateWithoutPower_interruption_tasksInput>, DeviceUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput = {
    create?: XOR<TaskCreateWithoutTask_detail_power_interruptionInput, TaskUncheckedCreateWithoutTask_detail_power_interruptionInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_power_interruptionInput
    upsert?: TaskUpsertWithoutTask_detail_power_interruptionInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_detail_power_interruptionInput, TaskUpdateWithoutTask_detail_power_interruptionInput>, TaskUncheckedUpdateWithoutTask_detail_power_interruptionInput>
  }

  export type PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput> | PowerInterruptionLinemanCreateWithoutTask_detailInput[] | PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput | PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: PowerInterruptionLinemanUpsertWithWhereUniqueWithoutTask_detailInput | PowerInterruptionLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: PowerInterruptionLinemanCreateManyTask_detailInputEnvelope
    set?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    disconnect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    delete?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    connect?: PowerInterruptionLinemanWhereUniqueInput | PowerInterruptionLinemanWhereUniqueInput[]
    update?: PowerInterruptionLinemanUpdateWithWhereUniqueWithoutTask_detailInput | PowerInterruptionLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: PowerInterruptionLinemanUpdateManyWithWhereWithoutTask_detailInput | PowerInterruptionLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
  }

  export type TaskDetailPowerInterruptionCreateNestedOneWithoutLinemen_inchargeInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutLinemen_inchargeInput
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
  }

  export type LinemanCreateNestedOneWithoutPower_interruptionsInput = {
    create?: XOR<LinemanCreateWithoutPower_interruptionsInput, LinemanUncheckedCreateWithoutPower_interruptionsInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutPower_interruptionsInput
    connect?: LinemanWhereUniqueInput
  }

  export type TaskDetailPowerInterruptionUpdateOneRequiredWithoutLinemen_inchargeNestedInput = {
    create?: XOR<TaskDetailPowerInterruptionCreateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailPowerInterruptionCreateOrConnectWithoutLinemen_inchargeInput
    upsert?: TaskDetailPowerInterruptionUpsertWithoutLinemen_inchargeInput
    connect?: TaskDetailPowerInterruptionWhereUniqueInput
    update?: XOR<XOR<TaskDetailPowerInterruptionUpdateToOneWithWhereWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUpdateWithoutLinemen_inchargeInput>, TaskDetailPowerInterruptionUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type LinemanUpdateOneRequiredWithoutPower_interruptionsNestedInput = {
    create?: XOR<LinemanCreateWithoutPower_interruptionsInput, LinemanUncheckedCreateWithoutPower_interruptionsInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutPower_interruptionsInput
    upsert?: LinemanUpsertWithoutPower_interruptionsInput
    connect?: LinemanWhereUniqueInput
    update?: XOR<XOR<LinemanUpdateToOneWithWhereWithoutPower_interruptionsInput, LinemanUpdateWithoutPower_interruptionsInput>, LinemanUncheckedUpdateWithoutPower_interruptionsInput>
  }

  export type KwhMeterLinemanCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput> | KwhMeterLinemanCreateWithoutTask_detailInput[] | KwhMeterLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutTask_detailInput | KwhMeterLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: KwhMeterLinemanCreateManyTask_detailInputEnvelope
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
  }

  export type TaskCreateNestedOneWithoutTask_detail_kwh_meterInput = {
    create?: XOR<TaskCreateWithoutTask_detail_kwh_meterInput, TaskUncheckedCreateWithoutTask_detail_kwh_meterInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_kwh_meterInput
    connect?: TaskWhereUniqueInput
  }

  export type MeterBrandCreateNestedOneWithoutKwh_meter_tasksInput = {
    create?: XOR<MeterBrandCreateWithoutKwh_meter_tasksInput, MeterBrandUncheckedCreateWithoutKwh_meter_tasksInput>
    connectOrCreate?: MeterBrandCreateOrConnectWithoutKwh_meter_tasksInput
    connect?: MeterBrandWhereUniqueInput
  }

  export type KwhMeterLinemanUncheckedCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput> | KwhMeterLinemanCreateWithoutTask_detailInput[] | KwhMeterLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutTask_detailInput | KwhMeterLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: KwhMeterLinemanCreateManyTask_detailInputEnvelope
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
  }

  export type KwhMeterLinemanUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput> | KwhMeterLinemanCreateWithoutTask_detailInput[] | KwhMeterLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutTask_detailInput | KwhMeterLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: KwhMeterLinemanUpsertWithWhereUniqueWithoutTask_detailInput | KwhMeterLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: KwhMeterLinemanCreateManyTask_detailInputEnvelope
    set?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    disconnect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    delete?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    update?: KwhMeterLinemanUpdateWithWhereUniqueWithoutTask_detailInput | KwhMeterLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: KwhMeterLinemanUpdateManyWithWhereWithoutTask_detailInput | KwhMeterLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
  }

  export type TaskUpdateOneRequiredWithoutTask_detail_kwh_meterNestedInput = {
    create?: XOR<TaskCreateWithoutTask_detail_kwh_meterInput, TaskUncheckedCreateWithoutTask_detail_kwh_meterInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_kwh_meterInput
    upsert?: TaskUpsertWithoutTask_detail_kwh_meterInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_detail_kwh_meterInput, TaskUpdateWithoutTask_detail_kwh_meterInput>, TaskUncheckedUpdateWithoutTask_detail_kwh_meterInput>
  }

  export type MeterBrandUpdateOneRequiredWithoutKwh_meter_tasksNestedInput = {
    create?: XOR<MeterBrandCreateWithoutKwh_meter_tasksInput, MeterBrandUncheckedCreateWithoutKwh_meter_tasksInput>
    connectOrCreate?: MeterBrandCreateOrConnectWithoutKwh_meter_tasksInput
    upsert?: MeterBrandUpsertWithoutKwh_meter_tasksInput
    connect?: MeterBrandWhereUniqueInput
    update?: XOR<XOR<MeterBrandUpdateToOneWithWhereWithoutKwh_meter_tasksInput, MeterBrandUpdateWithoutKwh_meter_tasksInput>, MeterBrandUncheckedUpdateWithoutKwh_meter_tasksInput>
  }

  export type KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput> | KwhMeterLinemanCreateWithoutTask_detailInput[] | KwhMeterLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: KwhMeterLinemanCreateOrConnectWithoutTask_detailInput | KwhMeterLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: KwhMeterLinemanUpsertWithWhereUniqueWithoutTask_detailInput | KwhMeterLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: KwhMeterLinemanCreateManyTask_detailInputEnvelope
    set?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    disconnect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    delete?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    connect?: KwhMeterLinemanWhereUniqueInput | KwhMeterLinemanWhereUniqueInput[]
    update?: KwhMeterLinemanUpdateWithWhereUniqueWithoutTask_detailInput | KwhMeterLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: KwhMeterLinemanUpdateManyWithWhereWithoutTask_detailInput | KwhMeterLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
  }

  export type TaskDetailKwhMeterCreateNestedOneWithoutLinemen_inchargeInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutLinemen_inchargeInput
    connect?: TaskDetailKwhMeterWhereUniqueInput
  }

  export type LinemanCreateNestedOneWithoutKwh_metersInput = {
    create?: XOR<LinemanCreateWithoutKwh_metersInput, LinemanUncheckedCreateWithoutKwh_metersInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutKwh_metersInput
    connect?: LinemanWhereUniqueInput
  }

  export type TaskDetailKwhMeterUpdateOneRequiredWithoutLinemen_inchargeNestedInput = {
    create?: XOR<TaskDetailKwhMeterCreateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailKwhMeterCreateOrConnectWithoutLinemen_inchargeInput
    upsert?: TaskDetailKwhMeterUpsertWithoutLinemen_inchargeInput
    connect?: TaskDetailKwhMeterWhereUniqueInput
    update?: XOR<XOR<TaskDetailKwhMeterUpdateToOneWithWhereWithoutLinemen_inchargeInput, TaskDetailKwhMeterUpdateWithoutLinemen_inchargeInput>, TaskDetailKwhMeterUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type LinemanUpdateOneRequiredWithoutKwh_metersNestedInput = {
    create?: XOR<LinemanCreateWithoutKwh_metersInput, LinemanUncheckedCreateWithoutKwh_metersInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutKwh_metersInput
    upsert?: LinemanUpsertWithoutKwh_metersInput
    connect?: LinemanWhereUniqueInput
    update?: XOR<XOR<LinemanUpdateToOneWithWhereWithoutKwh_metersInput, LinemanUpdateWithoutKwh_metersInput>, LinemanUncheckedUpdateWithoutKwh_metersInput>
  }

  export type LineServicesLinemanCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput> | LineServicesLinemanCreateWithoutTask_detailInput[] | LineServicesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutTask_detailInput | LineServicesLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: LineServicesLinemanCreateManyTask_detailInputEnvelope
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
  }

  export type TaskCreateNestedOneWithoutTask_detail_line_servicesInput = {
    create?: XOR<TaskCreateWithoutTask_detail_line_servicesInput, TaskUncheckedCreateWithoutTask_detail_line_servicesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_line_servicesInput
    connect?: TaskWhereUniqueInput
  }

  export type LineServicesLinemanUncheckedCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput> | LineServicesLinemanCreateWithoutTask_detailInput[] | LineServicesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutTask_detailInput | LineServicesLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: LineServicesLinemanCreateManyTask_detailInputEnvelope
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
  }

  export type LineServicesLinemanUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput> | LineServicesLinemanCreateWithoutTask_detailInput[] | LineServicesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutTask_detailInput | LineServicesLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: LineServicesLinemanUpsertWithWhereUniqueWithoutTask_detailInput | LineServicesLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: LineServicesLinemanCreateManyTask_detailInputEnvelope
    set?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    disconnect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    delete?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    update?: LineServicesLinemanUpdateWithWhereUniqueWithoutTask_detailInput | LineServicesLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: LineServicesLinemanUpdateManyWithWhereWithoutTask_detailInput | LineServicesLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
  }

  export type TaskUpdateOneRequiredWithoutTask_detail_line_servicesNestedInput = {
    create?: XOR<TaskCreateWithoutTask_detail_line_servicesInput, TaskUncheckedCreateWithoutTask_detail_line_servicesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_line_servicesInput
    upsert?: TaskUpsertWithoutTask_detail_line_servicesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_detail_line_servicesInput, TaskUpdateWithoutTask_detail_line_servicesInput>, TaskUncheckedUpdateWithoutTask_detail_line_servicesInput>
  }

  export type LineServicesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput> | LineServicesLinemanCreateWithoutTask_detailInput[] | LineServicesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LineServicesLinemanCreateOrConnectWithoutTask_detailInput | LineServicesLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: LineServicesLinemanUpsertWithWhereUniqueWithoutTask_detailInput | LineServicesLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: LineServicesLinemanCreateManyTask_detailInputEnvelope
    set?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    disconnect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    delete?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    connect?: LineServicesLinemanWhereUniqueInput | LineServicesLinemanWhereUniqueInput[]
    update?: LineServicesLinemanUpdateWithWhereUniqueWithoutTask_detailInput | LineServicesLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: LineServicesLinemanUpdateManyWithWhereWithoutTask_detailInput | LineServicesLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
  }

  export type TaskDetailLineServicesCreateNestedOneWithoutLinemen_inchargeInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutLinemen_inchargeInput
    connect?: TaskDetailLineServicesWhereUniqueInput
  }

  export type LinemanCreateNestedOneWithoutLine_servicesInput = {
    create?: XOR<LinemanCreateWithoutLine_servicesInput, LinemanUncheckedCreateWithoutLine_servicesInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutLine_servicesInput
    connect?: LinemanWhereUniqueInput
  }

  export type TaskDetailLineServicesUpdateOneRequiredWithoutLinemen_inchargeNestedInput = {
    create?: XOR<TaskDetailLineServicesCreateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailLineServicesCreateOrConnectWithoutLinemen_inchargeInput
    upsert?: TaskDetailLineServicesUpsertWithoutLinemen_inchargeInput
    connect?: TaskDetailLineServicesWhereUniqueInput
    update?: XOR<XOR<TaskDetailLineServicesUpdateToOneWithWhereWithoutLinemen_inchargeInput, TaskDetailLineServicesUpdateWithoutLinemen_inchargeInput>, TaskDetailLineServicesUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type LinemanUpdateOneRequiredWithoutLine_servicesNestedInput = {
    create?: XOR<LinemanCreateWithoutLine_servicesInput, LinemanUncheckedCreateWithoutLine_servicesInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutLine_servicesInput
    upsert?: LinemanUpsertWithoutLine_servicesInput
    connect?: LinemanWhereUniqueInput
    update?: XOR<XOR<LinemanUpdateToOneWithWhereWithoutLine_servicesInput, LinemanUpdateWithoutLine_servicesInput>, LinemanUncheckedUpdateWithoutLine_servicesInput>
  }

  export type DlesLinemanCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput> | DlesLinemanCreateWithoutTask_detailInput[] | DlesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutTask_detailInput | DlesLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: DlesLinemanCreateManyTask_detailInputEnvelope
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
  }

  export type TaskCreateNestedOneWithoutTask_detail_dlesInput = {
    create?: XOR<TaskCreateWithoutTask_detail_dlesInput, TaskUncheckedCreateWithoutTask_detail_dlesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_dlesInput
    connect?: TaskWhereUniqueInput
  }

  export type DlesLinemanUncheckedCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput> | DlesLinemanCreateWithoutTask_detailInput[] | DlesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutTask_detailInput | DlesLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: DlesLinemanCreateManyTask_detailInputEnvelope
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
  }

  export type DlesLinemanUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput> | DlesLinemanCreateWithoutTask_detailInput[] | DlesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutTask_detailInput | DlesLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: DlesLinemanUpsertWithWhereUniqueWithoutTask_detailInput | DlesLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: DlesLinemanCreateManyTask_detailInputEnvelope
    set?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    disconnect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    delete?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    update?: DlesLinemanUpdateWithWhereUniqueWithoutTask_detailInput | DlesLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: DlesLinemanUpdateManyWithWhereWithoutTask_detailInput | DlesLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
  }

  export type TaskUpdateOneRequiredWithoutTask_detail_dlesNestedInput = {
    create?: XOR<TaskCreateWithoutTask_detail_dlesInput, TaskUncheckedCreateWithoutTask_detail_dlesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_dlesInput
    upsert?: TaskUpsertWithoutTask_detail_dlesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_detail_dlesInput, TaskUpdateWithoutTask_detail_dlesInput>, TaskUncheckedUpdateWithoutTask_detail_dlesInput>
  }

  export type DlesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput> | DlesLinemanCreateWithoutTask_detailInput[] | DlesLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: DlesLinemanCreateOrConnectWithoutTask_detailInput | DlesLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: DlesLinemanUpsertWithWhereUniqueWithoutTask_detailInput | DlesLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: DlesLinemanCreateManyTask_detailInputEnvelope
    set?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    disconnect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    delete?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    connect?: DlesLinemanWhereUniqueInput | DlesLinemanWhereUniqueInput[]
    update?: DlesLinemanUpdateWithWhereUniqueWithoutTask_detailInput | DlesLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: DlesLinemanUpdateManyWithWhereWithoutTask_detailInput | DlesLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
  }

  export type TaskDetailDlesCreateNestedOneWithoutLinemen_inchargeInput = {
    create?: XOR<TaskDetailDlesCreateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutLinemen_inchargeInput
    connect?: TaskDetailDlesWhereUniqueInput
  }

  export type LinemanCreateNestedOneWithoutDlesInput = {
    create?: XOR<LinemanCreateWithoutDlesInput, LinemanUncheckedCreateWithoutDlesInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutDlesInput
    connect?: LinemanWhereUniqueInput
  }

  export type TaskDetailDlesUpdateOneRequiredWithoutLinemen_inchargeNestedInput = {
    create?: XOR<TaskDetailDlesCreateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailDlesCreateOrConnectWithoutLinemen_inchargeInput
    upsert?: TaskDetailDlesUpsertWithoutLinemen_inchargeInput
    connect?: TaskDetailDlesWhereUniqueInput
    update?: XOR<XOR<TaskDetailDlesUpdateToOneWithWhereWithoutLinemen_inchargeInput, TaskDetailDlesUpdateWithoutLinemen_inchargeInput>, TaskDetailDlesUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type LinemanUpdateOneRequiredWithoutDlesNestedInput = {
    create?: XOR<LinemanCreateWithoutDlesInput, LinemanUncheckedCreateWithoutDlesInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutDlesInput
    upsert?: LinemanUpsertWithoutDlesInput
    connect?: LinemanWhereUniqueInput
    update?: XOR<XOR<LinemanUpdateToOneWithWhereWithoutDlesInput, LinemanUpdateWithoutDlesInput>, LinemanUncheckedUpdateWithoutDlesInput>
  }

  export type LmdgaLinemanCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput> | LmdgaLinemanCreateWithoutTask_detailInput[] | LmdgaLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutTask_detailInput | LmdgaLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: LmdgaLinemanCreateManyTask_detailInputEnvelope
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
  }

  export type FeederCreateNestedOneWithoutLmdga_tasksInput = {
    create?: XOR<FeederCreateWithoutLmdga_tasksInput, FeederUncheckedCreateWithoutLmdga_tasksInput>
    connectOrCreate?: FeederCreateOrConnectWithoutLmdga_tasksInput
    connect?: FeederWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTask_detail_lmdgaInput = {
    create?: XOR<TaskCreateWithoutTask_detail_lmdgaInput, TaskUncheckedCreateWithoutTask_detail_lmdgaInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_lmdgaInput
    connect?: TaskWhereUniqueInput
  }

  export type LmdgaLinemanUncheckedCreateNestedManyWithoutTask_detailInput = {
    create?: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput> | LmdgaLinemanCreateWithoutTask_detailInput[] | LmdgaLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutTask_detailInput | LmdgaLinemanCreateOrConnectWithoutTask_detailInput[]
    createMany?: LmdgaLinemanCreateManyTask_detailInputEnvelope
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
  }

  export type LmdgaLinemanUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput> | LmdgaLinemanCreateWithoutTask_detailInput[] | LmdgaLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutTask_detailInput | LmdgaLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: LmdgaLinemanUpsertWithWhereUniqueWithoutTask_detailInput | LmdgaLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: LmdgaLinemanCreateManyTask_detailInputEnvelope
    set?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    disconnect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    delete?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    update?: LmdgaLinemanUpdateWithWhereUniqueWithoutTask_detailInput | LmdgaLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: LmdgaLinemanUpdateManyWithWhereWithoutTask_detailInput | LmdgaLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
  }

  export type FeederUpdateOneRequiredWithoutLmdga_tasksNestedInput = {
    create?: XOR<FeederCreateWithoutLmdga_tasksInput, FeederUncheckedCreateWithoutLmdga_tasksInput>
    connectOrCreate?: FeederCreateOrConnectWithoutLmdga_tasksInput
    upsert?: FeederUpsertWithoutLmdga_tasksInput
    connect?: FeederWhereUniqueInput
    update?: XOR<XOR<FeederUpdateToOneWithWhereWithoutLmdga_tasksInput, FeederUpdateWithoutLmdga_tasksInput>, FeederUncheckedUpdateWithoutLmdga_tasksInput>
  }

  export type TaskUpdateOneRequiredWithoutTask_detail_lmdgaNestedInput = {
    create?: XOR<TaskCreateWithoutTask_detail_lmdgaInput, TaskUncheckedCreateWithoutTask_detail_lmdgaInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_detail_lmdgaInput
    upsert?: TaskUpsertWithoutTask_detail_lmdgaInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_detail_lmdgaInput, TaskUpdateWithoutTask_detail_lmdgaInput>, TaskUncheckedUpdateWithoutTask_detail_lmdgaInput>
  }

  export type LmdgaLinemanUncheckedUpdateManyWithoutTask_detailNestedInput = {
    create?: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput> | LmdgaLinemanCreateWithoutTask_detailInput[] | LmdgaLinemanUncheckedCreateWithoutTask_detailInput[]
    connectOrCreate?: LmdgaLinemanCreateOrConnectWithoutTask_detailInput | LmdgaLinemanCreateOrConnectWithoutTask_detailInput[]
    upsert?: LmdgaLinemanUpsertWithWhereUniqueWithoutTask_detailInput | LmdgaLinemanUpsertWithWhereUniqueWithoutTask_detailInput[]
    createMany?: LmdgaLinemanCreateManyTask_detailInputEnvelope
    set?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    disconnect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    delete?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    connect?: LmdgaLinemanWhereUniqueInput | LmdgaLinemanWhereUniqueInput[]
    update?: LmdgaLinemanUpdateWithWhereUniqueWithoutTask_detailInput | LmdgaLinemanUpdateWithWhereUniqueWithoutTask_detailInput[]
    updateMany?: LmdgaLinemanUpdateManyWithWhereWithoutTask_detailInput | LmdgaLinemanUpdateManyWithWhereWithoutTask_detailInput[]
    deleteMany?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
  }

  export type TaskDetailLmdgaCreateNestedOneWithoutLinemen_inchargeInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutLinemen_inchargeInput
    connect?: TaskDetailLmdgaWhereUniqueInput
  }

  export type LinemanCreateNestedOneWithoutLmdgasInput = {
    create?: XOR<LinemanCreateWithoutLmdgasInput, LinemanUncheckedCreateWithoutLmdgasInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutLmdgasInput
    connect?: LinemanWhereUniqueInput
  }

  export type TaskDetailLmdgaUpdateOneRequiredWithoutLinemen_inchargeNestedInput = {
    create?: XOR<TaskDetailLmdgaCreateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedCreateWithoutLinemen_inchargeInput>
    connectOrCreate?: TaskDetailLmdgaCreateOrConnectWithoutLinemen_inchargeInput
    upsert?: TaskDetailLmdgaUpsertWithoutLinemen_inchargeInput
    connect?: TaskDetailLmdgaWhereUniqueInput
    update?: XOR<XOR<TaskDetailLmdgaUpdateToOneWithWhereWithoutLinemen_inchargeInput, TaskDetailLmdgaUpdateWithoutLinemen_inchargeInput>, TaskDetailLmdgaUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type LinemanUpdateOneRequiredWithoutLmdgasNestedInput = {
    create?: XOR<LinemanCreateWithoutLmdgasInput, LinemanUncheckedCreateWithoutLmdgasInput>
    connectOrCreate?: LinemanCreateOrConnectWithoutLmdgasInput
    upsert?: LinemanUpsertWithoutLmdgasInput
    connect?: LinemanWhereUniqueInput
    update?: XOR<XOR<LinemanUpdateToOneWithWhereWithoutLmdgasInput, LinemanUpdateWithoutLmdgasInput>, LinemanUncheckedUpdateWithoutLmdgasInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLinemanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LinemanStatus | EnumLinemanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLinemanStatusFilter<$PrismaModel> | $Enums.LinemanStatus
  }

  export type NestedEnumLinemanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinemanStatus | EnumLinemanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinemanStatus[] | ListEnumLinemanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLinemanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LinemanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLinemanStatusFilter<$PrismaModel>
    _max?: NestedEnumLinemanStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AreaCreateWithoutLinemenInput = {
    id?: string
    oic_id: string
    name: string
    municipalities?: MunicipalityCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutLinemenInput = {
    id?: string
    oic_id: string
    name: string
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutLinemenInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutLinemenInput, AreaUncheckedCreateWithoutLinemenInput>
  }

  export type PowerInterruptionLinemanCreateWithoutLinemanInput = {
    task_detail: TaskDetailPowerInterruptionCreateNestedOneWithoutLinemen_inchargeInput
  }

  export type PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type PowerInterruptionLinemanCreateOrConnectWithoutLinemanInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    create: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type PowerInterruptionLinemanCreateManyLinemanInputEnvelope = {
    data: PowerInterruptionLinemanCreateManyLinemanInput | PowerInterruptionLinemanCreateManyLinemanInput[]
    skipDuplicates?: boolean
  }

  export type KwhMeterLinemanCreateWithoutLinemanInput = {
    task_detail: TaskDetailKwhMeterCreateNestedOneWithoutLinemen_inchargeInput
  }

  export type KwhMeterLinemanUncheckedCreateWithoutLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type KwhMeterLinemanCreateOrConnectWithoutLinemanInput = {
    where: KwhMeterLinemanWhereUniqueInput
    create: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type KwhMeterLinemanCreateManyLinemanInputEnvelope = {
    data: KwhMeterLinemanCreateManyLinemanInput | KwhMeterLinemanCreateManyLinemanInput[]
    skipDuplicates?: boolean
  }

  export type LineServicesLinemanCreateWithoutLinemanInput = {
    task_detail: TaskDetailLineServicesCreateNestedOneWithoutLinemen_inchargeInput
  }

  export type LineServicesLinemanUncheckedCreateWithoutLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type LineServicesLinemanCreateOrConnectWithoutLinemanInput = {
    where: LineServicesLinemanWhereUniqueInput
    create: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type LineServicesLinemanCreateManyLinemanInputEnvelope = {
    data: LineServicesLinemanCreateManyLinemanInput | LineServicesLinemanCreateManyLinemanInput[]
    skipDuplicates?: boolean
  }

  export type DlesLinemanCreateWithoutLinemanInput = {
    task_detail: TaskDetailDlesCreateNestedOneWithoutLinemen_inchargeInput
  }

  export type DlesLinemanUncheckedCreateWithoutLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type DlesLinemanCreateOrConnectWithoutLinemanInput = {
    where: DlesLinemanWhereUniqueInput
    create: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type DlesLinemanCreateManyLinemanInputEnvelope = {
    data: DlesLinemanCreateManyLinemanInput | DlesLinemanCreateManyLinemanInput[]
    skipDuplicates?: boolean
  }

  export type LmdgaLinemanCreateWithoutLinemanInput = {
    task_detail: TaskDetailLmdgaCreateNestedOneWithoutLinemen_inchargeInput
  }

  export type LmdgaLinemanUncheckedCreateWithoutLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type LmdgaLinemanCreateOrConnectWithoutLinemanInput = {
    where: LmdgaLinemanWhereUniqueInput
    create: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type LmdgaLinemanCreateManyLinemanInputEnvelope = {
    data: LmdgaLinemanCreateManyLinemanInput | LmdgaLinemanCreateManyLinemanInput[]
    skipDuplicates?: boolean
  }

  export type AreaUpsertWithoutLinemenInput = {
    update: XOR<AreaUpdateWithoutLinemenInput, AreaUncheckedUpdateWithoutLinemenInput>
    create: XOR<AreaCreateWithoutLinemenInput, AreaUncheckedCreateWithoutLinemenInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutLinemenInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutLinemenInput, AreaUncheckedUpdateWithoutLinemenInput>
  }

  export type AreaUpdateWithoutLinemenInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalities?: MunicipalityUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutLinemenInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipalities?: MunicipalityUncheckedUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type PowerInterruptionLinemanUpsertWithWhereUniqueWithoutLinemanInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    update: XOR<PowerInterruptionLinemanUpdateWithoutLinemanInput, PowerInterruptionLinemanUncheckedUpdateWithoutLinemanInput>
    create: XOR<PowerInterruptionLinemanCreateWithoutLinemanInput, PowerInterruptionLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type PowerInterruptionLinemanUpdateWithWhereUniqueWithoutLinemanInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    data: XOR<PowerInterruptionLinemanUpdateWithoutLinemanInput, PowerInterruptionLinemanUncheckedUpdateWithoutLinemanInput>
  }

  export type PowerInterruptionLinemanUpdateManyWithWhereWithoutLinemanInput = {
    where: PowerInterruptionLinemanScalarWhereInput
    data: XOR<PowerInterruptionLinemanUpdateManyMutationInput, PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanInput>
  }

  export type PowerInterruptionLinemanScalarWhereInput = {
    AND?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
    OR?: PowerInterruptionLinemanScalarWhereInput[]
    NOT?: PowerInterruptionLinemanScalarWhereInput | PowerInterruptionLinemanScalarWhereInput[]
    id?: IntFilter<"PowerInterruptionLineman"> | number
    task_detail_id?: IntFilter<"PowerInterruptionLineman"> | number
    lineman_id?: StringFilter<"PowerInterruptionLineman"> | string
  }

  export type KwhMeterLinemanUpsertWithWhereUniqueWithoutLinemanInput = {
    where: KwhMeterLinemanWhereUniqueInput
    update: XOR<KwhMeterLinemanUpdateWithoutLinemanInput, KwhMeterLinemanUncheckedUpdateWithoutLinemanInput>
    create: XOR<KwhMeterLinemanCreateWithoutLinemanInput, KwhMeterLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type KwhMeterLinemanUpdateWithWhereUniqueWithoutLinemanInput = {
    where: KwhMeterLinemanWhereUniqueInput
    data: XOR<KwhMeterLinemanUpdateWithoutLinemanInput, KwhMeterLinemanUncheckedUpdateWithoutLinemanInput>
  }

  export type KwhMeterLinemanUpdateManyWithWhereWithoutLinemanInput = {
    where: KwhMeterLinemanScalarWhereInput
    data: XOR<KwhMeterLinemanUpdateManyMutationInput, KwhMeterLinemanUncheckedUpdateManyWithoutLinemanInput>
  }

  export type KwhMeterLinemanScalarWhereInput = {
    AND?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
    OR?: KwhMeterLinemanScalarWhereInput[]
    NOT?: KwhMeterLinemanScalarWhereInput | KwhMeterLinemanScalarWhereInput[]
    id?: IntFilter<"KwhMeterLineman"> | number
    task_detail_id?: IntFilter<"KwhMeterLineman"> | number
    lineman_id?: StringFilter<"KwhMeterLineman"> | string
  }

  export type LineServicesLinemanUpsertWithWhereUniqueWithoutLinemanInput = {
    where: LineServicesLinemanWhereUniqueInput
    update: XOR<LineServicesLinemanUpdateWithoutLinemanInput, LineServicesLinemanUncheckedUpdateWithoutLinemanInput>
    create: XOR<LineServicesLinemanCreateWithoutLinemanInput, LineServicesLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type LineServicesLinemanUpdateWithWhereUniqueWithoutLinemanInput = {
    where: LineServicesLinemanWhereUniqueInput
    data: XOR<LineServicesLinemanUpdateWithoutLinemanInput, LineServicesLinemanUncheckedUpdateWithoutLinemanInput>
  }

  export type LineServicesLinemanUpdateManyWithWhereWithoutLinemanInput = {
    where: LineServicesLinemanScalarWhereInput
    data: XOR<LineServicesLinemanUpdateManyMutationInput, LineServicesLinemanUncheckedUpdateManyWithoutLinemanInput>
  }

  export type LineServicesLinemanScalarWhereInput = {
    AND?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
    OR?: LineServicesLinemanScalarWhereInput[]
    NOT?: LineServicesLinemanScalarWhereInput | LineServicesLinemanScalarWhereInput[]
    id?: IntFilter<"LineServicesLineman"> | number
    task_detail_id?: IntFilter<"LineServicesLineman"> | number
    lineman_id?: StringFilter<"LineServicesLineman"> | string
  }

  export type DlesLinemanUpsertWithWhereUniqueWithoutLinemanInput = {
    where: DlesLinemanWhereUniqueInput
    update: XOR<DlesLinemanUpdateWithoutLinemanInput, DlesLinemanUncheckedUpdateWithoutLinemanInput>
    create: XOR<DlesLinemanCreateWithoutLinemanInput, DlesLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type DlesLinemanUpdateWithWhereUniqueWithoutLinemanInput = {
    where: DlesLinemanWhereUniqueInput
    data: XOR<DlesLinemanUpdateWithoutLinemanInput, DlesLinemanUncheckedUpdateWithoutLinemanInput>
  }

  export type DlesLinemanUpdateManyWithWhereWithoutLinemanInput = {
    where: DlesLinemanScalarWhereInput
    data: XOR<DlesLinemanUpdateManyMutationInput, DlesLinemanUncheckedUpdateManyWithoutLinemanInput>
  }

  export type DlesLinemanScalarWhereInput = {
    AND?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
    OR?: DlesLinemanScalarWhereInput[]
    NOT?: DlesLinemanScalarWhereInput | DlesLinemanScalarWhereInput[]
    id?: IntFilter<"DlesLineman"> | number
    task_detail_id?: IntFilter<"DlesLineman"> | number
    lineman_id?: StringFilter<"DlesLineman"> | string
  }

  export type LmdgaLinemanUpsertWithWhereUniqueWithoutLinemanInput = {
    where: LmdgaLinemanWhereUniqueInput
    update: XOR<LmdgaLinemanUpdateWithoutLinemanInput, LmdgaLinemanUncheckedUpdateWithoutLinemanInput>
    create: XOR<LmdgaLinemanCreateWithoutLinemanInput, LmdgaLinemanUncheckedCreateWithoutLinemanInput>
  }

  export type LmdgaLinemanUpdateWithWhereUniqueWithoutLinemanInput = {
    where: LmdgaLinemanWhereUniqueInput
    data: XOR<LmdgaLinemanUpdateWithoutLinemanInput, LmdgaLinemanUncheckedUpdateWithoutLinemanInput>
  }

  export type LmdgaLinemanUpdateManyWithWhereWithoutLinemanInput = {
    where: LmdgaLinemanScalarWhereInput
    data: XOR<LmdgaLinemanUpdateManyMutationInput, LmdgaLinemanUncheckedUpdateManyWithoutLinemanInput>
  }

  export type LmdgaLinemanScalarWhereInput = {
    AND?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
    OR?: LmdgaLinemanScalarWhereInput[]
    NOT?: LmdgaLinemanScalarWhereInput | LmdgaLinemanScalarWhereInput[]
    id?: IntFilter<"LmdgaLineman"> | number
    task_detail_id?: IntFilter<"LmdgaLineman"> | number
    lineman_id?: StringFilter<"LmdgaLineman"> | string
  }

  export type LinemanCreateWithoutAreaInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutAreaInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutAreaInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput>
  }

  export type LinemanCreateManyAreaInputEnvelope = {
    data: LinemanCreateManyAreaInput | LinemanCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type MunicipalityCreateWithoutAreaInput = {
    id?: string
    name: string
    barangays?: BarangayCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutAreaInput = {
    id?: string
    name: string
    barangays?: BarangayUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutAreaInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput>
  }

  export type MunicipalityCreateManyAreaInputEnvelope = {
    data: MunicipalityCreateManyAreaInput | MunicipalityCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssignmentCreateWithoutAreaInput = {
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
    task: TaskCreateNestedOneWithoutTask_assignmentInput
  }

  export type TaskAssignmentUncheckedCreateWithoutAreaInput = {
    id?: number
    task_id: number
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutAreaInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput>
  }

  export type TaskAssignmentCreateManyAreaInputEnvelope = {
    data: TaskAssignmentCreateManyAreaInput | TaskAssignmentCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type LinemanUpsertWithWhereUniqueWithoutAreaInput = {
    where: LinemanWhereUniqueInput
    update: XOR<LinemanUpdateWithoutAreaInput, LinemanUncheckedUpdateWithoutAreaInput>
    create: XOR<LinemanCreateWithoutAreaInput, LinemanUncheckedCreateWithoutAreaInput>
  }

  export type LinemanUpdateWithWhereUniqueWithoutAreaInput = {
    where: LinemanWhereUniqueInput
    data: XOR<LinemanUpdateWithoutAreaInput, LinemanUncheckedUpdateWithoutAreaInput>
  }

  export type LinemanUpdateManyWithWhereWithoutAreaInput = {
    where: LinemanScalarWhereInput
    data: XOR<LinemanUpdateManyMutationInput, LinemanUncheckedUpdateManyWithoutAreaInput>
  }

  export type LinemanScalarWhereInput = {
    AND?: LinemanScalarWhereInput | LinemanScalarWhereInput[]
    OR?: LinemanScalarWhereInput[]
    NOT?: LinemanScalarWhereInput | LinemanScalarWhereInput[]
    id?: StringFilter<"Lineman"> | string
    employee_id?: StringFilter<"Lineman"> | string
    area_id?: StringFilter<"Lineman"> | string
    supervisor_id?: StringFilter<"Lineman"> | string
    status?: EnumLinemanStatusFilter<"Lineman"> | $Enums.LinemanStatus
  }

  export type MunicipalityUpsertWithWhereUniqueWithoutAreaInput = {
    where: MunicipalityWhereUniqueInput
    update: XOR<MunicipalityUpdateWithoutAreaInput, MunicipalityUncheckedUpdateWithoutAreaInput>
    create: XOR<MunicipalityCreateWithoutAreaInput, MunicipalityUncheckedCreateWithoutAreaInput>
  }

  export type MunicipalityUpdateWithWhereUniqueWithoutAreaInput = {
    where: MunicipalityWhereUniqueInput
    data: XOR<MunicipalityUpdateWithoutAreaInput, MunicipalityUncheckedUpdateWithoutAreaInput>
  }

  export type MunicipalityUpdateManyWithWhereWithoutAreaInput = {
    where: MunicipalityScalarWhereInput
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyWithoutAreaInput>
  }

  export type MunicipalityScalarWhereInput = {
    AND?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    OR?: MunicipalityScalarWhereInput[]
    NOT?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    id?: StringFilter<"Municipality"> | string
    area_id?: StringFilter<"Municipality"> | string
    name?: StringFilter<"Municipality"> | string
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutAreaInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutAreaInput, TaskAssignmentUncheckedUpdateWithoutAreaInput>
    create: XOR<TaskAssignmentCreateWithoutAreaInput, TaskAssignmentUncheckedCreateWithoutAreaInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutAreaInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutAreaInput, TaskAssignmentUncheckedUpdateWithoutAreaInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutAreaInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutAreaInput>
  }

  export type TaskAssignmentScalarWhereInput = {
    AND?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    OR?: TaskAssignmentScalarWhereInput[]
    NOT?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    id?: IntFilter<"TaskAssignment"> | number
    task_id?: IntFilter<"TaskAssignment"> | number
    area_id?: StringNullableFilter<"TaskAssignment"> | string | null
    department_id?: StringNullableFilter<"TaskAssignment"> | string | null
    division_id?: StringNullableFilter<"TaskAssignment"> | string | null
    created_by?: StringFilter<"TaskAssignment"> | string
    created_at?: DateTimeFilter<"TaskAssignment"> | Date | string
  }

  export type AreaCreateWithoutMunicipalitiesInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutMunicipalitiesInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanUncheckedCreateNestedManyWithoutAreaInput
    task_assignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutMunicipalitiesInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutMunicipalitiesInput, AreaUncheckedCreateWithoutMunicipalitiesInput>
  }

  export type BarangayCreateWithoutMunicipalityInput = {
    id?: string
    name: string
    sitios?: SitioCreateNestedManyWithoutBarangayInput
    complaint_details?: ComplaintDetailCreateNestedManyWithoutBarangayInput
  }

  export type BarangayUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    name: string
    sitios?: SitioUncheckedCreateNestedManyWithoutBarangayInput
    complaint_details?: ComplaintDetailUncheckedCreateNestedManyWithoutBarangayInput
  }

  export type BarangayCreateOrConnectWithoutMunicipalityInput = {
    where: BarangayWhereUniqueInput
    create: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput>
  }

  export type BarangayCreateManyMunicipalityInputEnvelope = {
    data: BarangayCreateManyMunicipalityInput | BarangayCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type AreaUpsertWithoutMunicipalitiesInput = {
    update: XOR<AreaUpdateWithoutMunicipalitiesInput, AreaUncheckedUpdateWithoutMunicipalitiesInput>
    create: XOR<AreaCreateWithoutMunicipalitiesInput, AreaUncheckedCreateWithoutMunicipalitiesInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutMunicipalitiesInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutMunicipalitiesInput, AreaUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type AreaUpdateWithoutMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutMunicipalitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUncheckedUpdateManyWithoutAreaNestedInput
    task_assignments?: TaskAssignmentUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type BarangayUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: BarangayWhereUniqueInput
    update: XOR<BarangayUpdateWithoutMunicipalityInput, BarangayUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<BarangayCreateWithoutMunicipalityInput, BarangayUncheckedCreateWithoutMunicipalityInput>
  }

  export type BarangayUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: BarangayWhereUniqueInput
    data: XOR<BarangayUpdateWithoutMunicipalityInput, BarangayUncheckedUpdateWithoutMunicipalityInput>
  }

  export type BarangayUpdateManyWithWhereWithoutMunicipalityInput = {
    where: BarangayScalarWhereInput
    data: XOR<BarangayUpdateManyMutationInput, BarangayUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type BarangayScalarWhereInput = {
    AND?: BarangayScalarWhereInput | BarangayScalarWhereInput[]
    OR?: BarangayScalarWhereInput[]
    NOT?: BarangayScalarWhereInput | BarangayScalarWhereInput[]
    id?: StringFilter<"Barangay"> | string
    municipality_id?: StringFilter<"Barangay"> | string
    name?: StringFilter<"Barangay"> | string
  }

  export type MunicipalityCreateWithoutBarangaysInput = {
    id?: string
    name: string
    area: AreaCreateNestedOneWithoutMunicipalitiesInput
  }

  export type MunicipalityUncheckedCreateWithoutBarangaysInput = {
    id?: string
    area_id: string
    name: string
  }

  export type MunicipalityCreateOrConnectWithoutBarangaysInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutBarangaysInput, MunicipalityUncheckedCreateWithoutBarangaysInput>
  }

  export type SitioCreateWithoutBarangayInput = {
    id?: string
    name: string
    complaint_details?: ComplaintDetailCreateNestedManyWithoutSitioInput
  }

  export type SitioUncheckedCreateWithoutBarangayInput = {
    id?: string
    name: string
    complaint_details?: ComplaintDetailUncheckedCreateNestedManyWithoutSitioInput
  }

  export type SitioCreateOrConnectWithoutBarangayInput = {
    where: SitioWhereUniqueInput
    create: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput>
  }

  export type SitioCreateManyBarangayInputEnvelope = {
    data: SitioCreateManyBarangayInput | SitioCreateManyBarangayInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintDetailCreateWithoutBarangayInput = {
    consumer_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    complaint: ComplaintCreateNestedOneWithoutComplaint_detailInput
    sitio?: SitioCreateNestedOneWithoutComplaint_detailsInput
  }

  export type ComplaintDetailUncheckedCreateWithoutBarangayInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    sitio_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailCreateOrConnectWithoutBarangayInput = {
    where: ComplaintDetailWhereUniqueInput
    create: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput>
  }

  export type ComplaintDetailCreateManyBarangayInputEnvelope = {
    data: ComplaintDetailCreateManyBarangayInput | ComplaintDetailCreateManyBarangayInput[]
    skipDuplicates?: boolean
  }

  export type MunicipalityUpsertWithoutBarangaysInput = {
    update: XOR<MunicipalityUpdateWithoutBarangaysInput, MunicipalityUncheckedUpdateWithoutBarangaysInput>
    create: XOR<MunicipalityCreateWithoutBarangaysInput, MunicipalityUncheckedCreateWithoutBarangaysInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutBarangaysInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutBarangaysInput, MunicipalityUncheckedUpdateWithoutBarangaysInput>
  }

  export type MunicipalityUpdateWithoutBarangaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    area?: AreaUpdateOneRequiredWithoutMunicipalitiesNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutBarangaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SitioUpsertWithWhereUniqueWithoutBarangayInput = {
    where: SitioWhereUniqueInput
    update: XOR<SitioUpdateWithoutBarangayInput, SitioUncheckedUpdateWithoutBarangayInput>
    create: XOR<SitioCreateWithoutBarangayInput, SitioUncheckedCreateWithoutBarangayInput>
  }

  export type SitioUpdateWithWhereUniqueWithoutBarangayInput = {
    where: SitioWhereUniqueInput
    data: XOR<SitioUpdateWithoutBarangayInput, SitioUncheckedUpdateWithoutBarangayInput>
  }

  export type SitioUpdateManyWithWhereWithoutBarangayInput = {
    where: SitioScalarWhereInput
    data: XOR<SitioUpdateManyMutationInput, SitioUncheckedUpdateManyWithoutBarangayInput>
  }

  export type SitioScalarWhereInput = {
    AND?: SitioScalarWhereInput | SitioScalarWhereInput[]
    OR?: SitioScalarWhereInput[]
    NOT?: SitioScalarWhereInput | SitioScalarWhereInput[]
    id?: StringFilter<"Sitio"> | string
    barangay_id?: StringFilter<"Sitio"> | string
    name?: StringFilter<"Sitio"> | string
  }

  export type ComplaintDetailUpsertWithWhereUniqueWithoutBarangayInput = {
    where: ComplaintDetailWhereUniqueInput
    update: XOR<ComplaintDetailUpdateWithoutBarangayInput, ComplaintDetailUncheckedUpdateWithoutBarangayInput>
    create: XOR<ComplaintDetailCreateWithoutBarangayInput, ComplaintDetailUncheckedCreateWithoutBarangayInput>
  }

  export type ComplaintDetailUpdateWithWhereUniqueWithoutBarangayInput = {
    where: ComplaintDetailWhereUniqueInput
    data: XOR<ComplaintDetailUpdateWithoutBarangayInput, ComplaintDetailUncheckedUpdateWithoutBarangayInput>
  }

  export type ComplaintDetailUpdateManyWithWhereWithoutBarangayInput = {
    where: ComplaintDetailScalarWhereInput
    data: XOR<ComplaintDetailUpdateManyMutationInput, ComplaintDetailUncheckedUpdateManyWithoutBarangayInput>
  }

  export type ComplaintDetailScalarWhereInput = {
    AND?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
    OR?: ComplaintDetailScalarWhereInput[]
    NOT?: ComplaintDetailScalarWhereInput | ComplaintDetailScalarWhereInput[]
    id?: IntFilter<"ComplaintDetail"> | number
    complaint_id?: IntFilter<"ComplaintDetail"> | number
    consumer_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    barangay_id?: StringFilter<"ComplaintDetail"> | string
    sitio_id?: StringNullableFilter<"ComplaintDetail"> | string | null
    landmark?: StringNullableFilter<"ComplaintDetail"> | string | null
    created_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
    updated_at?: DateTimeFilter<"ComplaintDetail"> | Date | string
  }

  export type BarangayCreateWithoutSitiosInput = {
    id?: string
    name: string
    municipality: MunicipalityCreateNestedOneWithoutBarangaysInput
    complaint_details?: ComplaintDetailCreateNestedManyWithoutBarangayInput
  }

  export type BarangayUncheckedCreateWithoutSitiosInput = {
    id?: string
    municipality_id: string
    name: string
    complaint_details?: ComplaintDetailUncheckedCreateNestedManyWithoutBarangayInput
  }

  export type BarangayCreateOrConnectWithoutSitiosInput = {
    where: BarangayWhereUniqueInput
    create: XOR<BarangayCreateWithoutSitiosInput, BarangayUncheckedCreateWithoutSitiosInput>
  }

  export type ComplaintDetailCreateWithoutSitioInput = {
    consumer_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    complaint: ComplaintCreateNestedOneWithoutComplaint_detailInput
    barangay: BarangayCreateNestedOneWithoutComplaint_detailsInput
  }

  export type ComplaintDetailUncheckedCreateWithoutSitioInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    barangay_id: string
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailCreateOrConnectWithoutSitioInput = {
    where: ComplaintDetailWhereUniqueInput
    create: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput>
  }

  export type ComplaintDetailCreateManySitioInputEnvelope = {
    data: ComplaintDetailCreateManySitioInput | ComplaintDetailCreateManySitioInput[]
    skipDuplicates?: boolean
  }

  export type BarangayUpsertWithoutSitiosInput = {
    update: XOR<BarangayUpdateWithoutSitiosInput, BarangayUncheckedUpdateWithoutSitiosInput>
    create: XOR<BarangayCreateWithoutSitiosInput, BarangayUncheckedCreateWithoutSitiosInput>
    where?: BarangayWhereInput
  }

  export type BarangayUpdateToOneWithWhereWithoutSitiosInput = {
    where?: BarangayWhereInput
    data: XOR<BarangayUpdateWithoutSitiosInput, BarangayUncheckedUpdateWithoutSitiosInput>
  }

  export type BarangayUpdateWithoutSitiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipality?: MunicipalityUpdateOneRequiredWithoutBarangaysNestedInput
    complaint_details?: ComplaintDetailUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayUncheckedUpdateWithoutSitiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    municipality_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    complaint_details?: ComplaintDetailUncheckedUpdateManyWithoutBarangayNestedInput
  }

  export type ComplaintDetailUpsertWithWhereUniqueWithoutSitioInput = {
    where: ComplaintDetailWhereUniqueInput
    update: XOR<ComplaintDetailUpdateWithoutSitioInput, ComplaintDetailUncheckedUpdateWithoutSitioInput>
    create: XOR<ComplaintDetailCreateWithoutSitioInput, ComplaintDetailUncheckedCreateWithoutSitioInput>
  }

  export type ComplaintDetailUpdateWithWhereUniqueWithoutSitioInput = {
    where: ComplaintDetailWhereUniqueInput
    data: XOR<ComplaintDetailUpdateWithoutSitioInput, ComplaintDetailUncheckedUpdateWithoutSitioInput>
  }

  export type ComplaintDetailUpdateManyWithWhereWithoutSitioInput = {
    where: ComplaintDetailScalarWhereInput
    data: XOR<ComplaintDetailUpdateManyMutationInput, ComplaintDetailUncheckedUpdateManyWithoutSitioInput>
  }

  export type TaskDetailPowerInterruptionCreateWithoutFeederInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput
    weather_condition: WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput
    device: DeviceCreateNestedOneWithoutPower_interruption_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_power_interruptionInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput = {
    id?: number
    task_id: number
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailPowerInterruptionCreateOrConnectWithoutFeederInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    create: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput>
  }

  export type TaskDetailPowerInterruptionCreateManyFeederInputEnvelope = {
    data: TaskDetailPowerInterruptionCreateManyFeederInput | TaskDetailPowerInterruptionCreateManyFeederInput[]
    skipDuplicates?: boolean
  }

  export type TaskDetailLmdgaCreateWithoutFeederInput = {
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanCreateNestedManyWithoutTask_detailInput
    task: TaskCreateNestedOneWithoutTask_detail_lmdgaInput
  }

  export type TaskDetailLmdgaUncheckedCreateWithoutFeederInput = {
    id?: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLmdgaCreateOrConnectWithoutFeederInput = {
    where: TaskDetailLmdgaWhereUniqueInput
    create: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput>
  }

  export type TaskDetailLmdgaCreateManyFeederInputEnvelope = {
    data: TaskDetailLmdgaCreateManyFeederInput | TaskDetailLmdgaCreateManyFeederInput[]
    skipDuplicates?: boolean
  }

  export type TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutFeederInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    update: XOR<TaskDetailPowerInterruptionUpdateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutFeederInput>
    create: XOR<TaskDetailPowerInterruptionCreateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedCreateWithoutFeederInput>
  }

  export type TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutFeederInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    data: XOR<TaskDetailPowerInterruptionUpdateWithoutFeederInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutFeederInput>
  }

  export type TaskDetailPowerInterruptionUpdateManyWithWhereWithoutFeederInput = {
    where: TaskDetailPowerInterruptionScalarWhereInput
    data: XOR<TaskDetailPowerInterruptionUpdateManyMutationInput, TaskDetailPowerInterruptionUncheckedUpdateManyWithoutFeederInput>
  }

  export type TaskDetailPowerInterruptionScalarWhereInput = {
    AND?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
    OR?: TaskDetailPowerInterruptionScalarWhereInput[]
    NOT?: TaskDetailPowerInterruptionScalarWhereInput | TaskDetailPowerInterruptionScalarWhereInput[]
    id?: IntFilter<"TaskDetailPowerInterruption"> | number
    task_id?: IntFilter<"TaskDetailPowerInterruption"> | number
    feeder_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    weather_condition_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    device_id?: StringFilter<"TaskDetailPowerInterruption"> | string
    affected_area?: StringFilter<"TaskDetailPowerInterruption"> | string
    cause?: StringFilter<"TaskDetailPowerInterruption"> | string
    equipment_failed?: StringFilter<"TaskDetailPowerInterruption"> | string
    fuse_rating?: StringFilter<"TaskDetailPowerInterruption"> | string
  }

  export type TaskDetailLmdgaUpsertWithWhereUniqueWithoutFeederInput = {
    where: TaskDetailLmdgaWhereUniqueInput
    update: XOR<TaskDetailLmdgaUpdateWithoutFeederInput, TaskDetailLmdgaUncheckedUpdateWithoutFeederInput>
    create: XOR<TaskDetailLmdgaCreateWithoutFeederInput, TaskDetailLmdgaUncheckedCreateWithoutFeederInput>
  }

  export type TaskDetailLmdgaUpdateWithWhereUniqueWithoutFeederInput = {
    where: TaskDetailLmdgaWhereUniqueInput
    data: XOR<TaskDetailLmdgaUpdateWithoutFeederInput, TaskDetailLmdgaUncheckedUpdateWithoutFeederInput>
  }

  export type TaskDetailLmdgaUpdateManyWithWhereWithoutFeederInput = {
    where: TaskDetailLmdgaScalarWhereInput
    data: XOR<TaskDetailLmdgaUpdateManyMutationInput, TaskDetailLmdgaUncheckedUpdateManyWithoutFeederInput>
  }

  export type TaskDetailLmdgaScalarWhereInput = {
    AND?: TaskDetailLmdgaScalarWhereInput | TaskDetailLmdgaScalarWhereInput[]
    OR?: TaskDetailLmdgaScalarWhereInput[]
    NOT?: TaskDetailLmdgaScalarWhereInput | TaskDetailLmdgaScalarWhereInput[]
    id?: IntFilter<"TaskDetailLmdga"> | number
    task_id?: IntFilter<"TaskDetailLmdga"> | number
    kva_rating?: StringFilter<"TaskDetailLmdga"> | string
    substation_id?: StringFilter<"TaskDetailLmdga"> | string
    dt_location?: StringFilter<"TaskDetailLmdga"> | string
    feeder_id?: StringFilter<"TaskDetailLmdga"> | string
    phase_number?: StringFilter<"TaskDetailLmdga"> | string
    number_of_hc?: StringFilter<"TaskDetailLmdga"> | string
    number_of_spans?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_primary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_secondary?: StringFilter<"TaskDetailLmdga"> | string
    copper_aluminum_ground?: StringFilter<"TaskDetailLmdga"> | string
    size_primary?: StringFilter<"TaskDetailLmdga"> | string
    size_secondary?: StringFilter<"TaskDetailLmdga"> | string
    size_ground?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_primary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_secondary?: StringFilter<"TaskDetailLmdga"> | string
    terminal_connector_ground?: StringFilter<"TaskDetailLmdga"> | string
    tap_position?: StringFilter<"TaskDetailLmdga"> | string
    brand?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_primary?: StringFilter<"TaskDetailLmdga"> | string
    number_of_bushing_secondary?: StringFilter<"TaskDetailLmdga"> | string
    protective_device?: StringFilter<"TaskDetailLmdga"> | string
    load_current_sec_bushing?: StringFilter<"TaskDetailLmdga"> | string
    load_current_neutral?: StringFilter<"TaskDetailLmdga"> | string
    load_current_one?: StringFilter<"TaskDetailLmdga"> | string
    load_current_two?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_one?: StringFilter<"TaskDetailLmdga"> | string
    voltage_level_two?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_one?: StringFilter<"TaskDetailLmdga"> | string
    sec_line_conductor_size_two?: StringFilter<"TaskDetailLmdga"> | string
  }

  export type TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutPower_interruption_tasksInput
    device: DeviceCreateNestedOneWithoutPower_interruption_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_power_interruptionInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput = {
    id?: number
    task_id: number
    feeder_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailPowerInterruptionCreateOrConnectWithoutWeather_conditionInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    create: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput>
  }

  export type TaskDetailPowerInterruptionCreateManyWeather_conditionInputEnvelope = {
    data: TaskDetailPowerInterruptionCreateManyWeather_conditionInput | TaskDetailPowerInterruptionCreateManyWeather_conditionInput[]
    skipDuplicates?: boolean
  }

  export type TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutWeather_conditionInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    update: XOR<TaskDetailPowerInterruptionUpdateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutWeather_conditionInput>
    create: XOR<TaskDetailPowerInterruptionCreateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedCreateWithoutWeather_conditionInput>
  }

  export type TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutWeather_conditionInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    data: XOR<TaskDetailPowerInterruptionUpdateWithoutWeather_conditionInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutWeather_conditionInput>
  }

  export type TaskDetailPowerInterruptionUpdateManyWithWhereWithoutWeather_conditionInput = {
    where: TaskDetailPowerInterruptionScalarWhereInput
    data: XOR<TaskDetailPowerInterruptionUpdateManyMutationInput, TaskDetailPowerInterruptionUncheckedUpdateManyWithoutWeather_conditionInput>
  }

  export type TaskDetailPowerInterruptionCreateWithoutDeviceInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutPower_interruption_tasksInput
    weather_condition: WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_power_interruptionInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput = {
    id?: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailPowerInterruptionCreateOrConnectWithoutDeviceInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    create: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput>
  }

  export type TaskDetailPowerInterruptionCreateManyDeviceInputEnvelope = {
    data: TaskDetailPowerInterruptionCreateManyDeviceInput | TaskDetailPowerInterruptionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type TaskDetailPowerInterruptionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    update: XOR<TaskDetailPowerInterruptionUpdateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutDeviceInput>
    create: XOR<TaskDetailPowerInterruptionCreateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedCreateWithoutDeviceInput>
  }

  export type TaskDetailPowerInterruptionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    data: XOR<TaskDetailPowerInterruptionUpdateWithoutDeviceInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutDeviceInput>
  }

  export type TaskDetailPowerInterruptionUpdateManyWithWhereWithoutDeviceInput = {
    where: TaskDetailPowerInterruptionScalarWhereInput
    data: XOR<TaskDetailPowerInterruptionUpdateManyMutationInput, TaskDetailPowerInterruptionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type TaskDetailKwhMeterCreateWithoutMeter_brandInput = {
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanCreateNestedManyWithoutTask_detailInput
    task: TaskCreateNestedOneWithoutTask_detail_kwh_meterInput
  }

  export type TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput = {
    id?: number
    task_id: number
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailKwhMeterCreateOrConnectWithoutMeter_brandInput = {
    where: TaskDetailKwhMeterWhereUniqueInput
    create: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput>
  }

  export type TaskDetailKwhMeterCreateManyMeter_brandInputEnvelope = {
    data: TaskDetailKwhMeterCreateManyMeter_brandInput | TaskDetailKwhMeterCreateManyMeter_brandInput[]
    skipDuplicates?: boolean
  }

  export type TaskDetailKwhMeterUpsertWithWhereUniqueWithoutMeter_brandInput = {
    where: TaskDetailKwhMeterWhereUniqueInput
    update: XOR<TaskDetailKwhMeterUpdateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedUpdateWithoutMeter_brandInput>
    create: XOR<TaskDetailKwhMeterCreateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedCreateWithoutMeter_brandInput>
  }

  export type TaskDetailKwhMeterUpdateWithWhereUniqueWithoutMeter_brandInput = {
    where: TaskDetailKwhMeterWhereUniqueInput
    data: XOR<TaskDetailKwhMeterUpdateWithoutMeter_brandInput, TaskDetailKwhMeterUncheckedUpdateWithoutMeter_brandInput>
  }

  export type TaskDetailKwhMeterUpdateManyWithWhereWithoutMeter_brandInput = {
    where: TaskDetailKwhMeterScalarWhereInput
    data: XOR<TaskDetailKwhMeterUpdateManyMutationInput, TaskDetailKwhMeterUncheckedUpdateManyWithoutMeter_brandInput>
  }

  export type TaskDetailKwhMeterScalarWhereInput = {
    AND?: TaskDetailKwhMeterScalarWhereInput | TaskDetailKwhMeterScalarWhereInput[]
    OR?: TaskDetailKwhMeterScalarWhereInput[]
    NOT?: TaskDetailKwhMeterScalarWhereInput | TaskDetailKwhMeterScalarWhereInput[]
    id?: IntFilter<"TaskDetailKwhMeter"> | number
    task_id?: IntFilter<"TaskDetailKwhMeter"> | number
    meter_number?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_brand_id?: StringFilter<"TaskDetailKwhMeter"> | string
    last_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    initial_reading?: StringFilter<"TaskDetailKwhMeter"> | string
    meter_class?: StringFilter<"TaskDetailKwhMeter"> | string
  }

  export type ActivityCategoryCreateWithoutActivitiesInput = {
    id: number
    name: string
  }

  export type ActivityCategoryUncheckedCreateWithoutActivitiesInput = {
    id: number
    name: string
  }

  export type ActivityCategoryCreateOrConnectWithoutActivitiesInput = {
    where: ActivityCategoryWhereUniqueInput
    create: XOR<ActivityCategoryCreateWithoutActivitiesInput, ActivityCategoryUncheckedCreateWithoutActivitiesInput>
  }

  export type TaskCreateWithoutActivityInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutActivityInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutActivityInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput>
  }

  export type TaskCreateManyActivityInputEnvelope = {
    data: TaskCreateManyActivityInput | TaskCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCategoryUpsertWithoutActivitiesInput = {
    update: XOR<ActivityCategoryUpdateWithoutActivitiesInput, ActivityCategoryUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ActivityCategoryCreateWithoutActivitiesInput, ActivityCategoryUncheckedCreateWithoutActivitiesInput>
    where?: ActivityCategoryWhereInput
  }

  export type ActivityCategoryUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ActivityCategoryWhereInput
    data: XOR<ActivityCategoryUpdateWithoutActivitiesInput, ActivityCategoryUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityCategoryUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCategoryUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpsertWithWhereUniqueWithoutActivityInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutActivityInput, TaskUncheckedUpdateWithoutActivityInput>
    create: XOR<TaskCreateWithoutActivityInput, TaskUncheckedCreateWithoutActivityInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutActivityInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutActivityInput, TaskUncheckedUpdateWithoutActivityInput>
  }

  export type TaskUpdateManyWithWhereWithoutActivityInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutActivityInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    ref_number?: StringFilter<"Task"> | string
    complaint_id?: IntNullableFilter<"Task"> | number | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    task_status_id?: IntFilter<"Task"> | number
    activity_id?: StringNullableFilter<"Task"> | string | null
    description?: StringFilter<"Task"> | string
    remarks?: StringFilter<"Task"> | string
    accomplishment?: StringFilter<"Task"> | string
    action_taken?: StringFilter<"Task"> | string
    acted_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    created_by?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
  }

  export type ActivityCreateWithoutCategoryInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutCategoryInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput>
  }

  export type ActivityCreateManyCategoryInputEnvelope = {
    data: ActivityCreateManyCategoryInput | ActivityCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutCategoryInput, ActivityUncheckedUpdateWithoutCategoryInput>
    create: XOR<ActivityCreateWithoutCategoryInput, ActivityUncheckedCreateWithoutCategoryInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutCategoryInput, ActivityUncheckedUpdateWithoutCategoryInput>
  }

  export type ActivityUpdateManyWithWhereWithoutCategoryInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    category_id?: IntFilter<"Activity"> | number
    name?: StringFilter<"Activity"> | string
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ComplaintDetailCreateWithoutComplaintInput = {
    consumer_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    barangay: BarangayCreateNestedOneWithoutComplaint_detailsInput
    sitio?: SitioCreateNestedOneWithoutComplaint_detailsInput
  }

  export type ComplaintDetailUncheckedCreateWithoutComplaintInput = {
    id?: number
    consumer_id?: string | null
    barangay_id: string
    sitio_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailCreateOrConnectWithoutComplaintInput = {
    where: ComplaintDetailWhereUniqueInput
    create: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintLogCreateWithoutComplaintInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    status: ComplaintStatusCreateNestedOneWithoutLogsInput
  }

  export type ComplaintLogUncheckedCreateWithoutComplaintInput = {
    id?: number
    complaint_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ComplaintLogCreateOrConnectWithoutComplaintInput = {
    where: ComplaintLogWhereUniqueInput
    create: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintLogCreateManyComplaintInputEnvelope = {
    data: ComplaintLogCreateManyComplaintInput | ComplaintLogCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutComplaintInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutComplaintInput = {
    id?: number
    ref_number: string
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutComplaintInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput>
  }

  export type TaskCreateManyComplaintInputEnvelope = {
    data: TaskCreateManyComplaintInput | TaskCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintReportTypeCreateWithoutComplaintsInput = {
    id: number
    name: string
  }

  export type ComplaintReportTypeUncheckedCreateWithoutComplaintsInput = {
    id: number
    name: string
  }

  export type ComplaintReportTypeCreateOrConnectWithoutComplaintsInput = {
    where: ComplaintReportTypeWhereUniqueInput
    create: XOR<ComplaintReportTypeCreateWithoutComplaintsInput, ComplaintReportTypeUncheckedCreateWithoutComplaintsInput>
  }

  export type ComplaintStatusCreateWithoutComplaintsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    logs?: ComplaintLogCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusUncheckedCreateWithoutComplaintsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusCreateOrConnectWithoutComplaintsInput = {
    where: ComplaintStatusWhereUniqueInput
    create: XOR<ComplaintStatusCreateWithoutComplaintsInput, ComplaintStatusUncheckedCreateWithoutComplaintsInput>
  }

  export type ComplaintDetailUpsertWithoutComplaintInput = {
    update: XOR<ComplaintDetailUpdateWithoutComplaintInput, ComplaintDetailUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintDetailCreateWithoutComplaintInput, ComplaintDetailUncheckedCreateWithoutComplaintInput>
    where?: ComplaintDetailWhereInput
  }

  export type ComplaintDetailUpdateToOneWithWhereWithoutComplaintInput = {
    where?: ComplaintDetailWhereInput
    data: XOR<ComplaintDetailUpdateWithoutComplaintInput, ComplaintDetailUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintDetailUpdateWithoutComplaintInput = {
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    barangay?: BarangayUpdateOneRequiredWithoutComplaint_detailsNestedInput
    sitio?: SitioUpdateOneWithoutComplaint_detailsNestedInput
  }

  export type ComplaintDetailUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    barangay_id?: StringFieldUpdateOperationsInput | string
    sitio_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogUpsertWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintLogWhereUniqueInput
    update: XOR<ComplaintLogUpdateWithoutComplaintInput, ComplaintLogUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintLogCreateWithoutComplaintInput, ComplaintLogUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintLogUpdateWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintLogWhereUniqueInput
    data: XOR<ComplaintLogUpdateWithoutComplaintInput, ComplaintLogUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintLogUpdateManyWithWhereWithoutComplaintInput = {
    where: ComplaintLogScalarWhereInput
    data: XOR<ComplaintLogUpdateManyMutationInput, ComplaintLogUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintLogScalarWhereInput = {
    AND?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
    OR?: ComplaintLogScalarWhereInput[]
    NOT?: ComplaintLogScalarWhereInput | ComplaintLogScalarWhereInput[]
    id?: IntFilter<"ComplaintLog"> | number
    complaint_id?: IntFilter<"ComplaintLog"> | number
    complaint_status_id?: IntFilter<"ComplaintLog"> | number
    remarks?: StringNullableFilter<"ComplaintLog"> | string | null
    created_by?: StringFilter<"ComplaintLog"> | string
    created_at?: DateTimeFilter<"ComplaintLog"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutComplaintInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutComplaintInput, TaskUncheckedUpdateWithoutComplaintInput>
    create: XOR<TaskCreateWithoutComplaintInput, TaskUncheckedCreateWithoutComplaintInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutComplaintInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutComplaintInput, TaskUncheckedUpdateWithoutComplaintInput>
  }

  export type TaskUpdateManyWithWhereWithoutComplaintInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintReportTypeUpsertWithoutComplaintsInput = {
    update: XOR<ComplaintReportTypeUpdateWithoutComplaintsInput, ComplaintReportTypeUncheckedUpdateWithoutComplaintsInput>
    create: XOR<ComplaintReportTypeCreateWithoutComplaintsInput, ComplaintReportTypeUncheckedCreateWithoutComplaintsInput>
    where?: ComplaintReportTypeWhereInput
  }

  export type ComplaintReportTypeUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: ComplaintReportTypeWhereInput
    data: XOR<ComplaintReportTypeUpdateWithoutComplaintsInput, ComplaintReportTypeUncheckedUpdateWithoutComplaintsInput>
  }

  export type ComplaintReportTypeUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintReportTypeUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintStatusUpsertWithoutComplaintsInput = {
    update: XOR<ComplaintStatusUpdateWithoutComplaintsInput, ComplaintStatusUncheckedUpdateWithoutComplaintsInput>
    create: XOR<ComplaintStatusCreateWithoutComplaintsInput, ComplaintStatusUncheckedCreateWithoutComplaintsInput>
    where?: ComplaintStatusWhereInput
  }

  export type ComplaintStatusUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: ComplaintStatusWhereInput
    data: XOR<ComplaintStatusUpdateWithoutComplaintsInput, ComplaintStatusUncheckedUpdateWithoutComplaintsInput>
  }

  export type ComplaintStatusUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    logs?: ComplaintLogUpdateManyWithoutStatusNestedInput
  }

  export type ComplaintStatusUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    logs?: ComplaintLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type ComplaintCreateWithoutComplaint_detailInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    logs?: ComplaintLogCreateNestedManyWithoutComplaintInput
    tasks?: TaskCreateNestedManyWithoutComplaintInput
    report_type: ComplaintReportTypeCreateNestedOneWithoutComplaintsInput
    status: ComplaintStatusCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutComplaint_detailInput = {
    id?: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutComplaint_detailInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutComplaint_detailInput, ComplaintUncheckedCreateWithoutComplaint_detailInput>
  }

  export type BarangayCreateWithoutComplaint_detailsInput = {
    id?: string
    name: string
    municipality: MunicipalityCreateNestedOneWithoutBarangaysInput
    sitios?: SitioCreateNestedManyWithoutBarangayInput
  }

  export type BarangayUncheckedCreateWithoutComplaint_detailsInput = {
    id?: string
    municipality_id: string
    name: string
    sitios?: SitioUncheckedCreateNestedManyWithoutBarangayInput
  }

  export type BarangayCreateOrConnectWithoutComplaint_detailsInput = {
    where: BarangayWhereUniqueInput
    create: XOR<BarangayCreateWithoutComplaint_detailsInput, BarangayUncheckedCreateWithoutComplaint_detailsInput>
  }

  export type SitioCreateWithoutComplaint_detailsInput = {
    id?: string
    name: string
    barangay: BarangayCreateNestedOneWithoutSitiosInput
  }

  export type SitioUncheckedCreateWithoutComplaint_detailsInput = {
    id?: string
    barangay_id: string
    name: string
  }

  export type SitioCreateOrConnectWithoutComplaint_detailsInput = {
    where: SitioWhereUniqueInput
    create: XOR<SitioCreateWithoutComplaint_detailsInput, SitioUncheckedCreateWithoutComplaint_detailsInput>
  }

  export type ComplaintUpsertWithoutComplaint_detailInput = {
    update: XOR<ComplaintUpdateWithoutComplaint_detailInput, ComplaintUncheckedUpdateWithoutComplaint_detailInput>
    create: XOR<ComplaintCreateWithoutComplaint_detailInput, ComplaintUncheckedCreateWithoutComplaint_detailInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutComplaint_detailInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutComplaint_detailInput, ComplaintUncheckedUpdateWithoutComplaint_detailInput>
  }

  export type ComplaintUpdateWithoutComplaint_detailInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ComplaintLogUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUpdateManyWithoutComplaintNestedInput
    report_type?: ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutComplaint_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type BarangayUpsertWithoutComplaint_detailsInput = {
    update: XOR<BarangayUpdateWithoutComplaint_detailsInput, BarangayUncheckedUpdateWithoutComplaint_detailsInput>
    create: XOR<BarangayCreateWithoutComplaint_detailsInput, BarangayUncheckedCreateWithoutComplaint_detailsInput>
    where?: BarangayWhereInput
  }

  export type BarangayUpdateToOneWithWhereWithoutComplaint_detailsInput = {
    where?: BarangayWhereInput
    data: XOR<BarangayUpdateWithoutComplaint_detailsInput, BarangayUncheckedUpdateWithoutComplaint_detailsInput>
  }

  export type BarangayUpdateWithoutComplaint_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    municipality?: MunicipalityUpdateOneRequiredWithoutBarangaysNestedInput
    sitios?: SitioUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayUncheckedUpdateWithoutComplaint_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    municipality_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sitios?: SitioUncheckedUpdateManyWithoutBarangayNestedInput
  }

  export type SitioUpsertWithoutComplaint_detailsInput = {
    update: XOR<SitioUpdateWithoutComplaint_detailsInput, SitioUncheckedUpdateWithoutComplaint_detailsInput>
    create: XOR<SitioCreateWithoutComplaint_detailsInput, SitioUncheckedCreateWithoutComplaint_detailsInput>
    where?: SitioWhereInput
  }

  export type SitioUpdateToOneWithWhereWithoutComplaint_detailsInput = {
    where?: SitioWhereInput
    data: XOR<SitioUpdateWithoutComplaint_detailsInput, SitioUncheckedUpdateWithoutComplaint_detailsInput>
  }

  export type SitioUpdateWithoutComplaint_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barangay?: BarangayUpdateOneRequiredWithoutSitiosNestedInput
  }

  export type SitioUncheckedUpdateWithoutComplaint_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barangay_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintCreateWithoutStatusInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogCreateNestedManyWithoutComplaintInput
    tasks?: TaskCreateNestedManyWithoutComplaintInput
    report_type: ComplaintReportTypeCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutStatusInput = {
    id?: number
    report_type_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutStatusInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput>
  }

  export type ComplaintCreateManyStatusInputEnvelope = {
    data: ComplaintCreateManyStatusInput | ComplaintCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintLogCreateWithoutStatusInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    complaint: ComplaintCreateNestedOneWithoutLogsInput
  }

  export type ComplaintLogUncheckedCreateWithoutStatusInput = {
    id?: number
    complaint_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ComplaintLogCreateOrConnectWithoutStatusInput = {
    where: ComplaintLogWhereUniqueInput
    create: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput>
  }

  export type ComplaintLogCreateManyStatusInputEnvelope = {
    data: ComplaintLogCreateManyStatusInput | ComplaintLogCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintUpsertWithWhereUniqueWithoutStatusInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutStatusInput, ComplaintUncheckedUpdateWithoutStatusInput>
    create: XOR<ComplaintCreateWithoutStatusInput, ComplaintUncheckedCreateWithoutStatusInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutStatusInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutStatusInput, ComplaintUncheckedUpdateWithoutStatusInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutStatusInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutStatusInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    report_type_id?: IntFilter<"Complaint"> | number
    complaint_status_id?: IntFilter<"Complaint"> | number
    assigned_group_id?: StringFilter<"Complaint"> | string
    assigned_group_type?: IntFilter<"Complaint"> | number
    ref_number?: StringFilter<"Complaint"> | string
    complainant_name?: StringFilter<"Complaint"> | string
    complainant_contact_no?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    remarks?: StringNullableFilter<"Complaint"> | string | null
    created_by?: StringFilter<"Complaint"> | string
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type ComplaintLogUpsertWithWhereUniqueWithoutStatusInput = {
    where: ComplaintLogWhereUniqueInput
    update: XOR<ComplaintLogUpdateWithoutStatusInput, ComplaintLogUncheckedUpdateWithoutStatusInput>
    create: XOR<ComplaintLogCreateWithoutStatusInput, ComplaintLogUncheckedCreateWithoutStatusInput>
  }

  export type ComplaintLogUpdateWithWhereUniqueWithoutStatusInput = {
    where: ComplaintLogWhereUniqueInput
    data: XOR<ComplaintLogUpdateWithoutStatusInput, ComplaintLogUncheckedUpdateWithoutStatusInput>
  }

  export type ComplaintLogUpdateManyWithWhereWithoutStatusInput = {
    where: ComplaintLogScalarWhereInput
    data: XOR<ComplaintLogUpdateManyMutationInput, ComplaintLogUncheckedUpdateManyWithoutStatusInput>
  }

  export type ComplaintCreateWithoutReport_typeInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogCreateNestedManyWithoutComplaintInput
    tasks?: TaskCreateNestedManyWithoutComplaintInput
    status: ComplaintStatusCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutReport_typeInput = {
    id?: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutReport_typeInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput>
  }

  export type ComplaintCreateManyReport_typeInputEnvelope = {
    data: ComplaintCreateManyReport_typeInput | ComplaintCreateManyReport_typeInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintUpsertWithWhereUniqueWithoutReport_typeInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutReport_typeInput, ComplaintUncheckedUpdateWithoutReport_typeInput>
    create: XOR<ComplaintCreateWithoutReport_typeInput, ComplaintUncheckedCreateWithoutReport_typeInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutReport_typeInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutReport_typeInput, ComplaintUncheckedUpdateWithoutReport_typeInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutReport_typeInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutReport_typeInput>
  }

  export type ComplaintCreateWithoutLogsInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailCreateNestedOneWithoutComplaintInput
    tasks?: TaskCreateNestedManyWithoutComplaintInput
    report_type: ComplaintReportTypeCreateNestedOneWithoutComplaintsInput
    status: ComplaintStatusCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutLogsInput = {
    id?: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutLogsInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutLogsInput, ComplaintUncheckedCreateWithoutLogsInput>
  }

  export type ComplaintStatusCreateWithoutLogsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    complaints?: ComplaintCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusUncheckedCreateWithoutLogsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStatusInput
  }

  export type ComplaintStatusCreateOrConnectWithoutLogsInput = {
    where: ComplaintStatusWhereUniqueInput
    create: XOR<ComplaintStatusCreateWithoutLogsInput, ComplaintStatusUncheckedCreateWithoutLogsInput>
  }

  export type ComplaintUpsertWithoutLogsInput = {
    update: XOR<ComplaintUpdateWithoutLogsInput, ComplaintUncheckedUpdateWithoutLogsInput>
    create: XOR<ComplaintCreateWithoutLogsInput, ComplaintUncheckedCreateWithoutLogsInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutLogsInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutLogsInput, ComplaintUncheckedUpdateWithoutLogsInput>
  }

  export type ComplaintUpdateWithoutLogsInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUpdateOneWithoutComplaintNestedInput
    tasks?: TaskUpdateManyWithoutComplaintNestedInput
    report_type?: ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintStatusUpsertWithoutLogsInput = {
    update: XOR<ComplaintStatusUpdateWithoutLogsInput, ComplaintStatusUncheckedUpdateWithoutLogsInput>
    create: XOR<ComplaintStatusCreateWithoutLogsInput, ComplaintStatusUncheckedCreateWithoutLogsInput>
    where?: ComplaintStatusWhereInput
  }

  export type ComplaintStatusUpdateToOneWithWhereWithoutLogsInput = {
    where?: ComplaintStatusWhereInput
    data: XOR<ComplaintStatusUpdateWithoutLogsInput, ComplaintStatusUncheckedUpdateWithoutLogsInput>
  }

  export type ComplaintStatusUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUpdateManyWithoutStatusNestedInput
  }

  export type ComplaintStatusUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    complaints?: ComplaintUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type TaskAssignmentCreateWithoutTaskInput = {
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
    area?: AreaCreateNestedOneWithoutTask_assignmentsInput
  }

  export type TaskAssignmentUncheckedCreateWithoutTaskInput = {
    id?: number
    area_id?: string | null
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutTaskInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskLogCreateWithoutTaskInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    status: TaskStatusCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateWithoutTaskInput = {
    id?: number
    task_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskLogCreateOrConnectWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    create: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskLogCreateManyTaskInputEnvelope = {
    data: TaskLogCreateManyTaskInput | TaskLogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskFileCreateWithoutTaskInput = {
    filename: string
    source_path: string
  }

  export type TaskFileUncheckedCreateWithoutTaskInput = {
    id?: number
    filename: string
    source_path: string
  }

  export type TaskFileCreateOrConnectWithoutTaskInput = {
    where: TaskFileWhereUniqueInput
    create: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput>
  }

  export type TaskFileCreateManyTaskInputEnvelope = {
    data: TaskFileCreateManyTaskInput | TaskFileCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutTasksInput = {
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogCreateNestedManyWithoutComplaintInput
    report_type: ComplaintReportTypeCreateNestedOneWithoutComplaintsInput
    status: ComplaintStatusCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateWithoutTasksInput = {
    id?: number
    report_type_id: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    complaint_detail?: ComplaintDetailUncheckedCreateNestedOneWithoutComplaintInput
    logs?: ComplaintLogUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type ComplaintCreateOrConnectWithoutTasksInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutTasksInput, ComplaintUncheckedCreateWithoutTasksInput>
  }

  export type TaskStatusCreateWithoutTasksInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    logs?: TaskLogCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusUncheckedCreateWithoutTasksInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    logs?: TaskLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusCreateOrConnectWithoutTasksInput = {
    where: TaskStatusWhereUniqueInput
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
  }

  export type ActivityCreateWithoutTasksInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    category?: ActivityCategoryCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutTasksInput = {
    id?: string
    category_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityCreateOrConnectWithoutTasksInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTasksInput, ActivityUncheckedCreateWithoutTasksInput>
  }

  export type TaskDetailPowerInterruptionCreateWithoutTaskInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutPower_interruption_tasksInput
    weather_condition: WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput
    device: DeviceCreateNestedOneWithoutPower_interruption_tasksInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput = {
    id?: number
    feeder_id: string
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    linemen_incharge?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailPowerInterruptionCreateOrConnectWithoutTaskInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    create: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
  }

  export type TaskDetailKwhMeterCreateWithoutTaskInput = {
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanCreateNestedManyWithoutTask_detailInput
    meter_brand: MeterBrandCreateNestedOneWithoutKwh_meter_tasksInput
  }

  export type TaskDetailKwhMeterUncheckedCreateWithoutTaskInput = {
    id?: number
    meter_number: string
    meter_brand_id: string
    last_reading: string
    initial_reading: string
    meter_class: string
    linemen_incharge?: KwhMeterLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailKwhMeterCreateOrConnectWithoutTaskInput = {
    where: TaskDetailKwhMeterWhereUniqueInput
    create: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
  }

  export type TaskDetailLineServicesCreateWithoutTaskInput = {
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    linemen_incharge?: LineServicesLinemanCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLineServicesUncheckedCreateWithoutTaskInput = {
    id?: number
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    linemen_incharge?: LineServicesLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLineServicesCreateOrConnectWithoutTaskInput = {
    where: TaskDetailLineServicesWhereUniqueInput
    create: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
  }

  export type TaskDetailDlesCreateWithoutTaskInput = {
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    linemen_incharge?: DlesLinemanCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailDlesUncheckedCreateWithoutTaskInput = {
    id?: number
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    linemen_incharge?: DlesLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailDlesCreateOrConnectWithoutTaskInput = {
    where: TaskDetailDlesWhereUniqueInput
    create: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
  }

  export type TaskDetailLmdgaCreateWithoutTaskInput = {
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanCreateNestedManyWithoutTask_detailInput
    feeder: FeederCreateNestedOneWithoutLmdga_tasksInput
  }

  export type TaskDetailLmdgaUncheckedCreateWithoutTaskInput = {
    id?: number
    kva_rating: string
    substation_id: string
    dt_location: string
    feeder_id: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    linemen_incharge?: LmdgaLinemanUncheckedCreateNestedManyWithoutTask_detailInput
  }

  export type TaskDetailLmdgaCreateOrConnectWithoutTaskInput = {
    where: TaskDetailLmdgaWhereUniqueInput
    create: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssignmentUpsertWithoutTaskInput = {
    update: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssignmentCreateWithoutTaskInput, TaskAssignmentUncheckedCreateWithoutTaskInput>
    where?: TaskAssignmentWhereInput
  }

  export type TaskAssignmentUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskAssignmentWhereInput
    data: XOR<TaskAssignmentUpdateWithoutTaskInput, TaskAssignmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssignmentUpdateWithoutTaskInput = {
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneWithoutTask_assignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    update: XOR<TaskLogUpdateWithoutTaskInput, TaskLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    data: XOR<TaskLogUpdateWithoutTaskInput, TaskLogUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLogUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLogScalarWhereInput
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLogScalarWhereInput = {
    AND?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
    OR?: TaskLogScalarWhereInput[]
    NOT?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
    id?: IntFilter<"TaskLog"> | number
    task_id?: IntFilter<"TaskLog"> | number
    task_status_id?: IntFilter<"TaskLog"> | number
    remarks?: StringNullableFilter<"TaskLog"> | string | null
    created_by?: StringFilter<"TaskLog"> | string
    created_at?: DateTimeFilter<"TaskLog"> | Date | string
  }

  export type TaskFileUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskFileWhereUniqueInput
    update: XOR<TaskFileUpdateWithoutTaskInput, TaskFileUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskFileCreateWithoutTaskInput, TaskFileUncheckedCreateWithoutTaskInput>
  }

  export type TaskFileUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskFileWhereUniqueInput
    data: XOR<TaskFileUpdateWithoutTaskInput, TaskFileUncheckedUpdateWithoutTaskInput>
  }

  export type TaskFileUpdateManyWithWhereWithoutTaskInput = {
    where: TaskFileScalarWhereInput
    data: XOR<TaskFileUpdateManyMutationInput, TaskFileUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskFileScalarWhereInput = {
    AND?: TaskFileScalarWhereInput | TaskFileScalarWhereInput[]
    OR?: TaskFileScalarWhereInput[]
    NOT?: TaskFileScalarWhereInput | TaskFileScalarWhereInput[]
    id?: IntFilter<"TaskFile"> | number
    task_id?: IntFilter<"TaskFile"> | number
    filename?: StringFilter<"TaskFile"> | string
    source_path?: StringFilter<"TaskFile"> | string
  }

  export type ComplaintUpsertWithoutTasksInput = {
    update: XOR<ComplaintUpdateWithoutTasksInput, ComplaintUncheckedUpdateWithoutTasksInput>
    create: XOR<ComplaintCreateWithoutTasksInput, ComplaintUncheckedCreateWithoutTasksInput>
    where?: ComplaintWhereInput
  }

  export type ComplaintUpdateToOneWithWhereWithoutTasksInput = {
    where?: ComplaintWhereInput
    data: XOR<ComplaintUpdateWithoutTasksInput, ComplaintUncheckedUpdateWithoutTasksInput>
  }

  export type ComplaintUpdateWithoutTasksInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUpdateManyWithoutComplaintNestedInput
    report_type?: ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type TaskStatusUpsertWithoutTasksInput = {
    update: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    where?: TaskStatusWhereInput
  }

  export type TaskStatusUpdateToOneWithWhereWithoutTasksInput = {
    where?: TaskStatusWhereInput
    data: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    logs?: TaskLogUpdateManyWithoutStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    logs?: TaskLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type ActivityUpsertWithoutTasksInput = {
    update: XOR<ActivityUpdateWithoutTasksInput, ActivityUncheckedUpdateWithoutTasksInput>
    create: XOR<ActivityCreateWithoutTasksInput, ActivityUncheckedCreateWithoutTasksInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutTasksInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutTasksInput, ActivityUncheckedUpdateWithoutTasksInput>
  }

  export type ActivityUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ActivityCategoryUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailPowerInterruptionUpsertWithoutTaskInput = {
    update: XOR<TaskDetailPowerInterruptionUpdateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDetailPowerInterruptionCreateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedCreateWithoutTaskInput>
    where?: TaskDetailPowerInterruptionWhereInput
  }

  export type TaskDetailPowerInterruptionUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskDetailPowerInterruptionWhereInput
    data: XOR<TaskDetailPowerInterruptionUpdateWithoutTaskInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailPowerInterruptionUpdateWithoutTaskInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    weather_condition?: WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    device?: DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailKwhMeterUpsertWithoutTaskInput = {
    update: XOR<TaskDetailKwhMeterUpdateWithoutTaskInput, TaskDetailKwhMeterUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDetailKwhMeterCreateWithoutTaskInput, TaskDetailKwhMeterUncheckedCreateWithoutTaskInput>
    where?: TaskDetailKwhMeterWhereInput
  }

  export type TaskDetailKwhMeterUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskDetailKwhMeterWhereInput
    data: XOR<TaskDetailKwhMeterUpdateWithoutTaskInput, TaskDetailKwhMeterUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailKwhMeterUpdateWithoutTaskInput = {
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUpdateManyWithoutTask_detailNestedInput
    meter_brand?: MeterBrandUpdateOneRequiredWithoutKwh_meter_tasksNestedInput
  }

  export type TaskDetailKwhMeterUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    meter_brand_id?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLineServicesUpsertWithoutTaskInput = {
    update: XOR<TaskDetailLineServicesUpdateWithoutTaskInput, TaskDetailLineServicesUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDetailLineServicesCreateWithoutTaskInput, TaskDetailLineServicesUncheckedCreateWithoutTaskInput>
    where?: TaskDetailLineServicesWhereInput
  }

  export type TaskDetailLineServicesUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskDetailLineServicesWhereInput
    data: XOR<TaskDetailLineServicesUpdateWithoutTaskInput, TaskDetailLineServicesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLineServicesUpdateWithoutTaskInput = {
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LineServicesLinemanUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLineServicesUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LineServicesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailDlesUpsertWithoutTaskInput = {
    update: XOR<TaskDetailDlesUpdateWithoutTaskInput, TaskDetailDlesUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDetailDlesCreateWithoutTaskInput, TaskDetailDlesUncheckedCreateWithoutTaskInput>
    where?: TaskDetailDlesWhereInput
  }

  export type TaskDetailDlesUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskDetailDlesWhereInput
    data: XOR<TaskDetailDlesUpdateWithoutTaskInput, TaskDetailDlesUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailDlesUpdateWithoutTaskInput = {
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: DlesLinemanUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailDlesUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: DlesLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLmdgaUpsertWithoutTaskInput = {
    update: XOR<TaskDetailLmdgaUpdateWithoutTaskInput, TaskDetailLmdgaUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDetailLmdgaCreateWithoutTaskInput, TaskDetailLmdgaUncheckedCreateWithoutTaskInput>
    where?: TaskDetailLmdgaWhereInput
  }

  export type TaskDetailLmdgaUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskDetailLmdgaWhereInput
    data: XOR<TaskDetailLmdgaUpdateWithoutTaskInput, TaskDetailLmdgaUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDetailLmdgaUpdateWithoutTaskInput = {
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutLmdga_tasksNestedInput
  }

  export type TaskDetailLmdgaUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    feeder_id?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskCreateWithoutTask_assignmentInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_assignmentInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_assignmentInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_assignmentInput, TaskUncheckedCreateWithoutTask_assignmentInput>
  }

  export type AreaCreateWithoutTask_assignmentsInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanCreateNestedManyWithoutAreaInput
    municipalities?: MunicipalityCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutTask_assignmentsInput = {
    id?: string
    oic_id: string
    name: string
    linemen?: LinemanUncheckedCreateNestedManyWithoutAreaInput
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutTask_assignmentsInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutTask_assignmentsInput, AreaUncheckedCreateWithoutTask_assignmentsInput>
  }

  export type TaskUpsertWithoutTask_assignmentInput = {
    update: XOR<TaskUpdateWithoutTask_assignmentInput, TaskUncheckedUpdateWithoutTask_assignmentInput>
    create: XOR<TaskCreateWithoutTask_assignmentInput, TaskUncheckedCreateWithoutTask_assignmentInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_assignmentInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_assignmentInput, TaskUncheckedUpdateWithoutTask_assignmentInput>
  }

  export type TaskUpdateWithoutTask_assignmentInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_assignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type AreaUpsertWithoutTask_assignmentsInput = {
    update: XOR<AreaUpdateWithoutTask_assignmentsInput, AreaUncheckedUpdateWithoutTask_assignmentsInput>
    create: XOR<AreaCreateWithoutTask_assignmentsInput, AreaUncheckedCreateWithoutTask_assignmentsInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutTask_assignmentsInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutTask_assignmentsInput, AreaUncheckedUpdateWithoutTask_assignmentsInput>
  }

  export type AreaUpdateWithoutTask_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUpdateManyWithoutAreaNestedInput
    municipalities?: MunicipalityUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutTask_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oic_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linemen?: LinemanUncheckedUpdateManyWithoutAreaNestedInput
    municipalities?: MunicipalityUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type TaskCreateWithoutLogsInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLogsInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLogsInput, TaskUncheckedCreateWithoutLogsInput>
  }

  export type TaskStatusCreateWithoutLogsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    tasks?: TaskCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusUncheckedCreateWithoutLogsInput = {
    id: number
    name: string
    color_class?: string
    description?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutStatusInput
  }

  export type TaskStatusCreateOrConnectWithoutLogsInput = {
    where: TaskStatusWhereUniqueInput
    create: XOR<TaskStatusCreateWithoutLogsInput, TaskStatusUncheckedCreateWithoutLogsInput>
  }

  export type TaskUpsertWithoutLogsInput = {
    update: XOR<TaskUpdateWithoutLogsInput, TaskUncheckedUpdateWithoutLogsInput>
    create: XOR<TaskCreateWithoutLogsInput, TaskUncheckedCreateWithoutLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLogsInput, TaskUncheckedUpdateWithoutLogsInput>
  }

  export type TaskUpdateWithoutLogsInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskStatusUpsertWithoutLogsInput = {
    update: XOR<TaskStatusUpdateWithoutLogsInput, TaskStatusUncheckedUpdateWithoutLogsInput>
    create: XOR<TaskStatusCreateWithoutLogsInput, TaskStatusUncheckedCreateWithoutLogsInput>
    where?: TaskStatusWhereInput
  }

  export type TaskStatusUpdateToOneWithWhereWithoutLogsInput = {
    where?: TaskStatusWhereInput
    data: XOR<TaskStatusUpdateWithoutLogsInput, TaskStatusUncheckedUpdateWithoutLogsInput>
  }

  export type TaskStatusUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUpdateManyWithoutStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color_class?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type TaskCreateWithoutFilesInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutFilesInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutFilesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutFilesInput, TaskUncheckedCreateWithoutFilesInput>
  }

  export type TaskUpsertWithoutFilesInput = {
    update: XOR<TaskUpdateWithoutFilesInput, TaskUncheckedUpdateWithoutFilesInput>
    create: XOR<TaskCreateWithoutFilesInput, TaskUncheckedCreateWithoutFilesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutFilesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutFilesInput, TaskUncheckedUpdateWithoutFilesInput>
  }

  export type TaskUpdateWithoutFilesInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskCreateWithoutStatusInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutStatusInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutStatusInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
  }

  export type TaskCreateManyStatusInputEnvelope = {
    data: TaskCreateManyStatusInput | TaskCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type TaskLogCreateWithoutStatusInput = {
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    task: TaskCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateWithoutStatusInput = {
    id?: number
    task_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskLogCreateOrConnectWithoutStatusInput = {
    where: TaskLogWhereUniqueInput
    create: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput>
  }

  export type TaskLogCreateManyStatusInputEnvelope = {
    data: TaskLogCreateManyStatusInput | TaskLogCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>
    create: XOR<TaskCreateWithoutStatusInput, TaskUncheckedCreateWithoutStatusInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutStatusInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutStatusInput, TaskUncheckedUpdateWithoutStatusInput>
  }

  export type TaskUpdateManyWithWhereWithoutStatusInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutStatusInput>
  }

  export type TaskLogUpsertWithWhereUniqueWithoutStatusInput = {
    where: TaskLogWhereUniqueInput
    update: XOR<TaskLogUpdateWithoutStatusInput, TaskLogUncheckedUpdateWithoutStatusInput>
    create: XOR<TaskLogCreateWithoutStatusInput, TaskLogUncheckedCreateWithoutStatusInput>
  }

  export type TaskLogUpdateWithWhereUniqueWithoutStatusInput = {
    where: TaskLogWhereUniqueInput
    data: XOR<TaskLogUpdateWithoutStatusInput, TaskLogUncheckedUpdateWithoutStatusInput>
  }

  export type TaskLogUpdateManyWithWhereWithoutStatusInput = {
    where: TaskLogScalarWhereInput
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyWithoutStatusInput>
  }

  export type PowerInterruptionLinemanCreateWithoutTask_detailInput = {
    lineman: LinemanCreateNestedOneWithoutPower_interruptionsInput
  }

  export type PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type PowerInterruptionLinemanCreateOrConnectWithoutTask_detailInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    create: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type PowerInterruptionLinemanCreateManyTask_detailInputEnvelope = {
    data: PowerInterruptionLinemanCreateManyTask_detailInput | PowerInterruptionLinemanCreateManyTask_detailInput[]
    skipDuplicates?: boolean
  }

  export type FeederCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
    lmdga_tasks?: TaskDetailLmdgaCreateNestedManyWithoutFeederInput
  }

  export type FeederUncheckedCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
    lmdga_tasks?: TaskDetailLmdgaUncheckedCreateNestedManyWithoutFeederInput
  }

  export type FeederCreateOrConnectWithoutPower_interruption_tasksInput = {
    where: FeederWhereUniqueInput
    create: XOR<FeederCreateWithoutPower_interruption_tasksInput, FeederUncheckedCreateWithoutPower_interruption_tasksInput>
  }

  export type WeatherConditionCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
  }

  export type WeatherConditionUncheckedCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
  }

  export type WeatherConditionCreateOrConnectWithoutPower_interruption_tasksInput = {
    where: WeatherConditionWhereUniqueInput
    create: XOR<WeatherConditionCreateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedCreateWithoutPower_interruption_tasksInput>
  }

  export type DeviceCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
  }

  export type DeviceUncheckedCreateWithoutPower_interruption_tasksInput = {
    id?: string
    name: string
  }

  export type DeviceCreateOrConnectWithoutPower_interruption_tasksInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPower_interruption_tasksInput, DeviceUncheckedCreateWithoutPower_interruption_tasksInput>
  }

  export type TaskCreateWithoutTask_detail_power_interruptionInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_detail_power_interruptionInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_detail_power_interruptionInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_detail_power_interruptionInput, TaskUncheckedCreateWithoutTask_detail_power_interruptionInput>
  }

  export type PowerInterruptionLinemanUpsertWithWhereUniqueWithoutTask_detailInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    update: XOR<PowerInterruptionLinemanUpdateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedUpdateWithoutTask_detailInput>
    create: XOR<PowerInterruptionLinemanCreateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type PowerInterruptionLinemanUpdateWithWhereUniqueWithoutTask_detailInput = {
    where: PowerInterruptionLinemanWhereUniqueInput
    data: XOR<PowerInterruptionLinemanUpdateWithoutTask_detailInput, PowerInterruptionLinemanUncheckedUpdateWithoutTask_detailInput>
  }

  export type PowerInterruptionLinemanUpdateManyWithWhereWithoutTask_detailInput = {
    where: PowerInterruptionLinemanScalarWhereInput
    data: XOR<PowerInterruptionLinemanUpdateManyMutationInput, PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailInput>
  }

  export type FeederUpsertWithoutPower_interruption_tasksInput = {
    update: XOR<FeederUpdateWithoutPower_interruption_tasksInput, FeederUncheckedUpdateWithoutPower_interruption_tasksInput>
    create: XOR<FeederCreateWithoutPower_interruption_tasksInput, FeederUncheckedCreateWithoutPower_interruption_tasksInput>
    where?: FeederWhereInput
  }

  export type FeederUpdateToOneWithWhereWithoutPower_interruption_tasksInput = {
    where?: FeederWhereInput
    data: XOR<FeederUpdateWithoutPower_interruption_tasksInput, FeederUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type FeederUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lmdga_tasks?: TaskDetailLmdgaUpdateManyWithoutFeederNestedInput
  }

  export type FeederUncheckedUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lmdga_tasks?: TaskDetailLmdgaUncheckedUpdateManyWithoutFeederNestedInput
  }

  export type WeatherConditionUpsertWithoutPower_interruption_tasksInput = {
    update: XOR<WeatherConditionUpdateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedUpdateWithoutPower_interruption_tasksInput>
    create: XOR<WeatherConditionCreateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedCreateWithoutPower_interruption_tasksInput>
    where?: WeatherConditionWhereInput
  }

  export type WeatherConditionUpdateToOneWithWhereWithoutPower_interruption_tasksInput = {
    where?: WeatherConditionWhereInput
    data: XOR<WeatherConditionUpdateWithoutPower_interruption_tasksInput, WeatherConditionUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type WeatherConditionUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherConditionUncheckedUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUpsertWithoutPower_interruption_tasksInput = {
    update: XOR<DeviceUpdateWithoutPower_interruption_tasksInput, DeviceUncheckedUpdateWithoutPower_interruption_tasksInput>
    create: XOR<DeviceCreateWithoutPower_interruption_tasksInput, DeviceUncheckedCreateWithoutPower_interruption_tasksInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutPower_interruption_tasksInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutPower_interruption_tasksInput, DeviceUncheckedUpdateWithoutPower_interruption_tasksInput>
  }

  export type DeviceUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUncheckedUpdateWithoutPower_interruption_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpsertWithoutTask_detail_power_interruptionInput = {
    update: XOR<TaskUpdateWithoutTask_detail_power_interruptionInput, TaskUncheckedUpdateWithoutTask_detail_power_interruptionInput>
    create: XOR<TaskCreateWithoutTask_detail_power_interruptionInput, TaskUncheckedCreateWithoutTask_detail_power_interruptionInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_detail_power_interruptionInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_detail_power_interruptionInput, TaskUncheckedUpdateWithoutTask_detail_power_interruptionInput>
  }

  export type TaskUpdateWithoutTask_detail_power_interruptionInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_detail_power_interruptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskDetailPowerInterruptionCreateWithoutLinemen_inchargeInput = {
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
    feeder: FeederCreateNestedOneWithoutPower_interruption_tasksInput
    weather_condition: WeatherConditionCreateNestedOneWithoutPower_interruption_tasksInput
    device: DeviceCreateNestedOneWithoutPower_interruption_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_power_interruptionInput
  }

  export type TaskDetailPowerInterruptionUncheckedCreateWithoutLinemen_inchargeInput = {
    id?: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
  }

  export type TaskDetailPowerInterruptionCreateOrConnectWithoutLinemen_inchargeInput = {
    where: TaskDetailPowerInterruptionWhereUniqueInput
    create: XOR<TaskDetailPowerInterruptionCreateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedCreateWithoutLinemen_inchargeInput>
  }

  export type LinemanCreateWithoutPower_interruptionsInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutPower_interruptionsInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutPower_interruptionsInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutPower_interruptionsInput, LinemanUncheckedCreateWithoutPower_interruptionsInput>
  }

  export type TaskDetailPowerInterruptionUpsertWithoutLinemen_inchargeInput = {
    update: XOR<TaskDetailPowerInterruptionUpdateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutLinemen_inchargeInput>
    create: XOR<TaskDetailPowerInterruptionCreateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedCreateWithoutLinemen_inchargeInput>
    where?: TaskDetailPowerInterruptionWhereInput
  }

  export type TaskDetailPowerInterruptionUpdateToOneWithWhereWithoutLinemen_inchargeInput = {
    where?: TaskDetailPowerInterruptionWhereInput
    data: XOR<TaskDetailPowerInterruptionUpdateWithoutLinemen_inchargeInput, TaskDetailPowerInterruptionUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type TaskDetailPowerInterruptionUpdateWithoutLinemen_inchargeInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    feeder?: FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    weather_condition?: WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    device?: DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateWithoutLinemen_inchargeInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type LinemanUpsertWithoutPower_interruptionsInput = {
    update: XOR<LinemanUpdateWithoutPower_interruptionsInput, LinemanUncheckedUpdateWithoutPower_interruptionsInput>
    create: XOR<LinemanCreateWithoutPower_interruptionsInput, LinemanUncheckedCreateWithoutPower_interruptionsInput>
    where?: LinemanWhereInput
  }

  export type LinemanUpdateToOneWithWhereWithoutPower_interruptionsInput = {
    where?: LinemanWhereInput
    data: XOR<LinemanUpdateWithoutPower_interruptionsInput, LinemanUncheckedUpdateWithoutPower_interruptionsInput>
  }

  export type LinemanUpdateWithoutPower_interruptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutPower_interruptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type KwhMeterLinemanCreateWithoutTask_detailInput = {
    lineman: LinemanCreateNestedOneWithoutKwh_metersInput
  }

  export type KwhMeterLinemanUncheckedCreateWithoutTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type KwhMeterLinemanCreateOrConnectWithoutTask_detailInput = {
    where: KwhMeterLinemanWhereUniqueInput
    create: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type KwhMeterLinemanCreateManyTask_detailInputEnvelope = {
    data: KwhMeterLinemanCreateManyTask_detailInput | KwhMeterLinemanCreateManyTask_detailInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTask_detail_kwh_meterInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_detail_kwh_meterInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_detail_kwh_meterInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_detail_kwh_meterInput, TaskUncheckedCreateWithoutTask_detail_kwh_meterInput>
  }

  export type MeterBrandCreateWithoutKwh_meter_tasksInput = {
    id?: string
    name: string
  }

  export type MeterBrandUncheckedCreateWithoutKwh_meter_tasksInput = {
    id?: string
    name: string
  }

  export type MeterBrandCreateOrConnectWithoutKwh_meter_tasksInput = {
    where: MeterBrandWhereUniqueInput
    create: XOR<MeterBrandCreateWithoutKwh_meter_tasksInput, MeterBrandUncheckedCreateWithoutKwh_meter_tasksInput>
  }

  export type KwhMeterLinemanUpsertWithWhereUniqueWithoutTask_detailInput = {
    where: KwhMeterLinemanWhereUniqueInput
    update: XOR<KwhMeterLinemanUpdateWithoutTask_detailInput, KwhMeterLinemanUncheckedUpdateWithoutTask_detailInput>
    create: XOR<KwhMeterLinemanCreateWithoutTask_detailInput, KwhMeterLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type KwhMeterLinemanUpdateWithWhereUniqueWithoutTask_detailInput = {
    where: KwhMeterLinemanWhereUniqueInput
    data: XOR<KwhMeterLinemanUpdateWithoutTask_detailInput, KwhMeterLinemanUncheckedUpdateWithoutTask_detailInput>
  }

  export type KwhMeterLinemanUpdateManyWithWhereWithoutTask_detailInput = {
    where: KwhMeterLinemanScalarWhereInput
    data: XOR<KwhMeterLinemanUpdateManyMutationInput, KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailInput>
  }

  export type TaskUpsertWithoutTask_detail_kwh_meterInput = {
    update: XOR<TaskUpdateWithoutTask_detail_kwh_meterInput, TaskUncheckedUpdateWithoutTask_detail_kwh_meterInput>
    create: XOR<TaskCreateWithoutTask_detail_kwh_meterInput, TaskUncheckedCreateWithoutTask_detail_kwh_meterInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_detail_kwh_meterInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_detail_kwh_meterInput, TaskUncheckedUpdateWithoutTask_detail_kwh_meterInput>
  }

  export type TaskUpdateWithoutTask_detail_kwh_meterInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_detail_kwh_meterInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type MeterBrandUpsertWithoutKwh_meter_tasksInput = {
    update: XOR<MeterBrandUpdateWithoutKwh_meter_tasksInput, MeterBrandUncheckedUpdateWithoutKwh_meter_tasksInput>
    create: XOR<MeterBrandCreateWithoutKwh_meter_tasksInput, MeterBrandUncheckedCreateWithoutKwh_meter_tasksInput>
    where?: MeterBrandWhereInput
  }

  export type MeterBrandUpdateToOneWithWhereWithoutKwh_meter_tasksInput = {
    where?: MeterBrandWhereInput
    data: XOR<MeterBrandUpdateWithoutKwh_meter_tasksInput, MeterBrandUncheckedUpdateWithoutKwh_meter_tasksInput>
  }

  export type MeterBrandUpdateWithoutKwh_meter_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MeterBrandUncheckedUpdateWithoutKwh_meter_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailKwhMeterCreateWithoutLinemen_inchargeInput = {
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
    task: TaskCreateNestedOneWithoutTask_detail_kwh_meterInput
    meter_brand: MeterBrandCreateNestedOneWithoutKwh_meter_tasksInput
  }

  export type TaskDetailKwhMeterUncheckedCreateWithoutLinemen_inchargeInput = {
    id?: number
    task_id: number
    meter_number: string
    meter_brand_id: string
    last_reading: string
    initial_reading: string
    meter_class: string
  }

  export type TaskDetailKwhMeterCreateOrConnectWithoutLinemen_inchargeInput = {
    where: TaskDetailKwhMeterWhereUniqueInput
    create: XOR<TaskDetailKwhMeterCreateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedCreateWithoutLinemen_inchargeInput>
  }

  export type LinemanCreateWithoutKwh_metersInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutKwh_metersInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutKwh_metersInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutKwh_metersInput, LinemanUncheckedCreateWithoutKwh_metersInput>
  }

  export type TaskDetailKwhMeterUpsertWithoutLinemen_inchargeInput = {
    update: XOR<TaskDetailKwhMeterUpdateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedUpdateWithoutLinemen_inchargeInput>
    create: XOR<TaskDetailKwhMeterCreateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedCreateWithoutLinemen_inchargeInput>
    where?: TaskDetailKwhMeterWhereInput
  }

  export type TaskDetailKwhMeterUpdateToOneWithWhereWithoutLinemen_inchargeInput = {
    where?: TaskDetailKwhMeterWhereInput
    data: XOR<TaskDetailKwhMeterUpdateWithoutLinemen_inchargeInput, TaskDetailKwhMeterUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type TaskDetailKwhMeterUpdateWithoutLinemen_inchargeInput = {
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutTask_detail_kwh_meterNestedInput
    meter_brand?: MeterBrandUpdateOneRequiredWithoutKwh_meter_tasksNestedInput
  }

  export type TaskDetailKwhMeterUncheckedUpdateWithoutLinemen_inchargeInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    meter_brand_id?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
  }

  export type LinemanUpsertWithoutKwh_metersInput = {
    update: XOR<LinemanUpdateWithoutKwh_metersInput, LinemanUncheckedUpdateWithoutKwh_metersInput>
    create: XOR<LinemanCreateWithoutKwh_metersInput, LinemanUncheckedCreateWithoutKwh_metersInput>
    where?: LinemanWhereInput
  }

  export type LinemanUpdateToOneWithWhereWithoutKwh_metersInput = {
    where?: LinemanWhereInput
    data: XOR<LinemanUpdateWithoutKwh_metersInput, LinemanUncheckedUpdateWithoutKwh_metersInput>
  }

  export type LinemanUpdateWithoutKwh_metersInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutKwh_metersInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type LineServicesLinemanCreateWithoutTask_detailInput = {
    lineman: LinemanCreateNestedOneWithoutLine_servicesInput
  }

  export type LineServicesLinemanUncheckedCreateWithoutTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type LineServicesLinemanCreateOrConnectWithoutTask_detailInput = {
    where: LineServicesLinemanWhereUniqueInput
    create: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type LineServicesLinemanCreateManyTask_detailInputEnvelope = {
    data: LineServicesLinemanCreateManyTask_detailInput | LineServicesLinemanCreateManyTask_detailInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTask_detail_line_servicesInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_detail_line_servicesInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_detail_line_servicesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_detail_line_servicesInput, TaskUncheckedCreateWithoutTask_detail_line_servicesInput>
  }

  export type LineServicesLinemanUpsertWithWhereUniqueWithoutTask_detailInput = {
    where: LineServicesLinemanWhereUniqueInput
    update: XOR<LineServicesLinemanUpdateWithoutTask_detailInput, LineServicesLinemanUncheckedUpdateWithoutTask_detailInput>
    create: XOR<LineServicesLinemanCreateWithoutTask_detailInput, LineServicesLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type LineServicesLinemanUpdateWithWhereUniqueWithoutTask_detailInput = {
    where: LineServicesLinemanWhereUniqueInput
    data: XOR<LineServicesLinemanUpdateWithoutTask_detailInput, LineServicesLinemanUncheckedUpdateWithoutTask_detailInput>
  }

  export type LineServicesLinemanUpdateManyWithWhereWithoutTask_detailInput = {
    where: LineServicesLinemanScalarWhereInput
    data: XOR<LineServicesLinemanUpdateManyMutationInput, LineServicesLinemanUncheckedUpdateManyWithoutTask_detailInput>
  }

  export type TaskUpsertWithoutTask_detail_line_servicesInput = {
    update: XOR<TaskUpdateWithoutTask_detail_line_servicesInput, TaskUncheckedUpdateWithoutTask_detail_line_servicesInput>
    create: XOR<TaskCreateWithoutTask_detail_line_servicesInput, TaskUncheckedCreateWithoutTask_detail_line_servicesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_detail_line_servicesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_detail_line_servicesInput, TaskUncheckedUpdateWithoutTask_detail_line_servicesInput>
  }

  export type TaskUpdateWithoutTask_detail_line_servicesInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_detail_line_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskDetailLineServicesCreateWithoutLinemen_inchargeInput = {
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
    task: TaskCreateNestedOneWithoutTask_detail_line_servicesInput
  }

  export type TaskDetailLineServicesUncheckedCreateWithoutLinemen_inchargeInput = {
    id?: number
    task_id: number
    order_number: string
    cause: string
    mrv_number: string
    seriv_number: string
    mst_number: string
    mcrt_number: string
  }

  export type TaskDetailLineServicesCreateOrConnectWithoutLinemen_inchargeInput = {
    where: TaskDetailLineServicesWhereUniqueInput
    create: XOR<TaskDetailLineServicesCreateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedCreateWithoutLinemen_inchargeInput>
  }

  export type LinemanCreateWithoutLine_servicesInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutLine_servicesInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutLine_servicesInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutLine_servicesInput, LinemanUncheckedCreateWithoutLine_servicesInput>
  }

  export type TaskDetailLineServicesUpsertWithoutLinemen_inchargeInput = {
    update: XOR<TaskDetailLineServicesUpdateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedUpdateWithoutLinemen_inchargeInput>
    create: XOR<TaskDetailLineServicesCreateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedCreateWithoutLinemen_inchargeInput>
    where?: TaskDetailLineServicesWhereInput
  }

  export type TaskDetailLineServicesUpdateToOneWithWhereWithoutLinemen_inchargeInput = {
    where?: TaskDetailLineServicesWhereInput
    data: XOR<TaskDetailLineServicesUpdateWithoutLinemen_inchargeInput, TaskDetailLineServicesUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type TaskDetailLineServicesUpdateWithoutLinemen_inchargeInput = {
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutTask_detail_line_servicesNestedInput
  }

  export type TaskDetailLineServicesUncheckedUpdateWithoutLinemen_inchargeInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    order_number?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mcrt_number?: StringFieldUpdateOperationsInput | string
  }

  export type LinemanUpsertWithoutLine_servicesInput = {
    update: XOR<LinemanUpdateWithoutLine_servicesInput, LinemanUncheckedUpdateWithoutLine_servicesInput>
    create: XOR<LinemanCreateWithoutLine_servicesInput, LinemanUncheckedCreateWithoutLine_servicesInput>
    where?: LinemanWhereInput
  }

  export type LinemanUpdateToOneWithWhereWithoutLine_servicesInput = {
    where?: LinemanWhereInput
    data: XOR<LinemanUpdateWithoutLine_servicesInput, LinemanUncheckedUpdateWithoutLine_servicesInput>
  }

  export type LinemanUpdateWithoutLine_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutLine_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type DlesLinemanCreateWithoutTask_detailInput = {
    lineman: LinemanCreateNestedOneWithoutDlesInput
  }

  export type DlesLinemanUncheckedCreateWithoutTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type DlesLinemanCreateOrConnectWithoutTask_detailInput = {
    where: DlesLinemanWhereUniqueInput
    create: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type DlesLinemanCreateManyTask_detailInputEnvelope = {
    data: DlesLinemanCreateManyTask_detailInput | DlesLinemanCreateManyTask_detailInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTask_detail_dlesInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_detail_dlesInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_detail_dlesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_detail_dlesInput, TaskUncheckedCreateWithoutTask_detail_dlesInput>
  }

  export type DlesLinemanUpsertWithWhereUniqueWithoutTask_detailInput = {
    where: DlesLinemanWhereUniqueInput
    update: XOR<DlesLinemanUpdateWithoutTask_detailInput, DlesLinemanUncheckedUpdateWithoutTask_detailInput>
    create: XOR<DlesLinemanCreateWithoutTask_detailInput, DlesLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type DlesLinemanUpdateWithWhereUniqueWithoutTask_detailInput = {
    where: DlesLinemanWhereUniqueInput
    data: XOR<DlesLinemanUpdateWithoutTask_detailInput, DlesLinemanUncheckedUpdateWithoutTask_detailInput>
  }

  export type DlesLinemanUpdateManyWithWhereWithoutTask_detailInput = {
    where: DlesLinemanScalarWhereInput
    data: XOR<DlesLinemanUpdateManyMutationInput, DlesLinemanUncheckedUpdateManyWithoutTask_detailInput>
  }

  export type TaskUpsertWithoutTask_detail_dlesInput = {
    update: XOR<TaskUpdateWithoutTask_detail_dlesInput, TaskUncheckedUpdateWithoutTask_detail_dlesInput>
    create: XOR<TaskCreateWithoutTask_detail_dlesInput, TaskUncheckedCreateWithoutTask_detail_dlesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_detail_dlesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_detail_dlesInput, TaskUncheckedUpdateWithoutTask_detail_dlesInput>
  }

  export type TaskUpdateWithoutTask_detail_dlesInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_detail_dlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskDetailDlesCreateWithoutLinemen_inchargeInput = {
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
    task: TaskCreateNestedOneWithoutTask_detail_dlesInput
  }

  export type TaskDetailDlesUncheckedCreateWithoutLinemen_inchargeInput = {
    id?: number
    task_id: number
    sco_number: string
    old_serial_number: string
    new_serial_number: string
    seriv_number: string
    kva_rating: string
    cause: string
  }

  export type TaskDetailDlesCreateOrConnectWithoutLinemen_inchargeInput = {
    where: TaskDetailDlesWhereUniqueInput
    create: XOR<TaskDetailDlesCreateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedCreateWithoutLinemen_inchargeInput>
  }

  export type LinemanCreateWithoutDlesInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutDlesInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    lmdgas?: LmdgaLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutDlesInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutDlesInput, LinemanUncheckedCreateWithoutDlesInput>
  }

  export type TaskDetailDlesUpsertWithoutLinemen_inchargeInput = {
    update: XOR<TaskDetailDlesUpdateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedUpdateWithoutLinemen_inchargeInput>
    create: XOR<TaskDetailDlesCreateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedCreateWithoutLinemen_inchargeInput>
    where?: TaskDetailDlesWhereInput
  }

  export type TaskDetailDlesUpdateToOneWithWhereWithoutLinemen_inchargeInput = {
    where?: TaskDetailDlesWhereInput
    data: XOR<TaskDetailDlesUpdateWithoutLinemen_inchargeInput, TaskDetailDlesUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type TaskDetailDlesUpdateWithoutLinemen_inchargeInput = {
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutTask_detail_dlesNestedInput
  }

  export type TaskDetailDlesUncheckedUpdateWithoutLinemen_inchargeInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    sco_number?: StringFieldUpdateOperationsInput | string
    old_serial_number?: StringFieldUpdateOperationsInput | string
    new_serial_number?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    kva_rating?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
  }

  export type LinemanUpsertWithoutDlesInput = {
    update: XOR<LinemanUpdateWithoutDlesInput, LinemanUncheckedUpdateWithoutDlesInput>
    create: XOR<LinemanCreateWithoutDlesInput, LinemanUncheckedCreateWithoutDlesInput>
    where?: LinemanWhereInput
  }

  export type LinemanUpdateToOneWithWhereWithoutDlesInput = {
    where?: LinemanWhereInput
    data: XOR<LinemanUpdateWithoutDlesInput, LinemanUncheckedUpdateWithoutDlesInput>
  }

  export type LinemanUpdateWithoutDlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutDlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type LmdgaLinemanCreateWithoutTask_detailInput = {
    lineman: LinemanCreateNestedOneWithoutLmdgasInput
  }

  export type LmdgaLinemanUncheckedCreateWithoutTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type LmdgaLinemanCreateOrConnectWithoutTask_detailInput = {
    where: LmdgaLinemanWhereUniqueInput
    create: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type LmdgaLinemanCreateManyTask_detailInputEnvelope = {
    data: LmdgaLinemanCreateManyTask_detailInput | LmdgaLinemanCreateManyTask_detailInput[]
    skipDuplicates?: boolean
  }

  export type FeederCreateWithoutLmdga_tasksInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionCreateNestedManyWithoutFeederInput
  }

  export type FeederUncheckedCreateWithoutLmdga_tasksInput = {
    id?: string
    name: string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedCreateNestedManyWithoutFeederInput
  }

  export type FeederCreateOrConnectWithoutLmdga_tasksInput = {
    where: FeederWhereUniqueInput
    create: XOR<FeederCreateWithoutLmdga_tasksInput, FeederUncheckedCreateWithoutLmdga_tasksInput>
  }

  export type TaskCreateWithoutTask_detail_lmdgaInput = {
    ref_number: string
    assignee_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
    files?: TaskFileCreateNestedManyWithoutTaskInput
    complaint?: ComplaintCreateNestedOneWithoutTasksInput
    status: TaskStatusCreateNestedOneWithoutTasksInput
    activity?: ActivityCreateNestedOneWithoutTasksInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_detail_lmdgaInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    task_assignment?: TaskAssignmentUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
    files?: TaskFileUncheckedCreateNestedManyWithoutTaskInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedCreateNestedOneWithoutTaskInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedCreateNestedOneWithoutTaskInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedCreateNestedOneWithoutTaskInput
    task_detail_dles?: TaskDetailDlesUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_detail_lmdgaInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_detail_lmdgaInput, TaskUncheckedCreateWithoutTask_detail_lmdgaInput>
  }

  export type LmdgaLinemanUpsertWithWhereUniqueWithoutTask_detailInput = {
    where: LmdgaLinemanWhereUniqueInput
    update: XOR<LmdgaLinemanUpdateWithoutTask_detailInput, LmdgaLinemanUncheckedUpdateWithoutTask_detailInput>
    create: XOR<LmdgaLinemanCreateWithoutTask_detailInput, LmdgaLinemanUncheckedCreateWithoutTask_detailInput>
  }

  export type LmdgaLinemanUpdateWithWhereUniqueWithoutTask_detailInput = {
    where: LmdgaLinemanWhereUniqueInput
    data: XOR<LmdgaLinemanUpdateWithoutTask_detailInput, LmdgaLinemanUncheckedUpdateWithoutTask_detailInput>
  }

  export type LmdgaLinemanUpdateManyWithWhereWithoutTask_detailInput = {
    where: LmdgaLinemanScalarWhereInput
    data: XOR<LmdgaLinemanUpdateManyMutationInput, LmdgaLinemanUncheckedUpdateManyWithoutTask_detailInput>
  }

  export type FeederUpsertWithoutLmdga_tasksInput = {
    update: XOR<FeederUpdateWithoutLmdga_tasksInput, FeederUncheckedUpdateWithoutLmdga_tasksInput>
    create: XOR<FeederCreateWithoutLmdga_tasksInput, FeederUncheckedCreateWithoutLmdga_tasksInput>
    where?: FeederWhereInput
  }

  export type FeederUpdateToOneWithWhereWithoutLmdga_tasksInput = {
    where?: FeederWhereInput
    data: XOR<FeederUpdateWithoutLmdga_tasksInput, FeederUncheckedUpdateWithoutLmdga_tasksInput>
  }

  export type FeederUpdateWithoutLmdga_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUpdateManyWithoutFeederNestedInput
  }

  export type FeederUncheckedUpdateWithoutLmdga_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    power_interruption_tasks?: TaskDetailPowerInterruptionUncheckedUpdateManyWithoutFeederNestedInput
  }

  export type TaskUpsertWithoutTask_detail_lmdgaInput = {
    update: XOR<TaskUpdateWithoutTask_detail_lmdgaInput, TaskUncheckedUpdateWithoutTask_detail_lmdgaInput>
    create: XOR<TaskCreateWithoutTask_detail_lmdgaInput, TaskUncheckedCreateWithoutTask_detail_lmdgaInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_detail_lmdgaInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_detail_lmdgaInput, TaskUncheckedUpdateWithoutTask_detail_lmdgaInput>
  }

  export type TaskUpdateWithoutTask_detail_lmdgaInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_detail_lmdgaInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskDetailLmdgaCreateWithoutLinemen_inchargeInput = {
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
    feeder: FeederCreateNestedOneWithoutLmdga_tasksInput
    task: TaskCreateNestedOneWithoutTask_detail_lmdgaInput
  }

  export type TaskDetailLmdgaUncheckedCreateWithoutLinemen_inchargeInput = {
    id?: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    feeder_id: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
  }

  export type TaskDetailLmdgaCreateOrConnectWithoutLinemen_inchargeInput = {
    where: TaskDetailLmdgaWhereUniqueInput
    create: XOR<TaskDetailLmdgaCreateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedCreateWithoutLinemen_inchargeInput>
  }

  export type LinemanCreateWithoutLmdgasInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    area: AreaCreateNestedOneWithoutLinemenInput
    power_interruptions?: PowerInterruptionLinemanCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanCreateNestedManyWithoutLinemanInput
  }

  export type LinemanUncheckedCreateWithoutLmdgasInput = {
    id?: string
    employee_id: string
    area_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedCreateNestedManyWithoutLinemanInput
    kwh_meters?: KwhMeterLinemanUncheckedCreateNestedManyWithoutLinemanInput
    line_services?: LineServicesLinemanUncheckedCreateNestedManyWithoutLinemanInput
    dles?: DlesLinemanUncheckedCreateNestedManyWithoutLinemanInput
  }

  export type LinemanCreateOrConnectWithoutLmdgasInput = {
    where: LinemanWhereUniqueInput
    create: XOR<LinemanCreateWithoutLmdgasInput, LinemanUncheckedCreateWithoutLmdgasInput>
  }

  export type TaskDetailLmdgaUpsertWithoutLinemen_inchargeInput = {
    update: XOR<TaskDetailLmdgaUpdateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedUpdateWithoutLinemen_inchargeInput>
    create: XOR<TaskDetailLmdgaCreateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedCreateWithoutLinemen_inchargeInput>
    where?: TaskDetailLmdgaWhereInput
  }

  export type TaskDetailLmdgaUpdateToOneWithWhereWithoutLinemen_inchargeInput = {
    where?: TaskDetailLmdgaWhereInput
    data: XOR<TaskDetailLmdgaUpdateWithoutLinemen_inchargeInput, TaskDetailLmdgaUncheckedUpdateWithoutLinemen_inchargeInput>
  }

  export type TaskDetailLmdgaUpdateWithoutLinemen_inchargeInput = {
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    feeder?: FeederUpdateOneRequiredWithoutLmdga_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_lmdgaNestedInput
  }

  export type TaskDetailLmdgaUncheckedUpdateWithoutLinemen_inchargeInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    feeder_id?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
  }

  export type LinemanUpsertWithoutLmdgasInput = {
    update: XOR<LinemanUpdateWithoutLmdgasInput, LinemanUncheckedUpdateWithoutLmdgasInput>
    create: XOR<LinemanCreateWithoutLmdgasInput, LinemanUncheckedCreateWithoutLmdgasInput>
    where?: LinemanWhereInput
  }

  export type LinemanUpdateToOneWithWhereWithoutLmdgasInput = {
    where?: LinemanWhereInput
    data: XOR<LinemanUpdateWithoutLmdgasInput, LinemanUncheckedUpdateWithoutLmdgasInput>
  }

  export type LinemanUpdateWithoutLmdgasInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    area?: AreaUpdateOneRequiredWithoutLinemenNestedInput
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutLmdgasInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    area_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type PowerInterruptionLinemanCreateManyLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type KwhMeterLinemanCreateManyLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type LineServicesLinemanCreateManyLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type DlesLinemanCreateManyLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type LmdgaLinemanCreateManyLinemanInput = {
    id?: number
    task_detail_id: number
  }

  export type PowerInterruptionLinemanUpdateWithoutLinemanInput = {
    task_detail?: TaskDetailPowerInterruptionUpdateOneRequiredWithoutLinemen_inchargeNestedInput
  }

  export type PowerInterruptionLinemanUncheckedUpdateWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type KwhMeterLinemanUpdateWithoutLinemanInput = {
    task_detail?: TaskDetailKwhMeterUpdateOneRequiredWithoutLinemen_inchargeNestedInput
  }

  export type KwhMeterLinemanUncheckedUpdateWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type KwhMeterLinemanUncheckedUpdateManyWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type LineServicesLinemanUpdateWithoutLinemanInput = {
    task_detail?: TaskDetailLineServicesUpdateOneRequiredWithoutLinemen_inchargeNestedInput
  }

  export type LineServicesLinemanUncheckedUpdateWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type LineServicesLinemanUncheckedUpdateManyWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type DlesLinemanUpdateWithoutLinemanInput = {
    task_detail?: TaskDetailDlesUpdateOneRequiredWithoutLinemen_inchargeNestedInput
  }

  export type DlesLinemanUncheckedUpdateWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type DlesLinemanUncheckedUpdateManyWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type LmdgaLinemanUpdateWithoutLinemanInput = {
    task_detail?: TaskDetailLmdgaUpdateOneRequiredWithoutLinemen_inchargeNestedInput
  }

  export type LmdgaLinemanUncheckedUpdateWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type LmdgaLinemanUncheckedUpdateManyWithoutLinemanInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_detail_id?: IntFieldUpdateOperationsInput | number
  }

  export type LinemanCreateManyAreaInput = {
    id?: string
    employee_id: string
    supervisor_id: string
    status?: $Enums.LinemanStatus
  }

  export type MunicipalityCreateManyAreaInput = {
    id?: string
    name: string
  }

  export type TaskAssignmentCreateManyAreaInput = {
    id?: number
    task_id: number
    department_id?: string | null
    division_id?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type LinemanUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
    power_interruptions?: PowerInterruptionLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    kwh_meters?: KwhMeterLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    line_services?: LineServicesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    dles?: DlesLinemanUncheckedUpdateManyWithoutLinemanNestedInput
    lmdgas?: LmdgaLinemanUncheckedUpdateManyWithoutLinemanNestedInput
  }

  export type LinemanUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: EnumLinemanStatusFieldUpdateOperationsInput | $Enums.LinemanStatus
  }

  export type MunicipalityUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barangays?: BarangayUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barangays?: BarangayUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUpdateWithoutAreaInput = {
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTask_assignmentNestedInput
  }

  export type TaskAssignmentUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    division_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarangayCreateManyMunicipalityInput = {
    id?: string
    name: string
  }

  export type BarangayUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sitios?: SitioUpdateManyWithoutBarangayNestedInput
    complaint_details?: ComplaintDetailUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sitios?: SitioUncheckedUpdateManyWithoutBarangayNestedInput
    complaint_details?: ComplaintDetailUncheckedUpdateManyWithoutBarangayNestedInput
  }

  export type BarangayUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SitioCreateManyBarangayInput = {
    id?: string
    name: string
  }

  export type ComplaintDetailCreateManyBarangayInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    sitio_id?: string | null
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SitioUpdateWithoutBarangayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    complaint_details?: ComplaintDetailUpdateManyWithoutSitioNestedInput
  }

  export type SitioUncheckedUpdateWithoutBarangayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    complaint_details?: ComplaintDetailUncheckedUpdateManyWithoutSitioNestedInput
  }

  export type SitioUncheckedUpdateManyWithoutBarangayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ComplaintDetailUpdateWithoutBarangayInput = {
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutComplaint_detailNestedInput
    sitio?: SitioUpdateOneWithoutComplaint_detailsNestedInput
  }

  export type ComplaintDetailUncheckedUpdateWithoutBarangayInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    sitio_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailUncheckedUpdateManyWithoutBarangayInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    sitio_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailCreateManySitioInput = {
    id?: number
    complaint_id: number
    consumer_id?: string | null
    barangay_id: string
    landmark?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintDetailUpdateWithoutSitioInput = {
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutComplaint_detailNestedInput
    barangay?: BarangayUpdateOneRequiredWithoutComplaint_detailsNestedInput
  }

  export type ComplaintDetailUncheckedUpdateWithoutSitioInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    barangay_id?: StringFieldUpdateOperationsInput | string
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintDetailUncheckedUpdateManyWithoutSitioInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    consumer_id?: NullableStringFieldUpdateOperationsInput | string | null
    barangay_id?: StringFieldUpdateOperationsInput | string
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailPowerInterruptionCreateManyFeederInput = {
    id?: number
    task_id: number
    weather_condition_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
  }

  export type TaskDetailLmdgaCreateManyFeederInput = {
    id?: number
    task_id: number
    kva_rating: string
    substation_id: string
    dt_location: string
    phase_number: string
    number_of_hc: string
    number_of_spans: string
    copper_aluminum_primary: string
    copper_aluminum_secondary: string
    copper_aluminum_ground: string
    size_primary: string
    size_secondary: string
    size_ground: string
    terminal_connector_primary: string
    terminal_connector_secondary: string
    terminal_connector_ground: string
    tap_position: string
    brand: string
    number_of_bushing_primary: string
    number_of_bushing_secondary: string
    protective_device: string
    load_current_sec_bushing: string
    load_current_neutral: string
    load_current_one: string
    load_current_two: string
    voltage_level_one: string
    voltage_level_two: string
    sec_line_conductor_size_one: string
    sec_line_conductor_size_two: string
  }

  export type TaskDetailPowerInterruptionUpdateWithoutFeederInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput
    weather_condition?: WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    device?: DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateWithoutFeederInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutFeederInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailLmdgaUpdateWithoutFeederInput = {
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUpdateManyWithoutTask_detailNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_lmdgaNestedInput
  }

  export type TaskDetailLmdgaUncheckedUpdateWithoutFeederInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: LmdgaLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailLmdgaUncheckedUpdateManyWithoutFeederInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    kva_rating?: StringFieldUpdateOperationsInput | string
    substation_id?: StringFieldUpdateOperationsInput | string
    dt_location?: StringFieldUpdateOperationsInput | string
    phase_number?: StringFieldUpdateOperationsInput | string
    number_of_hc?: StringFieldUpdateOperationsInput | string
    number_of_spans?: StringFieldUpdateOperationsInput | string
    copper_aluminum_primary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_secondary?: StringFieldUpdateOperationsInput | string
    copper_aluminum_ground?: StringFieldUpdateOperationsInput | string
    size_primary?: StringFieldUpdateOperationsInput | string
    size_secondary?: StringFieldUpdateOperationsInput | string
    size_ground?: StringFieldUpdateOperationsInput | string
    terminal_connector_primary?: StringFieldUpdateOperationsInput | string
    terminal_connector_secondary?: StringFieldUpdateOperationsInput | string
    terminal_connector_ground?: StringFieldUpdateOperationsInput | string
    tap_position?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    number_of_bushing_primary?: StringFieldUpdateOperationsInput | string
    number_of_bushing_secondary?: StringFieldUpdateOperationsInput | string
    protective_device?: StringFieldUpdateOperationsInput | string
    load_current_sec_bushing?: StringFieldUpdateOperationsInput | string
    load_current_neutral?: StringFieldUpdateOperationsInput | string
    load_current_one?: StringFieldUpdateOperationsInput | string
    load_current_two?: StringFieldUpdateOperationsInput | string
    voltage_level_one?: StringFieldUpdateOperationsInput | string
    voltage_level_two?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_one?: StringFieldUpdateOperationsInput | string
    sec_line_conductor_size_two?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailPowerInterruptionCreateManyWeather_conditionInput = {
    id?: number
    task_id: number
    feeder_id: string
    device_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
  }

  export type TaskDetailPowerInterruptionUpdateWithoutWeather_conditionInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    device?: DeviceUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateWithoutWeather_conditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutWeather_conditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailPowerInterruptionCreateManyDeviceInput = {
    id?: number
    task_id: number
    feeder_id: string
    weather_condition_id: string
    affected_area: string
    cause: string
    equipment_failed: string
    fuse_rating: string
  }

  export type TaskDetailPowerInterruptionUpdateWithoutDeviceInput = {
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUpdateManyWithoutTask_detailNestedInput
    feeder?: FeederUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    weather_condition?: WeatherConditionUpdateOneRequiredWithoutPower_interruption_tasksNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_power_interruptionNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailPowerInterruptionUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    feeder_id?: StringFieldUpdateOperationsInput | string
    weather_condition_id?: StringFieldUpdateOperationsInput | string
    affected_area?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    equipment_failed?: StringFieldUpdateOperationsInput | string
    fuse_rating?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDetailKwhMeterCreateManyMeter_brandInput = {
    id?: number
    task_id: number
    meter_number: string
    last_reading: string
    initial_reading: string
    meter_class: string
  }

  export type TaskDetailKwhMeterUpdateWithoutMeter_brandInput = {
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUpdateManyWithoutTask_detailNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_detail_kwh_meterNestedInput
  }

  export type TaskDetailKwhMeterUncheckedUpdateWithoutMeter_brandInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
    linemen_incharge?: KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailNestedInput
  }

  export type TaskDetailKwhMeterUncheckedUpdateManyWithoutMeter_brandInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    meter_number?: StringFieldUpdateOperationsInput | string
    last_reading?: StringFieldUpdateOperationsInput | string
    initial_reading?: StringFieldUpdateOperationsInput | string
    meter_class?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyActivityInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    task_status_id: number
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateWithoutActivityInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyCategoryInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogCreateManyComplaintInput = {
    id?: number
    complaint_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskCreateManyComplaintInput = {
    id?: number
    ref_number: string
    assignee_id?: string | null
    task_status_id: number
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintLogUpdateWithoutComplaintInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: ComplaintStatusUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ComplaintLogUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogUncheckedUpdateManyWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutComplaintInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    status?: TaskStatusUpdateOneRequiredWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    task_status_id?: IntFieldUpdateOperationsInput | number
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateManyStatusInput = {
    id?: number
    report_type_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintLogCreateManyStatusInput = {
    id?: number
    complaint_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ComplaintUpdateWithoutStatusInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUpdateManyWithoutComplaintNestedInput
    report_type?: ComplaintReportTypeUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_type_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogUpdateWithoutStatusInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: ComplaintUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ComplaintLogUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintLogUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateManyReport_typeInput = {
    id?: number
    complaint_status_id: number
    assigned_group_id: string
    assigned_group_type: number
    ref_number: string
    complainant_name: string
    complainant_contact_no: string
    description: string
    remarks?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintUpdateWithoutReport_typeInput = {
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUpdateManyWithoutComplaintNestedInput
    status?: ComplaintStatusUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateWithoutReport_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint_detail?: ComplaintDetailUncheckedUpdateOneWithoutComplaintNestedInput
    logs?: ComplaintLogUncheckedUpdateManyWithoutComplaintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type ComplaintUncheckedUpdateManyWithoutReport_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    complaint_status_id?: IntFieldUpdateOperationsInput | number
    assigned_group_id?: StringFieldUpdateOperationsInput | string
    assigned_group_type?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complainant_name?: StringFieldUpdateOperationsInput | string
    complainant_contact_no?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogCreateManyTaskInput = {
    id?: number
    task_status_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskFileCreateManyTaskInput = {
    id?: number
    filename: string
    source_path: string
  }

  export type TaskLogUpdateWithoutTaskInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: TaskStatusUpdateOneRequiredWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_status_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskFileUpdateWithoutTaskInput = {
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFileUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFileUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    source_path?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyStatusInput = {
    id?: number
    ref_number: string
    complaint_id?: number | null
    assignee_id?: string | null
    activity_id?: string | null
    description: string
    remarks: string
    accomplishment: string
    action_taken: string
    acted_at?: Date | string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskLogCreateManyStatusInput = {
    id?: number
    task_id: number
    remarks?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type TaskUpdateWithoutStatusInput = {
    ref_number?: StringFieldUpdateOperationsInput | string
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
    files?: TaskFileUpdateManyWithoutTaskNestedInput
    complaint?: ComplaintUpdateOneWithoutTasksNestedInput
    activity?: ActivityUpdateOneWithoutTasksNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_assignment?: TaskAssignmentUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
    files?: TaskFileUncheckedUpdateManyWithoutTaskNestedInput
    task_detail_power_interruption?: TaskDetailPowerInterruptionUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_kwh_meter?: TaskDetailKwhMeterUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_line_services?: TaskDetailLineServicesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_dles?: TaskDetailDlesUncheckedUpdateOneWithoutTaskNestedInput
    task_detail_lmdga?: TaskDetailLmdgaUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref_number?: StringFieldUpdateOperationsInput | string
    complaint_id?: NullableIntFieldUpdateOperationsInput | number | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    activity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    accomplishment?: StringFieldUpdateOperationsInput | string
    action_taken?: StringFieldUpdateOperationsInput | string
    acted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUpdateWithoutStatusInput = {
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PowerInterruptionLinemanCreateManyTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type PowerInterruptionLinemanUpdateWithoutTask_detailInput = {
    lineman?: LinemanUpdateOneRequiredWithoutPower_interruptionsNestedInput
  }

  export type PowerInterruptionLinemanUncheckedUpdateWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type PowerInterruptionLinemanUncheckedUpdateManyWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type KwhMeterLinemanCreateManyTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type KwhMeterLinemanUpdateWithoutTask_detailInput = {
    lineman?: LinemanUpdateOneRequiredWithoutKwh_metersNestedInput
  }

  export type KwhMeterLinemanUncheckedUpdateWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type KwhMeterLinemanUncheckedUpdateManyWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LineServicesLinemanCreateManyTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type LineServicesLinemanUpdateWithoutTask_detailInput = {
    lineman?: LinemanUpdateOneRequiredWithoutLine_servicesNestedInput
  }

  export type LineServicesLinemanUncheckedUpdateWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LineServicesLinemanUncheckedUpdateManyWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type DlesLinemanCreateManyTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type DlesLinemanUpdateWithoutTask_detailInput = {
    lineman?: LinemanUpdateOneRequiredWithoutDlesNestedInput
  }

  export type DlesLinemanUncheckedUpdateWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type DlesLinemanUncheckedUpdateManyWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LmdgaLinemanCreateManyTask_detailInput = {
    id?: number
    lineman_id: string
  }

  export type LmdgaLinemanUpdateWithoutTask_detailInput = {
    lineman?: LinemanUpdateOneRequiredWithoutLmdgasNestedInput
  }

  export type LmdgaLinemanUncheckedUpdateWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }

  export type LmdgaLinemanUncheckedUpdateManyWithoutTask_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineman_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}