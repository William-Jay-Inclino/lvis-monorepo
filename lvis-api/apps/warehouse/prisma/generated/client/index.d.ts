
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Station
 * 
 */
export type Station = $Result.DefaultSelection<Prisma.$StationPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Pending
 * 
 */
export type Pending = $Result.DefaultSelection<Prisma.$PendingPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemLocation
 * 
 */
export type ItemLocation = $Result.DefaultSelection<Prisma.$ItemLocationPayload>
/**
 * Model ItemMovement
 * 
 */
export type ItemMovement = $Result.DefaultSelection<Prisma.$ItemMovementPayload>
/**
 * Model ItemTransaction
 * 
 */
export type ItemTransaction = $Result.DefaultSelection<Prisma.$ItemTransactionPayload>
/**
 * Model ItemCodeTracker
 * 
 */
export type ItemCodeTracker = $Result.DefaultSelection<Prisma.$ItemCodeTrackerPayload>
/**
 * Model Canvass
 * 
 */
export type Canvass = $Result.DefaultSelection<Prisma.$CanvassPayload>
/**
 * Model CanvassItem
 * 
 */
export type CanvassItem = $Result.DefaultSelection<Prisma.$CanvassItemPayload>
/**
 * Model RV
 * 
 */
export type RV = $Result.DefaultSelection<Prisma.$RVPayload>
/**
 * Model RVApprover
 * 
 */
export type RVApprover = $Result.DefaultSelection<Prisma.$RVApproverPayload>
/**
 * Model JO
 * 
 */
export type JO = $Result.DefaultSelection<Prisma.$JOPayload>
/**
 * Model JOApprover
 * 
 */
export type JOApprover = $Result.DefaultSelection<Prisma.$JOApproverPayload>
/**
 * Model SPR
 * 
 */
export type SPR = $Result.DefaultSelection<Prisma.$SPRPayload>
/**
 * Model SPRApprover
 * 
 */
export type SPRApprover = $Result.DefaultSelection<Prisma.$SPRApproverPayload>
/**
 * Model MEQS
 * 
 */
export type MEQS = $Result.DefaultSelection<Prisma.$MEQSPayload>
/**
 * Model MEQSSupplier
 * 
 */
export type MEQSSupplier = $Result.DefaultSelection<Prisma.$MEQSSupplierPayload>
/**
 * Model MEQSSupplierItem
 * 
 */
export type MEQSSupplierItem = $Result.DefaultSelection<Prisma.$MEQSSupplierItemPayload>
/**
 * Model MEQSSupplierAttachment
 * 
 */
export type MEQSSupplierAttachment = $Result.DefaultSelection<Prisma.$MEQSSupplierAttachmentPayload>
/**
 * Model MEQSApprover
 * 
 */
export type MEQSApprover = $Result.DefaultSelection<Prisma.$MEQSApproverPayload>
/**
 * Model PO
 * 
 */
export type PO = $Result.DefaultSelection<Prisma.$POPayload>
/**
 * Model POApprover
 * 
 */
export type POApprover = $Result.DefaultSelection<Prisma.$POApproverPayload>
/**
 * Model RR
 * 
 */
export type RR = $Result.DefaultSelection<Prisma.$RRPayload>
/**
 * Model RRApprover
 * 
 */
export type RRApprover = $Result.DefaultSelection<Prisma.$RRApproverPayload>
/**
 * Model RRItem
 * 
 */
export type RRItem = $Result.DefaultSelection<Prisma.$RRItemPayload>
/**
 * Model OSRIV
 * 
 */
export type OSRIV = $Result.DefaultSelection<Prisma.$OSRIVPayload>
/**
 * Model OSRIVApprover
 * 
 */
export type OSRIVApprover = $Result.DefaultSelection<Prisma.$OSRIVApproverPayload>
/**
 * Model OSRIVItem
 * 
 */
export type OSRIVItem = $Result.DefaultSelection<Prisma.$OSRIVItemPayload>
/**
 * Model SERIV
 * 
 */
export type SERIV = $Result.DefaultSelection<Prisma.$SERIVPayload>
/**
 * Model SERIVApprover
 * 
 */
export type SERIVApprover = $Result.DefaultSelection<Prisma.$SERIVApproverPayload>
/**
 * Model SERIVItem
 * 
 */
export type SERIVItem = $Result.DefaultSelection<Prisma.$SERIVItemPayload>
/**
 * Model MRV
 * 
 */
export type MRV = $Result.DefaultSelection<Prisma.$MRVPayload>
/**
 * Model MRVApprover
 * 
 */
export type MRVApprover = $Result.DefaultSelection<Prisma.$MRVApproverPayload>
/**
 * Model MRVItem
 * 
 */
export type MRVItem = $Result.DefaultSelection<Prisma.$MRVItemPayload>
/**
 * Model MCT
 * 
 */
export type MCT = $Result.DefaultSelection<Prisma.$MCTPayload>
/**
 * Model MCTApprover
 * 
 */
export type MCTApprover = $Result.DefaultSelection<Prisma.$MCTApproverPayload>
/**
 * Model MCRT
 * 
 */
export type MCRT = $Result.DefaultSelection<Prisma.$MCRTPayload>
/**
 * Model MCRTApprover
 * 
 */
export type MCRTApprover = $Result.DefaultSelection<Prisma.$MCRTApproverPayload>
/**
 * Model MCRTItem
 * 
 */
export type MCRTItem = $Result.DefaultSelection<Prisma.$MCRTItemPayload>
/**
 * Model MST
 * 
 */
export type MST = $Result.DefaultSelection<Prisma.$MSTPayload>
/**
 * Model MSTApprover
 * 
 */
export type MSTApprover = $Result.DefaultSelection<Prisma.$MSTApproverPayload>
/**
 * Model MSTItem
 * 
 */
export type MSTItem = $Result.DefaultSelection<Prisma.$MSTItemPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ItemTypes
 * const itemTypes = await prisma.itemType.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ItemTypes
   * const itemTypes = await prisma.itemType.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.station`: Exposes CRUD operations for the **Station** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stations
    * const stations = await prisma.station.findMany()
    * ```
    */
  get station(): Prisma.StationDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.pending`: Exposes CRUD operations for the **Pending** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pendings
    * const pendings = await prisma.pending.findMany()
    * ```
    */
  get pending(): Prisma.PendingDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.itemLocation`: Exposes CRUD operations for the **ItemLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemLocations
    * const itemLocations = await prisma.itemLocation.findMany()
    * ```
    */
  get itemLocation(): Prisma.ItemLocationDelegate<ExtArgs>;

  /**
   * `prisma.itemMovement`: Exposes CRUD operations for the **ItemMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemMovements
    * const itemMovements = await prisma.itemMovement.findMany()
    * ```
    */
  get itemMovement(): Prisma.ItemMovementDelegate<ExtArgs>;

  /**
   * `prisma.itemTransaction`: Exposes CRUD operations for the **ItemTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTransactions
    * const itemTransactions = await prisma.itemTransaction.findMany()
    * ```
    */
  get itemTransaction(): Prisma.ItemTransactionDelegate<ExtArgs>;

  /**
   * `prisma.itemCodeTracker`: Exposes CRUD operations for the **ItemCodeTracker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCodeTrackers
    * const itemCodeTrackers = await prisma.itemCodeTracker.findMany()
    * ```
    */
  get itemCodeTracker(): Prisma.ItemCodeTrackerDelegate<ExtArgs>;

  /**
   * `prisma.canvass`: Exposes CRUD operations for the **Canvass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Canvasses
    * const canvasses = await prisma.canvass.findMany()
    * ```
    */
  get canvass(): Prisma.CanvassDelegate<ExtArgs>;

  /**
   * `prisma.canvassItem`: Exposes CRUD operations for the **CanvassItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvassItems
    * const canvassItems = await prisma.canvassItem.findMany()
    * ```
    */
  get canvassItem(): Prisma.CanvassItemDelegate<ExtArgs>;

  /**
   * `prisma.rV`: Exposes CRUD operations for the **RV** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RVS
    * const rVS = await prisma.rV.findMany()
    * ```
    */
  get rV(): Prisma.RVDelegate<ExtArgs>;

  /**
   * `prisma.rVApprover`: Exposes CRUD operations for the **RVApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RVApprovers
    * const rVApprovers = await prisma.rVApprover.findMany()
    * ```
    */
  get rVApprover(): Prisma.RVApproverDelegate<ExtArgs>;

  /**
   * `prisma.jO`: Exposes CRUD operations for the **JO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JOS
    * const jOS = await prisma.jO.findMany()
    * ```
    */
  get jO(): Prisma.JODelegate<ExtArgs>;

  /**
   * `prisma.jOApprover`: Exposes CRUD operations for the **JOApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JOApprovers
    * const jOApprovers = await prisma.jOApprover.findMany()
    * ```
    */
  get jOApprover(): Prisma.JOApproverDelegate<ExtArgs>;

  /**
   * `prisma.sPR`: Exposes CRUD operations for the **SPR** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SPRS
    * const sPRS = await prisma.sPR.findMany()
    * ```
    */
  get sPR(): Prisma.SPRDelegate<ExtArgs>;

  /**
   * `prisma.sPRApprover`: Exposes CRUD operations for the **SPRApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SPRApprovers
    * const sPRApprovers = await prisma.sPRApprover.findMany()
    * ```
    */
  get sPRApprover(): Prisma.SPRApproverDelegate<ExtArgs>;

  /**
   * `prisma.mEQS`: Exposes CRUD operations for the **MEQS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQS
    * const mEQS = await prisma.mEQS.findMany()
    * ```
    */
  get mEQS(): Prisma.MEQSDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplier`: Exposes CRUD operations for the **MEQSSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSuppliers
    * const mEQSSuppliers = await prisma.mEQSSupplier.findMany()
    * ```
    */
  get mEQSSupplier(): Prisma.MEQSSupplierDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplierItem`: Exposes CRUD operations for the **MEQSSupplierItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSupplierItems
    * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany()
    * ```
    */
  get mEQSSupplierItem(): Prisma.MEQSSupplierItemDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplierAttachment`: Exposes CRUD operations for the **MEQSSupplierAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSupplierAttachments
    * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany()
    * ```
    */
  get mEQSSupplierAttachment(): Prisma.MEQSSupplierAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.mEQSApprover`: Exposes CRUD operations for the **MEQSApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSApprovers
    * const mEQSApprovers = await prisma.mEQSApprover.findMany()
    * ```
    */
  get mEQSApprover(): Prisma.MEQSApproverDelegate<ExtArgs>;

  /**
   * `prisma.pO`: Exposes CRUD operations for the **PO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POS
    * const pOS = await prisma.pO.findMany()
    * ```
    */
  get pO(): Prisma.PODelegate<ExtArgs>;

  /**
   * `prisma.pOApprover`: Exposes CRUD operations for the **POApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POApprovers
    * const pOApprovers = await prisma.pOApprover.findMany()
    * ```
    */
  get pOApprover(): Prisma.POApproverDelegate<ExtArgs>;

  /**
   * `prisma.rR`: Exposes CRUD operations for the **RR** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRS
    * const rRS = await prisma.rR.findMany()
    * ```
    */
  get rR(): Prisma.RRDelegate<ExtArgs>;

  /**
   * `prisma.rRApprover`: Exposes CRUD operations for the **RRApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRApprovers
    * const rRApprovers = await prisma.rRApprover.findMany()
    * ```
    */
  get rRApprover(): Prisma.RRApproverDelegate<ExtArgs>;

  /**
   * `prisma.rRItem`: Exposes CRUD operations for the **RRItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRItems
    * const rRItems = await prisma.rRItem.findMany()
    * ```
    */
  get rRItem(): Prisma.RRItemDelegate<ExtArgs>;

  /**
   * `prisma.oSRIV`: Exposes CRUD operations for the **OSRIV** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OSRIVS
    * const oSRIVS = await prisma.oSRIV.findMany()
    * ```
    */
  get oSRIV(): Prisma.OSRIVDelegate<ExtArgs>;

  /**
   * `prisma.oSRIVApprover`: Exposes CRUD operations for the **OSRIVApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OSRIVApprovers
    * const oSRIVApprovers = await prisma.oSRIVApprover.findMany()
    * ```
    */
  get oSRIVApprover(): Prisma.OSRIVApproverDelegate<ExtArgs>;

  /**
   * `prisma.oSRIVItem`: Exposes CRUD operations for the **OSRIVItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OSRIVItems
    * const oSRIVItems = await prisma.oSRIVItem.findMany()
    * ```
    */
  get oSRIVItem(): Prisma.OSRIVItemDelegate<ExtArgs>;

  /**
   * `prisma.sERIV`: Exposes CRUD operations for the **SERIV** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SERIVS
    * const sERIVS = await prisma.sERIV.findMany()
    * ```
    */
  get sERIV(): Prisma.SERIVDelegate<ExtArgs>;

  /**
   * `prisma.sERIVApprover`: Exposes CRUD operations for the **SERIVApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SERIVApprovers
    * const sERIVApprovers = await prisma.sERIVApprover.findMany()
    * ```
    */
  get sERIVApprover(): Prisma.SERIVApproverDelegate<ExtArgs>;

  /**
   * `prisma.sERIVItem`: Exposes CRUD operations for the **SERIVItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SERIVItems
    * const sERIVItems = await prisma.sERIVItem.findMany()
    * ```
    */
  get sERIVItem(): Prisma.SERIVItemDelegate<ExtArgs>;

  /**
   * `prisma.mRV`: Exposes CRUD operations for the **MRV** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MRVS
    * const mRVS = await prisma.mRV.findMany()
    * ```
    */
  get mRV(): Prisma.MRVDelegate<ExtArgs>;

  /**
   * `prisma.mRVApprover`: Exposes CRUD operations for the **MRVApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MRVApprovers
    * const mRVApprovers = await prisma.mRVApprover.findMany()
    * ```
    */
  get mRVApprover(): Prisma.MRVApproverDelegate<ExtArgs>;

  /**
   * `prisma.mRVItem`: Exposes CRUD operations for the **MRVItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MRVItems
    * const mRVItems = await prisma.mRVItem.findMany()
    * ```
    */
  get mRVItem(): Prisma.MRVItemDelegate<ExtArgs>;

  /**
   * `prisma.mCT`: Exposes CRUD operations for the **MCT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCTS
    * const mCTS = await prisma.mCT.findMany()
    * ```
    */
  get mCT(): Prisma.MCTDelegate<ExtArgs>;

  /**
   * `prisma.mCTApprover`: Exposes CRUD operations for the **MCTApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCTApprovers
    * const mCTApprovers = await prisma.mCTApprover.findMany()
    * ```
    */
  get mCTApprover(): Prisma.MCTApproverDelegate<ExtArgs>;

  /**
   * `prisma.mCRT`: Exposes CRUD operations for the **MCRT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCRTS
    * const mCRTS = await prisma.mCRT.findMany()
    * ```
    */
  get mCRT(): Prisma.MCRTDelegate<ExtArgs>;

  /**
   * `prisma.mCRTApprover`: Exposes CRUD operations for the **MCRTApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCRTApprovers
    * const mCRTApprovers = await prisma.mCRTApprover.findMany()
    * ```
    */
  get mCRTApprover(): Prisma.MCRTApproverDelegate<ExtArgs>;

  /**
   * `prisma.mCRTItem`: Exposes CRUD operations for the **MCRTItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCRTItems
    * const mCRTItems = await prisma.mCRTItem.findMany()
    * ```
    */
  get mCRTItem(): Prisma.MCRTItemDelegate<ExtArgs>;

  /**
   * `prisma.mST`: Exposes CRUD operations for the **MST** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MSTS
    * const mSTS = await prisma.mST.findMany()
    * ```
    */
  get mST(): Prisma.MSTDelegate<ExtArgs>;

  /**
   * `prisma.mSTApprover`: Exposes CRUD operations for the **MSTApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MSTApprovers
    * const mSTApprovers = await prisma.mSTApprover.findMany()
    * ```
    */
  get mSTApprover(): Prisma.MSTApproverDelegate<ExtArgs>;

  /**
   * `prisma.mSTItem`: Exposes CRUD operations for the **MSTItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MSTItems
    * const mSTItems = await prisma.mSTItem.findMany()
    * ```
    */
  get mSTItem(): Prisma.MSTItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ItemType: 'ItemType',
    Supplier: 'Supplier',
    Unit: 'Unit',
    Vehicle: 'Vehicle',
    Station: 'Station',
    Project: 'Project',
    Pending: 'Pending',
    Setting: 'Setting',
    Item: 'Item',
    ItemLocation: 'ItemLocation',
    ItemMovement: 'ItemMovement',
    ItemTransaction: 'ItemTransaction',
    ItemCodeTracker: 'ItemCodeTracker',
    Canvass: 'Canvass',
    CanvassItem: 'CanvassItem',
    RV: 'RV',
    RVApprover: 'RVApprover',
    JO: 'JO',
    JOApprover: 'JOApprover',
    SPR: 'SPR',
    SPRApprover: 'SPRApprover',
    MEQS: 'MEQS',
    MEQSSupplier: 'MEQSSupplier',
    MEQSSupplierItem: 'MEQSSupplierItem',
    MEQSSupplierAttachment: 'MEQSSupplierAttachment',
    MEQSApprover: 'MEQSApprover',
    PO: 'PO',
    POApprover: 'POApprover',
    RR: 'RR',
    RRApprover: 'RRApprover',
    RRItem: 'RRItem',
    OSRIV: 'OSRIV',
    OSRIVApprover: 'OSRIVApprover',
    OSRIVItem: 'OSRIVItem',
    SERIV: 'SERIV',
    SERIVApprover: 'SERIVApprover',
    SERIVItem: 'SERIVItem',
    MRV: 'MRV',
    MRVApprover: 'MRVApprover',
    MRVItem: 'MRVItem',
    MCT: 'MCT',
    MCTApprover: 'MCTApprover',
    MCRT: 'MCRT',
    MCRTApprover: 'MCRTApprover',
    MCRTItem: 'MCRTItem',
    MST: 'MST',
    MSTApprover: 'MSTApprover',
    MSTItem: 'MSTItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'itemType' | 'supplier' | 'unit' | 'vehicle' | 'station' | 'project' | 'pending' | 'setting' | 'item' | 'itemLocation' | 'itemMovement' | 'itemTransaction' | 'itemCodeTracker' | 'canvass' | 'canvassItem' | 'rV' | 'rVApprover' | 'jO' | 'jOApprover' | 'sPR' | 'sPRApprover' | 'mEQS' | 'mEQSSupplier' | 'mEQSSupplierItem' | 'mEQSSupplierAttachment' | 'mEQSApprover' | 'pO' | 'pOApprover' | 'rR' | 'rRApprover' | 'rRItem' | 'oSRIV' | 'oSRIVApprover' | 'oSRIVItem' | 'sERIV' | 'sERIVApprover' | 'sERIVItem' | 'mRV' | 'mRVApprover' | 'mRVItem' | 'mCT' | 'mCTApprover' | 'mCRT' | 'mCRTApprover' | 'mCRTItem' | 'mST' | 'mSTApprover' | 'mSTItem'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>,
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>,
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Station: {
        payload: Prisma.$StationPayload<ExtArgs>
        fields: Prisma.StationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findFirst: {
            args: Prisma.StationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findMany: {
            args: Prisma.StationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          create: {
            args: Prisma.StationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          createMany: {
            args: Prisma.StationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          update: {
            args: Prisma.StationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          deleteMany: {
            args: Prisma.StationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          aggregate: {
            args: Prisma.StationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStation>
          }
          groupBy: {
            args: Prisma.StationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StationCountArgs<ExtArgs>,
            result: $Utils.Optional<StationCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Pending: {
        payload: Prisma.$PendingPayload<ExtArgs>
        fields: Prisma.PendingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          findFirst: {
            args: Prisma.PendingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          findMany: {
            args: Prisma.PendingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>[]
          }
          create: {
            args: Prisma.PendingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          createMany: {
            args: Prisma.PendingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PendingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          update: {
            args: Prisma.PendingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          deleteMany: {
            args: Prisma.PendingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PendingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PendingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPayload>
          }
          aggregate: {
            args: Prisma.PendingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePending>
          }
          groupBy: {
            args: Prisma.PendingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PendingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingCountArgs<ExtArgs>,
            result: $Utils.Optional<PendingCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>,
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemLocation: {
        payload: Prisma.$ItemLocationPayload<ExtArgs>
        fields: Prisma.ItemLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemLocationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemLocationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          findFirst: {
            args: Prisma.ItemLocationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemLocationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          findMany: {
            args: Prisma.ItemLocationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>[]
          }
          create: {
            args: Prisma.ItemLocationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          createMany: {
            args: Prisma.ItemLocationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemLocationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          update: {
            args: Prisma.ItemLocationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          deleteMany: {
            args: Prisma.ItemLocationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemLocationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemLocationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          aggregate: {
            args: Prisma.ItemLocationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemLocation>
          }
          groupBy: {
            args: Prisma.ItemLocationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemLocationCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemLocationCountAggregateOutputType> | number
          }
        }
      }
      ItemMovement: {
        payload: Prisma.$ItemMovementPayload<ExtArgs>
        fields: Prisma.ItemMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemMovementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemMovementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          findFirst: {
            args: Prisma.ItemMovementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemMovementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          findMany: {
            args: Prisma.ItemMovementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>[]
          }
          create: {
            args: Prisma.ItemMovementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          createMany: {
            args: Prisma.ItemMovementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemMovementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          update: {
            args: Prisma.ItemMovementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          deleteMany: {
            args: Prisma.ItemMovementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemMovementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemMovementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMovementPayload>
          }
          aggregate: {
            args: Prisma.ItemMovementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemMovement>
          }
          groupBy: {
            args: Prisma.ItemMovementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemMovementCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemMovementCountAggregateOutputType> | number
          }
        }
      }
      ItemTransaction: {
        payload: Prisma.$ItemTransactionPayload<ExtArgs>
        fields: Prisma.ItemTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          findFirst: {
            args: Prisma.ItemTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          findMany: {
            args: Prisma.ItemTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>[]
          }
          create: {
            args: Prisma.ItemTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          createMany: {
            args: Prisma.ItemTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          update: {
            args: Prisma.ItemTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ItemTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          aggregate: {
            args: Prisma.ItemTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemTransaction>
          }
          groupBy: {
            args: Prisma.ItemTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemTransactionCountAggregateOutputType> | number
          }
        }
      }
      ItemCodeTracker: {
        payload: Prisma.$ItemCodeTrackerPayload<ExtArgs>
        fields: Prisma.ItemCodeTrackerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCodeTrackerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCodeTrackerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          findFirst: {
            args: Prisma.ItemCodeTrackerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCodeTrackerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          findMany: {
            args: Prisma.ItemCodeTrackerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>[]
          }
          create: {
            args: Prisma.ItemCodeTrackerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          createMany: {
            args: Prisma.ItemCodeTrackerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemCodeTrackerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          update: {
            args: Prisma.ItemCodeTrackerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          deleteMany: {
            args: Prisma.ItemCodeTrackerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCodeTrackerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemCodeTrackerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemCodeTrackerPayload>
          }
          aggregate: {
            args: Prisma.ItemCodeTrackerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemCodeTracker>
          }
          groupBy: {
            args: Prisma.ItemCodeTrackerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemCodeTrackerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCodeTrackerCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCodeTrackerCountAggregateOutputType> | number
          }
        }
      }
      Canvass: {
        payload: Prisma.$CanvassPayload<ExtArgs>
        fields: Prisma.CanvassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          findFirst: {
            args: Prisma.CanvassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          findMany: {
            args: Prisma.CanvassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>[]
          }
          create: {
            args: Prisma.CanvassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          createMany: {
            args: Prisma.CanvassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CanvassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          update: {
            args: Prisma.CanvassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          deleteMany: {
            args: Prisma.CanvassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CanvassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CanvassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          aggregate: {
            args: Prisma.CanvassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCanvass>
          }
          groupBy: {
            args: Prisma.CanvassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CanvassGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvassCountArgs<ExtArgs>,
            result: $Utils.Optional<CanvassCountAggregateOutputType> | number
          }
        }
      }
      CanvassItem: {
        payload: Prisma.$CanvassItemPayload<ExtArgs>
        fields: Prisma.CanvassItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvassItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvassItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          findFirst: {
            args: Prisma.CanvassItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvassItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          findMany: {
            args: Prisma.CanvassItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>[]
          }
          create: {
            args: Prisma.CanvassItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          createMany: {
            args: Prisma.CanvassItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CanvassItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          update: {
            args: Prisma.CanvassItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          deleteMany: {
            args: Prisma.CanvassItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CanvassItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CanvassItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          aggregate: {
            args: Prisma.CanvassItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCanvassItem>
          }
          groupBy: {
            args: Prisma.CanvassItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CanvassItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvassItemCountArgs<ExtArgs>,
            result: $Utils.Optional<CanvassItemCountAggregateOutputType> | number
          }
        }
      }
      RV: {
        payload: Prisma.$RVPayload<ExtArgs>
        fields: Prisma.RVFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RVFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RVFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          findFirst: {
            args: Prisma.RVFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RVFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          findMany: {
            args: Prisma.RVFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>[]
          }
          create: {
            args: Prisma.RVCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          createMany: {
            args: Prisma.RVCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RVDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          update: {
            args: Prisma.RVUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          deleteMany: {
            args: Prisma.RVDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RVUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RVUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          aggregate: {
            args: Prisma.RVAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRV>
          }
          groupBy: {
            args: Prisma.RVGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RVGroupByOutputType>[]
          }
          count: {
            args: Prisma.RVCountArgs<ExtArgs>,
            result: $Utils.Optional<RVCountAggregateOutputType> | number
          }
        }
      }
      RVApprover: {
        payload: Prisma.$RVApproverPayload<ExtArgs>
        fields: Prisma.RVApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RVApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RVApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          findFirst: {
            args: Prisma.RVApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RVApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          findMany: {
            args: Prisma.RVApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>[]
          }
          create: {
            args: Prisma.RVApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          createMany: {
            args: Prisma.RVApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RVApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          update: {
            args: Prisma.RVApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          deleteMany: {
            args: Prisma.RVApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RVApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RVApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          aggregate: {
            args: Prisma.RVApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRVApprover>
          }
          groupBy: {
            args: Prisma.RVApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RVApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.RVApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<RVApproverCountAggregateOutputType> | number
          }
        }
      }
      JO: {
        payload: Prisma.$JOPayload<ExtArgs>
        fields: Prisma.JOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JOFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JOFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          findFirst: {
            args: Prisma.JOFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JOFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          findMany: {
            args: Prisma.JOFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>[]
          }
          create: {
            args: Prisma.JOCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          createMany: {
            args: Prisma.JOCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JODeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          update: {
            args: Prisma.JOUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          deleteMany: {
            args: Prisma.JODeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JOUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JOUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          aggregate: {
            args: Prisma.JOAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJO>
          }
          groupBy: {
            args: Prisma.JOGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JOGroupByOutputType>[]
          }
          count: {
            args: Prisma.JOCountArgs<ExtArgs>,
            result: $Utils.Optional<JOCountAggregateOutputType> | number
          }
        }
      }
      JOApprover: {
        payload: Prisma.$JOApproverPayload<ExtArgs>
        fields: Prisma.JOApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JOApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JOApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          findFirst: {
            args: Prisma.JOApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JOApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          findMany: {
            args: Prisma.JOApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>[]
          }
          create: {
            args: Prisma.JOApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          createMany: {
            args: Prisma.JOApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JOApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          update: {
            args: Prisma.JOApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          deleteMany: {
            args: Prisma.JOApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JOApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JOApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          aggregate: {
            args: Prisma.JOApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJOApprover>
          }
          groupBy: {
            args: Prisma.JOApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JOApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.JOApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<JOApproverCountAggregateOutputType> | number
          }
        }
      }
      SPR: {
        payload: Prisma.$SPRPayload<ExtArgs>
        fields: Prisma.SPRFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SPRFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SPRFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          findFirst: {
            args: Prisma.SPRFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SPRFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          findMany: {
            args: Prisma.SPRFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>[]
          }
          create: {
            args: Prisma.SPRCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          createMany: {
            args: Prisma.SPRCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SPRDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          update: {
            args: Prisma.SPRUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          deleteMany: {
            args: Prisma.SPRDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SPRUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SPRUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          aggregate: {
            args: Prisma.SPRAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSPR>
          }
          groupBy: {
            args: Prisma.SPRGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SPRGroupByOutputType>[]
          }
          count: {
            args: Prisma.SPRCountArgs<ExtArgs>,
            result: $Utils.Optional<SPRCountAggregateOutputType> | number
          }
        }
      }
      SPRApprover: {
        payload: Prisma.$SPRApproverPayload<ExtArgs>
        fields: Prisma.SPRApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SPRApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SPRApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          findFirst: {
            args: Prisma.SPRApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SPRApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          findMany: {
            args: Prisma.SPRApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>[]
          }
          create: {
            args: Prisma.SPRApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          createMany: {
            args: Prisma.SPRApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SPRApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          update: {
            args: Prisma.SPRApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          deleteMany: {
            args: Prisma.SPRApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SPRApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SPRApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          aggregate: {
            args: Prisma.SPRApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSPRApprover>
          }
          groupBy: {
            args: Prisma.SPRApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SPRApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.SPRApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<SPRApproverCountAggregateOutputType> | number
          }
        }
      }
      MEQS: {
        payload: Prisma.$MEQSPayload<ExtArgs>
        fields: Prisma.MEQSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          findFirst: {
            args: Prisma.MEQSFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          findMany: {
            args: Prisma.MEQSFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>[]
          }
          create: {
            args: Prisma.MEQSCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          createMany: {
            args: Prisma.MEQSCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          update: {
            args: Prisma.MEQSUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          deleteMany: {
            args: Prisma.MEQSDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          aggregate: {
            args: Prisma.MEQSAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQS>
          }
          groupBy: {
            args: Prisma.MEQSGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplier: {
        payload: Prisma.$MEQSSupplierPayload<ExtArgs>
        fields: Prisma.MEQSSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          update: {
            args: Prisma.MEQSSupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplier>
          }
          groupBy: {
            args: Prisma.MEQSSupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplierItem: {
        payload: Prisma.$MEQSSupplierItemPayload<ExtArgs>
        fields: Prisma.MEQSSupplierItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          update: {
            args: Prisma.MEQSSupplierItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplierItem>
          }
          groupBy: {
            args: Prisma.MEQSSupplierItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierItemCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierItemCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplierAttachment: {
        payload: Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>
        fields: Prisma.MEQSSupplierAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          update: {
            args: Prisma.MEQSSupplierAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplierAttachment>
          }
          groupBy: {
            args: Prisma.MEQSSupplierAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierAttachmentCountAggregateOutputType> | number
          }
        }
      }
      MEQSApprover: {
        payload: Prisma.$MEQSApproverPayload<ExtArgs>
        fields: Prisma.MEQSApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          findFirst: {
            args: Prisma.MEQSApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          findMany: {
            args: Prisma.MEQSApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>[]
          }
          create: {
            args: Prisma.MEQSApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          createMany: {
            args: Prisma.MEQSApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          update: {
            args: Prisma.MEQSApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          deleteMany: {
            args: Prisma.MEQSApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          aggregate: {
            args: Prisma.MEQSApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSApprover>
          }
          groupBy: {
            args: Prisma.MEQSApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSApproverCountAggregateOutputType> | number
          }
        }
      }
      PO: {
        payload: Prisma.$POPayload<ExtArgs>
        fields: Prisma.POFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          findFirst: {
            args: Prisma.POFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          findMany: {
            args: Prisma.POFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>[]
          }
          create: {
            args: Prisma.POCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          createMany: {
            args: Prisma.POCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PODeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          update: {
            args: Prisma.POUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          deleteMany: {
            args: Prisma.PODeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.POUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.POUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          aggregate: {
            args: Prisma.POAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePO>
          }
          groupBy: {
            args: Prisma.POGroupByArgs<ExtArgs>,
            result: $Utils.Optional<POGroupByOutputType>[]
          }
          count: {
            args: Prisma.POCountArgs<ExtArgs>,
            result: $Utils.Optional<POCountAggregateOutputType> | number
          }
        }
      }
      POApprover: {
        payload: Prisma.$POApproverPayload<ExtArgs>
        fields: Prisma.POApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          findFirst: {
            args: Prisma.POApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          findMany: {
            args: Prisma.POApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>[]
          }
          create: {
            args: Prisma.POApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          createMany: {
            args: Prisma.POApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.POApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          update: {
            args: Prisma.POApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          deleteMany: {
            args: Prisma.POApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.POApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.POApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          aggregate: {
            args: Prisma.POApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePOApprover>
          }
          groupBy: {
            args: Prisma.POApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<POApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.POApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<POApproverCountAggregateOutputType> | number
          }
        }
      }
      RR: {
        payload: Prisma.$RRPayload<ExtArgs>
        fields: Prisma.RRFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          findFirst: {
            args: Prisma.RRFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          findMany: {
            args: Prisma.RRFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>[]
          }
          create: {
            args: Prisma.RRCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          createMany: {
            args: Prisma.RRCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          update: {
            args: Prisma.RRUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          deleteMany: {
            args: Prisma.RRDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          aggregate: {
            args: Prisma.RRAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRR>
          }
          groupBy: {
            args: Prisma.RRGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRCountArgs<ExtArgs>,
            result: $Utils.Optional<RRCountAggregateOutputType> | number
          }
        }
      }
      RRApprover: {
        payload: Prisma.$RRApproverPayload<ExtArgs>
        fields: Prisma.RRApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          findFirst: {
            args: Prisma.RRApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          findMany: {
            args: Prisma.RRApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>[]
          }
          create: {
            args: Prisma.RRApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          createMany: {
            args: Prisma.RRApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          update: {
            args: Prisma.RRApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          deleteMany: {
            args: Prisma.RRApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          aggregate: {
            args: Prisma.RRApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRRApprover>
          }
          groupBy: {
            args: Prisma.RRApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<RRApproverCountAggregateOutputType> | number
          }
        }
      }
      RRItem: {
        payload: Prisma.$RRItemPayload<ExtArgs>
        fields: Prisma.RRItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          findFirst: {
            args: Prisma.RRItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          findMany: {
            args: Prisma.RRItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>[]
          }
          create: {
            args: Prisma.RRItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          createMany: {
            args: Prisma.RRItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          update: {
            args: Prisma.RRItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          deleteMany: {
            args: Prisma.RRItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          aggregate: {
            args: Prisma.RRItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRRItem>
          }
          groupBy: {
            args: Prisma.RRItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRItemCountArgs<ExtArgs>,
            result: $Utils.Optional<RRItemCountAggregateOutputType> | number
          }
        }
      }
      OSRIV: {
        payload: Prisma.$OSRIVPayload<ExtArgs>
        fields: Prisma.OSRIVFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OSRIVFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OSRIVFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          findFirst: {
            args: Prisma.OSRIVFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OSRIVFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          findMany: {
            args: Prisma.OSRIVFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>[]
          }
          create: {
            args: Prisma.OSRIVCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          createMany: {
            args: Prisma.OSRIVCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OSRIVDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          update: {
            args: Prisma.OSRIVUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          deleteMany: {
            args: Prisma.OSRIVDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OSRIVUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OSRIVUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVPayload>
          }
          aggregate: {
            args: Prisma.OSRIVAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOSRIV>
          }
          groupBy: {
            args: Prisma.OSRIVGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVGroupByOutputType>[]
          }
          count: {
            args: Prisma.OSRIVCountArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVCountAggregateOutputType> | number
          }
        }
      }
      OSRIVApprover: {
        payload: Prisma.$OSRIVApproverPayload<ExtArgs>
        fields: Prisma.OSRIVApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OSRIVApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OSRIVApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          findFirst: {
            args: Prisma.OSRIVApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OSRIVApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          findMany: {
            args: Prisma.OSRIVApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>[]
          }
          create: {
            args: Prisma.OSRIVApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          createMany: {
            args: Prisma.OSRIVApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OSRIVApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          update: {
            args: Prisma.OSRIVApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          deleteMany: {
            args: Prisma.OSRIVApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OSRIVApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OSRIVApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVApproverPayload>
          }
          aggregate: {
            args: Prisma.OSRIVApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOSRIVApprover>
          }
          groupBy: {
            args: Prisma.OSRIVApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.OSRIVApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVApproverCountAggregateOutputType> | number
          }
        }
      }
      OSRIVItem: {
        payload: Prisma.$OSRIVItemPayload<ExtArgs>
        fields: Prisma.OSRIVItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OSRIVItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OSRIVItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          findFirst: {
            args: Prisma.OSRIVItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OSRIVItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          findMany: {
            args: Prisma.OSRIVItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>[]
          }
          create: {
            args: Prisma.OSRIVItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          createMany: {
            args: Prisma.OSRIVItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OSRIVItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          update: {
            args: Prisma.OSRIVItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          deleteMany: {
            args: Prisma.OSRIVItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OSRIVItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OSRIVItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OSRIVItemPayload>
          }
          aggregate: {
            args: Prisma.OSRIVItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOSRIVItem>
          }
          groupBy: {
            args: Prisma.OSRIVItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OSRIVItemCountArgs<ExtArgs>,
            result: $Utils.Optional<OSRIVItemCountAggregateOutputType> | number
          }
        }
      }
      SERIV: {
        payload: Prisma.$SERIVPayload<ExtArgs>
        fields: Prisma.SERIVFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SERIVFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SERIVFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          findFirst: {
            args: Prisma.SERIVFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SERIVFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          findMany: {
            args: Prisma.SERIVFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>[]
          }
          create: {
            args: Prisma.SERIVCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          createMany: {
            args: Prisma.SERIVCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SERIVDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          update: {
            args: Prisma.SERIVUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          deleteMany: {
            args: Prisma.SERIVDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SERIVUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SERIVUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVPayload>
          }
          aggregate: {
            args: Prisma.SERIVAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSERIV>
          }
          groupBy: {
            args: Prisma.SERIVGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SERIVGroupByOutputType>[]
          }
          count: {
            args: Prisma.SERIVCountArgs<ExtArgs>,
            result: $Utils.Optional<SERIVCountAggregateOutputType> | number
          }
        }
      }
      SERIVApprover: {
        payload: Prisma.$SERIVApproverPayload<ExtArgs>
        fields: Prisma.SERIVApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SERIVApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SERIVApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          findFirst: {
            args: Prisma.SERIVApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SERIVApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          findMany: {
            args: Prisma.SERIVApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>[]
          }
          create: {
            args: Prisma.SERIVApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          createMany: {
            args: Prisma.SERIVApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SERIVApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          update: {
            args: Prisma.SERIVApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          deleteMany: {
            args: Prisma.SERIVApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SERIVApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SERIVApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVApproverPayload>
          }
          aggregate: {
            args: Prisma.SERIVApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSERIVApprover>
          }
          groupBy: {
            args: Prisma.SERIVApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SERIVApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.SERIVApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<SERIVApproverCountAggregateOutputType> | number
          }
        }
      }
      SERIVItem: {
        payload: Prisma.$SERIVItemPayload<ExtArgs>
        fields: Prisma.SERIVItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SERIVItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SERIVItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          findFirst: {
            args: Prisma.SERIVItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SERIVItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          findMany: {
            args: Prisma.SERIVItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>[]
          }
          create: {
            args: Prisma.SERIVItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          createMany: {
            args: Prisma.SERIVItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SERIVItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          update: {
            args: Prisma.SERIVItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          deleteMany: {
            args: Prisma.SERIVItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SERIVItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SERIVItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SERIVItemPayload>
          }
          aggregate: {
            args: Prisma.SERIVItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSERIVItem>
          }
          groupBy: {
            args: Prisma.SERIVItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SERIVItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SERIVItemCountArgs<ExtArgs>,
            result: $Utils.Optional<SERIVItemCountAggregateOutputType> | number
          }
        }
      }
      MRV: {
        payload: Prisma.$MRVPayload<ExtArgs>
        fields: Prisma.MRVFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MRVFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MRVFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          findFirst: {
            args: Prisma.MRVFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MRVFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          findMany: {
            args: Prisma.MRVFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>[]
          }
          create: {
            args: Prisma.MRVCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          createMany: {
            args: Prisma.MRVCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MRVDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          update: {
            args: Prisma.MRVUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          deleteMany: {
            args: Prisma.MRVDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MRVUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MRVUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVPayload>
          }
          aggregate: {
            args: Prisma.MRVAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMRV>
          }
          groupBy: {
            args: Prisma.MRVGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MRVGroupByOutputType>[]
          }
          count: {
            args: Prisma.MRVCountArgs<ExtArgs>,
            result: $Utils.Optional<MRVCountAggregateOutputType> | number
          }
        }
      }
      MRVApprover: {
        payload: Prisma.$MRVApproverPayload<ExtArgs>
        fields: Prisma.MRVApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MRVApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MRVApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          findFirst: {
            args: Prisma.MRVApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MRVApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          findMany: {
            args: Prisma.MRVApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>[]
          }
          create: {
            args: Prisma.MRVApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          createMany: {
            args: Prisma.MRVApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MRVApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          update: {
            args: Prisma.MRVApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          deleteMany: {
            args: Prisma.MRVApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MRVApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MRVApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVApproverPayload>
          }
          aggregate: {
            args: Prisma.MRVApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMRVApprover>
          }
          groupBy: {
            args: Prisma.MRVApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MRVApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MRVApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MRVApproverCountAggregateOutputType> | number
          }
        }
      }
      MRVItem: {
        payload: Prisma.$MRVItemPayload<ExtArgs>
        fields: Prisma.MRVItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MRVItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MRVItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          findFirst: {
            args: Prisma.MRVItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MRVItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          findMany: {
            args: Prisma.MRVItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>[]
          }
          create: {
            args: Prisma.MRVItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          createMany: {
            args: Prisma.MRVItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MRVItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          update: {
            args: Prisma.MRVItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          deleteMany: {
            args: Prisma.MRVItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MRVItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MRVItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MRVItemPayload>
          }
          aggregate: {
            args: Prisma.MRVItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMRVItem>
          }
          groupBy: {
            args: Prisma.MRVItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MRVItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MRVItemCountArgs<ExtArgs>,
            result: $Utils.Optional<MRVItemCountAggregateOutputType> | number
          }
        }
      }
      MCT: {
        payload: Prisma.$MCTPayload<ExtArgs>
        fields: Prisma.MCTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCTFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCTFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          findFirst: {
            args: Prisma.MCTFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCTFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          findMany: {
            args: Prisma.MCTFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>[]
          }
          create: {
            args: Prisma.MCTCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          createMany: {
            args: Prisma.MCTCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCTDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          update: {
            args: Prisma.MCTUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          deleteMany: {
            args: Prisma.MCTDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCTUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCTUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTPayload>
          }
          aggregate: {
            args: Prisma.MCTAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCT>
          }
          groupBy: {
            args: Prisma.MCTGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCTGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCTCountArgs<ExtArgs>,
            result: $Utils.Optional<MCTCountAggregateOutputType> | number
          }
        }
      }
      MCTApprover: {
        payload: Prisma.$MCTApproverPayload<ExtArgs>
        fields: Prisma.MCTApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCTApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCTApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          findFirst: {
            args: Prisma.MCTApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCTApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          findMany: {
            args: Prisma.MCTApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>[]
          }
          create: {
            args: Prisma.MCTApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          createMany: {
            args: Prisma.MCTApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCTApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          update: {
            args: Prisma.MCTApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          deleteMany: {
            args: Prisma.MCTApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCTApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCTApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCTApproverPayload>
          }
          aggregate: {
            args: Prisma.MCTApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCTApprover>
          }
          groupBy: {
            args: Prisma.MCTApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCTApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCTApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MCTApproverCountAggregateOutputType> | number
          }
        }
      }
      MCRT: {
        payload: Prisma.$MCRTPayload<ExtArgs>
        fields: Prisma.MCRTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCRTFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCRTFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          findFirst: {
            args: Prisma.MCRTFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCRTFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          findMany: {
            args: Prisma.MCRTFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>[]
          }
          create: {
            args: Prisma.MCRTCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          createMany: {
            args: Prisma.MCRTCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCRTDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          update: {
            args: Prisma.MCRTUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          deleteMany: {
            args: Prisma.MCRTDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCRTUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCRTUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTPayload>
          }
          aggregate: {
            args: Prisma.MCRTAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCRT>
          }
          groupBy: {
            args: Prisma.MCRTGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCRTGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCRTCountArgs<ExtArgs>,
            result: $Utils.Optional<MCRTCountAggregateOutputType> | number
          }
        }
      }
      MCRTApprover: {
        payload: Prisma.$MCRTApproverPayload<ExtArgs>
        fields: Prisma.MCRTApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCRTApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCRTApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          findFirst: {
            args: Prisma.MCRTApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCRTApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          findMany: {
            args: Prisma.MCRTApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>[]
          }
          create: {
            args: Prisma.MCRTApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          createMany: {
            args: Prisma.MCRTApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCRTApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          update: {
            args: Prisma.MCRTApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          deleteMany: {
            args: Prisma.MCRTApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCRTApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCRTApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTApproverPayload>
          }
          aggregate: {
            args: Prisma.MCRTApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCRTApprover>
          }
          groupBy: {
            args: Prisma.MCRTApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCRTApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCRTApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MCRTApproverCountAggregateOutputType> | number
          }
        }
      }
      MCRTItem: {
        payload: Prisma.$MCRTItemPayload<ExtArgs>
        fields: Prisma.MCRTItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCRTItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCRTItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          findFirst: {
            args: Prisma.MCRTItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCRTItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          findMany: {
            args: Prisma.MCRTItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>[]
          }
          create: {
            args: Prisma.MCRTItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          createMany: {
            args: Prisma.MCRTItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCRTItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          update: {
            args: Prisma.MCRTItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          deleteMany: {
            args: Prisma.MCRTItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCRTItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCRTItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MCRTItemPayload>
          }
          aggregate: {
            args: Prisma.MCRTItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCRTItem>
          }
          groupBy: {
            args: Prisma.MCRTItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCRTItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCRTItemCountArgs<ExtArgs>,
            result: $Utils.Optional<MCRTItemCountAggregateOutputType> | number
          }
        }
      }
      MST: {
        payload: Prisma.$MSTPayload<ExtArgs>
        fields: Prisma.MSTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MSTFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MSTFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          findFirst: {
            args: Prisma.MSTFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MSTFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          findMany: {
            args: Prisma.MSTFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>[]
          }
          create: {
            args: Prisma.MSTCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          createMany: {
            args: Prisma.MSTCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MSTDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          update: {
            args: Prisma.MSTUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          deleteMany: {
            args: Prisma.MSTDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MSTUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MSTUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTPayload>
          }
          aggregate: {
            args: Prisma.MSTAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMST>
          }
          groupBy: {
            args: Prisma.MSTGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MSTGroupByOutputType>[]
          }
          count: {
            args: Prisma.MSTCountArgs<ExtArgs>,
            result: $Utils.Optional<MSTCountAggregateOutputType> | number
          }
        }
      }
      MSTApprover: {
        payload: Prisma.$MSTApproverPayload<ExtArgs>
        fields: Prisma.MSTApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MSTApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MSTApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          findFirst: {
            args: Prisma.MSTApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MSTApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          findMany: {
            args: Prisma.MSTApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>[]
          }
          create: {
            args: Prisma.MSTApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          createMany: {
            args: Prisma.MSTApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MSTApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          update: {
            args: Prisma.MSTApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          deleteMany: {
            args: Prisma.MSTApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MSTApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MSTApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTApproverPayload>
          }
          aggregate: {
            args: Prisma.MSTApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMSTApprover>
          }
          groupBy: {
            args: Prisma.MSTApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MSTApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MSTApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MSTApproverCountAggregateOutputType> | number
          }
        }
      }
      MSTItem: {
        payload: Prisma.$MSTItemPayload<ExtArgs>
        fields: Prisma.MSTItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MSTItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MSTItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          findFirst: {
            args: Prisma.MSTItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MSTItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          findMany: {
            args: Prisma.MSTItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>[]
          }
          create: {
            args: Prisma.MSTItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          createMany: {
            args: Prisma.MSTItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MSTItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          update: {
            args: Prisma.MSTItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          deleteMany: {
            args: Prisma.MSTItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MSTItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MSTItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MSTItemPayload>
          }
          aggregate: {
            args: Prisma.MSTItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMSTItem>
          }
          groupBy: {
            args: Prisma.MSTItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MSTItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MSTItemCountArgs<ExtArgs>,
            result: $Utils.Optional<MSTItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    items: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemTypeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }



  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    MEQSSupplier: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MEQSSupplier?: boolean | SupplierCountOutputTypeCountMEQSSupplierArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountMEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
  }



  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    canvass_items: number
    items: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | UnitCountOutputTypeCountCanvass_itemsArgs
    items?: boolean | UnitCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }



  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    sprs: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprs?: boolean | VehicleCountOutputTypeCountSprsArgs
  }

  // Custom InputTypes

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountSprsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRWhereInput
  }



  /**
   * Count Type StationCountOutputType
   */

  export type StationCountOutputType = {
    items: number
    osrivs: number
    mrvs: number
    serivs: number
  }

  export type StationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | StationCountOutputTypeCountItemsArgs
    osrivs?: boolean | StationCountOutputTypeCountOsrivsArgs
    mrvs?: boolean | StationCountOutputTypeCountMrvsArgs
    serivs?: boolean | StationCountOutputTypeCountSerivsArgs
  }

  // Custom InputTypes

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationCountOutputType
     */
    select?: StationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
  }


  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountOsrivsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVWhereInput
  }


  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountMrvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVWhereInput
  }


  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountSerivsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVWhereInput
  }



  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    mrv: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv?: boolean | ProjectCountOutputTypeCountMrvArgs
  }

  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMrvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVWhereInput
  }



  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    item_transactions: number
    canvass_items: number
    item_locations: number
    osriv_items: number
    seriv_items: number
    mrv_items: number
    mcrt_items: number
    mst_items: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_transactions?: boolean | ItemCountOutputTypeCountItem_transactionsArgs
    canvass_items?: boolean | ItemCountOutputTypeCountCanvass_itemsArgs
    item_locations?: boolean | ItemCountOutputTypeCountItem_locationsArgs
    osriv_items?: boolean | ItemCountOutputTypeCountOsriv_itemsArgs
    seriv_items?: boolean | ItemCountOutputTypeCountSeriv_itemsArgs
    mrv_items?: boolean | ItemCountOutputTypeCountMrv_itemsArgs
    mcrt_items?: boolean | ItemCountOutputTypeCountMcrt_itemsArgs
    mst_items?: boolean | ItemCountOutputTypeCountMst_itemsArgs
  }

  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItem_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItem_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountOsriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVItemWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSeriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVItemWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountMrv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVItemWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountMcrt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTItemWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountMst_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTItemWhereInput
  }



  /**
   * Count Type ItemLocationCountOutputType
   */

  export type ItemLocationCountOutputType = {
    origin_movements: number
    destination_movements: number
  }

  export type ItemLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin_movements?: boolean | ItemLocationCountOutputTypeCountOrigin_movementsArgs
    destination_movements?: boolean | ItemLocationCountOutputTypeCountDestination_movementsArgs
  }

  // Custom InputTypes

  /**
   * ItemLocationCountOutputType without action
   */
  export type ItemLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocationCountOutputType
     */
    select?: ItemLocationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemLocationCountOutputType without action
   */
  export type ItemLocationCountOutputTypeCountOrigin_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMovementWhereInput
  }


  /**
   * ItemLocationCountOutputType without action
   */
  export type ItemLocationCountOutputTypeCountDestination_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMovementWhereInput
  }



  /**
   * Count Type CanvassCountOutputType
   */

  export type CanvassCountOutputType = {
    canvass_items: number
  }

  export type CanvassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | CanvassCountOutputTypeCountCanvass_itemsArgs
  }

  // Custom InputTypes

  /**
   * CanvassCountOutputType without action
   */
  export type CanvassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassCountOutputType
     */
    select?: CanvassCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CanvassCountOutputType without action
   */
  export type CanvassCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }



  /**
   * Count Type CanvassItemCountOutputType
   */

  export type CanvassItemCountOutputType = {
    meqs_supplier_items: number
  }

  export type CanvassItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier_items?: boolean | CanvassItemCountOutputTypeCountMeqs_supplier_itemsArgs
  }

  // Custom InputTypes

  /**
   * CanvassItemCountOutputType without action
   */
  export type CanvassItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItemCountOutputType
     */
    select?: CanvassItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CanvassItemCountOutputType without action
   */
  export type CanvassItemCountOutputTypeCountMeqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
  }



  /**
   * Count Type RVCountOutputType
   */

  export type RVCountOutputType = {
    rv_approvers: number
  }

  export type RVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rv_approvers?: boolean | RVCountOutputTypeCountRv_approversArgs
  }

  // Custom InputTypes

  /**
   * RVCountOutputType without action
   */
  export type RVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVCountOutputType
     */
    select?: RVCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RVCountOutputType without action
   */
  export type RVCountOutputTypeCountRv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVApproverWhereInput
  }



  /**
   * Count Type JOCountOutputType
   */

  export type JOCountOutputType = {
    jo_approvers: number
  }

  export type JOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo_approvers?: boolean | JOCountOutputTypeCountJo_approversArgs
  }

  // Custom InputTypes

  /**
   * JOCountOutputType without action
   */
  export type JOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOCountOutputType
     */
    select?: JOCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JOCountOutputType without action
   */
  export type JOCountOutputTypeCountJo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOApproverWhereInput
  }



  /**
   * Count Type SPRCountOutputType
   */

  export type SPRCountOutputType = {
    spr_approvers: number
  }

  export type SPRCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spr_approvers?: boolean | SPRCountOutputTypeCountSpr_approversArgs
  }

  // Custom InputTypes

  /**
   * SPRCountOutputType without action
   */
  export type SPRCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRCountOutputType
     */
    select?: SPRCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SPRCountOutputType without action
   */
  export type SPRCountOutputTypeCountSpr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRApproverWhereInput
  }



  /**
   * Count Type MEQSCountOutputType
   */

  export type MEQSCountOutputType = {
    meqs_approvers: number
    meqs_suppliers: number
  }

  export type MEQSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_approvers?: boolean | MEQSCountOutputTypeCountMeqs_approversArgs
    meqs_suppliers?: boolean | MEQSCountOutputTypeCountMeqs_suppliersArgs
  }

  // Custom InputTypes

  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSCountOutputType
     */
    select?: MEQSCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeCountMeqs_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeCountMeqs_suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
  }



  /**
   * Count Type MEQSSupplierCountOutputType
   */

  export type MEQSSupplierCountOutputType = {
    attachments: number
    meqs_supplier_items: number
  }

  export type MEQSSupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MEQSSupplierCountOutputTypeCountAttachmentsArgs
    meqs_supplier_items?: boolean | MEQSSupplierCountOutputTypeCountMeqs_supplier_itemsArgs
  }

  // Custom InputTypes

  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierCountOutputType
     */
    select?: MEQSSupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeCountMeqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
  }



  /**
   * Count Type MEQSSupplierItemCountOutputType
   */

  export type MEQSSupplierItemCountOutputType = {
    rr_items: number
  }

  export type MEQSSupplierItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr_items?: boolean | MEQSSupplierItemCountOutputTypeCountRr_itemsArgs
  }

  // Custom InputTypes

  /**
   * MEQSSupplierItemCountOutputType without action
   */
  export type MEQSSupplierItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItemCountOutputType
     */
    select?: MEQSSupplierItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MEQSSupplierItemCountOutputType without action
   */
  export type MEQSSupplierItemCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }



  /**
   * Count Type POCountOutputType
   */

  export type POCountOutputType = {
    rrs: number
    po_approvers: number
  }

  export type POCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rrs?: boolean | POCountOutputTypeCountRrsArgs
    po_approvers?: boolean | POCountOutputTypeCountPo_approversArgs
  }

  // Custom InputTypes

  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POCountOutputType
     */
    select?: POCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeCountRrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRWhereInput
  }


  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeCountPo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POApproverWhereInput
  }



  /**
   * Count Type RRCountOutputType
   */

  export type RRCountOutputType = {
    rr_approvers: number
    rr_items: number
  }

  export type RRCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr_approvers?: boolean | RRCountOutputTypeCountRr_approversArgs
    rr_items?: boolean | RRCountOutputTypeCountRr_itemsArgs
  }

  // Custom InputTypes

  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRCountOutputType
     */
    select?: RRCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeCountRr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRApproverWhereInput
  }


  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }



  /**
   * Count Type OSRIVCountOutputType
   */

  export type OSRIVCountOutputType = {
    osriv_approvers: number
    osriv_items: number
  }

  export type OSRIVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    osriv_approvers?: boolean | OSRIVCountOutputTypeCountOsriv_approversArgs
    osriv_items?: boolean | OSRIVCountOutputTypeCountOsriv_itemsArgs
  }

  // Custom InputTypes

  /**
   * OSRIVCountOutputType without action
   */
  export type OSRIVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVCountOutputType
     */
    select?: OSRIVCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OSRIVCountOutputType without action
   */
  export type OSRIVCountOutputTypeCountOsriv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVApproverWhereInput
  }


  /**
   * OSRIVCountOutputType without action
   */
  export type OSRIVCountOutputTypeCountOsriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVItemWhereInput
  }



  /**
   * Count Type SERIVCountOutputType
   */

  export type SERIVCountOutputType = {
    seriv_approvers: number
    seriv_items: number
    mcrts: number
  }

  export type SERIVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seriv_approvers?: boolean | SERIVCountOutputTypeCountSeriv_approversArgs
    seriv_items?: boolean | SERIVCountOutputTypeCountSeriv_itemsArgs
    mcrts?: boolean | SERIVCountOutputTypeCountMcrtsArgs
  }

  // Custom InputTypes

  /**
   * SERIVCountOutputType without action
   */
  export type SERIVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVCountOutputType
     */
    select?: SERIVCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SERIVCountOutputType without action
   */
  export type SERIVCountOutputTypeCountSeriv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVApproverWhereInput
  }


  /**
   * SERIVCountOutputType without action
   */
  export type SERIVCountOutputTypeCountSeriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVItemWhereInput
  }


  /**
   * SERIVCountOutputType without action
   */
  export type SERIVCountOutputTypeCountMcrtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTWhereInput
  }



  /**
   * Count Type MRVCountOutputType
   */

  export type MRVCountOutputType = {
    mrv_approvers: number
    mrv_items: number
  }

  export type MRVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv_approvers?: boolean | MRVCountOutputTypeCountMrv_approversArgs
    mrv_items?: boolean | MRVCountOutputTypeCountMrv_itemsArgs
  }

  // Custom InputTypes

  /**
   * MRVCountOutputType without action
   */
  export type MRVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVCountOutputType
     */
    select?: MRVCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MRVCountOutputType without action
   */
  export type MRVCountOutputTypeCountMrv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVApproverWhereInput
  }


  /**
   * MRVCountOutputType without action
   */
  export type MRVCountOutputTypeCountMrv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVItemWhereInput
  }



  /**
   * Count Type MCTCountOutputType
   */

  export type MCTCountOutputType = {
    mct_approvers: number
    mcrts: number
  }

  export type MCTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mct_approvers?: boolean | MCTCountOutputTypeCountMct_approversArgs
    mcrts?: boolean | MCTCountOutputTypeCountMcrtsArgs
  }

  // Custom InputTypes

  /**
   * MCTCountOutputType without action
   */
  export type MCTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTCountOutputType
     */
    select?: MCTCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MCTCountOutputType without action
   */
  export type MCTCountOutputTypeCountMct_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCTApproverWhereInput
  }


  /**
   * MCTCountOutputType without action
   */
  export type MCTCountOutputTypeCountMcrtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTWhereInput
  }



  /**
   * Count Type MCRTCountOutputType
   */

  export type MCRTCountOutputType = {
    mcrt_approvers: number
    mcrt_items: number
  }

  export type MCRTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcrt_approvers?: boolean | MCRTCountOutputTypeCountMcrt_approversArgs
    mcrt_items?: boolean | MCRTCountOutputTypeCountMcrt_itemsArgs
  }

  // Custom InputTypes

  /**
   * MCRTCountOutputType without action
   */
  export type MCRTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTCountOutputType
     */
    select?: MCRTCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MCRTCountOutputType without action
   */
  export type MCRTCountOutputTypeCountMcrt_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTApproverWhereInput
  }


  /**
   * MCRTCountOutputType without action
   */
  export type MCRTCountOutputTypeCountMcrt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTItemWhereInput
  }



  /**
   * Count Type MSTCountOutputType
   */

  export type MSTCountOutputType = {
    mst_approvers: number
    mst_items: number
  }

  export type MSTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mst_approvers?: boolean | MSTCountOutputTypeCountMst_approversArgs
    mst_items?: boolean | MSTCountOutputTypeCountMst_itemsArgs
  }

  // Custom InputTypes

  /**
   * MSTCountOutputType without action
   */
  export type MSTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTCountOutputType
     */
    select?: MSTCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MSTCountOutputType without action
   */
  export type MSTCountOutputTypeCountMst_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTApproverWhereInput
  }


  /**
   * MSTCountOutputType without action
   */
  export type MSTCountOutputTypeCountMst_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTItemWhereInput
  }



  /**
   * Models
   */

  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type ItemTypeAvgAggregateInputType = {
    id?: true
  }

  export type ItemTypeSumAggregateInputType = {
    id?: true
  }

  export type ItemTypeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _avg?: ItemTypeAvgAggregateInputType
    _sum?: ItemTypeSumAggregateInputType
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: number
    code: string
    name: string
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
  }

  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }


  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
    **/
    create<T extends ItemTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemTypes.
     *     @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     *     @example
     *     // Create many ItemTypes
     *     const itemType = await prisma.itemType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
    **/
    delete<T extends ItemTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends ItemType$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemType model
   */ 
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'Int'>
    readonly code: FieldRef<"ItemType", 'String'>
    readonly name: FieldRef<"ItemType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }


  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }


  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType.items
   */
  export type ItemType$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }



  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    vat_type: number | null
  }

  export type SupplierSumAggregateOutputType = {
    vat_type: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    tin: string | null
    address: string | null
    vat_type: number | null
    is_vat_registered: boolean | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    tin: string | null
    address: string | null
    vat_type: number | null
    is_vat_registered: boolean | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    tin: number
    address: number
    vat_type: number
    is_vat_registered: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    vat_type?: true
  }

  export type SupplierSumAggregateInputType = {
    vat_type?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    tin?: true
    address?: true
    vat_type?: true
    is_vat_registered?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    tin?: true
    address?: true
    vat_type?: true
    is_vat_registered?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    tin?: true
    address?: true
    vat_type?: true
    is_vat_registered?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contact: string
    tin: string
    address: string
    vat_type: number
    is_vat_registered: boolean
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    tin?: boolean
    address?: boolean
    vat_type?: boolean
    is_vat_registered?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    MEQSSupplier?: boolean | Supplier$MEQSSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    tin?: boolean
    address?: boolean
    vat_type?: boolean
    is_vat_registered?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MEQSSupplier?: boolean | Supplier$MEQSSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      MEQSSupplier: Prisma.$MEQSSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string
      tin: string
      address: string
      vat_type: number
      is_vat_registered: boolean
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    MEQSSupplier<T extends Supplier$MEQSSupplierArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$MEQSSupplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
    readonly tin: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly vat_type: FieldRef<"Supplier", 'Int'>
    readonly is_vat_registered: FieldRef<"Supplier", 'Boolean'>
    readonly created_by: FieldRef<"Supplier", 'String'>
    readonly updated_by: FieldRef<"Supplier", 'String'>
    readonly deleted_by: FieldRef<"Supplier", 'String'>
    readonly created_at: FieldRef<"Supplier", 'DateTime'>
    readonly updated_at: FieldRef<"Supplier", 'DateTime'>
    readonly deleted_at: FieldRef<"Supplier", 'DateTime'>
    readonly metadata: FieldRef<"Supplier", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier.MEQSSupplier
   */
  export type Supplier$MEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    cursor?: MEQSSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
  }



  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    name: string
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    canvass_items?: boolean | Unit$canvass_itemsArgs<ExtArgs>
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | Unit$canvass_itemsArgs<ExtArgs>
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }


  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
    **/
    create<T extends UnitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitCreateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Units.
     *     @param {UnitCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const unit = await prisma.unit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
    **/
    delete<T extends UnitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
    **/
    upsert<T extends UnitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_items<T extends Unit$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    items<T extends Unit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly created_by: FieldRef<"Unit", 'String'>
    readonly updated_by: FieldRef<"Unit", 'String'>
    readonly deleted_by: FieldRef<"Unit", 'String'>
    readonly created_at: FieldRef<"Unit", 'DateTime'>
    readonly updated_at: FieldRef<"Unit", 'DateTime'>
    readonly deleted_at: FieldRef<"Unit", 'DateTime'>
    readonly metadata: FieldRef<"Unit", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }


  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }


  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }


  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }


  /**
   * Unit.canvass_items
   */
  export type Unit$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Unit.items
   */
  export type Unit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
  }



  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    name: string | null
    plate_number: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    plate_number: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    name: number
    plate_number: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type VehicleMinAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    name: string
    plate_number: string
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plate_number?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    sprs?: boolean | Vehicle$sprsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    name?: boolean
    plate_number?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprs?: boolean | Vehicle$sprsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      sprs: Prisma.$SPRPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      plate_number: string
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }


  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VehicleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VehicleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VehicleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
    **/
    create<T extends VehicleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Vehicles.
     *     @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     *     @example
     *     // Create many Vehicles
     *     const vehicle = await prisma.vehicle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VehicleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
    **/
    delete<T extends VehicleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VehicleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VehicleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VehicleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
    **/
    upsert<T extends VehicleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sprs<T extends Vehicle$sprsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$sprsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly name: FieldRef<"Vehicle", 'String'>
    readonly plate_number: FieldRef<"Vehicle", 'String'>
    readonly created_by: FieldRef<"Vehicle", 'String'>
    readonly updated_by: FieldRef<"Vehicle", 'String'>
    readonly deleted_by: FieldRef<"Vehicle", 'String'>
    readonly created_at: FieldRef<"Vehicle", 'DateTime'>
    readonly updated_at: FieldRef<"Vehicle", 'DateTime'>
    readonly deleted_at: FieldRef<"Vehicle", 'DateTime'>
    readonly metadata: FieldRef<"Vehicle", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }


  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }


  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }


  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }


  /**
   * Vehicle.sprs
   */
  export type Vehicle$sprsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    cursor?: SPRWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
  }



  /**
   * Model Station
   */

  export type AggregateStation = {
    _count: StationCountAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  export type StationMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StationCountAggregateOutputType = {
    id: number
    name: number
    location: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type StationMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StationMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StationCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type StationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Station to aggregate.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stations
    **/
    _count?: true | StationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StationMaxAggregateInputType
  }

  export type GetStationAggregateType<T extends StationAggregateArgs> = {
        [P in keyof T & keyof AggregateStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation[P]>
      : GetScalarType<T[P], AggregateStation[P]>
  }




  export type StationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationWhereInput
    orderBy?: StationOrderByWithAggregationInput | StationOrderByWithAggregationInput[]
    by: StationScalarFieldEnum[] | StationScalarFieldEnum
    having?: StationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StationCountAggregateInputType | true
    _min?: StationMinAggregateInputType
    _max?: StationMaxAggregateInputType
  }

  export type StationGroupByOutputType = {
    id: string
    name: string
    location: string
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: StationCountAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  type GetStationGroupByPayload<T extends StationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StationGroupByOutputType[P]>
            : GetScalarType<T[P], StationGroupByOutputType[P]>
        }
      >
    >


  export type StationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    items?: boolean | Station$itemsArgs<ExtArgs>
    osrivs?: boolean | Station$osrivsArgs<ExtArgs>
    mrvs?: boolean | Station$mrvsArgs<ExtArgs>
    serivs?: boolean | Station$serivsArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["station"]>

  export type StationSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type StationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Station$itemsArgs<ExtArgs>
    osrivs?: boolean | Station$osrivsArgs<ExtArgs>
    mrvs?: boolean | Station$mrvsArgs<ExtArgs>
    serivs?: boolean | Station$serivsArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Station"
    objects: {
      items: Prisma.$ItemLocationPayload<ExtArgs>[]
      osrivs: Prisma.$OSRIVPayload<ExtArgs>[]
      mrvs: Prisma.$MRVPayload<ExtArgs>[]
      serivs: Prisma.$SERIVPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["station"]>
    composites: {}
  }


  type StationGetPayload<S extends boolean | null | undefined | StationDefaultArgs> = $Result.GetResult<Prisma.$StationPayload, S>

  type StationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StationCountAggregateInputType | true
    }

  export interface StationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Station'], meta: { name: 'Station' } }
    /**
     * Find zero or one Station that matches the filter.
     * @param {StationFindUniqueArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StationFindUniqueArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Station that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StationFindUniqueOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Station that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StationFindFirstArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Station that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Stations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stations
     * const stations = await prisma.station.findMany()
     * 
     * // Get first 10 Stations
     * const stations = await prisma.station.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stationWithIdOnly = await prisma.station.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Station.
     * @param {StationCreateArgs} args - Arguments to create a Station.
     * @example
     * // Create one Station
     * const Station = await prisma.station.create({
     *   data: {
     *     // ... data to create a Station
     *   }
     * })
     * 
    **/
    create<T extends StationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StationCreateArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Stations.
     *     @param {StationCreateManyArgs} args - Arguments to create many Stations.
     *     @example
     *     // Create many Stations
     *     const station = await prisma.station.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Station.
     * @param {StationDeleteArgs} args - Arguments to delete one Station.
     * @example
     * // Delete one Station
     * const Station = await prisma.station.delete({
     *   where: {
     *     // ... filter to delete one Station
     *   }
     * })
     * 
    **/
    delete<T extends StationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StationDeleteArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Station.
     * @param {StationUpdateArgs} args - Arguments to update one Station.
     * @example
     * // Update one Station
     * const station = await prisma.station.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StationUpdateArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Stations.
     * @param {StationDeleteManyArgs} args - Arguments to filter Stations to delete.
     * @example
     * // Delete a few Stations
     * const { count } = await prisma.station.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stations
     * const station = await prisma.station.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station.
     * @param {StationUpsertArgs} args - Arguments to update or create a Station.
     * @example
     * // Update or create a Station
     * const station = await prisma.station.upsert({
     *   create: {
     *     // ... data to create a Station
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station we want to update
     *   }
     * })
    **/
    upsert<T extends StationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StationUpsertArgs<ExtArgs>>
    ): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationCountArgs} args - Arguments to filter Stations to count.
     * @example
     * // Count the number of Stations
     * const count = await prisma.station.count({
     *   where: {
     *     // ... the filter for the Stations we want to count
     *   }
     * })
    **/
    count<T extends StationCountArgs>(
      args?: Subset<T, StationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StationAggregateArgs>(args: Subset<T, StationAggregateArgs>): Prisma.PrismaPromise<GetStationAggregateType<T>>

    /**
     * Group by Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StationGroupByArgs['orderBy'] }
        : { orderBy?: StationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Station model
   */
  readonly fields: StationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Station.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends Station$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Station$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findMany'> | Null>;

    osrivs<T extends Station$osrivsArgs<ExtArgs> = {}>(args?: Subset<T, Station$osrivsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findMany'> | Null>;

    mrvs<T extends Station$mrvsArgs<ExtArgs> = {}>(args?: Subset<T, Station$mrvsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findMany'> | Null>;

    serivs<T extends Station$serivsArgs<ExtArgs> = {}>(args?: Subset<T, Station$serivsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Station model
   */ 
  interface StationFieldRefs {
    readonly id: FieldRef<"Station", 'String'>
    readonly name: FieldRef<"Station", 'String'>
    readonly location: FieldRef<"Station", 'String'>
    readonly created_by: FieldRef<"Station", 'String'>
    readonly updated_by: FieldRef<"Station", 'String'>
    readonly deleted_by: FieldRef<"Station", 'String'>
    readonly created_at: FieldRef<"Station", 'DateTime'>
    readonly updated_at: FieldRef<"Station", 'DateTime'>
    readonly deleted_at: FieldRef<"Station", 'DateTime'>
    readonly metadata: FieldRef<"Station", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Station findUnique
   */
  export type StationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }


  /**
   * Station findUniqueOrThrow
   */
  export type StationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }


  /**
   * Station findFirst
   */
  export type StationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }


  /**
   * Station findFirstOrThrow
   */
  export type StationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }


  /**
   * Station findMany
   */
  export type StationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Stations to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }


  /**
   * Station create
   */
  export type StationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to create a Station.
     */
    data: XOR<StationCreateInput, StationUncheckedCreateInput>
  }


  /**
   * Station createMany
   */
  export type StationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stations.
     */
    data: StationCreateManyInput | StationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Station update
   */
  export type StationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to update a Station.
     */
    data: XOR<StationUpdateInput, StationUncheckedUpdateInput>
    /**
     * Choose, which Station to update.
     */
    where: StationWhereUniqueInput
  }


  /**
   * Station updateMany
   */
  export type StationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stations.
     */
    data: XOR<StationUpdateManyMutationInput, StationUncheckedUpdateManyInput>
    /**
     * Filter which Stations to update
     */
    where?: StationWhereInput
  }


  /**
   * Station upsert
   */
  export type StationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The filter to search for the Station to update in case it exists.
     */
    where: StationWhereUniqueInput
    /**
     * In case the Station found by the `where` argument doesn't exist, create a new Station with this data.
     */
    create: XOR<StationCreateInput, StationUncheckedCreateInput>
    /**
     * In case the Station was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StationUpdateInput, StationUncheckedUpdateInput>
  }


  /**
   * Station delete
   */
  export type StationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter which Station to delete.
     */
    where: StationWhereUniqueInput
  }


  /**
   * Station deleteMany
   */
  export type StationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stations to delete
     */
    where?: StationWhereInput
  }


  /**
   * Station.items
   */
  export type Station$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    cursor?: ItemLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }


  /**
   * Station.osrivs
   */
  export type Station$osrivsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    where?: OSRIVWhereInput
    orderBy?: OSRIVOrderByWithRelationInput | OSRIVOrderByWithRelationInput[]
    cursor?: OSRIVWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OSRIVScalarFieldEnum | OSRIVScalarFieldEnum[]
  }


  /**
   * Station.mrvs
   */
  export type Station$mrvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    where?: MRVWhereInput
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    cursor?: MRVWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MRVScalarFieldEnum | MRVScalarFieldEnum[]
  }


  /**
   * Station.serivs
   */
  export type Station$serivsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    where?: SERIVWhereInput
    orderBy?: SERIVOrderByWithRelationInput | SERIVOrderByWithRelationInput[]
    cursor?: SERIVWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SERIVScalarFieldEnum | SERIVScalarFieldEnum[]
  }


  /**
   * Station without action
   */
  export type StationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StationInclude<ExtArgs> | null
  }



  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    mrv?: boolean | Project$mrvArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv?: boolean | Project$mrvArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      mrv: Prisma.$MRVPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }


  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mrv<T extends Project$mrvArgs<ExtArgs> = {}>(args?: Subset<T, Project$mrvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly created_by: FieldRef<"Project", 'String'>
    readonly updated_by: FieldRef<"Project", 'String'>
    readonly deleted_by: FieldRef<"Project", 'String'>
    readonly created_at: FieldRef<"Project", 'DateTime'>
    readonly updated_at: FieldRef<"Project", 'DateTime'>
    readonly deleted_at: FieldRef<"Project", 'DateTime'>
    readonly metadata: FieldRef<"Project", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }


  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }


  /**
   * Project.mrv
   */
  export type Project$mrvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    where?: MRVWhereInput
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    cursor?: MRVWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MRVScalarFieldEnum | MRVScalarFieldEnum[]
  }


  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
  }



  /**
   * Model Pending
   */

  export type AggregatePending = {
    _count: PendingCountAggregateOutputType | null
    _avg: PendingAvgAggregateOutputType | null
    _sum: PendingSumAggregateOutputType | null
    _min: PendingMinAggregateOutputType | null
    _max: PendingMaxAggregateOutputType | null
  }

  export type PendingAvgAggregateOutputType = {
    id: number | null
  }

  export type PendingSumAggregateOutputType = {
    id: number | null
  }

  export type PendingMinAggregateOutputType = {
    id: number | null
    approver_id: string | null
    reference_number: string | null
    reference_table: string | null
    description: string | null
    transaction_date: Date | null
  }

  export type PendingMaxAggregateOutputType = {
    id: number | null
    approver_id: string | null
    reference_number: string | null
    reference_table: string | null
    description: string | null
    transaction_date: Date | null
  }

  export type PendingCountAggregateOutputType = {
    id: number
    approver_id: number
    reference_number: number
    reference_table: number
    description: number
    transaction_date: number
    _all: number
  }


  export type PendingAvgAggregateInputType = {
    id?: true
  }

  export type PendingSumAggregateInputType = {
    id?: true
  }

  export type PendingMinAggregateInputType = {
    id?: true
    approver_id?: true
    reference_number?: true
    reference_table?: true
    description?: true
    transaction_date?: true
  }

  export type PendingMaxAggregateInputType = {
    id?: true
    approver_id?: true
    reference_number?: true
    reference_table?: true
    description?: true
    transaction_date?: true
  }

  export type PendingCountAggregateInputType = {
    id?: true
    approver_id?: true
    reference_number?: true
    reference_table?: true
    description?: true
    transaction_date?: true
    _all?: true
  }

  export type PendingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pending to aggregate.
     */
    where?: PendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendings to fetch.
     */
    orderBy?: PendingOrderByWithRelationInput | PendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pendings
    **/
    _count?: true | PendingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingMaxAggregateInputType
  }

  export type GetPendingAggregateType<T extends PendingAggregateArgs> = {
        [P in keyof T & keyof AggregatePending]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePending[P]>
      : GetScalarType<T[P], AggregatePending[P]>
  }




  export type PendingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingWhereInput
    orderBy?: PendingOrderByWithAggregationInput | PendingOrderByWithAggregationInput[]
    by: PendingScalarFieldEnum[] | PendingScalarFieldEnum
    having?: PendingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingCountAggregateInputType | true
    _avg?: PendingAvgAggregateInputType
    _sum?: PendingSumAggregateInputType
    _min?: PendingMinAggregateInputType
    _max?: PendingMaxAggregateInputType
  }

  export type PendingGroupByOutputType = {
    id: number
    approver_id: string
    reference_number: string
    reference_table: string
    description: string
    transaction_date: Date
    _count: PendingCountAggregateOutputType | null
    _avg: PendingAvgAggregateOutputType | null
    _sum: PendingSumAggregateOutputType | null
    _min: PendingMinAggregateOutputType | null
    _max: PendingMaxAggregateOutputType | null
  }

  type GetPendingGroupByPayload<T extends PendingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingGroupByOutputType[P]>
            : GetScalarType<T[P], PendingGroupByOutputType[P]>
        }
      >
    >


  export type PendingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approver_id?: boolean
    reference_number?: boolean
    reference_table?: boolean
    description?: boolean
    transaction_date?: boolean
  }, ExtArgs["result"]["pending"]>

  export type PendingSelectScalar = {
    id?: boolean
    approver_id?: boolean
    reference_number?: boolean
    reference_table?: boolean
    description?: boolean
    transaction_date?: boolean
  }


  export type $PendingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pending"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      approver_id: string
      reference_number: string
      reference_table: string
      description: string
      transaction_date: Date
    }, ExtArgs["result"]["pending"]>
    composites: {}
  }


  type PendingGetPayload<S extends boolean | null | undefined | PendingDefaultArgs> = $Result.GetResult<Prisma.$PendingPayload, S>

  type PendingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PendingCountAggregateInputType | true
    }

  export interface PendingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pending'], meta: { name: 'Pending' } }
    /**
     * Find zero or one Pending that matches the filter.
     * @param {PendingFindUniqueArgs} args - Arguments to find a Pending
     * @example
     * // Get one Pending
     * const pending = await prisma.pending.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PendingFindUniqueArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pending that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PendingFindUniqueOrThrowArgs} args - Arguments to find a Pending
     * @example
     * // Get one Pending
     * const pending = await prisma.pending.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PendingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pending that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFindFirstArgs} args - Arguments to find a Pending
     * @example
     * // Get one Pending
     * const pending = await prisma.pending.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingFindFirstArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pending that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFindFirstOrThrowArgs} args - Arguments to find a Pending
     * @example
     * // Get one Pending
     * const pending = await prisma.pending.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PendingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pendings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pendings
     * const pendings = await prisma.pending.findMany()
     * 
     * // Get first 10 Pendings
     * const pendings = await prisma.pending.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingWithIdOnly = await prisma.pending.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pending.
     * @param {PendingCreateArgs} args - Arguments to create a Pending.
     * @example
     * // Create one Pending
     * const Pending = await prisma.pending.create({
     *   data: {
     *     // ... data to create a Pending
     *   }
     * })
     * 
    **/
    create<T extends PendingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingCreateArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pendings.
     *     @param {PendingCreateManyArgs} args - Arguments to create many Pendings.
     *     @example
     *     // Create many Pendings
     *     const pending = await prisma.pending.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pending.
     * @param {PendingDeleteArgs} args - Arguments to delete one Pending.
     * @example
     * // Delete one Pending
     * const Pending = await prisma.pending.delete({
     *   where: {
     *     // ... filter to delete one Pending
     *   }
     * })
     * 
    **/
    delete<T extends PendingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PendingDeleteArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pending.
     * @param {PendingUpdateArgs} args - Arguments to update one Pending.
     * @example
     * // Update one Pending
     * const pending = await prisma.pending.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingUpdateArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pendings.
     * @param {PendingDeleteManyArgs} args - Arguments to filter Pendings to delete.
     * @example
     * // Delete a few Pendings
     * const { count } = await prisma.pending.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pendings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pendings
     * const pending = await prisma.pending.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PendingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pending.
     * @param {PendingUpsertArgs} args - Arguments to update or create a Pending.
     * @example
     * // Update or create a Pending
     * const pending = await prisma.pending.upsert({
     *   create: {
     *     // ... data to create a Pending
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pending we want to update
     *   }
     * })
    **/
    upsert<T extends PendingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PendingUpsertArgs<ExtArgs>>
    ): Prisma__PendingClient<$Result.GetResult<Prisma.$PendingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pendings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCountArgs} args - Arguments to filter Pendings to count.
     * @example
     * // Count the number of Pendings
     * const count = await prisma.pending.count({
     *   where: {
     *     // ... the filter for the Pendings we want to count
     *   }
     * })
    **/
    count<T extends PendingCountArgs>(
      args?: Subset<T, PendingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pending.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingAggregateArgs>(args: Subset<T, PendingAggregateArgs>): Prisma.PrismaPromise<GetPendingAggregateType<T>>

    /**
     * Group by Pending.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingGroupByArgs['orderBy'] }
        : { orderBy?: PendingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pending model
   */
  readonly fields: PendingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pending.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pending model
   */ 
  interface PendingFieldRefs {
    readonly id: FieldRef<"Pending", 'Int'>
    readonly approver_id: FieldRef<"Pending", 'String'>
    readonly reference_number: FieldRef<"Pending", 'String'>
    readonly reference_table: FieldRef<"Pending", 'String'>
    readonly description: FieldRef<"Pending", 'String'>
    readonly transaction_date: FieldRef<"Pending", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Pending findUnique
   */
  export type PendingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter, which Pending to fetch.
     */
    where: PendingWhereUniqueInput
  }


  /**
   * Pending findUniqueOrThrow
   */
  export type PendingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter, which Pending to fetch.
     */
    where: PendingWhereUniqueInput
  }


  /**
   * Pending findFirst
   */
  export type PendingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter, which Pending to fetch.
     */
    where?: PendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendings to fetch.
     */
    orderBy?: PendingOrderByWithRelationInput | PendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pendings.
     */
    cursor?: PendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pendings.
     */
    distinct?: PendingScalarFieldEnum | PendingScalarFieldEnum[]
  }


  /**
   * Pending findFirstOrThrow
   */
  export type PendingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter, which Pending to fetch.
     */
    where?: PendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendings to fetch.
     */
    orderBy?: PendingOrderByWithRelationInput | PendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pendings.
     */
    cursor?: PendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pendings.
     */
    distinct?: PendingScalarFieldEnum | PendingScalarFieldEnum[]
  }


  /**
   * Pending findMany
   */
  export type PendingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter, which Pendings to fetch.
     */
    where?: PendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendings to fetch.
     */
    orderBy?: PendingOrderByWithRelationInput | PendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pendings.
     */
    cursor?: PendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendings.
     */
    skip?: number
    distinct?: PendingScalarFieldEnum | PendingScalarFieldEnum[]
  }


  /**
   * Pending create
   */
  export type PendingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * The data needed to create a Pending.
     */
    data: XOR<PendingCreateInput, PendingUncheckedCreateInput>
  }


  /**
   * Pending createMany
   */
  export type PendingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pendings.
     */
    data: PendingCreateManyInput | PendingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pending update
   */
  export type PendingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * The data needed to update a Pending.
     */
    data: XOR<PendingUpdateInput, PendingUncheckedUpdateInput>
    /**
     * Choose, which Pending to update.
     */
    where: PendingWhereUniqueInput
  }


  /**
   * Pending updateMany
   */
  export type PendingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pendings.
     */
    data: XOR<PendingUpdateManyMutationInput, PendingUncheckedUpdateManyInput>
    /**
     * Filter which Pendings to update
     */
    where?: PendingWhereInput
  }


  /**
   * Pending upsert
   */
  export type PendingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * The filter to search for the Pending to update in case it exists.
     */
    where: PendingWhereUniqueInput
    /**
     * In case the Pending found by the `where` argument doesn't exist, create a new Pending with this data.
     */
    create: XOR<PendingCreateInput, PendingUncheckedCreateInput>
    /**
     * In case the Pending was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingUpdateInput, PendingUncheckedUpdateInput>
  }


  /**
   * Pending delete
   */
  export type PendingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
    /**
     * Filter which Pending to delete.
     */
    where: PendingWhereUniqueInput
  }


  /**
   * Pending deleteMany
   */
  export type PendingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pendings to delete
     */
    where?: PendingWhereInput
  }


  /**
   * Pending without action
   */
  export type PendingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pending
     */
    select?: PendingSelect<ExtArgs> | null
  }



  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }


  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SettingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SettingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SettingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
    **/
    create<T extends SettingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SettingCreateArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Settings.
     *     @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const setting = await prisma.setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SettingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
    **/
    delete<T extends SettingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SettingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SettingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SettingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
    **/
    upsert<T extends SettingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'Int'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }


  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }


  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }


  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }


  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }



  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    item_type_id: number | null
    total_quantity: number | null
    quantity_on_queue: number | null
    initial_quantity: number | null
    alert_level: number | null
  }

  export type ItemSumAggregateOutputType = {
    item_type_id: number | null
    total_quantity: number | null
    quantity_on_queue: number | null
    initial_quantity: number | null
    alert_level: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    item_type_id: number | null
    unit_id: string | null
    code: string | null
    description: string | null
    total_quantity: number | null
    quantity_on_queue: number | null
    initial_quantity: number | null
    alert_level: number | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    item_type_id: number | null
    unit_id: string | null
    code: string | null
    description: string | null
    total_quantity: number | null
    quantity_on_queue: number | null
    initial_quantity: number | null
    alert_level: number | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    item_type_id: number
    unit_id: number
    code: number
    description: number
    total_quantity: number
    quantity_on_queue: number
    initial_quantity: number
    alert_level: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    item_type_id?: true
    total_quantity?: true
    quantity_on_queue?: true
    initial_quantity?: true
    alert_level?: true
  }

  export type ItemSumAggregateInputType = {
    item_type_id?: true
    total_quantity?: true
    quantity_on_queue?: true
    initial_quantity?: true
    alert_level?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    total_quantity?: true
    quantity_on_queue?: true
    initial_quantity?: true
    alert_level?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    total_quantity?: true
    quantity_on_queue?: true
    initial_quantity?: true
    alert_level?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    total_quantity?: true
    quantity_on_queue?: true
    initial_quantity?: true
    alert_level?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    item_type_id: number
    unit_id: string
    code: string
    description: string | null
    total_quantity: number
    quantity_on_queue: number
    initial_quantity: number
    alert_level: number
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_type_id?: boolean
    unit_id?: boolean
    code?: boolean
    description?: boolean
    total_quantity?: boolean
    quantity_on_queue?: boolean
    initial_quantity?: boolean
    alert_level?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    item_type?: boolean | ItemTypeDefaultArgs<ExtArgs>
    item_transactions?: boolean | Item$item_transactionsArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    canvass_items?: boolean | Item$canvass_itemsArgs<ExtArgs>
    item_locations?: boolean | Item$item_locationsArgs<ExtArgs>
    osriv_items?: boolean | Item$osriv_itemsArgs<ExtArgs>
    seriv_items?: boolean | Item$seriv_itemsArgs<ExtArgs>
    mrv_items?: boolean | Item$mrv_itemsArgs<ExtArgs>
    mcrt_items?: boolean | Item$mcrt_itemsArgs<ExtArgs>
    mst_items?: boolean | Item$mst_itemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    item_type_id?: boolean
    unit_id?: boolean
    code?: boolean
    description?: boolean
    total_quantity?: boolean
    quantity_on_queue?: boolean
    initial_quantity?: boolean
    alert_level?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_type?: boolean | ItemTypeDefaultArgs<ExtArgs>
    item_transactions?: boolean | Item$item_transactionsArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    canvass_items?: boolean | Item$canvass_itemsArgs<ExtArgs>
    item_locations?: boolean | Item$item_locationsArgs<ExtArgs>
    osriv_items?: boolean | Item$osriv_itemsArgs<ExtArgs>
    seriv_items?: boolean | Item$seriv_itemsArgs<ExtArgs>
    mrv_items?: boolean | Item$mrv_itemsArgs<ExtArgs>
    mcrt_items?: boolean | Item$mcrt_itemsArgs<ExtArgs>
    mst_items?: boolean | Item$mst_itemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      item_type: Prisma.$ItemTypePayload<ExtArgs>
      item_transactions: Prisma.$ItemTransactionPayload<ExtArgs>[]
      unit: Prisma.$UnitPayload<ExtArgs>
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      item_locations: Prisma.$ItemLocationPayload<ExtArgs>[]
      osriv_items: Prisma.$OSRIVItemPayload<ExtArgs>[]
      seriv_items: Prisma.$SERIVItemPayload<ExtArgs>[]
      mrv_items: Prisma.$MRVItemPayload<ExtArgs>[]
      mcrt_items: Prisma.$MCRTItemPayload<ExtArgs>[]
      mst_items: Prisma.$MSTItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_type_id: number
      unit_id: string
      code: string
      description: string | null
      total_quantity: number
      quantity_on_queue: number
      initial_quantity: number
      alert_level: number
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }


  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCreateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item_type<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transactions<T extends Item$item_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Item$item_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    canvass_items<T extends Item$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    item_locations<T extends Item$item_locationsArgs<ExtArgs> = {}>(args?: Subset<T, Item$item_locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findMany'> | Null>;

    osriv_items<T extends Item$osriv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$osriv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    seriv_items<T extends Item$seriv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$seriv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mrv_items<T extends Item$mrv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$mrv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mcrt_items<T extends Item$mcrt_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$mcrt_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mst_items<T extends Item$mst_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$mst_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly item_type_id: FieldRef<"Item", 'Int'>
    readonly unit_id: FieldRef<"Item", 'String'>
    readonly code: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly total_quantity: FieldRef<"Item", 'Int'>
    readonly quantity_on_queue: FieldRef<"Item", 'Int'>
    readonly initial_quantity: FieldRef<"Item", 'Int'>
    readonly alert_level: FieldRef<"Item", 'Int'>
    readonly created_by: FieldRef<"Item", 'String'>
    readonly updated_by: FieldRef<"Item", 'String'>
    readonly deleted_by: FieldRef<"Item", 'String'>
    readonly created_at: FieldRef<"Item", 'DateTime'>
    readonly updated_at: FieldRef<"Item", 'DateTime'>
    readonly deleted_at: FieldRef<"Item", 'DateTime'>
    readonly metadata: FieldRef<"Item", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item.item_transactions
   */
  export type Item$item_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    cursor?: ItemTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * Item.canvass_items
   */
  export type Item$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Item.item_locations
   */
  export type Item$item_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    cursor?: ItemLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }


  /**
   * Item.osriv_items
   */
  export type Item$osriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    where?: OSRIVItemWhereInput
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    cursor?: OSRIVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OSRIVItemScalarFieldEnum | OSRIVItemScalarFieldEnum[]
  }


  /**
   * Item.seriv_items
   */
  export type Item$seriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    where?: SERIVItemWhereInput
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    cursor?: SERIVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SERIVItemScalarFieldEnum | SERIVItemScalarFieldEnum[]
  }


  /**
   * Item.mrv_items
   */
  export type Item$mrv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    where?: MRVItemWhereInput
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    cursor?: MRVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MRVItemScalarFieldEnum | MRVItemScalarFieldEnum[]
  }


  /**
   * Item.mcrt_items
   */
  export type Item$mcrt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    where?: MCRTItemWhereInput
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    cursor?: MCRTItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCRTItemScalarFieldEnum | MCRTItemScalarFieldEnum[]
  }


  /**
   * Item.mst_items
   */
  export type Item$mst_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    where?: MSTItemWhereInput
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    cursor?: MSTItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MSTItemScalarFieldEnum | MSTItemScalarFieldEnum[]
  }


  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
  }



  /**
   * Model ItemLocation
   */

  export type AggregateItemLocation = {
    _count: ItemLocationCountAggregateOutputType | null
    _avg: ItemLocationAvgAggregateOutputType | null
    _sum: ItemLocationSumAggregateOutputType | null
    _min: ItemLocationMinAggregateOutputType | null
    _max: ItemLocationMaxAggregateOutputType | null
  }

  export type ItemLocationAvgAggregateOutputType = {
    quantity_on_hand: number | null
  }

  export type ItemLocationSumAggregateOutputType = {
    quantity_on_hand: number | null
  }

  export type ItemLocationMinAggregateOutputType = {
    id: string | null
    item_id: string | null
    station_id: string | null
    quantity_on_hand: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ItemLocationMaxAggregateOutputType = {
    id: string | null
    item_id: string | null
    station_id: string | null
    quantity_on_hand: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ItemLocationCountAggregateOutputType = {
    id: number
    item_id: number
    station_id: number
    quantity_on_hand: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type ItemLocationAvgAggregateInputType = {
    quantity_on_hand?: true
  }

  export type ItemLocationSumAggregateInputType = {
    quantity_on_hand?: true
  }

  export type ItemLocationMinAggregateInputType = {
    id?: true
    item_id?: true
    station_id?: true
    quantity_on_hand?: true
    created_by?: true
    created_at?: true
  }

  export type ItemLocationMaxAggregateInputType = {
    id?: true
    item_id?: true
    station_id?: true
    quantity_on_hand?: true
    created_by?: true
    created_at?: true
  }

  export type ItemLocationCountAggregateInputType = {
    id?: true
    item_id?: true
    station_id?: true
    quantity_on_hand?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type ItemLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLocation to aggregate.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemLocations
    **/
    _count?: true | ItemLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemLocationMaxAggregateInputType
  }

  export type GetItemLocationAggregateType<T extends ItemLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateItemLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemLocation[P]>
      : GetScalarType<T[P], AggregateItemLocation[P]>
  }




  export type ItemLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithAggregationInput | ItemLocationOrderByWithAggregationInput[]
    by: ItemLocationScalarFieldEnum[] | ItemLocationScalarFieldEnum
    having?: ItemLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemLocationCountAggregateInputType | true
    _avg?: ItemLocationAvgAggregateInputType
    _sum?: ItemLocationSumAggregateInputType
    _min?: ItemLocationMinAggregateInputType
    _max?: ItemLocationMaxAggregateInputType
  }

  export type ItemLocationGroupByOutputType = {
    id: string
    item_id: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: ItemLocationCountAggregateOutputType | null
    _avg: ItemLocationAvgAggregateOutputType | null
    _sum: ItemLocationSumAggregateOutputType | null
    _min: ItemLocationMinAggregateOutputType | null
    _max: ItemLocationMaxAggregateOutputType | null
  }

  type GetItemLocationGroupByPayload<T extends ItemLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemLocationGroupByOutputType[P]>
            : GetScalarType<T[P], ItemLocationGroupByOutputType[P]>
        }
      >
    >


  export type ItemLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    station_id?: boolean
    quantity_on_hand?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
    origin_movements?: boolean | ItemLocation$origin_movementsArgs<ExtArgs>
    destination_movements?: boolean | ItemLocation$destination_movementsArgs<ExtArgs>
    _count?: boolean | ItemLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLocation"]>

  export type ItemLocationSelectScalar = {
    id?: boolean
    item_id?: boolean
    station_id?: boolean
    quantity_on_hand?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type ItemLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
    origin_movements?: boolean | ItemLocation$origin_movementsArgs<ExtArgs>
    destination_movements?: boolean | ItemLocation$destination_movementsArgs<ExtArgs>
    _count?: boolean | ItemLocationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemLocation"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      station: Prisma.$StationPayload<ExtArgs>
      origin_movements: Prisma.$ItemMovementPayload<ExtArgs>[]
      destination_movements: Prisma.$ItemMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_id: string
      station_id: string
      quantity_on_hand: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["itemLocation"]>
    composites: {}
  }


  type ItemLocationGetPayload<S extends boolean | null | undefined | ItemLocationDefaultArgs> = $Result.GetResult<Prisma.$ItemLocationPayload, S>

  type ItemLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemLocationCountAggregateInputType | true
    }

  export interface ItemLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemLocation'], meta: { name: 'ItemLocation' } }
    /**
     * Find zero or one ItemLocation that matches the filter.
     * @param {ItemLocationFindUniqueArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemLocationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemLocation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemLocationFindUniqueOrThrowArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemLocationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindFirstArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemLocationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationFindFirstArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindFirstOrThrowArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemLocationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemLocations
     * const itemLocations = await prisma.itemLocation.findMany()
     * 
     * // Get first 10 ItemLocations
     * const itemLocations = await prisma.itemLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemLocationWithIdOnly = await prisma.itemLocation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemLocationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemLocation.
     * @param {ItemLocationCreateArgs} args - Arguments to create a ItemLocation.
     * @example
     * // Create one ItemLocation
     * const ItemLocation = await prisma.itemLocation.create({
     *   data: {
     *     // ... data to create a ItemLocation
     *   }
     * })
     * 
    **/
    create<T extends ItemLocationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationCreateArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemLocations.
     *     @param {ItemLocationCreateManyArgs} args - Arguments to create many ItemLocations.
     *     @example
     *     // Create many ItemLocations
     *     const itemLocation = await prisma.itemLocation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemLocationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemLocation.
     * @param {ItemLocationDeleteArgs} args - Arguments to delete one ItemLocation.
     * @example
     * // Delete one ItemLocation
     * const ItemLocation = await prisma.itemLocation.delete({
     *   where: {
     *     // ... filter to delete one ItemLocation
     *   }
     * })
     * 
    **/
    delete<T extends ItemLocationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationDeleteArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemLocation.
     * @param {ItemLocationUpdateArgs} args - Arguments to update one ItemLocation.
     * @example
     * // Update one ItemLocation
     * const itemLocation = await prisma.itemLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemLocationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationUpdateArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemLocations.
     * @param {ItemLocationDeleteManyArgs} args - Arguments to filter ItemLocations to delete.
     * @example
     * // Delete a few ItemLocations
     * const { count } = await prisma.itemLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemLocationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLocationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemLocations
     * const itemLocation = await prisma.itemLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemLocationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemLocation.
     * @param {ItemLocationUpsertArgs} args - Arguments to update or create a ItemLocation.
     * @example
     * // Update or create a ItemLocation
     * const itemLocation = await prisma.itemLocation.upsert({
     *   create: {
     *     // ... data to create a ItemLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemLocation we want to update
     *   }
     * })
    **/
    upsert<T extends ItemLocationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLocationUpsertArgs<ExtArgs>>
    ): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationCountArgs} args - Arguments to filter ItemLocations to count.
     * @example
     * // Count the number of ItemLocations
     * const count = await prisma.itemLocation.count({
     *   where: {
     *     // ... the filter for the ItemLocations we want to count
     *   }
     * })
    **/
    count<T extends ItemLocationCountArgs>(
      args?: Subset<T, ItemLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemLocationAggregateArgs>(args: Subset<T, ItemLocationAggregateArgs>): Prisma.PrismaPromise<GetItemLocationAggregateType<T>>

    /**
     * Group by ItemLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemLocationGroupByArgs['orderBy'] }
        : { orderBy?: ItemLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemLocation model
   */
  readonly fields: ItemLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    station<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    origin_movements<T extends ItemLocation$origin_movementsArgs<ExtArgs> = {}>(args?: Subset<T, ItemLocation$origin_movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findMany'> | Null>;

    destination_movements<T extends ItemLocation$destination_movementsArgs<ExtArgs> = {}>(args?: Subset<T, ItemLocation$destination_movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemLocation model
   */ 
  interface ItemLocationFieldRefs {
    readonly id: FieldRef<"ItemLocation", 'String'>
    readonly item_id: FieldRef<"ItemLocation", 'String'>
    readonly station_id: FieldRef<"ItemLocation", 'String'>
    readonly quantity_on_hand: FieldRef<"ItemLocation", 'Int'>
    readonly created_by: FieldRef<"ItemLocation", 'String'>
    readonly created_at: FieldRef<"ItemLocation", 'DateTime'>
    readonly metadata: FieldRef<"ItemLocation", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * ItemLocation findUnique
   */
  export type ItemLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where: ItemLocationWhereUniqueInput
  }


  /**
   * ItemLocation findUniqueOrThrow
   */
  export type ItemLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where: ItemLocationWhereUniqueInput
  }


  /**
   * ItemLocation findFirst
   */
  export type ItemLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLocations.
     */
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }


  /**
   * ItemLocation findFirstOrThrow
   */
  export type ItemLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLocations.
     */
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }


  /**
   * ItemLocation findMany
   */
  export type ItemLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocations to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }


  /**
   * ItemLocation create
   */
  export type ItemLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemLocation.
     */
    data: XOR<ItemLocationCreateInput, ItemLocationUncheckedCreateInput>
  }


  /**
   * ItemLocation createMany
   */
  export type ItemLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemLocations.
     */
    data: ItemLocationCreateManyInput | ItemLocationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemLocation update
   */
  export type ItemLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemLocation.
     */
    data: XOR<ItemLocationUpdateInput, ItemLocationUncheckedUpdateInput>
    /**
     * Choose, which ItemLocation to update.
     */
    where: ItemLocationWhereUniqueInput
  }


  /**
   * ItemLocation updateMany
   */
  export type ItemLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemLocations.
     */
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyInput>
    /**
     * Filter which ItemLocations to update
     */
    where?: ItemLocationWhereInput
  }


  /**
   * ItemLocation upsert
   */
  export type ItemLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemLocation to update in case it exists.
     */
    where: ItemLocationWhereUniqueInput
    /**
     * In case the ItemLocation found by the `where` argument doesn't exist, create a new ItemLocation with this data.
     */
    create: XOR<ItemLocationCreateInput, ItemLocationUncheckedCreateInput>
    /**
     * In case the ItemLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemLocationUpdateInput, ItemLocationUncheckedUpdateInput>
  }


  /**
   * ItemLocation delete
   */
  export type ItemLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter which ItemLocation to delete.
     */
    where: ItemLocationWhereUniqueInput
  }


  /**
   * ItemLocation deleteMany
   */
  export type ItemLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLocations to delete
     */
    where?: ItemLocationWhereInput
  }


  /**
   * ItemLocation.origin_movements
   */
  export type ItemLocation$origin_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    where?: ItemMovementWhereInput
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    cursor?: ItemMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMovementScalarFieldEnum | ItemMovementScalarFieldEnum[]
  }


  /**
   * ItemLocation.destination_movements
   */
  export type ItemLocation$destination_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    where?: ItemMovementWhereInput
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    cursor?: ItemMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMovementScalarFieldEnum | ItemMovementScalarFieldEnum[]
  }


  /**
   * ItemLocation without action
   */
  export type ItemLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemLocationInclude<ExtArgs> | null
  }



  /**
   * Model ItemMovement
   */

  export type AggregateItemMovement = {
    _count: ItemMovementCountAggregateOutputType | null
    _avg: ItemMovementAvgAggregateOutputType | null
    _sum: ItemMovementSumAggregateOutputType | null
    _min: ItemMovementMinAggregateOutputType | null
    _max: ItemMovementMaxAggregateOutputType | null
  }

  export type ItemMovementAvgAggregateOutputType = {
    quantity_moved: number | null
  }

  export type ItemMovementSumAggregateOutputType = {
    quantity_moved: number | null
  }

  export type ItemMovementMinAggregateOutputType = {
    id: string | null
    origin_id: string | null
    destination_id: string | null
    quantity_moved: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ItemMovementMaxAggregateOutputType = {
    id: string | null
    origin_id: string | null
    destination_id: string | null
    quantity_moved: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ItemMovementCountAggregateOutputType = {
    id: number
    origin_id: number
    destination_id: number
    quantity_moved: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type ItemMovementAvgAggregateInputType = {
    quantity_moved?: true
  }

  export type ItemMovementSumAggregateInputType = {
    quantity_moved?: true
  }

  export type ItemMovementMinAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    quantity_moved?: true
    created_by?: true
    created_at?: true
  }

  export type ItemMovementMaxAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    quantity_moved?: true
    created_by?: true
    created_at?: true
  }

  export type ItemMovementCountAggregateInputType = {
    id?: true
    origin_id?: true
    destination_id?: true
    quantity_moved?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type ItemMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMovement to aggregate.
     */
    where?: ItemMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMovements to fetch.
     */
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemMovements
    **/
    _count?: true | ItemMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMovementMaxAggregateInputType
  }

  export type GetItemMovementAggregateType<T extends ItemMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateItemMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemMovement[P]>
      : GetScalarType<T[P], AggregateItemMovement[P]>
  }




  export type ItemMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMovementWhereInput
    orderBy?: ItemMovementOrderByWithAggregationInput | ItemMovementOrderByWithAggregationInput[]
    by: ItemMovementScalarFieldEnum[] | ItemMovementScalarFieldEnum
    having?: ItemMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemMovementCountAggregateInputType | true
    _avg?: ItemMovementAvgAggregateInputType
    _sum?: ItemMovementSumAggregateInputType
    _min?: ItemMovementMinAggregateInputType
    _max?: ItemMovementMaxAggregateInputType
  }

  export type ItemMovementGroupByOutputType = {
    id: string
    origin_id: string
    destination_id: string
    quantity_moved: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: ItemMovementCountAggregateOutputType | null
    _avg: ItemMovementAvgAggregateOutputType | null
    _sum: ItemMovementSumAggregateOutputType | null
    _min: ItemMovementMinAggregateOutputType | null
    _max: ItemMovementMaxAggregateOutputType | null
  }

  type GetItemMovementGroupByPayload<T extends ItemMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemMovementGroupByOutputType[P]>
            : GetScalarType<T[P], ItemMovementGroupByOutputType[P]>
        }
      >
    >


  export type ItemMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    quantity_moved?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    origin?: boolean | ItemLocationDefaultArgs<ExtArgs>
    destination?: boolean | ItemLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemMovement"]>

  export type ItemMovementSelectScalar = {
    id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    quantity_moved?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type ItemMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | ItemLocationDefaultArgs<ExtArgs>
    destination?: boolean | ItemLocationDefaultArgs<ExtArgs>
  }


  export type $ItemMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemMovement"
    objects: {
      origin: Prisma.$ItemLocationPayload<ExtArgs>
      destination: Prisma.$ItemLocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      origin_id: string
      destination_id: string
      quantity_moved: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["itemMovement"]>
    composites: {}
  }


  type ItemMovementGetPayload<S extends boolean | null | undefined | ItemMovementDefaultArgs> = $Result.GetResult<Prisma.$ItemMovementPayload, S>

  type ItemMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemMovementCountAggregateInputType | true
    }

  export interface ItemMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemMovement'], meta: { name: 'ItemMovement' } }
    /**
     * Find zero or one ItemMovement that matches the filter.
     * @param {ItemMovementFindUniqueArgs} args - Arguments to find a ItemMovement
     * @example
     * // Get one ItemMovement
     * const itemMovement = await prisma.itemMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemMovementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemMovement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemMovementFindUniqueOrThrowArgs} args - Arguments to find a ItemMovement
     * @example
     * // Get one ItemMovement
     * const itemMovement = await prisma.itemMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemMovementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementFindFirstArgs} args - Arguments to find a ItemMovement
     * @example
     * // Get one ItemMovement
     * const itemMovement = await prisma.itemMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemMovementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementFindFirstArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementFindFirstOrThrowArgs} args - Arguments to find a ItemMovement
     * @example
     * // Get one ItemMovement
     * const itemMovement = await prisma.itemMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemMovementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemMovements
     * const itemMovements = await prisma.itemMovement.findMany()
     * 
     * // Get first 10 ItemMovements
     * const itemMovements = await prisma.itemMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemMovementWithIdOnly = await prisma.itemMovement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemMovementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemMovement.
     * @param {ItemMovementCreateArgs} args - Arguments to create a ItemMovement.
     * @example
     * // Create one ItemMovement
     * const ItemMovement = await prisma.itemMovement.create({
     *   data: {
     *     // ... data to create a ItemMovement
     *   }
     * })
     * 
    **/
    create<T extends ItemMovementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementCreateArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemMovements.
     *     @param {ItemMovementCreateManyArgs} args - Arguments to create many ItemMovements.
     *     @example
     *     // Create many ItemMovements
     *     const itemMovement = await prisma.itemMovement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemMovementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemMovement.
     * @param {ItemMovementDeleteArgs} args - Arguments to delete one ItemMovement.
     * @example
     * // Delete one ItemMovement
     * const ItemMovement = await prisma.itemMovement.delete({
     *   where: {
     *     // ... filter to delete one ItemMovement
     *   }
     * })
     * 
    **/
    delete<T extends ItemMovementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementDeleteArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemMovement.
     * @param {ItemMovementUpdateArgs} args - Arguments to update one ItemMovement.
     * @example
     * // Update one ItemMovement
     * const itemMovement = await prisma.itemMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemMovementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementUpdateArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemMovements.
     * @param {ItemMovementDeleteManyArgs} args - Arguments to filter ItemMovements to delete.
     * @example
     * // Delete a few ItemMovements
     * const { count } = await prisma.itemMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemMovementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMovementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemMovements
     * const itemMovement = await prisma.itemMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemMovementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemMovement.
     * @param {ItemMovementUpsertArgs} args - Arguments to update or create a ItemMovement.
     * @example
     * // Update or create a ItemMovement
     * const itemMovement = await prisma.itemMovement.upsert({
     *   create: {
     *     // ... data to create a ItemMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemMovement we want to update
     *   }
     * })
    **/
    upsert<T extends ItemMovementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMovementUpsertArgs<ExtArgs>>
    ): Prisma__ItemMovementClient<$Result.GetResult<Prisma.$ItemMovementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementCountArgs} args - Arguments to filter ItemMovements to count.
     * @example
     * // Count the number of ItemMovements
     * const count = await prisma.itemMovement.count({
     *   where: {
     *     // ... the filter for the ItemMovements we want to count
     *   }
     * })
    **/
    count<T extends ItemMovementCountArgs>(
      args?: Subset<T, ItemMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemMovementAggregateArgs>(args: Subset<T, ItemMovementAggregateArgs>): Prisma.PrismaPromise<GetItemMovementAggregateType<T>>

    /**
     * Group by ItemMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemMovementGroupByArgs['orderBy'] }
        : { orderBy?: ItemMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemMovement model
   */
  readonly fields: ItemMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    origin<T extends ItemLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemLocationDefaultArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    destination<T extends ItemLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemLocationDefaultArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemMovement model
   */ 
  interface ItemMovementFieldRefs {
    readonly id: FieldRef<"ItemMovement", 'String'>
    readonly origin_id: FieldRef<"ItemMovement", 'String'>
    readonly destination_id: FieldRef<"ItemMovement", 'String'>
    readonly quantity_moved: FieldRef<"ItemMovement", 'Int'>
    readonly created_by: FieldRef<"ItemMovement", 'String'>
    readonly created_at: FieldRef<"ItemMovement", 'DateTime'>
    readonly metadata: FieldRef<"ItemMovement", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * ItemMovement findUnique
   */
  export type ItemMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter, which ItemMovement to fetch.
     */
    where: ItemMovementWhereUniqueInput
  }


  /**
   * ItemMovement findUniqueOrThrow
   */
  export type ItemMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter, which ItemMovement to fetch.
     */
    where: ItemMovementWhereUniqueInput
  }


  /**
   * ItemMovement findFirst
   */
  export type ItemMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter, which ItemMovement to fetch.
     */
    where?: ItemMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMovements to fetch.
     */
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMovements.
     */
    cursor?: ItemMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMovements.
     */
    distinct?: ItemMovementScalarFieldEnum | ItemMovementScalarFieldEnum[]
  }


  /**
   * ItemMovement findFirstOrThrow
   */
  export type ItemMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter, which ItemMovement to fetch.
     */
    where?: ItemMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMovements to fetch.
     */
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMovements.
     */
    cursor?: ItemMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMovements.
     */
    distinct?: ItemMovementScalarFieldEnum | ItemMovementScalarFieldEnum[]
  }


  /**
   * ItemMovement findMany
   */
  export type ItemMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter, which ItemMovements to fetch.
     */
    where?: ItemMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMovements to fetch.
     */
    orderBy?: ItemMovementOrderByWithRelationInput | ItemMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemMovements.
     */
    cursor?: ItemMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMovements.
     */
    skip?: number
    distinct?: ItemMovementScalarFieldEnum | ItemMovementScalarFieldEnum[]
  }


  /**
   * ItemMovement create
   */
  export type ItemMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemMovement.
     */
    data: XOR<ItemMovementCreateInput, ItemMovementUncheckedCreateInput>
  }


  /**
   * ItemMovement createMany
   */
  export type ItemMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemMovements.
     */
    data: ItemMovementCreateManyInput | ItemMovementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemMovement update
   */
  export type ItemMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemMovement.
     */
    data: XOR<ItemMovementUpdateInput, ItemMovementUncheckedUpdateInput>
    /**
     * Choose, which ItemMovement to update.
     */
    where: ItemMovementWhereUniqueInput
  }


  /**
   * ItemMovement updateMany
   */
  export type ItemMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemMovements.
     */
    data: XOR<ItemMovementUpdateManyMutationInput, ItemMovementUncheckedUpdateManyInput>
    /**
     * Filter which ItemMovements to update
     */
    where?: ItemMovementWhereInput
  }


  /**
   * ItemMovement upsert
   */
  export type ItemMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemMovement to update in case it exists.
     */
    where: ItemMovementWhereUniqueInput
    /**
     * In case the ItemMovement found by the `where` argument doesn't exist, create a new ItemMovement with this data.
     */
    create: XOR<ItemMovementCreateInput, ItemMovementUncheckedCreateInput>
    /**
     * In case the ItemMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemMovementUpdateInput, ItemMovementUncheckedUpdateInput>
  }


  /**
   * ItemMovement delete
   */
  export type ItemMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
    /**
     * Filter which ItemMovement to delete.
     */
    where: ItemMovementWhereUniqueInput
  }


  /**
   * ItemMovement deleteMany
   */
  export type ItemMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMovements to delete
     */
    where?: ItemMovementWhereInput
  }


  /**
   * ItemMovement without action
   */
  export type ItemMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMovement
     */
    select?: ItemMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemMovementInclude<ExtArgs> | null
  }



  /**
   * Model ItemTransaction
   */

  export type AggregateItemTransaction = {
    _count: ItemTransactionCountAggregateOutputType | null
    _avg: ItemTransactionAvgAggregateOutputType | null
    _sum: ItemTransactionSumAggregateOutputType | null
    _min: ItemTransactionMinAggregateOutputType | null
    _max: ItemTransactionMaxAggregateOutputType | null
  }

  export type ItemTransactionAvgAggregateOutputType = {
    id: number | null
    type: number | null
    quantity: number | null
    price: number | null
  }

  export type ItemTransactionSumAggregateOutputType = {
    id: number | null
    type: number | null
    quantity: number | null
    price: number | null
  }

  export type ItemTransactionMinAggregateOutputType = {
    id: number | null
    item_id: string | null
    rr_item_id: string | null
    osriv_item_id: string | null
    seriv_item_id: string | null
    mrv_item_id: string | null
    mcrt_item_id: string | null
    type: number | null
    quantity: number | null
    price: number | null
    remarks: string | null
    is_initial: boolean | null
    created_at: Date | null
    created_by: string | null
  }

  export type ItemTransactionMaxAggregateOutputType = {
    id: number | null
    item_id: string | null
    rr_item_id: string | null
    osriv_item_id: string | null
    seriv_item_id: string | null
    mrv_item_id: string | null
    mcrt_item_id: string | null
    type: number | null
    quantity: number | null
    price: number | null
    remarks: string | null
    is_initial: boolean | null
    created_at: Date | null
    created_by: string | null
  }

  export type ItemTransactionCountAggregateOutputType = {
    id: number
    item_id: number
    rr_item_id: number
    osriv_item_id: number
    seriv_item_id: number
    mrv_item_id: number
    mcrt_item_id: number
    type: number
    quantity: number
    price: number
    remarks: number
    is_initial: number
    created_at: number
    created_by: number
    metadata: number
    _all: number
  }


  export type ItemTransactionAvgAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    price?: true
  }

  export type ItemTransactionSumAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    price?: true
  }

  export type ItemTransactionMinAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    osriv_item_id?: true
    seriv_item_id?: true
    mrv_item_id?: true
    mcrt_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    created_by?: true
  }

  export type ItemTransactionMaxAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    osriv_item_id?: true
    seriv_item_id?: true
    mrv_item_id?: true
    mcrt_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    created_by?: true
  }

  export type ItemTransactionCountAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    osriv_item_id?: true
    seriv_item_id?: true
    mrv_item_id?: true
    mcrt_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    created_by?: true
    metadata?: true
    _all?: true
  }

  export type ItemTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTransaction to aggregate.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTransactions
    **/
    _count?: true | ItemTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTransactionMaxAggregateInputType
  }

  export type GetItemTransactionAggregateType<T extends ItemTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateItemTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemTransaction[P]>
      : GetScalarType<T[P], AggregateItemTransaction[P]>
  }




  export type ItemTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTransactionWhereInput
    orderBy?: ItemTransactionOrderByWithAggregationInput | ItemTransactionOrderByWithAggregationInput[]
    by: ItemTransactionScalarFieldEnum[] | ItemTransactionScalarFieldEnum
    having?: ItemTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTransactionCountAggregateInputType | true
    _avg?: ItemTransactionAvgAggregateInputType
    _sum?: ItemTransactionSumAggregateInputType
    _min?: ItemTransactionMinAggregateInputType
    _max?: ItemTransactionMaxAggregateInputType
  }

  export type ItemTransactionGroupByOutputType = {
    id: number
    item_id: string
    rr_item_id: string | null
    osriv_item_id: string | null
    seriv_item_id: string | null
    mrv_item_id: string | null
    mcrt_item_id: string | null
    type: number
    quantity: number
    price: number
    remarks: string | null
    is_initial: boolean
    created_at: Date
    created_by: string
    metadata: JsonValue | null
    _count: ItemTransactionCountAggregateOutputType | null
    _avg: ItemTransactionAvgAggregateOutputType | null
    _sum: ItemTransactionSumAggregateOutputType | null
    _min: ItemTransactionMinAggregateOutputType | null
    _max: ItemTransactionMaxAggregateOutputType | null
  }

  type GetItemTransactionGroupByPayload<T extends ItemTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ItemTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    rr_item_id?: boolean
    osriv_item_id?: boolean
    seriv_item_id?: boolean
    mrv_item_id?: boolean
    mcrt_item_id?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    remarks?: boolean
    is_initial?: boolean
    created_at?: boolean
    created_by?: boolean
    metadata?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    rr_item?: boolean | ItemTransaction$rr_itemArgs<ExtArgs>
    osriv_item?: boolean | ItemTransaction$osriv_itemArgs<ExtArgs>
    seriv_item?: boolean | ItemTransaction$seriv_itemArgs<ExtArgs>
    mrv_item?: boolean | ItemTransaction$mrv_itemArgs<ExtArgs>
    mcrt_item?: boolean | ItemTransaction$mcrt_itemArgs<ExtArgs>
  }, ExtArgs["result"]["itemTransaction"]>

  export type ItemTransactionSelectScalar = {
    id?: boolean
    item_id?: boolean
    rr_item_id?: boolean
    osriv_item_id?: boolean
    seriv_item_id?: boolean
    mrv_item_id?: boolean
    mcrt_item_id?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    remarks?: boolean
    is_initial?: boolean
    created_at?: boolean
    created_by?: boolean
    metadata?: boolean
  }

  export type ItemTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    rr_item?: boolean | ItemTransaction$rr_itemArgs<ExtArgs>
    osriv_item?: boolean | ItemTransaction$osriv_itemArgs<ExtArgs>
    seriv_item?: boolean | ItemTransaction$seriv_itemArgs<ExtArgs>
    mrv_item?: boolean | ItemTransaction$mrv_itemArgs<ExtArgs>
    mcrt_item?: boolean | ItemTransaction$mcrt_itemArgs<ExtArgs>
  }


  export type $ItemTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemTransaction"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      rr_item: Prisma.$RRItemPayload<ExtArgs> | null
      osriv_item: Prisma.$OSRIVItemPayload<ExtArgs> | null
      seriv_item: Prisma.$SERIVItemPayload<ExtArgs> | null
      mrv_item: Prisma.$MRVItemPayload<ExtArgs> | null
      mcrt_item: Prisma.$MCRTItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: string
      rr_item_id: string | null
      osriv_item_id: string | null
      seriv_item_id: string | null
      mrv_item_id: string | null
      mcrt_item_id: string | null
      type: number
      quantity: number
      price: number
      remarks: string | null
      is_initial: boolean
      created_at: Date
      created_by: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["itemTransaction"]>
    composites: {}
  }


  type ItemTransactionGetPayload<S extends boolean | null | undefined | ItemTransactionDefaultArgs> = $Result.GetResult<Prisma.$ItemTransactionPayload, S>

  type ItemTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTransactionCountAggregateInputType | true
    }

  export interface ItemTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemTransaction'], meta: { name: 'ItemTransaction' } }
    /**
     * Find zero or one ItemTransaction that matches the filter.
     * @param {ItemTransactionFindUniqueArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemTransaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemTransactionFindUniqueOrThrowArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindFirstArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindFirstArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindFirstOrThrowArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTransactions
     * const itemTransactions = await prisma.itemTransaction.findMany()
     * 
     * // Get first 10 ItemTransactions
     * const itemTransactions = await prisma.itemTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTransactionWithIdOnly = await prisma.itemTransaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemTransaction.
     * @param {ItemTransactionCreateArgs} args - Arguments to create a ItemTransaction.
     * @example
     * // Create one ItemTransaction
     * const ItemTransaction = await prisma.itemTransaction.create({
     *   data: {
     *     // ... data to create a ItemTransaction
     *   }
     * })
     * 
    **/
    create<T extends ItemTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionCreateArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemTransactions.
     *     @param {ItemTransactionCreateManyArgs} args - Arguments to create many ItemTransactions.
     *     @example
     *     // Create many ItemTransactions
     *     const itemTransaction = await prisma.itemTransaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemTransaction.
     * @param {ItemTransactionDeleteArgs} args - Arguments to delete one ItemTransaction.
     * @example
     * // Delete one ItemTransaction
     * const ItemTransaction = await prisma.itemTransaction.delete({
     *   where: {
     *     // ... filter to delete one ItemTransaction
     *   }
     * })
     * 
    **/
    delete<T extends ItemTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionDeleteArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemTransaction.
     * @param {ItemTransactionUpdateArgs} args - Arguments to update one ItemTransaction.
     * @example
     * // Update one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpdateArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemTransactions.
     * @param {ItemTransactionDeleteManyArgs} args - Arguments to filter ItemTransactions to delete.
     * @example
     * // Delete a few ItemTransactions
     * const { count } = await prisma.itemTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTransactions
     * const itemTransaction = await prisma.itemTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemTransaction.
     * @param {ItemTransactionUpsertArgs} args - Arguments to update or create a ItemTransaction.
     * @example
     * // Update or create a ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.upsert({
     *   create: {
     *     // ... data to create a ItemTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpsertArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionCountArgs} args - Arguments to filter ItemTransactions to count.
     * @example
     * // Count the number of ItemTransactions
     * const count = await prisma.itemTransaction.count({
     *   where: {
     *     // ... the filter for the ItemTransactions we want to count
     *   }
     * })
    **/
    count<T extends ItemTransactionCountArgs>(
      args?: Subset<T, ItemTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTransactionAggregateArgs>(args: Subset<T, ItemTransactionAggregateArgs>): Prisma.PrismaPromise<GetItemTransactionAggregateType<T>>

    /**
     * Group by ItemTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ItemTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemTransaction model
   */
  readonly fields: ItemTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rr_item<T extends ItemTransaction$rr_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$rr_itemArgs<ExtArgs>>): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    osriv_item<T extends ItemTransaction$osriv_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$osriv_itemArgs<ExtArgs>>): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    seriv_item<T extends ItemTransaction$seriv_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$seriv_itemArgs<ExtArgs>>): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mrv_item<T extends ItemTransaction$mrv_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$mrv_itemArgs<ExtArgs>>): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mcrt_item<T extends ItemTransaction$mcrt_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$mcrt_itemArgs<ExtArgs>>): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemTransaction model
   */ 
  interface ItemTransactionFieldRefs {
    readonly id: FieldRef<"ItemTransaction", 'Int'>
    readonly item_id: FieldRef<"ItemTransaction", 'String'>
    readonly rr_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly osriv_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly seriv_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly mrv_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly mcrt_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly type: FieldRef<"ItemTransaction", 'Int'>
    readonly quantity: FieldRef<"ItemTransaction", 'Int'>
    readonly price: FieldRef<"ItemTransaction", 'Float'>
    readonly remarks: FieldRef<"ItemTransaction", 'String'>
    readonly is_initial: FieldRef<"ItemTransaction", 'Boolean'>
    readonly created_at: FieldRef<"ItemTransaction", 'DateTime'>
    readonly created_by: FieldRef<"ItemTransaction", 'String'>
    readonly metadata: FieldRef<"ItemTransaction", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * ItemTransaction findUnique
   */
  export type ItemTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction findUniqueOrThrow
   */
  export type ItemTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction findFirst
   */
  export type ItemTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTransactions.
     */
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction findFirstOrThrow
   */
  export type ItemTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTransactions.
     */
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction findMany
   */
  export type ItemTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransactions to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction create
   */
  export type ItemTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemTransaction.
     */
    data: XOR<ItemTransactionCreateInput, ItemTransactionUncheckedCreateInput>
  }


  /**
   * ItemTransaction createMany
   */
  export type ItemTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTransactions.
     */
    data: ItemTransactionCreateManyInput | ItemTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemTransaction update
   */
  export type ItemTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemTransaction.
     */
    data: XOR<ItemTransactionUpdateInput, ItemTransactionUncheckedUpdateInput>
    /**
     * Choose, which ItemTransaction to update.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction updateMany
   */
  export type ItemTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTransactions.
     */
    data: XOR<ItemTransactionUpdateManyMutationInput, ItemTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ItemTransactions to update
     */
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemTransaction upsert
   */
  export type ItemTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemTransaction to update in case it exists.
     */
    where: ItemTransactionWhereUniqueInput
    /**
     * In case the ItemTransaction found by the `where` argument doesn't exist, create a new ItemTransaction with this data.
     */
    create: XOR<ItemTransactionCreateInput, ItemTransactionUncheckedCreateInput>
    /**
     * In case the ItemTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTransactionUpdateInput, ItemTransactionUncheckedUpdateInput>
  }


  /**
   * ItemTransaction delete
   */
  export type ItemTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter which ItemTransaction to delete.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction deleteMany
   */
  export type ItemTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTransactions to delete
     */
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemTransaction.rr_item
   */
  export type ItemTransaction$rr_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
  }


  /**
   * ItemTransaction.osriv_item
   */
  export type ItemTransaction$osriv_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    where?: OSRIVItemWhereInput
  }


  /**
   * ItemTransaction.seriv_item
   */
  export type ItemTransaction$seriv_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    where?: SERIVItemWhereInput
  }


  /**
   * ItemTransaction.mrv_item
   */
  export type ItemTransaction$mrv_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    where?: MRVItemWhereInput
  }


  /**
   * ItemTransaction.mcrt_item
   */
  export type ItemTransaction$mcrt_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    where?: MCRTItemWhereInput
  }


  /**
   * ItemTransaction without action
   */
  export type ItemTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
  }



  /**
   * Model ItemCodeTracker
   */

  export type AggregateItemCodeTracker = {
    _count: ItemCodeTrackerCountAggregateOutputType | null
    _avg: ItemCodeTrackerAvgAggregateOutputType | null
    _sum: ItemCodeTrackerSumAggregateOutputType | null
    _min: ItemCodeTrackerMinAggregateOutputType | null
    _max: ItemCodeTrackerMaxAggregateOutputType | null
  }

  export type ItemCodeTrackerAvgAggregateOutputType = {
    id: number | null
    year: number | null
    last_incremental: number | null
  }

  export type ItemCodeTrackerSumAggregateOutputType = {
    id: number | null
    year: number | null
    last_incremental: number | null
  }

  export type ItemCodeTrackerMinAggregateOutputType = {
    id: number | null
    item_code: string | null
    year: number | null
    last_incremental: number | null
  }

  export type ItemCodeTrackerMaxAggregateOutputType = {
    id: number | null
    item_code: string | null
    year: number | null
    last_incremental: number | null
  }

  export type ItemCodeTrackerCountAggregateOutputType = {
    id: number
    item_code: number
    year: number
    last_incremental: number
    _all: number
  }


  export type ItemCodeTrackerAvgAggregateInputType = {
    id?: true
    year?: true
    last_incremental?: true
  }

  export type ItemCodeTrackerSumAggregateInputType = {
    id?: true
    year?: true
    last_incremental?: true
  }

  export type ItemCodeTrackerMinAggregateInputType = {
    id?: true
    item_code?: true
    year?: true
    last_incremental?: true
  }

  export type ItemCodeTrackerMaxAggregateInputType = {
    id?: true
    item_code?: true
    year?: true
    last_incremental?: true
  }

  export type ItemCodeTrackerCountAggregateInputType = {
    id?: true
    item_code?: true
    year?: true
    last_incremental?: true
    _all?: true
  }

  export type ItemCodeTrackerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCodeTracker to aggregate.
     */
    where?: ItemCodeTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCodeTrackers to fetch.
     */
    orderBy?: ItemCodeTrackerOrderByWithRelationInput | ItemCodeTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCodeTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCodeTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCodeTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCodeTrackers
    **/
    _count?: true | ItemCodeTrackerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCodeTrackerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCodeTrackerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCodeTrackerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCodeTrackerMaxAggregateInputType
  }

  export type GetItemCodeTrackerAggregateType<T extends ItemCodeTrackerAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCodeTracker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCodeTracker[P]>
      : GetScalarType<T[P], AggregateItemCodeTracker[P]>
  }




  export type ItemCodeTrackerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCodeTrackerWhereInput
    orderBy?: ItemCodeTrackerOrderByWithAggregationInput | ItemCodeTrackerOrderByWithAggregationInput[]
    by: ItemCodeTrackerScalarFieldEnum[] | ItemCodeTrackerScalarFieldEnum
    having?: ItemCodeTrackerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCodeTrackerCountAggregateInputType | true
    _avg?: ItemCodeTrackerAvgAggregateInputType
    _sum?: ItemCodeTrackerSumAggregateInputType
    _min?: ItemCodeTrackerMinAggregateInputType
    _max?: ItemCodeTrackerMaxAggregateInputType
  }

  export type ItemCodeTrackerGroupByOutputType = {
    id: number
    item_code: string
    year: number
    last_incremental: number
    _count: ItemCodeTrackerCountAggregateOutputType | null
    _avg: ItemCodeTrackerAvgAggregateOutputType | null
    _sum: ItemCodeTrackerSumAggregateOutputType | null
    _min: ItemCodeTrackerMinAggregateOutputType | null
    _max: ItemCodeTrackerMaxAggregateOutputType | null
  }

  type GetItemCodeTrackerGroupByPayload<T extends ItemCodeTrackerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCodeTrackerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCodeTrackerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCodeTrackerGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCodeTrackerGroupByOutputType[P]>
        }
      >
    >


  export type ItemCodeTrackerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_code?: boolean
    year?: boolean
    last_incremental?: boolean
  }, ExtArgs["result"]["itemCodeTracker"]>

  export type ItemCodeTrackerSelectScalar = {
    id?: boolean
    item_code?: boolean
    year?: boolean
    last_incremental?: boolean
  }


  export type $ItemCodeTrackerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCodeTracker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_code: string
      year: number
      last_incremental: number
    }, ExtArgs["result"]["itemCodeTracker"]>
    composites: {}
  }


  type ItemCodeTrackerGetPayload<S extends boolean | null | undefined | ItemCodeTrackerDefaultArgs> = $Result.GetResult<Prisma.$ItemCodeTrackerPayload, S>

  type ItemCodeTrackerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemCodeTrackerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCodeTrackerCountAggregateInputType | true
    }

  export interface ItemCodeTrackerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCodeTracker'], meta: { name: 'ItemCodeTracker' } }
    /**
     * Find zero or one ItemCodeTracker that matches the filter.
     * @param {ItemCodeTrackerFindUniqueArgs} args - Arguments to find a ItemCodeTracker
     * @example
     * // Get one ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemCodeTrackerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemCodeTracker that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemCodeTrackerFindUniqueOrThrowArgs} args - Arguments to find a ItemCodeTracker
     * @example
     * // Get one ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemCodeTrackerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemCodeTracker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerFindFirstArgs} args - Arguments to find a ItemCodeTracker
     * @example
     * // Get one ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemCodeTrackerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerFindFirstArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemCodeTracker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerFindFirstOrThrowArgs} args - Arguments to find a ItemCodeTracker
     * @example
     * // Get one ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemCodeTrackerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemCodeTrackers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCodeTrackers
     * const itemCodeTrackers = await prisma.itemCodeTracker.findMany()
     * 
     * // Get first 10 ItemCodeTrackers
     * const itemCodeTrackers = await prisma.itemCodeTracker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCodeTrackerWithIdOnly = await prisma.itemCodeTracker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemCodeTrackerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemCodeTracker.
     * @param {ItemCodeTrackerCreateArgs} args - Arguments to create a ItemCodeTracker.
     * @example
     * // Create one ItemCodeTracker
     * const ItemCodeTracker = await prisma.itemCodeTracker.create({
     *   data: {
     *     // ... data to create a ItemCodeTracker
     *   }
     * })
     * 
    **/
    create<T extends ItemCodeTrackerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerCreateArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemCodeTrackers.
     *     @param {ItemCodeTrackerCreateManyArgs} args - Arguments to create many ItemCodeTrackers.
     *     @example
     *     // Create many ItemCodeTrackers
     *     const itemCodeTracker = await prisma.itemCodeTracker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCodeTrackerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemCodeTracker.
     * @param {ItemCodeTrackerDeleteArgs} args - Arguments to delete one ItemCodeTracker.
     * @example
     * // Delete one ItemCodeTracker
     * const ItemCodeTracker = await prisma.itemCodeTracker.delete({
     *   where: {
     *     // ... filter to delete one ItemCodeTracker
     *   }
     * })
     * 
    **/
    delete<T extends ItemCodeTrackerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerDeleteArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemCodeTracker.
     * @param {ItemCodeTrackerUpdateArgs} args - Arguments to update one ItemCodeTracker.
     * @example
     * // Update one ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemCodeTrackerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerUpdateArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemCodeTrackers.
     * @param {ItemCodeTrackerDeleteManyArgs} args - Arguments to filter ItemCodeTrackers to delete.
     * @example
     * // Delete a few ItemCodeTrackers
     * const { count } = await prisma.itemCodeTracker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemCodeTrackerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCodeTrackerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCodeTrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCodeTrackers
     * const itemCodeTracker = await prisma.itemCodeTracker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemCodeTrackerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemCodeTracker.
     * @param {ItemCodeTrackerUpsertArgs} args - Arguments to update or create a ItemCodeTracker.
     * @example
     * // Update or create a ItemCodeTracker
     * const itemCodeTracker = await prisma.itemCodeTracker.upsert({
     *   create: {
     *     // ... data to create a ItemCodeTracker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCodeTracker we want to update
     *   }
     * })
    **/
    upsert<T extends ItemCodeTrackerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCodeTrackerUpsertArgs<ExtArgs>>
    ): Prisma__ItemCodeTrackerClient<$Result.GetResult<Prisma.$ItemCodeTrackerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemCodeTrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerCountArgs} args - Arguments to filter ItemCodeTrackers to count.
     * @example
     * // Count the number of ItemCodeTrackers
     * const count = await prisma.itemCodeTracker.count({
     *   where: {
     *     // ... the filter for the ItemCodeTrackers we want to count
     *   }
     * })
    **/
    count<T extends ItemCodeTrackerCountArgs>(
      args?: Subset<T, ItemCodeTrackerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCodeTrackerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCodeTracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCodeTrackerAggregateArgs>(args: Subset<T, ItemCodeTrackerAggregateArgs>): Prisma.PrismaPromise<GetItemCodeTrackerAggregateType<T>>

    /**
     * Group by ItemCodeTracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCodeTrackerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCodeTrackerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCodeTrackerGroupByArgs['orderBy'] }
        : { orderBy?: ItemCodeTrackerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCodeTrackerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCodeTrackerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCodeTracker model
   */
  readonly fields: ItemCodeTrackerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCodeTracker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCodeTrackerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemCodeTracker model
   */ 
  interface ItemCodeTrackerFieldRefs {
    readonly id: FieldRef<"ItemCodeTracker", 'Int'>
    readonly item_code: FieldRef<"ItemCodeTracker", 'String'>
    readonly year: FieldRef<"ItemCodeTracker", 'Int'>
    readonly last_incremental: FieldRef<"ItemCodeTracker", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemCodeTracker findUnique
   */
  export type ItemCodeTrackerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter, which ItemCodeTracker to fetch.
     */
    where: ItemCodeTrackerWhereUniqueInput
  }


  /**
   * ItemCodeTracker findUniqueOrThrow
   */
  export type ItemCodeTrackerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter, which ItemCodeTracker to fetch.
     */
    where: ItemCodeTrackerWhereUniqueInput
  }


  /**
   * ItemCodeTracker findFirst
   */
  export type ItemCodeTrackerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter, which ItemCodeTracker to fetch.
     */
    where?: ItemCodeTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCodeTrackers to fetch.
     */
    orderBy?: ItemCodeTrackerOrderByWithRelationInput | ItemCodeTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCodeTrackers.
     */
    cursor?: ItemCodeTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCodeTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCodeTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCodeTrackers.
     */
    distinct?: ItemCodeTrackerScalarFieldEnum | ItemCodeTrackerScalarFieldEnum[]
  }


  /**
   * ItemCodeTracker findFirstOrThrow
   */
  export type ItemCodeTrackerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter, which ItemCodeTracker to fetch.
     */
    where?: ItemCodeTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCodeTrackers to fetch.
     */
    orderBy?: ItemCodeTrackerOrderByWithRelationInput | ItemCodeTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCodeTrackers.
     */
    cursor?: ItemCodeTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCodeTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCodeTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCodeTrackers.
     */
    distinct?: ItemCodeTrackerScalarFieldEnum | ItemCodeTrackerScalarFieldEnum[]
  }


  /**
   * ItemCodeTracker findMany
   */
  export type ItemCodeTrackerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter, which ItemCodeTrackers to fetch.
     */
    where?: ItemCodeTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCodeTrackers to fetch.
     */
    orderBy?: ItemCodeTrackerOrderByWithRelationInput | ItemCodeTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCodeTrackers.
     */
    cursor?: ItemCodeTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCodeTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCodeTrackers.
     */
    skip?: number
    distinct?: ItemCodeTrackerScalarFieldEnum | ItemCodeTrackerScalarFieldEnum[]
  }


  /**
   * ItemCodeTracker create
   */
  export type ItemCodeTrackerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemCodeTracker.
     */
    data: XOR<ItemCodeTrackerCreateInput, ItemCodeTrackerUncheckedCreateInput>
  }


  /**
   * ItemCodeTracker createMany
   */
  export type ItemCodeTrackerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCodeTrackers.
     */
    data: ItemCodeTrackerCreateManyInput | ItemCodeTrackerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemCodeTracker update
   */
  export type ItemCodeTrackerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemCodeTracker.
     */
    data: XOR<ItemCodeTrackerUpdateInput, ItemCodeTrackerUncheckedUpdateInput>
    /**
     * Choose, which ItemCodeTracker to update.
     */
    where: ItemCodeTrackerWhereUniqueInput
  }


  /**
   * ItemCodeTracker updateMany
   */
  export type ItemCodeTrackerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCodeTrackers.
     */
    data: XOR<ItemCodeTrackerUpdateManyMutationInput, ItemCodeTrackerUncheckedUpdateManyInput>
    /**
     * Filter which ItemCodeTrackers to update
     */
    where?: ItemCodeTrackerWhereInput
  }


  /**
   * ItemCodeTracker upsert
   */
  export type ItemCodeTrackerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemCodeTracker to update in case it exists.
     */
    where: ItemCodeTrackerWhereUniqueInput
    /**
     * In case the ItemCodeTracker found by the `where` argument doesn't exist, create a new ItemCodeTracker with this data.
     */
    create: XOR<ItemCodeTrackerCreateInput, ItemCodeTrackerUncheckedCreateInput>
    /**
     * In case the ItemCodeTracker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCodeTrackerUpdateInput, ItemCodeTrackerUncheckedUpdateInput>
  }


  /**
   * ItemCodeTracker delete
   */
  export type ItemCodeTrackerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
    /**
     * Filter which ItemCodeTracker to delete.
     */
    where: ItemCodeTrackerWhereUniqueInput
  }


  /**
   * ItemCodeTracker deleteMany
   */
  export type ItemCodeTrackerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCodeTrackers to delete
     */
    where?: ItemCodeTrackerWhereInput
  }


  /**
   * ItemCodeTracker without action
   */
  export type ItemCodeTrackerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCodeTracker
     */
    select?: ItemCodeTrackerSelect<ExtArgs> | null
  }



  /**
   * Model Canvass
   */

  export type AggregateCanvass = {
    _count: CanvassCountAggregateOutputType | null
    _min: CanvassMinAggregateOutputType | null
    _max: CanvassMaxAggregateOutputType | null
  }

  export type CanvassMinAggregateOutputType = {
    id: string | null
    rc_number: string | null
    date_requested: Date | null
    purpose: string | null
    notes: string | null
    requested_by_id: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CanvassMaxAggregateOutputType = {
    id: string | null
    rc_number: string | null
    date_requested: Date | null
    purpose: string | null
    notes: string | null
    requested_by_id: string | null
    created_by: string | null
    updated_by: string | null
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CanvassCountAggregateOutputType = {
    id: number
    rc_number: number
    date_requested: number
    purpose: number
    notes: number
    requested_by_id: number
    created_by: number
    updated_by: number
    deleted_by: number
    created_at: number
    updated_at: number
    deleted_at: number
    metadata: number
    _all: number
  }


  export type CanvassMinAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CanvassMaxAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CanvassCountAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    created_by?: true
    updated_by?: true
    deleted_by?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    metadata?: true
    _all?: true
  }

  export type CanvassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvass to aggregate.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Canvasses
    **/
    _count?: true | CanvassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvassMaxAggregateInputType
  }

  export type GetCanvassAggregateType<T extends CanvassAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvass[P]>
      : GetScalarType<T[P], AggregateCanvass[P]>
  }




  export type CanvassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassWhereInput
    orderBy?: CanvassOrderByWithAggregationInput | CanvassOrderByWithAggregationInput[]
    by: CanvassScalarFieldEnum[] | CanvassScalarFieldEnum
    having?: CanvassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvassCountAggregateInputType | true
    _min?: CanvassMinAggregateInputType
    _max?: CanvassMaxAggregateInputType
  }

  export type CanvassGroupByOutputType = {
    id: string
    rc_number: string
    date_requested: Date
    purpose: string
    notes: string | null
    requested_by_id: string
    created_by: string
    updated_by: string | null
    deleted_by: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    metadata: JsonValue | null
    _count: CanvassCountAggregateOutputType | null
    _min: CanvassMinAggregateOutputType | null
    _max: CanvassMaxAggregateOutputType | null
  }

  type GetCanvassGroupByPayload<T extends CanvassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvassGroupByOutputType[P]>
            : GetScalarType<T[P], CanvassGroupByOutputType[P]>
        }
      >
    >


  export type CanvassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rc_number?: boolean
    date_requested?: boolean
    purpose?: boolean
    notes?: boolean
    requested_by_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
    canvass_items?: boolean | Canvass$canvass_itemsArgs<ExtArgs>
    jo?: boolean | Canvass$joArgs<ExtArgs>
    rv?: boolean | Canvass$rvArgs<ExtArgs>
    spr?: boolean | Canvass$sprArgs<ExtArgs>
    _count?: boolean | CanvassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvass"]>

  export type CanvassSelectScalar = {
    id?: boolean
    rc_number?: boolean
    date_requested?: boolean
    purpose?: boolean
    notes?: boolean
    requested_by_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    deleted_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    metadata?: boolean
  }

  export type CanvassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | Canvass$canvass_itemsArgs<ExtArgs>
    jo?: boolean | Canvass$joArgs<ExtArgs>
    rv?: boolean | Canvass$rvArgs<ExtArgs>
    spr?: boolean | Canvass$sprArgs<ExtArgs>
    _count?: boolean | CanvassCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CanvassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canvass"
    objects: {
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      jo: Prisma.$JOPayload<ExtArgs> | null
      rv: Prisma.$RVPayload<ExtArgs> | null
      spr: Prisma.$SPRPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rc_number: string
      date_requested: Date
      purpose: string
      notes: string | null
      requested_by_id: string
      created_by: string
      updated_by: string | null
      deleted_by: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["canvass"]>
    composites: {}
  }


  type CanvassGetPayload<S extends boolean | null | undefined | CanvassDefaultArgs> = $Result.GetResult<Prisma.$CanvassPayload, S>

  type CanvassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CanvassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CanvassCountAggregateInputType | true
    }

  export interface CanvassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canvass'], meta: { name: 'Canvass' } }
    /**
     * Find zero or one Canvass that matches the filter.
     * @param {CanvassFindUniqueArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CanvassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassFindUniqueArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Canvass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CanvassFindUniqueOrThrowArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CanvassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Canvass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindFirstArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CanvassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindFirstArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Canvass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindFirstOrThrowArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CanvassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Canvasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Canvasses
     * const canvasses = await prisma.canvass.findMany()
     * 
     * // Get first 10 Canvasses
     * const canvasses = await prisma.canvass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvassWithIdOnly = await prisma.canvass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CanvassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Canvass.
     * @param {CanvassCreateArgs} args - Arguments to create a Canvass.
     * @example
     * // Create one Canvass
     * const Canvass = await prisma.canvass.create({
     *   data: {
     *     // ... data to create a Canvass
     *   }
     * })
     * 
    **/
    create<T extends CanvassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassCreateArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Canvasses.
     *     @param {CanvassCreateManyArgs} args - Arguments to create many Canvasses.
     *     @example
     *     // Create many Canvasses
     *     const canvass = await prisma.canvass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CanvassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Canvass.
     * @param {CanvassDeleteArgs} args - Arguments to delete one Canvass.
     * @example
     * // Delete one Canvass
     * const Canvass = await prisma.canvass.delete({
     *   where: {
     *     // ... filter to delete one Canvass
     *   }
     * })
     * 
    **/
    delete<T extends CanvassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassDeleteArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Canvass.
     * @param {CanvassUpdateArgs} args - Arguments to update one Canvass.
     * @example
     * // Update one Canvass
     * const canvass = await prisma.canvass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CanvassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpdateArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Canvasses.
     * @param {CanvassDeleteManyArgs} args - Arguments to filter Canvasses to delete.
     * @example
     * // Delete a few Canvasses
     * const { count } = await prisma.canvass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CanvassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Canvasses
     * const canvass = await prisma.canvass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CanvassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Canvass.
     * @param {CanvassUpsertArgs} args - Arguments to update or create a Canvass.
     * @example
     * // Update or create a Canvass
     * const canvass = await prisma.canvass.upsert({
     *   create: {
     *     // ... data to create a Canvass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canvass we want to update
     *   }
     * })
    **/
    upsert<T extends CanvassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpsertArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Canvasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassCountArgs} args - Arguments to filter Canvasses to count.
     * @example
     * // Count the number of Canvasses
     * const count = await prisma.canvass.count({
     *   where: {
     *     // ... the filter for the Canvasses we want to count
     *   }
     * })
    **/
    count<T extends CanvassCountArgs>(
      args?: Subset<T, CanvassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canvass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvassAggregateArgs>(args: Subset<T, CanvassAggregateArgs>): Prisma.PrismaPromise<GetCanvassAggregateType<T>>

    /**
     * Group by Canvass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvassGroupByArgs['orderBy'] }
        : { orderBy?: CanvassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canvass model
   */
  readonly fields: CanvassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canvass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_items<T extends Canvass$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    jo<T extends Canvass$joArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$joArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv<T extends Canvass$rvArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$rvArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    spr<T extends Canvass$sprArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$sprArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Canvass model
   */ 
  interface CanvassFieldRefs {
    readonly id: FieldRef<"Canvass", 'String'>
    readonly rc_number: FieldRef<"Canvass", 'String'>
    readonly date_requested: FieldRef<"Canvass", 'DateTime'>
    readonly purpose: FieldRef<"Canvass", 'String'>
    readonly notes: FieldRef<"Canvass", 'String'>
    readonly requested_by_id: FieldRef<"Canvass", 'String'>
    readonly created_by: FieldRef<"Canvass", 'String'>
    readonly updated_by: FieldRef<"Canvass", 'String'>
    readonly deleted_by: FieldRef<"Canvass", 'String'>
    readonly created_at: FieldRef<"Canvass", 'DateTime'>
    readonly updated_at: FieldRef<"Canvass", 'DateTime'>
    readonly deleted_at: FieldRef<"Canvass", 'DateTime'>
    readonly metadata: FieldRef<"Canvass", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Canvass findUnique
   */
  export type CanvassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass findUniqueOrThrow
   */
  export type CanvassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass findFirst
   */
  export type CanvassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvasses.
     */
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass findFirstOrThrow
   */
  export type CanvassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvasses.
     */
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass findMany
   */
  export type CanvassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvasses to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass create
   */
  export type CanvassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The data needed to create a Canvass.
     */
    data: XOR<CanvassCreateInput, CanvassUncheckedCreateInput>
  }


  /**
   * Canvass createMany
   */
  export type CanvassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Canvasses.
     */
    data: CanvassCreateManyInput | CanvassCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Canvass update
   */
  export type CanvassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The data needed to update a Canvass.
     */
    data: XOR<CanvassUpdateInput, CanvassUncheckedUpdateInput>
    /**
     * Choose, which Canvass to update.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass updateMany
   */
  export type CanvassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Canvasses.
     */
    data: XOR<CanvassUpdateManyMutationInput, CanvassUncheckedUpdateManyInput>
    /**
     * Filter which Canvasses to update
     */
    where?: CanvassWhereInput
  }


  /**
   * Canvass upsert
   */
  export type CanvassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The filter to search for the Canvass to update in case it exists.
     */
    where: CanvassWhereUniqueInput
    /**
     * In case the Canvass found by the `where` argument doesn't exist, create a new Canvass with this data.
     */
    create: XOR<CanvassCreateInput, CanvassUncheckedCreateInput>
    /**
     * In case the Canvass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvassUpdateInput, CanvassUncheckedUpdateInput>
  }


  /**
   * Canvass delete
   */
  export type CanvassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter which Canvass to delete.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass deleteMany
   */
  export type CanvassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvasses to delete
     */
    where?: CanvassWhereInput
  }


  /**
   * Canvass.canvass_items
   */
  export type Canvass$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Canvass.jo
   */
  export type Canvass$joArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    where?: JOWhereInput
  }


  /**
   * Canvass.rv
   */
  export type Canvass$rvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    where?: RVWhereInput
  }


  /**
   * Canvass.spr
   */
  export type Canvass$sprArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
  }


  /**
   * Canvass without action
   */
  export type CanvassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
  }



  /**
   * Model CanvassItem
   */

  export type AggregateCanvassItem = {
    _count: CanvassItemCountAggregateOutputType | null
    _avg: CanvassItemAvgAggregateOutputType | null
    _sum: CanvassItemSumAggregateOutputType | null
    _min: CanvassItemMinAggregateOutputType | null
    _max: CanvassItemMaxAggregateOutputType | null
  }

  export type CanvassItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CanvassItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CanvassItemMinAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    unit_id: string | null
    item_id: string | null
    description: string | null
    quantity: number | null
  }

  export type CanvassItemMaxAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    unit_id: string | null
    item_id: string | null
    description: string | null
    quantity: number | null
  }

  export type CanvassItemCountAggregateOutputType = {
    id: number
    canvass_id: number
    unit_id: number
    item_id: number
    description: number
    quantity: number
    metadata: number
    _all: number
  }


  export type CanvassItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CanvassItemSumAggregateInputType = {
    quantity?: true
  }

  export type CanvassItemMinAggregateInputType = {
    id?: true
    canvass_id?: true
    unit_id?: true
    item_id?: true
    description?: true
    quantity?: true
  }

  export type CanvassItemMaxAggregateInputType = {
    id?: true
    canvass_id?: true
    unit_id?: true
    item_id?: true
    description?: true
    quantity?: true
  }

  export type CanvassItemCountAggregateInputType = {
    id?: true
    canvass_id?: true
    unit_id?: true
    item_id?: true
    description?: true
    quantity?: true
    metadata?: true
    _all?: true
  }

  export type CanvassItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvassItem to aggregate.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvassItems
    **/
    _count?: true | CanvassItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvassItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvassItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvassItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvassItemMaxAggregateInputType
  }

  export type GetCanvassItemAggregateType<T extends CanvassItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvassItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvassItem[P]>
      : GetScalarType<T[P], AggregateCanvassItem[P]>
  }




  export type CanvassItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithAggregationInput | CanvassItemOrderByWithAggregationInput[]
    by: CanvassItemScalarFieldEnum[] | CanvassItemScalarFieldEnum
    having?: CanvassItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvassItemCountAggregateInputType | true
    _avg?: CanvassItemAvgAggregateInputType
    _sum?: CanvassItemSumAggregateInputType
    _min?: CanvassItemMinAggregateInputType
    _max?: CanvassItemMaxAggregateInputType
  }

  export type CanvassItemGroupByOutputType = {
    id: string
    canvass_id: string
    unit_id: string | null
    item_id: string | null
    description: string
    quantity: number
    metadata: JsonValue | null
    _count: CanvassItemCountAggregateOutputType | null
    _avg: CanvassItemAvgAggregateOutputType | null
    _sum: CanvassItemSumAggregateOutputType | null
    _min: CanvassItemMinAggregateOutputType | null
    _max: CanvassItemMaxAggregateOutputType | null
  }

  type GetCanvassItemGroupByPayload<T extends CanvassItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvassItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvassItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvassItemGroupByOutputType[P]>
            : GetScalarType<T[P], CanvassItemGroupByOutputType[P]>
        }
      >
    >


  export type CanvassItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvass_id?: boolean
    unit_id?: boolean
    item_id?: boolean
    description?: boolean
    quantity?: boolean
    metadata?: boolean
    meqs_supplier_items?: boolean | CanvassItem$meqs_supplier_itemsArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    unit?: boolean | CanvassItem$unitArgs<ExtArgs>
    item?: boolean | CanvassItem$itemArgs<ExtArgs>
    _count?: boolean | CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvassItem"]>

  export type CanvassItemSelectScalar = {
    id?: boolean
    canvass_id?: boolean
    unit_id?: boolean
    item_id?: boolean
    description?: boolean
    quantity?: boolean
    metadata?: boolean
  }

  export type CanvassItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier_items?: boolean | CanvassItem$meqs_supplier_itemsArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    unit?: boolean | CanvassItem$unitArgs<ExtArgs>
    item?: boolean | CanvassItem$itemArgs<ExtArgs>
    _count?: boolean | CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CanvassItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvassItem"
    objects: {
      meqs_supplier_items: Prisma.$MEQSSupplierItemPayload<ExtArgs>[]
      canvass: Prisma.$CanvassPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs> | null
      item: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvass_id: string
      unit_id: string | null
      item_id: string | null
      description: string
      quantity: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["canvassItem"]>
    composites: {}
  }


  type CanvassItemGetPayload<S extends boolean | null | undefined | CanvassItemDefaultArgs> = $Result.GetResult<Prisma.$CanvassItemPayload, S>

  type CanvassItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CanvassItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CanvassItemCountAggregateInputType | true
    }

  export interface CanvassItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvassItem'], meta: { name: 'CanvassItem' } }
    /**
     * Find zero or one CanvassItem that matches the filter.
     * @param {CanvassItemFindUniqueArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CanvassItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CanvassItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CanvassItemFindUniqueOrThrowArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CanvassItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CanvassItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindFirstArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CanvassItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindFirstArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CanvassItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindFirstOrThrowArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CanvassItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CanvassItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvassItems
     * const canvassItems = await prisma.canvassItem.findMany()
     * 
     * // Get first 10 CanvassItems
     * const canvassItems = await prisma.canvassItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvassItemWithIdOnly = await prisma.canvassItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CanvassItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CanvassItem.
     * @param {CanvassItemCreateArgs} args - Arguments to create a CanvassItem.
     * @example
     * // Create one CanvassItem
     * const CanvassItem = await prisma.canvassItem.create({
     *   data: {
     *     // ... data to create a CanvassItem
     *   }
     * })
     * 
    **/
    create<T extends CanvassItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemCreateArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CanvassItems.
     *     @param {CanvassItemCreateManyArgs} args - Arguments to create many CanvassItems.
     *     @example
     *     // Create many CanvassItems
     *     const canvassItem = await prisma.canvassItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CanvassItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CanvassItem.
     * @param {CanvassItemDeleteArgs} args - Arguments to delete one CanvassItem.
     * @example
     * // Delete one CanvassItem
     * const CanvassItem = await prisma.canvassItem.delete({
     *   where: {
     *     // ... filter to delete one CanvassItem
     *   }
     * })
     * 
    **/
    delete<T extends CanvassItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemDeleteArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CanvassItem.
     * @param {CanvassItemUpdateArgs} args - Arguments to update one CanvassItem.
     * @example
     * // Update one CanvassItem
     * const canvassItem = await prisma.canvassItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CanvassItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpdateArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CanvassItems.
     * @param {CanvassItemDeleteManyArgs} args - Arguments to filter CanvassItems to delete.
     * @example
     * // Delete a few CanvassItems
     * const { count } = await prisma.canvassItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CanvassItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvassItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvassItems
     * const canvassItem = await prisma.canvassItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CanvassItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CanvassItem.
     * @param {CanvassItemUpsertArgs} args - Arguments to update or create a CanvassItem.
     * @example
     * // Update or create a CanvassItem
     * const canvassItem = await prisma.canvassItem.upsert({
     *   create: {
     *     // ... data to create a CanvassItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvassItem we want to update
     *   }
     * })
    **/
    upsert<T extends CanvassItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpsertArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CanvassItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemCountArgs} args - Arguments to filter CanvassItems to count.
     * @example
     * // Count the number of CanvassItems
     * const count = await prisma.canvassItem.count({
     *   where: {
     *     // ... the filter for the CanvassItems we want to count
     *   }
     * })
    **/
    count<T extends CanvassItemCountArgs>(
      args?: Subset<T, CanvassItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvassItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvassItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvassItemAggregateArgs>(args: Subset<T, CanvassItemAggregateArgs>): Prisma.PrismaPromise<GetCanvassItemAggregateType<T>>

    /**
     * Group by CanvassItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvassItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvassItemGroupByArgs['orderBy'] }
        : { orderBy?: CanvassItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvassItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvassItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvassItem model
   */
  readonly fields: CanvassItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvassItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvassItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs_supplier_items<T extends CanvassItem$meqs_supplier_itemsArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItem$meqs_supplier_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    canvass<T extends CanvassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassDefaultArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    unit<T extends CanvassItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    item<T extends CanvassItem$itemArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItem$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CanvassItem model
   */ 
  interface CanvassItemFieldRefs {
    readonly id: FieldRef<"CanvassItem", 'String'>
    readonly canvass_id: FieldRef<"CanvassItem", 'String'>
    readonly unit_id: FieldRef<"CanvassItem", 'String'>
    readonly item_id: FieldRef<"CanvassItem", 'String'>
    readonly description: FieldRef<"CanvassItem", 'String'>
    readonly quantity: FieldRef<"CanvassItem", 'Int'>
    readonly metadata: FieldRef<"CanvassItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * CanvassItem findUnique
   */
  export type CanvassItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem findUniqueOrThrow
   */
  export type CanvassItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem findFirst
   */
  export type CanvassItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvassItems.
     */
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem findFirstOrThrow
   */
  export type CanvassItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvassItems.
     */
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem findMany
   */
  export type CanvassItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItems to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem create
   */
  export type CanvassItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvassItem.
     */
    data: XOR<CanvassItemCreateInput, CanvassItemUncheckedCreateInput>
  }


  /**
   * CanvassItem createMany
   */
  export type CanvassItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvassItems.
     */
    data: CanvassItemCreateManyInput | CanvassItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CanvassItem update
   */
  export type CanvassItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvassItem.
     */
    data: XOR<CanvassItemUpdateInput, CanvassItemUncheckedUpdateInput>
    /**
     * Choose, which CanvassItem to update.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem updateMany
   */
  export type CanvassItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvassItems.
     */
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyInput>
    /**
     * Filter which CanvassItems to update
     */
    where?: CanvassItemWhereInput
  }


  /**
   * CanvassItem upsert
   */
  export type CanvassItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvassItem to update in case it exists.
     */
    where: CanvassItemWhereUniqueInput
    /**
     * In case the CanvassItem found by the `where` argument doesn't exist, create a new CanvassItem with this data.
     */
    create: XOR<CanvassItemCreateInput, CanvassItemUncheckedCreateInput>
    /**
     * In case the CanvassItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvassItemUpdateInput, CanvassItemUncheckedUpdateInput>
  }


  /**
   * CanvassItem delete
   */
  export type CanvassItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter which CanvassItem to delete.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem deleteMany
   */
  export type CanvassItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvassItems to delete
     */
    where?: CanvassItemWhereInput
  }


  /**
   * CanvassItem.meqs_supplier_items
   */
  export type CanvassItem$meqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    cursor?: MEQSSupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * CanvassItem.unit
   */
  export type CanvassItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }


  /**
   * CanvassItem.item
   */
  export type CanvassItem$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }


  /**
   * CanvassItem without action
   */
  export type CanvassItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
  }



  /**
   * Model RV
   */

  export type AggregateRV = {
    _count: RVCountAggregateOutputType | null
    _min: RVMinAggregateOutputType | null
    _max: RVMaxAggregateOutputType | null
  }

  export type RVMinAggregateOutputType = {
    id: string | null
    rv_number: string | null
    canvass_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    date_requested: Date | null
    work_order_no: string | null
    work_order_date: Date | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RVMaxAggregateOutputType = {
    id: string | null
    rv_number: string | null
    canvass_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    date_requested: Date | null
    work_order_no: string | null
    work_order_date: Date | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RVCountAggregateOutputType = {
    id: number
    rv_number: number
    canvass_id: number
    classification_id: number
    supervisor_id: number
    date_requested: number
    work_order_no: number
    work_order_date: number
    notes: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type RVMinAggregateInputType = {
    id?: true
    rv_number?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RVMaxAggregateInputType = {
    id?: true
    rv_number?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RVCountAggregateInputType = {
    id?: true
    rv_number?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type RVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RV to aggregate.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RVS
    **/
    _count?: true | RVCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RVMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RVMaxAggregateInputType
  }

  export type GetRVAggregateType<T extends RVAggregateArgs> = {
        [P in keyof T & keyof AggregateRV]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRV[P]>
      : GetScalarType<T[P], AggregateRV[P]>
  }




  export type RVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVWhereInput
    orderBy?: RVOrderByWithAggregationInput | RVOrderByWithAggregationInput[]
    by: RVScalarFieldEnum[] | RVScalarFieldEnum
    having?: RVScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RVCountAggregateInputType | true
    _min?: RVMinAggregateInputType
    _max?: RVMaxAggregateInputType
  }

  export type RVGroupByOutputType = {
    id: string
    rv_number: string
    canvass_id: string | null
    classification_id: string | null
    supervisor_id: string
    date_requested: Date
    work_order_no: string | null
    work_order_date: Date | null
    notes: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: RVCountAggregateOutputType | null
    _min: RVMinAggregateOutputType | null
    _max: RVMaxAggregateOutputType | null
  }

  type GetRVGroupByPayload<T extends RVGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RVGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RVGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RVGroupByOutputType[P]>
            : GetScalarType<T[P], RVGroupByOutputType[P]>
        }
      >
    >


  export type RVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rv_number?: boolean
    canvass_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    date_requested?: boolean
    work_order_no?: boolean
    work_order_date?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    canvass?: boolean | RV$canvassArgs<ExtArgs>
    meqs?: boolean | RV$meqsArgs<ExtArgs>
    rv_approvers?: boolean | RV$rv_approversArgs<ExtArgs>
    _count?: boolean | RVCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rV"]>

  export type RVSelectScalar = {
    id?: boolean
    rv_number?: boolean
    canvass_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    date_requested?: boolean
    work_order_no?: boolean
    work_order_date?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type RVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass?: boolean | RV$canvassArgs<ExtArgs>
    meqs?: boolean | RV$meqsArgs<ExtArgs>
    rv_approvers?: boolean | RV$rv_approversArgs<ExtArgs>
    _count?: boolean | RVCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RV"
    objects: {
      canvass: Prisma.$CanvassPayload<ExtArgs> | null
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
      rv_approvers: Prisma.$RVApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rv_number: string
      canvass_id: string | null
      classification_id: string | null
      supervisor_id: string
      date_requested: Date
      work_order_no: string | null
      work_order_date: Date | null
      notes: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["rV"]>
    composites: {}
  }


  type RVGetPayload<S extends boolean | null | undefined | RVDefaultArgs> = $Result.GetResult<Prisma.$RVPayload, S>

  type RVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RVFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RVCountAggregateInputType | true
    }

  export interface RVDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RV'], meta: { name: 'RV' } }
    /**
     * Find zero or one RV that matches the filter.
     * @param {RVFindUniqueArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RVFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RVFindUniqueArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RV that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RVFindUniqueOrThrowArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RVFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RV that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindFirstArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RVFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindFirstArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RV that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindFirstOrThrowArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RVFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RVS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RVS
     * const rVS = await prisma.rV.findMany()
     * 
     * // Get first 10 RVS
     * const rVS = await prisma.rV.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rVWithIdOnly = await prisma.rV.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RVFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RV.
     * @param {RVCreateArgs} args - Arguments to create a RV.
     * @example
     * // Create one RV
     * const RV = await prisma.rV.create({
     *   data: {
     *     // ... data to create a RV
     *   }
     * })
     * 
    **/
    create<T extends RVCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RVCreateArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RVS.
     *     @param {RVCreateManyArgs} args - Arguments to create many RVS.
     *     @example
     *     // Create many RVS
     *     const rV = await prisma.rV.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RVCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RV.
     * @param {RVDeleteArgs} args - Arguments to delete one RV.
     * @example
     * // Delete one RV
     * const RV = await prisma.rV.delete({
     *   where: {
     *     // ... filter to delete one RV
     *   }
     * })
     * 
    **/
    delete<T extends RVDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RVDeleteArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RV.
     * @param {RVUpdateArgs} args - Arguments to update one RV.
     * @example
     * // Update one RV
     * const rV = await prisma.rV.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RVUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpdateArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RVS.
     * @param {RVDeleteManyArgs} args - Arguments to filter RVS to delete.
     * @example
     * // Delete a few RVS
     * const { count } = await prisma.rV.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RVDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RVS
     * const rV = await prisma.rV.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RVUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RV.
     * @param {RVUpsertArgs} args - Arguments to update or create a RV.
     * @example
     * // Update or create a RV
     * const rV = await prisma.rV.upsert({
     *   create: {
     *     // ... data to create a RV
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RV we want to update
     *   }
     * })
    **/
    upsert<T extends RVUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpsertArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVCountArgs} args - Arguments to filter RVS to count.
     * @example
     * // Count the number of RVS
     * const count = await prisma.rV.count({
     *   where: {
     *     // ... the filter for the RVS we want to count
     *   }
     * })
    **/
    count<T extends RVCountArgs>(
      args?: Subset<T, RVCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RVCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RVAggregateArgs>(args: Subset<T, RVAggregateArgs>): Prisma.PrismaPromise<GetRVAggregateType<T>>

    /**
     * Group by RV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RVGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RVGroupByArgs['orderBy'] }
        : { orderBy?: RVGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RVGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RV model
   */
  readonly fields: RVFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RV.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RVClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass<T extends RV$canvassArgs<ExtArgs> = {}>(args?: Subset<T, RV$canvassArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs<T extends RV$meqsArgs<ExtArgs> = {}>(args?: Subset<T, RV$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv_approvers<T extends RV$rv_approversArgs<ExtArgs> = {}>(args?: Subset<T, RV$rv_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RV model
   */ 
  interface RVFieldRefs {
    readonly id: FieldRef<"RV", 'String'>
    readonly rv_number: FieldRef<"RV", 'String'>
    readonly canvass_id: FieldRef<"RV", 'String'>
    readonly classification_id: FieldRef<"RV", 'String'>
    readonly supervisor_id: FieldRef<"RV", 'String'>
    readonly date_requested: FieldRef<"RV", 'DateTime'>
    readonly work_order_no: FieldRef<"RV", 'String'>
    readonly work_order_date: FieldRef<"RV", 'DateTime'>
    readonly notes: FieldRef<"RV", 'String'>
    readonly cancelled_by: FieldRef<"RV", 'String'>
    readonly created_by: FieldRef<"RV", 'String'>
    readonly updated_by: FieldRef<"RV", 'String'>
    readonly cancelled_at: FieldRef<"RV", 'DateTime'>
    readonly created_at: FieldRef<"RV", 'DateTime'>
    readonly updated_at: FieldRef<"RV", 'DateTime'>
    readonly metadata: FieldRef<"RV", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * RV findUnique
   */
  export type RVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV findUniqueOrThrow
   */
  export type RVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV findFirst
   */
  export type RVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVS.
     */
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV findFirstOrThrow
   */
  export type RVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVS.
     */
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV findMany
   */
  export type RVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RVS to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV create
   */
  export type RVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The data needed to create a RV.
     */
    data: XOR<RVCreateInput, RVUncheckedCreateInput>
  }


  /**
   * RV createMany
   */
  export type RVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RVS.
     */
    data: RVCreateManyInput | RVCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RV update
   */
  export type RVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The data needed to update a RV.
     */
    data: XOR<RVUpdateInput, RVUncheckedUpdateInput>
    /**
     * Choose, which RV to update.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV updateMany
   */
  export type RVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RVS.
     */
    data: XOR<RVUpdateManyMutationInput, RVUncheckedUpdateManyInput>
    /**
     * Filter which RVS to update
     */
    where?: RVWhereInput
  }


  /**
   * RV upsert
   */
  export type RVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The filter to search for the RV to update in case it exists.
     */
    where: RVWhereUniqueInput
    /**
     * In case the RV found by the `where` argument doesn't exist, create a new RV with this data.
     */
    create: XOR<RVCreateInput, RVUncheckedCreateInput>
    /**
     * In case the RV was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RVUpdateInput, RVUncheckedUpdateInput>
  }


  /**
   * RV delete
   */
  export type RVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter which RV to delete.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV deleteMany
   */
  export type RVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVS to delete
     */
    where?: RVWhereInput
  }


  /**
   * RV.canvass
   */
  export type RV$canvassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    where?: CanvassWhereInput
  }


  /**
   * RV.meqs
   */
  export type RV$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * RV.rv_approvers
   */
  export type RV$rv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    where?: RVApproverWhereInput
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    cursor?: RVApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RV without action
   */
  export type RVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
  }



  /**
   * Model RVApprover
   */

  export type AggregateRVApprover = {
    _count: RVApproverCountAggregateOutputType | null
    _avg: RVApproverAvgAggregateOutputType | null
    _sum: RVApproverSumAggregateOutputType | null
    _min: RVApproverMinAggregateOutputType | null
    _max: RVApproverMaxAggregateOutputType | null
  }

  export type RVApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RVApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RVApproverMinAggregateOutputType = {
    id: string | null
    rv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type RVApproverMaxAggregateOutputType = {
    id: string | null
    rv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type RVApproverCountAggregateOutputType = {
    id: number
    rv_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    is_supervisor: number
    metadata: number
    _all: number
  }


  export type RVApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type RVApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type RVApproverMinAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type RVApproverMaxAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type RVApproverCountAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
    metadata?: true
    _all?: true
  }

  export type RVApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVApprover to aggregate.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RVApprovers
    **/
    _count?: true | RVApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RVApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RVApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RVApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RVApproverMaxAggregateInputType
  }

  export type GetRVApproverAggregateType<T extends RVApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateRVApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRVApprover[P]>
      : GetScalarType<T[P], AggregateRVApprover[P]>
  }




  export type RVApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVApproverWhereInput
    orderBy?: RVApproverOrderByWithAggregationInput | RVApproverOrderByWithAggregationInput[]
    by: RVApproverScalarFieldEnum[] | RVApproverScalarFieldEnum
    having?: RVApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RVApproverCountAggregateInputType | true
    _avg?: RVApproverAvgAggregateInputType
    _sum?: RVApproverSumAggregateInputType
    _min?: RVApproverMinAggregateInputType
    _max?: RVApproverMaxAggregateInputType
  }

  export type RVApproverGroupByOutputType = {
    id: string
    rv_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor: boolean
    metadata: JsonValue | null
    _count: RVApproverCountAggregateOutputType | null
    _avg: RVApproverAvgAggregateOutputType | null
    _sum: RVApproverSumAggregateOutputType | null
    _min: RVApproverMinAggregateOutputType | null
    _max: RVApproverMaxAggregateOutputType | null
  }

  type GetRVApproverGroupByPayload<T extends RVApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RVApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RVApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RVApproverGroupByOutputType[P]>
            : GetScalarType<T[P], RVApproverGroupByOutputType[P]>
        }
      >
    >


  export type RVApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
    rv?: boolean | RVDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rVApprover"]>

  export type RVApproverSelectScalar = {
    id?: boolean
    rv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
  }

  export type RVApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rv?: boolean | RVDefaultArgs<ExtArgs>
  }


  export type $RVApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RVApprover"
    objects: {
      rv: Prisma.$RVPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rv_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      order: number
      is_supervisor: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["rVApprover"]>
    composites: {}
  }


  type RVApproverGetPayload<S extends boolean | null | undefined | RVApproverDefaultArgs> = $Result.GetResult<Prisma.$RVApproverPayload, S>

  type RVApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RVApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RVApproverCountAggregateInputType | true
    }

  export interface RVApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RVApprover'], meta: { name: 'RVApprover' } }
    /**
     * Find zero or one RVApprover that matches the filter.
     * @param {RVApproverFindUniqueArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RVApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RVApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RVApproverFindUniqueOrThrowArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RVApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RVApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindFirstArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RVApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindFirstArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RVApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindFirstOrThrowArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RVApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RVApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RVApprovers
     * const rVApprovers = await prisma.rVApprover.findMany()
     * 
     * // Get first 10 RVApprovers
     * const rVApprovers = await prisma.rVApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rVApproverWithIdOnly = await prisma.rVApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RVApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RVApprover.
     * @param {RVApproverCreateArgs} args - Arguments to create a RVApprover.
     * @example
     * // Create one RVApprover
     * const RVApprover = await prisma.rVApprover.create({
     *   data: {
     *     // ... data to create a RVApprover
     *   }
     * })
     * 
    **/
    create<T extends RVApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverCreateArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RVApprovers.
     *     @param {RVApproverCreateManyArgs} args - Arguments to create many RVApprovers.
     *     @example
     *     // Create many RVApprovers
     *     const rVApprover = await prisma.rVApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RVApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RVApprover.
     * @param {RVApproverDeleteArgs} args - Arguments to delete one RVApprover.
     * @example
     * // Delete one RVApprover
     * const RVApprover = await prisma.rVApprover.delete({
     *   where: {
     *     // ... filter to delete one RVApprover
     *   }
     * })
     * 
    **/
    delete<T extends RVApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverDeleteArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RVApprover.
     * @param {RVApproverUpdateArgs} args - Arguments to update one RVApprover.
     * @example
     * // Update one RVApprover
     * const rVApprover = await prisma.rVApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RVApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpdateArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RVApprovers.
     * @param {RVApproverDeleteManyArgs} args - Arguments to filter RVApprovers to delete.
     * @example
     * // Delete a few RVApprovers
     * const { count } = await prisma.rVApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RVApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RVApprovers
     * const rVApprover = await prisma.rVApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RVApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RVApprover.
     * @param {RVApproverUpsertArgs} args - Arguments to update or create a RVApprover.
     * @example
     * // Update or create a RVApprover
     * const rVApprover = await prisma.rVApprover.upsert({
     *   create: {
     *     // ... data to create a RVApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RVApprover we want to update
     *   }
     * })
    **/
    upsert<T extends RVApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpsertArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverCountArgs} args - Arguments to filter RVApprovers to count.
     * @example
     * // Count the number of RVApprovers
     * const count = await prisma.rVApprover.count({
     *   where: {
     *     // ... the filter for the RVApprovers we want to count
     *   }
     * })
    **/
    count<T extends RVApproverCountArgs>(
      args?: Subset<T, RVApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RVApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RVApproverAggregateArgs>(args: Subset<T, RVApproverAggregateArgs>): Prisma.PrismaPromise<GetRVApproverAggregateType<T>>

    /**
     * Group by RVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RVApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RVApproverGroupByArgs['orderBy'] }
        : { orderBy?: RVApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RVApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRVApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RVApprover model
   */
  readonly fields: RVApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RVApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RVApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rv<T extends RVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RVDefaultArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RVApprover model
   */ 
  interface RVApproverFieldRefs {
    readonly id: FieldRef<"RVApprover", 'String'>
    readonly rv_id: FieldRef<"RVApprover", 'String'>
    readonly approver_id: FieldRef<"RVApprover", 'String'>
    readonly date_approval: FieldRef<"RVApprover", 'DateTime'>
    readonly notes: FieldRef<"RVApprover", 'String'>
    readonly status: FieldRef<"RVApprover", 'Int'>
    readonly label: FieldRef<"RVApprover", 'String'>
    readonly order: FieldRef<"RVApprover", 'Int'>
    readonly is_supervisor: FieldRef<"RVApprover", 'Boolean'>
    readonly metadata: FieldRef<"RVApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * RVApprover findUnique
   */
  export type RVApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover findUniqueOrThrow
   */
  export type RVApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover findFirst
   */
  export type RVApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVApprovers.
     */
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover findFirstOrThrow
   */
  export type RVApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVApprovers.
     */
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover findMany
   */
  export type RVApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprovers to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover create
   */
  export type RVApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a RVApprover.
     */
    data: XOR<RVApproverCreateInput, RVApproverUncheckedCreateInput>
  }


  /**
   * RVApprover createMany
   */
  export type RVApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RVApprovers.
     */
    data: RVApproverCreateManyInput | RVApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RVApprover update
   */
  export type RVApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a RVApprover.
     */
    data: XOR<RVApproverUpdateInput, RVApproverUncheckedUpdateInput>
    /**
     * Choose, which RVApprover to update.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover updateMany
   */
  export type RVApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RVApprovers.
     */
    data: XOR<RVApproverUpdateManyMutationInput, RVApproverUncheckedUpdateManyInput>
    /**
     * Filter which RVApprovers to update
     */
    where?: RVApproverWhereInput
  }


  /**
   * RVApprover upsert
   */
  export type RVApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the RVApprover to update in case it exists.
     */
    where: RVApproverWhereUniqueInput
    /**
     * In case the RVApprover found by the `where` argument doesn't exist, create a new RVApprover with this data.
     */
    create: XOR<RVApproverCreateInput, RVApproverUncheckedCreateInput>
    /**
     * In case the RVApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RVApproverUpdateInput, RVApproverUncheckedUpdateInput>
  }


  /**
   * RVApprover delete
   */
  export type RVApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter which RVApprover to delete.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover deleteMany
   */
  export type RVApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVApprovers to delete
     */
    where?: RVApproverWhereInput
  }


  /**
   * RVApprover without action
   */
  export type RVApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
  }



  /**
   * Model JO
   */

  export type AggregateJO = {
    _count: JOCountAggregateOutputType | null
    _min: JOMinAggregateOutputType | null
    _max: JOMaxAggregateOutputType | null
  }

  export type JOMinAggregateOutputType = {
    id: string | null
    jo_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    equipment: string | null
    classification_id: string | null
    department_id: string | null
    supervisor_id: string | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JOMaxAggregateOutputType = {
    id: string | null
    jo_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    equipment: string | null
    classification_id: string | null
    department_id: string | null
    supervisor_id: string | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JOCountAggregateOutputType = {
    id: number
    jo_number: number
    date_requested: number
    canvass_id: number
    equipment: number
    classification_id: number
    department_id: number
    supervisor_id: number
    notes: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type JOMinAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type JOMaxAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type JOCountAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type JOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JO to aggregate.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JOS
    **/
    _count?: true | JOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JOMaxAggregateInputType
  }

  export type GetJOAggregateType<T extends JOAggregateArgs> = {
        [P in keyof T & keyof AggregateJO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJO[P]>
      : GetScalarType<T[P], AggregateJO[P]>
  }




  export type JOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOWhereInput
    orderBy?: JOOrderByWithAggregationInput | JOOrderByWithAggregationInput[]
    by: JOScalarFieldEnum[] | JOScalarFieldEnum
    having?: JOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JOCountAggregateInputType | true
    _min?: JOMinAggregateInputType
    _max?: JOMaxAggregateInputType
  }

  export type JOGroupByOutputType = {
    id: string
    jo_number: string
    date_requested: Date
    canvass_id: string | null
    equipment: string
    classification_id: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: JOCountAggregateOutputType | null
    _min: JOMinAggregateOutputType | null
    _max: JOMaxAggregateOutputType | null
  }

  type GetJOGroupByPayload<T extends JOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JOGroupByOutputType[P]>
            : GetScalarType<T[P], JOGroupByOutputType[P]>
        }
      >
    >


  export type JOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    equipment?: boolean
    classification_id?: boolean
    department_id?: boolean
    supervisor_id?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    canvass?: boolean | JO$canvassArgs<ExtArgs>
    meqs?: boolean | JO$meqsArgs<ExtArgs>
    jo_approvers?: boolean | JO$jo_approversArgs<ExtArgs>
    _count?: boolean | JOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jO"]>

  export type JOSelectScalar = {
    id?: boolean
    jo_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    equipment?: boolean
    classification_id?: boolean
    department_id?: boolean
    supervisor_id?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type JOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass?: boolean | JO$canvassArgs<ExtArgs>
    meqs?: boolean | JO$meqsArgs<ExtArgs>
    jo_approvers?: boolean | JO$jo_approversArgs<ExtArgs>
    _count?: boolean | JOCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JO"
    objects: {
      canvass: Prisma.$CanvassPayload<ExtArgs> | null
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
      jo_approvers: Prisma.$JOApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_number: string
      date_requested: Date
      canvass_id: string | null
      equipment: string
      classification_id: string | null
      department_id: string
      supervisor_id: string
      notes: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["jO"]>
    composites: {}
  }


  type JOGetPayload<S extends boolean | null | undefined | JODefaultArgs> = $Result.GetResult<Prisma.$JOPayload, S>

  type JOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JOFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JOCountAggregateInputType | true
    }

  export interface JODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JO'], meta: { name: 'JO' } }
    /**
     * Find zero or one JO that matches the filter.
     * @param {JOFindUniqueArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JOFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JOFindUniqueArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JOFindUniqueOrThrowArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JOFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindFirstArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JOFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindFirstArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindFirstOrThrowArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JOFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JOS
     * const jOS = await prisma.jO.findMany()
     * 
     * // Get first 10 JOS
     * const jOS = await prisma.jO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jOWithIdOnly = await prisma.jO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JOFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JO.
     * @param {JOCreateArgs} args - Arguments to create a JO.
     * @example
     * // Create one JO
     * const JO = await prisma.jO.create({
     *   data: {
     *     // ... data to create a JO
     *   }
     * })
     * 
    **/
    create<T extends JOCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JOCreateArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JOS.
     *     @param {JOCreateManyArgs} args - Arguments to create many JOS.
     *     @example
     *     // Create many JOS
     *     const jO = await prisma.jO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JOCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JO.
     * @param {JODeleteArgs} args - Arguments to delete one JO.
     * @example
     * // Delete one JO
     * const JO = await prisma.jO.delete({
     *   where: {
     *     // ... filter to delete one JO
     *   }
     * })
     * 
    **/
    delete<T extends JODeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JODeleteArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JO.
     * @param {JOUpdateArgs} args - Arguments to update one JO.
     * @example
     * // Update one JO
     * const jO = await prisma.jO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JOUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpdateArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JOS.
     * @param {JODeleteManyArgs} args - Arguments to filter JOS to delete.
     * @example
     * // Delete a few JOS
     * const { count } = await prisma.jO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JODeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JODeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JOS
     * const jO = await prisma.jO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JOUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JO.
     * @param {JOUpsertArgs} args - Arguments to update or create a JO.
     * @example
     * // Update or create a JO
     * const jO = await prisma.jO.upsert({
     *   create: {
     *     // ... data to create a JO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JO we want to update
     *   }
     * })
    **/
    upsert<T extends JOUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpsertArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOCountArgs} args - Arguments to filter JOS to count.
     * @example
     * // Count the number of JOS
     * const count = await prisma.jO.count({
     *   where: {
     *     // ... the filter for the JOS we want to count
     *   }
     * })
    **/
    count<T extends JOCountArgs>(
      args?: Subset<T, JOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JOAggregateArgs>(args: Subset<T, JOAggregateArgs>): Prisma.PrismaPromise<GetJOAggregateType<T>>

    /**
     * Group by JO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JOGroupByArgs['orderBy'] }
        : { orderBy?: JOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JO model
   */
  readonly fields: JOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass<T extends JO$canvassArgs<ExtArgs> = {}>(args?: Subset<T, JO$canvassArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs<T extends JO$meqsArgs<ExtArgs> = {}>(args?: Subset<T, JO$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    jo_approvers<T extends JO$jo_approversArgs<ExtArgs> = {}>(args?: Subset<T, JO$jo_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JO model
   */ 
  interface JOFieldRefs {
    readonly id: FieldRef<"JO", 'String'>
    readonly jo_number: FieldRef<"JO", 'String'>
    readonly date_requested: FieldRef<"JO", 'DateTime'>
    readonly canvass_id: FieldRef<"JO", 'String'>
    readonly equipment: FieldRef<"JO", 'String'>
    readonly classification_id: FieldRef<"JO", 'String'>
    readonly department_id: FieldRef<"JO", 'String'>
    readonly supervisor_id: FieldRef<"JO", 'String'>
    readonly notes: FieldRef<"JO", 'String'>
    readonly cancelled_by: FieldRef<"JO", 'String'>
    readonly created_by: FieldRef<"JO", 'String'>
    readonly updated_by: FieldRef<"JO", 'String'>
    readonly cancelled_at: FieldRef<"JO", 'DateTime'>
    readonly created_at: FieldRef<"JO", 'DateTime'>
    readonly updated_at: FieldRef<"JO", 'DateTime'>
    readonly metadata: FieldRef<"JO", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * JO findUnique
   */
  export type JOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO findUniqueOrThrow
   */
  export type JOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO findFirst
   */
  export type JOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOS.
     */
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO findFirstOrThrow
   */
  export type JOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOS.
     */
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO findMany
   */
  export type JOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JOS to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO create
   */
  export type JOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The data needed to create a JO.
     */
    data: XOR<JOCreateInput, JOUncheckedCreateInput>
  }


  /**
   * JO createMany
   */
  export type JOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JOS.
     */
    data: JOCreateManyInput | JOCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JO update
   */
  export type JOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The data needed to update a JO.
     */
    data: XOR<JOUpdateInput, JOUncheckedUpdateInput>
    /**
     * Choose, which JO to update.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO updateMany
   */
  export type JOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JOS.
     */
    data: XOR<JOUpdateManyMutationInput, JOUncheckedUpdateManyInput>
    /**
     * Filter which JOS to update
     */
    where?: JOWhereInput
  }


  /**
   * JO upsert
   */
  export type JOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The filter to search for the JO to update in case it exists.
     */
    where: JOWhereUniqueInput
    /**
     * In case the JO found by the `where` argument doesn't exist, create a new JO with this data.
     */
    create: XOR<JOCreateInput, JOUncheckedCreateInput>
    /**
     * In case the JO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JOUpdateInput, JOUncheckedUpdateInput>
  }


  /**
   * JO delete
   */
  export type JODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter which JO to delete.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO deleteMany
   */
  export type JODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOS to delete
     */
    where?: JOWhereInput
  }


  /**
   * JO.canvass
   */
  export type JO$canvassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    where?: CanvassWhereInput
  }


  /**
   * JO.meqs
   */
  export type JO$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * JO.jo_approvers
   */
  export type JO$jo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    where?: JOApproverWhereInput
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    cursor?: JOApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JO without action
   */
  export type JODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
  }



  /**
   * Model JOApprover
   */

  export type AggregateJOApprover = {
    _count: JOApproverCountAggregateOutputType | null
    _avg: JOApproverAvgAggregateOutputType | null
    _sum: JOApproverSumAggregateOutputType | null
    _min: JOApproverMinAggregateOutputType | null
    _max: JOApproverMaxAggregateOutputType | null
  }

  export type JOApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type JOApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type JOApproverMinAggregateOutputType = {
    id: string | null
    jo_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type JOApproverMaxAggregateOutputType = {
    id: string | null
    jo_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type JOApproverCountAggregateOutputType = {
    id: number
    jo_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    is_supervisor: number
    metadata: number
    _all: number
  }


  export type JOApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type JOApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type JOApproverMinAggregateInputType = {
    id?: true
    jo_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type JOApproverMaxAggregateInputType = {
    id?: true
    jo_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type JOApproverCountAggregateInputType = {
    id?: true
    jo_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
    metadata?: true
    _all?: true
  }

  export type JOApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOApprover to aggregate.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JOApprovers
    **/
    _count?: true | JOApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JOApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JOApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JOApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JOApproverMaxAggregateInputType
  }

  export type GetJOApproverAggregateType<T extends JOApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateJOApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJOApprover[P]>
      : GetScalarType<T[P], AggregateJOApprover[P]>
  }




  export type JOApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOApproverWhereInput
    orderBy?: JOApproverOrderByWithAggregationInput | JOApproverOrderByWithAggregationInput[]
    by: JOApproverScalarFieldEnum[] | JOApproverScalarFieldEnum
    having?: JOApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JOApproverCountAggregateInputType | true
    _avg?: JOApproverAvgAggregateInputType
    _sum?: JOApproverSumAggregateInputType
    _min?: JOApproverMinAggregateInputType
    _max?: JOApproverMaxAggregateInputType
  }

  export type JOApproverGroupByOutputType = {
    id: string
    jo_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor: boolean
    metadata: JsonValue | null
    _count: JOApproverCountAggregateOutputType | null
    _avg: JOApproverAvgAggregateOutputType | null
    _sum: JOApproverSumAggregateOutputType | null
    _min: JOApproverMinAggregateOutputType | null
    _max: JOApproverMaxAggregateOutputType | null
  }

  type GetJOApproverGroupByPayload<T extends JOApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JOApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JOApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JOApproverGroupByOutputType[P]>
            : GetScalarType<T[P], JOApproverGroupByOutputType[P]>
        }
      >
    >


  export type JOApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
    jo?: boolean | JODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jOApprover"]>

  export type JOApproverSelectScalar = {
    id?: boolean
    jo_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
  }

  export type JOApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo?: boolean | JODefaultArgs<ExtArgs>
  }


  export type $JOApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JOApprover"
    objects: {
      jo: Prisma.$JOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      order: number
      is_supervisor: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["jOApprover"]>
    composites: {}
  }


  type JOApproverGetPayload<S extends boolean | null | undefined | JOApproverDefaultArgs> = $Result.GetResult<Prisma.$JOApproverPayload, S>

  type JOApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JOApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JOApproverCountAggregateInputType | true
    }

  export interface JOApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JOApprover'], meta: { name: 'JOApprover' } }
    /**
     * Find zero or one JOApprover that matches the filter.
     * @param {JOApproverFindUniqueArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JOApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JOApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JOApproverFindUniqueOrThrowArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JOApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JOApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindFirstArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JOApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindFirstArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JOApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindFirstOrThrowArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JOApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JOApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JOApprovers
     * const jOApprovers = await prisma.jOApprover.findMany()
     * 
     * // Get first 10 JOApprovers
     * const jOApprovers = await prisma.jOApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jOApproverWithIdOnly = await prisma.jOApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JOApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JOApprover.
     * @param {JOApproverCreateArgs} args - Arguments to create a JOApprover.
     * @example
     * // Create one JOApprover
     * const JOApprover = await prisma.jOApprover.create({
     *   data: {
     *     // ... data to create a JOApprover
     *   }
     * })
     * 
    **/
    create<T extends JOApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverCreateArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JOApprovers.
     *     @param {JOApproverCreateManyArgs} args - Arguments to create many JOApprovers.
     *     @example
     *     // Create many JOApprovers
     *     const jOApprover = await prisma.jOApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JOApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JOApprover.
     * @param {JOApproverDeleteArgs} args - Arguments to delete one JOApprover.
     * @example
     * // Delete one JOApprover
     * const JOApprover = await prisma.jOApprover.delete({
     *   where: {
     *     // ... filter to delete one JOApprover
     *   }
     * })
     * 
    **/
    delete<T extends JOApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverDeleteArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JOApprover.
     * @param {JOApproverUpdateArgs} args - Arguments to update one JOApprover.
     * @example
     * // Update one JOApprover
     * const jOApprover = await prisma.jOApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JOApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpdateArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JOApprovers.
     * @param {JOApproverDeleteManyArgs} args - Arguments to filter JOApprovers to delete.
     * @example
     * // Delete a few JOApprovers
     * const { count } = await prisma.jOApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JOApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JOApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JOApprovers
     * const jOApprover = await prisma.jOApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JOApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JOApprover.
     * @param {JOApproverUpsertArgs} args - Arguments to update or create a JOApprover.
     * @example
     * // Update or create a JOApprover
     * const jOApprover = await prisma.jOApprover.upsert({
     *   create: {
     *     // ... data to create a JOApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JOApprover we want to update
     *   }
     * })
    **/
    upsert<T extends JOApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpsertArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JOApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverCountArgs} args - Arguments to filter JOApprovers to count.
     * @example
     * // Count the number of JOApprovers
     * const count = await prisma.jOApprover.count({
     *   where: {
     *     // ... the filter for the JOApprovers we want to count
     *   }
     * })
    **/
    count<T extends JOApproverCountArgs>(
      args?: Subset<T, JOApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JOApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JOApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JOApproverAggregateArgs>(args: Subset<T, JOApproverAggregateArgs>): Prisma.PrismaPromise<GetJOApproverAggregateType<T>>

    /**
     * Group by JOApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JOApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JOApproverGroupByArgs['orderBy'] }
        : { orderBy?: JOApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JOApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJOApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JOApprover model
   */
  readonly fields: JOApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JOApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JOApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jo<T extends JODefaultArgs<ExtArgs> = {}>(args?: Subset<T, JODefaultArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JOApprover model
   */ 
  interface JOApproverFieldRefs {
    readonly id: FieldRef<"JOApprover", 'String'>
    readonly jo_id: FieldRef<"JOApprover", 'String'>
    readonly approver_id: FieldRef<"JOApprover", 'String'>
    readonly date_approval: FieldRef<"JOApprover", 'DateTime'>
    readonly notes: FieldRef<"JOApprover", 'String'>
    readonly status: FieldRef<"JOApprover", 'Int'>
    readonly label: FieldRef<"JOApprover", 'String'>
    readonly order: FieldRef<"JOApprover", 'Int'>
    readonly is_supervisor: FieldRef<"JOApprover", 'Boolean'>
    readonly metadata: FieldRef<"JOApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * JOApprover findUnique
   */
  export type JOApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover findUniqueOrThrow
   */
  export type JOApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover findFirst
   */
  export type JOApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOApprovers.
     */
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover findFirstOrThrow
   */
  export type JOApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOApprovers.
     */
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover findMany
   */
  export type JOApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprovers to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover create
   */
  export type JOApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a JOApprover.
     */
    data: XOR<JOApproverCreateInput, JOApproverUncheckedCreateInput>
  }


  /**
   * JOApprover createMany
   */
  export type JOApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JOApprovers.
     */
    data: JOApproverCreateManyInput | JOApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JOApprover update
   */
  export type JOApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a JOApprover.
     */
    data: XOR<JOApproverUpdateInput, JOApproverUncheckedUpdateInput>
    /**
     * Choose, which JOApprover to update.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover updateMany
   */
  export type JOApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JOApprovers.
     */
    data: XOR<JOApproverUpdateManyMutationInput, JOApproverUncheckedUpdateManyInput>
    /**
     * Filter which JOApprovers to update
     */
    where?: JOApproverWhereInput
  }


  /**
   * JOApprover upsert
   */
  export type JOApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the JOApprover to update in case it exists.
     */
    where: JOApproverWhereUniqueInput
    /**
     * In case the JOApprover found by the `where` argument doesn't exist, create a new JOApprover with this data.
     */
    create: XOR<JOApproverCreateInput, JOApproverUncheckedCreateInput>
    /**
     * In case the JOApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JOApproverUpdateInput, JOApproverUncheckedUpdateInput>
  }


  /**
   * JOApprover delete
   */
  export type JOApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter which JOApprover to delete.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover deleteMany
   */
  export type JOApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOApprovers to delete
     */
    where?: JOApproverWhereInput
  }


  /**
   * JOApprover without action
   */
  export type JOApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
  }



  /**
   * Model SPR
   */

  export type AggregateSPR = {
    _count: SPRCountAggregateOutputType | null
    _min: SPRMinAggregateOutputType | null
    _max: SPRMaxAggregateOutputType | null
  }

  export type SPRMinAggregateOutputType = {
    id: string | null
    spr_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    vehicle_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SPRMaxAggregateOutputType = {
    id: string | null
    spr_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    vehicle_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SPRCountAggregateOutputType = {
    id: number
    spr_number: number
    date_requested: number
    canvass_id: number
    vehicle_id: number
    classification_id: number
    supervisor_id: number
    notes: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type SPRMinAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type SPRMaxAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type SPRCountAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type SPRAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPR to aggregate.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SPRS
    **/
    _count?: true | SPRCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SPRMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SPRMaxAggregateInputType
  }

  export type GetSPRAggregateType<T extends SPRAggregateArgs> = {
        [P in keyof T & keyof AggregateSPR]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSPR[P]>
      : GetScalarType<T[P], AggregateSPR[P]>
  }




  export type SPRGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRWhereInput
    orderBy?: SPROrderByWithAggregationInput | SPROrderByWithAggregationInput[]
    by: SPRScalarFieldEnum[] | SPRScalarFieldEnum
    having?: SPRScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SPRCountAggregateInputType | true
    _min?: SPRMinAggregateInputType
    _max?: SPRMaxAggregateInputType
  }

  export type SPRGroupByOutputType = {
    id: string
    spr_number: string
    date_requested: Date
    canvass_id: string | null
    vehicle_id: string
    classification_id: string | null
    supervisor_id: string
    notes: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: SPRCountAggregateOutputType | null
    _min: SPRMinAggregateOutputType | null
    _max: SPRMaxAggregateOutputType | null
  }

  type GetSPRGroupByPayload<T extends SPRGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SPRGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SPRGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SPRGroupByOutputType[P]>
            : GetScalarType<T[P], SPRGroupByOutputType[P]>
        }
      >
    >


  export type SPRSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spr_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    vehicle_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    canvass?: boolean | SPR$canvassArgs<ExtArgs>
    meqs?: boolean | SPR$meqsArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    spr_approvers?: boolean | SPR$spr_approversArgs<ExtArgs>
    _count?: boolean | SPRCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sPR"]>

  export type SPRSelectScalar = {
    id?: boolean
    spr_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    vehicle_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type SPRInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass?: boolean | SPR$canvassArgs<ExtArgs>
    meqs?: boolean | SPR$meqsArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    spr_approvers?: boolean | SPR$spr_approversArgs<ExtArgs>
    _count?: boolean | SPRCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SPRPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SPR"
    objects: {
      canvass: Prisma.$CanvassPayload<ExtArgs> | null
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      spr_approvers: Prisma.$SPRApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spr_number: string
      date_requested: Date
      canvass_id: string | null
      vehicle_id: string
      classification_id: string | null
      supervisor_id: string
      notes: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sPR"]>
    composites: {}
  }


  type SPRGetPayload<S extends boolean | null | undefined | SPRDefaultArgs> = $Result.GetResult<Prisma.$SPRPayload, S>

  type SPRCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SPRFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SPRCountAggregateInputType | true
    }

  export interface SPRDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SPR'], meta: { name: 'SPR' } }
    /**
     * Find zero or one SPR that matches the filter.
     * @param {SPRFindUniqueArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SPRFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SPRFindUniqueArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SPR that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SPRFindUniqueOrThrowArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SPRFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SPR that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindFirstArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SPRFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindFirstArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SPR that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindFirstOrThrowArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SPRFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SPRS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SPRS
     * const sPRS = await prisma.sPR.findMany()
     * 
     * // Get first 10 SPRS
     * const sPRS = await prisma.sPR.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sPRWithIdOnly = await prisma.sPR.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SPRFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SPR.
     * @param {SPRCreateArgs} args - Arguments to create a SPR.
     * @example
     * // Create one SPR
     * const SPR = await prisma.sPR.create({
     *   data: {
     *     // ... data to create a SPR
     *   }
     * })
     * 
    **/
    create<T extends SPRCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRCreateArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SPRS.
     *     @param {SPRCreateManyArgs} args - Arguments to create many SPRS.
     *     @example
     *     // Create many SPRS
     *     const sPR = await prisma.sPR.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SPRCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SPR.
     * @param {SPRDeleteArgs} args - Arguments to delete one SPR.
     * @example
     * // Delete one SPR
     * const SPR = await prisma.sPR.delete({
     *   where: {
     *     // ... filter to delete one SPR
     *   }
     * })
     * 
    **/
    delete<T extends SPRDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SPRDeleteArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SPR.
     * @param {SPRUpdateArgs} args - Arguments to update one SPR.
     * @example
     * // Update one SPR
     * const sPR = await prisma.sPR.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SPRUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpdateArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SPRS.
     * @param {SPRDeleteManyArgs} args - Arguments to filter SPRS to delete.
     * @example
     * // Delete a few SPRS
     * const { count } = await prisma.sPR.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SPRDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SPRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SPRS
     * const sPR = await prisma.sPR.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SPRUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SPR.
     * @param {SPRUpsertArgs} args - Arguments to update or create a SPR.
     * @example
     * // Update or create a SPR
     * const sPR = await prisma.sPR.upsert({
     *   create: {
     *     // ... data to create a SPR
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SPR we want to update
     *   }
     * })
    **/
    upsert<T extends SPRUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpsertArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SPRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRCountArgs} args - Arguments to filter SPRS to count.
     * @example
     * // Count the number of SPRS
     * const count = await prisma.sPR.count({
     *   where: {
     *     // ... the filter for the SPRS we want to count
     *   }
     * })
    **/
    count<T extends SPRCountArgs>(
      args?: Subset<T, SPRCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SPRCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SPR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SPRAggregateArgs>(args: Subset<T, SPRAggregateArgs>): Prisma.PrismaPromise<GetSPRAggregateType<T>>

    /**
     * Group by SPR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SPRGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SPRGroupByArgs['orderBy'] }
        : { orderBy?: SPRGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SPRGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSPRGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SPR model
   */
  readonly fields: SPRFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SPR.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SPRClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass<T extends SPR$canvassArgs<ExtArgs> = {}>(args?: Subset<T, SPR$canvassArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs<T extends SPR$meqsArgs<ExtArgs> = {}>(args?: Subset<T, SPR$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spr_approvers<T extends SPR$spr_approversArgs<ExtArgs> = {}>(args?: Subset<T, SPR$spr_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SPR model
   */ 
  interface SPRFieldRefs {
    readonly id: FieldRef<"SPR", 'String'>
    readonly spr_number: FieldRef<"SPR", 'String'>
    readonly date_requested: FieldRef<"SPR", 'DateTime'>
    readonly canvass_id: FieldRef<"SPR", 'String'>
    readonly vehicle_id: FieldRef<"SPR", 'String'>
    readonly classification_id: FieldRef<"SPR", 'String'>
    readonly supervisor_id: FieldRef<"SPR", 'String'>
    readonly notes: FieldRef<"SPR", 'String'>
    readonly cancelled_by: FieldRef<"SPR", 'String'>
    readonly created_by: FieldRef<"SPR", 'String'>
    readonly updated_by: FieldRef<"SPR", 'String'>
    readonly cancelled_at: FieldRef<"SPR", 'DateTime'>
    readonly created_at: FieldRef<"SPR", 'DateTime'>
    readonly updated_at: FieldRef<"SPR", 'DateTime'>
    readonly metadata: FieldRef<"SPR", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SPR findUnique
   */
  export type SPRFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR findUniqueOrThrow
   */
  export type SPRFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR findFirst
   */
  export type SPRFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRS.
     */
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR findFirstOrThrow
   */
  export type SPRFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRS.
     */
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR findMany
   */
  export type SPRFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPRS to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR create
   */
  export type SPRCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The data needed to create a SPR.
     */
    data: XOR<SPRCreateInput, SPRUncheckedCreateInput>
  }


  /**
   * SPR createMany
   */
  export type SPRCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SPRS.
     */
    data: SPRCreateManyInput | SPRCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SPR update
   */
  export type SPRUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The data needed to update a SPR.
     */
    data: XOR<SPRUpdateInput, SPRUncheckedUpdateInput>
    /**
     * Choose, which SPR to update.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR updateMany
   */
  export type SPRUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SPRS.
     */
    data: XOR<SPRUpdateManyMutationInput, SPRUncheckedUpdateManyInput>
    /**
     * Filter which SPRS to update
     */
    where?: SPRWhereInput
  }


  /**
   * SPR upsert
   */
  export type SPRUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The filter to search for the SPR to update in case it exists.
     */
    where: SPRWhereUniqueInput
    /**
     * In case the SPR found by the `where` argument doesn't exist, create a new SPR with this data.
     */
    create: XOR<SPRCreateInput, SPRUncheckedCreateInput>
    /**
     * In case the SPR was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SPRUpdateInput, SPRUncheckedUpdateInput>
  }


  /**
   * SPR delete
   */
  export type SPRDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter which SPR to delete.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR deleteMany
   */
  export type SPRDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRS to delete
     */
    where?: SPRWhereInput
  }


  /**
   * SPR.canvass
   */
  export type SPR$canvassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    where?: CanvassWhereInput
  }


  /**
   * SPR.meqs
   */
  export type SPR$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * SPR.spr_approvers
   */
  export type SPR$spr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    where?: SPRApproverWhereInput
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    cursor?: SPRApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPR without action
   */
  export type SPRDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
  }



  /**
   * Model SPRApprover
   */

  export type AggregateSPRApprover = {
    _count: SPRApproverCountAggregateOutputType | null
    _avg: SPRApproverAvgAggregateOutputType | null
    _sum: SPRApproverSumAggregateOutputType | null
    _min: SPRApproverMinAggregateOutputType | null
    _max: SPRApproverMaxAggregateOutputType | null
  }

  export type SPRApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SPRApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SPRApproverMinAggregateOutputType = {
    id: string | null
    spr_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type SPRApproverMaxAggregateOutputType = {
    id: string | null
    spr_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    is_supervisor: boolean | null
  }

  export type SPRApproverCountAggregateOutputType = {
    id: number
    spr_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    is_supervisor: number
    metadata: number
    _all: number
  }


  export type SPRApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type SPRApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type SPRApproverMinAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type SPRApproverMaxAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
  }

  export type SPRApproverCountAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    is_supervisor?: true
    metadata?: true
    _all?: true
  }

  export type SPRApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRApprover to aggregate.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SPRApprovers
    **/
    _count?: true | SPRApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SPRApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SPRApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SPRApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SPRApproverMaxAggregateInputType
  }

  export type GetSPRApproverAggregateType<T extends SPRApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateSPRApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSPRApprover[P]>
      : GetScalarType<T[P], AggregateSPRApprover[P]>
  }




  export type SPRApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRApproverWhereInput
    orderBy?: SPRApproverOrderByWithAggregationInput | SPRApproverOrderByWithAggregationInput[]
    by: SPRApproverScalarFieldEnum[] | SPRApproverScalarFieldEnum
    having?: SPRApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SPRApproverCountAggregateInputType | true
    _avg?: SPRApproverAvgAggregateInputType
    _sum?: SPRApproverSumAggregateInputType
    _min?: SPRApproverMinAggregateInputType
    _max?: SPRApproverMaxAggregateInputType
  }

  export type SPRApproverGroupByOutputType = {
    id: string
    spr_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor: boolean
    metadata: JsonValue | null
    _count: SPRApproverCountAggregateOutputType | null
    _avg: SPRApproverAvgAggregateOutputType | null
    _sum: SPRApproverSumAggregateOutputType | null
    _min: SPRApproverMinAggregateOutputType | null
    _max: SPRApproverMaxAggregateOutputType | null
  }

  type GetSPRApproverGroupByPayload<T extends SPRApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SPRApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SPRApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SPRApproverGroupByOutputType[P]>
            : GetScalarType<T[P], SPRApproverGroupByOutputType[P]>
        }
      >
    >


  export type SPRApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spr_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
    spr?: boolean | SPRDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sPRApprover"]>

  export type SPRApproverSelectScalar = {
    id?: boolean
    spr_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    is_supervisor?: boolean
    metadata?: boolean
  }

  export type SPRApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spr?: boolean | SPRDefaultArgs<ExtArgs>
  }


  export type $SPRApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SPRApprover"
    objects: {
      spr: Prisma.$SPRPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spr_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      order: number
      is_supervisor: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sPRApprover"]>
    composites: {}
  }


  type SPRApproverGetPayload<S extends boolean | null | undefined | SPRApproverDefaultArgs> = $Result.GetResult<Prisma.$SPRApproverPayload, S>

  type SPRApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SPRApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SPRApproverCountAggregateInputType | true
    }

  export interface SPRApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SPRApprover'], meta: { name: 'SPRApprover' } }
    /**
     * Find zero or one SPRApprover that matches the filter.
     * @param {SPRApproverFindUniqueArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SPRApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SPRApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SPRApproverFindUniqueOrThrowArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SPRApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SPRApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindFirstArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SPRApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindFirstArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SPRApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindFirstOrThrowArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SPRApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SPRApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SPRApprovers
     * const sPRApprovers = await prisma.sPRApprover.findMany()
     * 
     * // Get first 10 SPRApprovers
     * const sPRApprovers = await prisma.sPRApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sPRApproverWithIdOnly = await prisma.sPRApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SPRApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SPRApprover.
     * @param {SPRApproverCreateArgs} args - Arguments to create a SPRApprover.
     * @example
     * // Create one SPRApprover
     * const SPRApprover = await prisma.sPRApprover.create({
     *   data: {
     *     // ... data to create a SPRApprover
     *   }
     * })
     * 
    **/
    create<T extends SPRApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverCreateArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SPRApprovers.
     *     @param {SPRApproverCreateManyArgs} args - Arguments to create many SPRApprovers.
     *     @example
     *     // Create many SPRApprovers
     *     const sPRApprover = await prisma.sPRApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SPRApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SPRApprover.
     * @param {SPRApproverDeleteArgs} args - Arguments to delete one SPRApprover.
     * @example
     * // Delete one SPRApprover
     * const SPRApprover = await prisma.sPRApprover.delete({
     *   where: {
     *     // ... filter to delete one SPRApprover
     *   }
     * })
     * 
    **/
    delete<T extends SPRApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverDeleteArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SPRApprover.
     * @param {SPRApproverUpdateArgs} args - Arguments to update one SPRApprover.
     * @example
     * // Update one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SPRApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpdateArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SPRApprovers.
     * @param {SPRApproverDeleteManyArgs} args - Arguments to filter SPRApprovers to delete.
     * @example
     * // Delete a few SPRApprovers
     * const { count } = await prisma.sPRApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SPRApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SPRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SPRApprovers
     * const sPRApprover = await prisma.sPRApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SPRApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SPRApprover.
     * @param {SPRApproverUpsertArgs} args - Arguments to update or create a SPRApprover.
     * @example
     * // Update or create a SPRApprover
     * const sPRApprover = await prisma.sPRApprover.upsert({
     *   create: {
     *     // ... data to create a SPRApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SPRApprover we want to update
     *   }
     * })
    **/
    upsert<T extends SPRApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpsertArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SPRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverCountArgs} args - Arguments to filter SPRApprovers to count.
     * @example
     * // Count the number of SPRApprovers
     * const count = await prisma.sPRApprover.count({
     *   where: {
     *     // ... the filter for the SPRApprovers we want to count
     *   }
     * })
    **/
    count<T extends SPRApproverCountArgs>(
      args?: Subset<T, SPRApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SPRApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SPRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SPRApproverAggregateArgs>(args: Subset<T, SPRApproverAggregateArgs>): Prisma.PrismaPromise<GetSPRApproverAggregateType<T>>

    /**
     * Group by SPRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SPRApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SPRApproverGroupByArgs['orderBy'] }
        : { orderBy?: SPRApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SPRApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSPRApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SPRApprover model
   */
  readonly fields: SPRApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SPRApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SPRApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spr<T extends SPRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SPRDefaultArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SPRApprover model
   */ 
  interface SPRApproverFieldRefs {
    readonly id: FieldRef<"SPRApprover", 'String'>
    readonly spr_id: FieldRef<"SPRApprover", 'String'>
    readonly approver_id: FieldRef<"SPRApprover", 'String'>
    readonly date_approval: FieldRef<"SPRApprover", 'DateTime'>
    readonly notes: FieldRef<"SPRApprover", 'String'>
    readonly status: FieldRef<"SPRApprover", 'Int'>
    readonly label: FieldRef<"SPRApprover", 'String'>
    readonly order: FieldRef<"SPRApprover", 'Int'>
    readonly is_supervisor: FieldRef<"SPRApprover", 'Boolean'>
    readonly metadata: FieldRef<"SPRApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SPRApprover findUnique
   */
  export type SPRApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover findUniqueOrThrow
   */
  export type SPRApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover findFirst
   */
  export type SPRApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRApprovers.
     */
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover findFirstOrThrow
   */
  export type SPRApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRApprovers.
     */
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover findMany
   */
  export type SPRApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprovers to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover create
   */
  export type SPRApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a SPRApprover.
     */
    data: XOR<SPRApproverCreateInput, SPRApproverUncheckedCreateInput>
  }


  /**
   * SPRApprover createMany
   */
  export type SPRApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SPRApprovers.
     */
    data: SPRApproverCreateManyInput | SPRApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SPRApprover update
   */
  export type SPRApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a SPRApprover.
     */
    data: XOR<SPRApproverUpdateInput, SPRApproverUncheckedUpdateInput>
    /**
     * Choose, which SPRApprover to update.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover updateMany
   */
  export type SPRApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SPRApprovers.
     */
    data: XOR<SPRApproverUpdateManyMutationInput, SPRApproverUncheckedUpdateManyInput>
    /**
     * Filter which SPRApprovers to update
     */
    where?: SPRApproverWhereInput
  }


  /**
   * SPRApprover upsert
   */
  export type SPRApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the SPRApprover to update in case it exists.
     */
    where: SPRApproverWhereUniqueInput
    /**
     * In case the SPRApprover found by the `where` argument doesn't exist, create a new SPRApprover with this data.
     */
    create: XOR<SPRApproverCreateInput, SPRApproverUncheckedCreateInput>
    /**
     * In case the SPRApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SPRApproverUpdateInput, SPRApproverUncheckedUpdateInput>
  }


  /**
   * SPRApprover delete
   */
  export type SPRApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter which SPRApprover to delete.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover deleteMany
   */
  export type SPRApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRApprovers to delete
     */
    where?: SPRApproverWhereInput
  }


  /**
   * SPRApprover without action
   */
  export type SPRApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
  }



  /**
   * Model MEQS
   */

  export type AggregateMEQS = {
    _count: MEQSCountAggregateOutputType | null
    _min: MEQSMinAggregateOutputType | null
    _max: MEQSMaxAggregateOutputType | null
  }

  export type MEQSMinAggregateOutputType = {
    id: string | null
    jo_id: string | null
    jo_number: string | null
    rv_id: string | null
    rv_number: string | null
    spr_id: string | null
    spr_number: string | null
    meqs_number: string | null
    meqs_date: Date | null
    notes: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_by: string | null
    created_at: Date | null
    updated_at: Date | null
    cancelled_at: Date | null
  }

  export type MEQSMaxAggregateOutputType = {
    id: string | null
    jo_id: string | null
    jo_number: string | null
    rv_id: string | null
    rv_number: string | null
    spr_id: string | null
    spr_number: string | null
    meqs_number: string | null
    meqs_date: Date | null
    notes: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_by: string | null
    created_at: Date | null
    updated_at: Date | null
    cancelled_at: Date | null
  }

  export type MEQSCountAggregateOutputType = {
    id: number
    jo_id: number
    jo_number: number
    rv_id: number
    rv_number: number
    spr_id: number
    spr_number: number
    meqs_number: number
    meqs_date: number
    notes: number
    created_by: number
    updated_by: number
    cancelled_by: number
    created_at: number
    updated_at: number
    cancelled_at: number
    metadata: number
    _all: number
  }


  export type MEQSMinAggregateInputType = {
    id?: true
    jo_id?: true
    jo_number?: true
    rv_id?: true
    rv_number?: true
    spr_id?: true
    spr_number?: true
    meqs_number?: true
    meqs_date?: true
    notes?: true
    created_by?: true
    updated_by?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
    cancelled_at?: true
  }

  export type MEQSMaxAggregateInputType = {
    id?: true
    jo_id?: true
    jo_number?: true
    rv_id?: true
    rv_number?: true
    spr_id?: true
    spr_number?: true
    meqs_number?: true
    meqs_date?: true
    notes?: true
    created_by?: true
    updated_by?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
    cancelled_at?: true
  }

  export type MEQSCountAggregateInputType = {
    id?: true
    jo_id?: true
    jo_number?: true
    rv_id?: true
    rv_number?: true
    spr_id?: true
    spr_number?: true
    meqs_number?: true
    meqs_date?: true
    notes?: true
    created_by?: true
    updated_by?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
    cancelled_at?: true
    metadata?: true
    _all?: true
  }

  export type MEQSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQS to aggregate.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQS
    **/
    _count?: true | MEQSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSMaxAggregateInputType
  }

  export type GetMEQSAggregateType<T extends MEQSAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQS[P]>
      : GetScalarType<T[P], AggregateMEQS[P]>
  }




  export type MEQSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSWhereInput
    orderBy?: MEQSOrderByWithAggregationInput | MEQSOrderByWithAggregationInput[]
    by: MEQSScalarFieldEnum[] | MEQSScalarFieldEnum
    having?: MEQSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSCountAggregateInputType | true
    _min?: MEQSMinAggregateInputType
    _max?: MEQSMaxAggregateInputType
  }

  export type MEQSGroupByOutputType = {
    id: string
    jo_id: string | null
    jo_number: string | null
    rv_id: string | null
    rv_number: string | null
    spr_id: string | null
    spr_number: string | null
    meqs_number: string
    meqs_date: Date
    notes: string
    created_by: string
    updated_by: string | null
    cancelled_by: string | null
    created_at: Date
    updated_at: Date
    cancelled_at: Date | null
    metadata: JsonValue | null
    _count: MEQSCountAggregateOutputType | null
    _min: MEQSMinAggregateOutputType | null
    _max: MEQSMaxAggregateOutputType | null
  }

  type GetMEQSGroupByPayload<T extends MEQSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_id?: boolean
    jo_number?: boolean
    rv_id?: boolean
    rv_number?: boolean
    spr_id?: boolean
    spr_number?: boolean
    meqs_number?: boolean
    meqs_date?: boolean
    notes?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    cancelled_at?: boolean
    metadata?: boolean
    jo?: boolean | MEQS$joArgs<ExtArgs>
    rv?: boolean | MEQS$rvArgs<ExtArgs>
    spr?: boolean | MEQS$sprArgs<ExtArgs>
    meqs_approvers?: boolean | MEQS$meqs_approversArgs<ExtArgs>
    meqs_suppliers?: boolean | MEQS$meqs_suppliersArgs<ExtArgs>
    _count?: boolean | MEQSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQS"]>

  export type MEQSSelectScalar = {
    id?: boolean
    jo_id?: boolean
    jo_number?: boolean
    rv_id?: boolean
    rv_number?: boolean
    spr_id?: boolean
    spr_number?: boolean
    meqs_number?: boolean
    meqs_date?: boolean
    notes?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    cancelled_at?: boolean
    metadata?: boolean
  }

  export type MEQSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo?: boolean | MEQS$joArgs<ExtArgs>
    rv?: boolean | MEQS$rvArgs<ExtArgs>
    spr?: boolean | MEQS$sprArgs<ExtArgs>
    meqs_approvers?: boolean | MEQS$meqs_approversArgs<ExtArgs>
    meqs_suppliers?: boolean | MEQS$meqs_suppliersArgs<ExtArgs>
    _count?: boolean | MEQSCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MEQSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQS"
    objects: {
      jo: Prisma.$JOPayload<ExtArgs> | null
      rv: Prisma.$RVPayload<ExtArgs> | null
      spr: Prisma.$SPRPayload<ExtArgs> | null
      meqs_approvers: Prisma.$MEQSApproverPayload<ExtArgs>[]
      meqs_suppliers: Prisma.$MEQSSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_id: string | null
      jo_number: string | null
      rv_id: string | null
      rv_number: string | null
      spr_id: string | null
      spr_number: string | null
      meqs_number: string
      meqs_date: Date
      notes: string
      created_by: string
      updated_by: string | null
      cancelled_by: string | null
      created_at: Date
      updated_at: Date
      cancelled_at: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mEQS"]>
    composites: {}
  }


  type MEQSGetPayload<S extends boolean | null | undefined | MEQSDefaultArgs> = $Result.GetResult<Prisma.$MEQSPayload, S>

  type MEQSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSCountAggregateInputType | true
    }

  export interface MEQSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQS'], meta: { name: 'MEQS' } }
    /**
     * Find zero or one MEQS that matches the filter.
     * @param {MEQSFindUniqueArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQS that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSFindUniqueOrThrowArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindFirstArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindFirstOrThrowArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQS
     * const mEQS = await prisma.mEQS.findMany()
     * 
     * // Get first 10 MEQS
     * const mEQS = await prisma.mEQS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSWithIdOnly = await prisma.mEQS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQS.
     * @param {MEQSCreateArgs} args - Arguments to create a MEQS.
     * @example
     * // Create one MEQS
     * const MEQS = await prisma.mEQS.create({
     *   data: {
     *     // ... data to create a MEQS
     *   }
     * })
     * 
    **/
    create<T extends MEQSCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSCreateArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQS.
     *     @param {MEQSCreateManyArgs} args - Arguments to create many MEQS.
     *     @example
     *     // Create many MEQS
     *     const mEQS = await prisma.mEQS.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQS.
     * @param {MEQSDeleteArgs} args - Arguments to delete one MEQS.
     * @example
     * // Delete one MEQS
     * const MEQS = await prisma.mEQS.delete({
     *   where: {
     *     // ... filter to delete one MEQS
     *   }
     * })
     * 
    **/
    delete<T extends MEQSDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSDeleteArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQS.
     * @param {MEQSUpdateArgs} args - Arguments to update one MEQS.
     * @example
     * // Update one MEQS
     * const mEQS = await prisma.mEQS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpdateArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQS.
     * @param {MEQSDeleteManyArgs} args - Arguments to filter MEQS to delete.
     * @example
     * // Delete a few MEQS
     * const { count } = await prisma.mEQS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQS
     * const mEQS = await prisma.mEQS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQS.
     * @param {MEQSUpsertArgs} args - Arguments to update or create a MEQS.
     * @example
     * // Update or create a MEQS
     * const mEQS = await prisma.mEQS.upsert({
     *   create: {
     *     // ... data to create a MEQS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQS we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpsertArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSCountArgs} args - Arguments to filter MEQS to count.
     * @example
     * // Count the number of MEQS
     * const count = await prisma.mEQS.count({
     *   where: {
     *     // ... the filter for the MEQS we want to count
     *   }
     * })
    **/
    count<T extends MEQSCountArgs>(
      args?: Subset<T, MEQSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSAggregateArgs>(args: Subset<T, MEQSAggregateArgs>): Prisma.PrismaPromise<GetMEQSAggregateType<T>>

    /**
     * Group by MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSGroupByArgs['orderBy'] }
        : { orderBy?: MEQSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQS model
   */
  readonly fields: MEQSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jo<T extends MEQS$joArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$joArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv<T extends MEQS$rvArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$rvArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    spr<T extends MEQS$sprArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$sprArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs_approvers<T extends MEQS$meqs_approversArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$meqs_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    meqs_suppliers<T extends MEQS$meqs_suppliersArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$meqs_suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQS model
   */ 
  interface MEQSFieldRefs {
    readonly id: FieldRef<"MEQS", 'String'>
    readonly jo_id: FieldRef<"MEQS", 'String'>
    readonly jo_number: FieldRef<"MEQS", 'String'>
    readonly rv_id: FieldRef<"MEQS", 'String'>
    readonly rv_number: FieldRef<"MEQS", 'String'>
    readonly spr_id: FieldRef<"MEQS", 'String'>
    readonly spr_number: FieldRef<"MEQS", 'String'>
    readonly meqs_number: FieldRef<"MEQS", 'String'>
    readonly meqs_date: FieldRef<"MEQS", 'DateTime'>
    readonly notes: FieldRef<"MEQS", 'String'>
    readonly created_by: FieldRef<"MEQS", 'String'>
    readonly updated_by: FieldRef<"MEQS", 'String'>
    readonly cancelled_by: FieldRef<"MEQS", 'String'>
    readonly created_at: FieldRef<"MEQS", 'DateTime'>
    readonly updated_at: FieldRef<"MEQS", 'DateTime'>
    readonly cancelled_at: FieldRef<"MEQS", 'DateTime'>
    readonly metadata: FieldRef<"MEQS", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MEQS findUnique
   */
  export type MEQSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS findUniqueOrThrow
   */
  export type MEQSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS findFirst
   */
  export type MEQSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQS.
     */
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS findFirstOrThrow
   */
  export type MEQSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQS.
     */
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS findMany
   */
  export type MEQSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS create
   */
  export type MEQSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQS.
     */
    data: XOR<MEQSCreateInput, MEQSUncheckedCreateInput>
  }


  /**
   * MEQS createMany
   */
  export type MEQSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQS.
     */
    data: MEQSCreateManyInput | MEQSCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQS update
   */
  export type MEQSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQS.
     */
    data: XOR<MEQSUpdateInput, MEQSUncheckedUpdateInput>
    /**
     * Choose, which MEQS to update.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS updateMany
   */
  export type MEQSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQS.
     */
    data: XOR<MEQSUpdateManyMutationInput, MEQSUncheckedUpdateManyInput>
    /**
     * Filter which MEQS to update
     */
    where?: MEQSWhereInput
  }


  /**
   * MEQS upsert
   */
  export type MEQSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQS to update in case it exists.
     */
    where: MEQSWhereUniqueInput
    /**
     * In case the MEQS found by the `where` argument doesn't exist, create a new MEQS with this data.
     */
    create: XOR<MEQSCreateInput, MEQSUncheckedCreateInput>
    /**
     * In case the MEQS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSUpdateInput, MEQSUncheckedUpdateInput>
  }


  /**
   * MEQS delete
   */
  export type MEQSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter which MEQS to delete.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS deleteMany
   */
  export type MEQSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQS to delete
     */
    where?: MEQSWhereInput
  }


  /**
   * MEQS.jo
   */
  export type MEQS$joArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    where?: JOWhereInput
  }


  /**
   * MEQS.rv
   */
  export type MEQS$rvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    where?: RVWhereInput
  }


  /**
   * MEQS.spr
   */
  export type MEQS$sprArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
  }


  /**
   * MEQS.meqs_approvers
   */
  export type MEQS$meqs_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    where?: MEQSApproverWhereInput
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    cursor?: MEQSApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQS.meqs_suppliers
   */
  export type MEQS$meqs_suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    cursor?: MEQSSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQS without action
   */
  export type MEQSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplier
   */

  export type AggregateMEQSSupplier = {
    _count: MEQSSupplierCountAggregateOutputType | null
    _min: MEQSSupplierMinAggregateOutputType | null
    _max: MEQSSupplierMaxAggregateOutputType | null
  }

  export type MEQSSupplierMinAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    supplier_id: string | null
    payment_terms: string | null
  }

  export type MEQSSupplierMaxAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    supplier_id: string | null
    payment_terms: string | null
  }

  export type MEQSSupplierCountAggregateOutputType = {
    id: number
    meqs_id: number
    supplier_id: number
    payment_terms: number
    metadata: number
    _all: number
  }


  export type MEQSSupplierMinAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
  }

  export type MEQSSupplierMaxAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
  }

  export type MEQSSupplierCountAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
    metadata?: true
    _all?: true
  }

  export type MEQSSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplier to aggregate.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSuppliers
    **/
    _count?: true | MEQSSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierMaxAggregateInputType
  }

  export type GetMEQSSupplierAggregateType<T extends MEQSSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplier[P]>
      : GetScalarType<T[P], AggregateMEQSSupplier[P]>
  }




  export type MEQSSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithAggregationInput | MEQSSupplierOrderByWithAggregationInput[]
    by: MEQSSupplierScalarFieldEnum[] | MEQSSupplierScalarFieldEnum
    having?: MEQSSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierCountAggregateInputType | true
    _min?: MEQSSupplierMinAggregateInputType
    _max?: MEQSSupplierMaxAggregateInputType
  }

  export type MEQSSupplierGroupByOutputType = {
    id: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata: JsonValue | null
    _count: MEQSSupplierCountAggregateOutputType | null
    _min: MEQSSupplierMinAggregateOutputType | null
    _max: MEQSSupplierMaxAggregateOutputType | null
  }

  type GetMEQSSupplierGroupByPayload<T extends MEQSSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_id?: boolean
    supplier_id?: boolean
    payment_terms?: boolean
    metadata?: boolean
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    attachments?: boolean | MEQSSupplier$attachmentsArgs<ExtArgs>
    meqs_supplier_items?: boolean | MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>
    po?: boolean | MEQSSupplier$poArgs<ExtArgs>
    _count?: boolean | MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplier"]>

  export type MEQSSupplierSelectScalar = {
    id?: boolean
    meqs_id?: boolean
    supplier_id?: boolean
    payment_terms?: boolean
    metadata?: boolean
  }

  export type MEQSSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    attachments?: boolean | MEQSSupplier$attachmentsArgs<ExtArgs>
    meqs_supplier_items?: boolean | MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>
    po?: boolean | MEQSSupplier$poArgs<ExtArgs>
    _count?: boolean | MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplier"
    objects: {
      meqs: Prisma.$MEQSPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      attachments: Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>[]
      meqs_supplier_items: Prisma.$MEQSSupplierItemPayload<ExtArgs>[]
      po: Prisma.$POPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_id: string
      supplier_id: string
      payment_terms: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mEQSSupplier"]>
    composites: {}
  }


  type MEQSSupplierGetPayload<S extends boolean | null | undefined | MEQSSupplierDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierPayload, S>

  type MEQSSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierCountAggregateInputType | true
    }

  export interface MEQSSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplier'], meta: { name: 'MEQSSupplier' } }
    /**
     * Find zero or one MEQSSupplier that matches the filter.
     * @param {MEQSSupplierFindUniqueArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindFirstArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSuppliers
     * const mEQSSuppliers = await prisma.mEQSSupplier.findMany()
     * 
     * // Get first 10 MEQSSuppliers
     * const mEQSSuppliers = await prisma.mEQSSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierWithIdOnly = await prisma.mEQSSupplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplier.
     * @param {MEQSSupplierCreateArgs} args - Arguments to create a MEQSSupplier.
     * @example
     * // Create one MEQSSupplier
     * const MEQSSupplier = await prisma.mEQSSupplier.create({
     *   data: {
     *     // ... data to create a MEQSSupplier
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSuppliers.
     *     @param {MEQSSupplierCreateManyArgs} args - Arguments to create many MEQSSuppliers.
     *     @example
     *     // Create many MEQSSuppliers
     *     const mEQSSupplier = await prisma.mEQSSupplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplier.
     * @param {MEQSSupplierDeleteArgs} args - Arguments to delete one MEQSSupplier.
     * @example
     * // Delete one MEQSSupplier
     * const MEQSSupplier = await prisma.mEQSSupplier.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplier
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplier.
     * @param {MEQSSupplierUpdateArgs} args - Arguments to update one MEQSSupplier.
     * @example
     * // Update one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSuppliers.
     * @param {MEQSSupplierDeleteManyArgs} args - Arguments to filter MEQSSuppliers to delete.
     * @example
     * // Delete a few MEQSSuppliers
     * const { count } = await prisma.mEQSSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSuppliers
     * const mEQSSupplier = await prisma.mEQSSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplier.
     * @param {MEQSSupplierUpsertArgs} args - Arguments to update or create a MEQSSupplier.
     * @example
     * // Update or create a MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplier we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierCountArgs} args - Arguments to filter MEQSSuppliers to count.
     * @example
     * // Count the number of MEQSSuppliers
     * const count = await prisma.mEQSSupplier.count({
     *   where: {
     *     // ... the filter for the MEQSSuppliers we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierCountArgs>(
      args?: Subset<T, MEQSSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierAggregateArgs>(args: Subset<T, MEQSSupplierAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierAggregateType<T>>

    /**
     * Group by MEQSSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplier model
   */
  readonly fields: MEQSSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs<T extends MEQSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSDefaultArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    attachments<T extends MEQSSupplier$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    meqs_supplier_items<T extends MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    po<T extends MEQSSupplier$poArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$poArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplier model
   */ 
  interface MEQSSupplierFieldRefs {
    readonly id: FieldRef<"MEQSSupplier", 'String'>
    readonly meqs_id: FieldRef<"MEQSSupplier", 'String'>
    readonly supplier_id: FieldRef<"MEQSSupplier", 'String'>
    readonly payment_terms: FieldRef<"MEQSSupplier", 'String'>
    readonly metadata: FieldRef<"MEQSSupplier", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplier findUnique
   */
  export type MEQSSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier findUniqueOrThrow
   */
  export type MEQSSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier findFirst
   */
  export type MEQSSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSuppliers.
     */
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier findFirstOrThrow
   */
  export type MEQSSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSuppliers.
     */
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier findMany
   */
  export type MEQSSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSuppliers to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier create
   */
  export type MEQSSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplier.
     */
    data: XOR<MEQSSupplierCreateInput, MEQSSupplierUncheckedCreateInput>
  }


  /**
   * MEQSSupplier createMany
   */
  export type MEQSSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSuppliers.
     */
    data: MEQSSupplierCreateManyInput | MEQSSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplier update
   */
  export type MEQSSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplier.
     */
    data: XOR<MEQSSupplierUpdateInput, MEQSSupplierUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplier to update.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier updateMany
   */
  export type MEQSSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSuppliers.
     */
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSuppliers to update
     */
    where?: MEQSSupplierWhereInput
  }


  /**
   * MEQSSupplier upsert
   */
  export type MEQSSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplier to update in case it exists.
     */
    where: MEQSSupplierWhereUniqueInput
    /**
     * In case the MEQSSupplier found by the `where` argument doesn't exist, create a new MEQSSupplier with this data.
     */
    create: XOR<MEQSSupplierCreateInput, MEQSSupplierUncheckedCreateInput>
    /**
     * In case the MEQSSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierUpdateInput, MEQSSupplierUncheckedUpdateInput>
  }


  /**
   * MEQSSupplier delete
   */
  export type MEQSSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplier to delete.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier deleteMany
   */
  export type MEQSSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSuppliers to delete
     */
    where?: MEQSSupplierWhereInput
  }


  /**
   * MEQSSupplier.attachments
   */
  export type MEQSSupplier$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    where?: MEQSSupplierAttachmentWhereInput
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplier.meqs_supplier_items
   */
  export type MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    cursor?: MEQSSupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplier.po
   */
  export type MEQSSupplier$poArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    where?: POWhereInput
  }


  /**
   * MEQSSupplier without action
   */
  export type MEQSSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplierItem
   */

  export type AggregateMEQSSupplierItem = {
    _count: MEQSSupplierItemCountAggregateOutputType | null
    _avg: MEQSSupplierItemAvgAggregateOutputType | null
    _sum: MEQSSupplierItemSumAggregateOutputType | null
    _min: MEQSSupplierItemMinAggregateOutputType | null
    _max: MEQSSupplierItemMaxAggregateOutputType | null
  }

  export type MEQSSupplierItemAvgAggregateOutputType = {
    price: number | null
    vat_type: number | null
  }

  export type MEQSSupplierItemSumAggregateOutputType = {
    price: number | null
    vat_type: number | null
  }

  export type MEQSSupplierItemMinAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    canvass_item_id: string | null
    price: number | null
    notes: string | null
    is_awarded: boolean | null
    vat_type: number | null
  }

  export type MEQSSupplierItemMaxAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    canvass_item_id: string | null
    price: number | null
    notes: string | null
    is_awarded: boolean | null
    vat_type: number | null
  }

  export type MEQSSupplierItemCountAggregateOutputType = {
    id: number
    meqs_supplier_id: number
    canvass_item_id: number
    price: number
    notes: number
    is_awarded: number
    vat_type: number
    metadata: number
    _all: number
  }


  export type MEQSSupplierItemAvgAggregateInputType = {
    price?: true
    vat_type?: true
  }

  export type MEQSSupplierItemSumAggregateInputType = {
    price?: true
    vat_type?: true
  }

  export type MEQSSupplierItemMinAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    canvass_item_id?: true
    price?: true
    notes?: true
    is_awarded?: true
    vat_type?: true
  }

  export type MEQSSupplierItemMaxAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    canvass_item_id?: true
    price?: true
    notes?: true
    is_awarded?: true
    vat_type?: true
  }

  export type MEQSSupplierItemCountAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    canvass_item_id?: true
    price?: true
    notes?: true
    is_awarded?: true
    vat_type?: true
    metadata?: true
    _all?: true
  }

  export type MEQSSupplierItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierItem to aggregate.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSupplierItems
    **/
    _count?: true | MEQSSupplierItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEQSSupplierItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEQSSupplierItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierItemMaxAggregateInputType
  }

  export type GetMEQSSupplierItemAggregateType<T extends MEQSSupplierItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplierItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplierItem[P]>
      : GetScalarType<T[P], AggregateMEQSSupplierItem[P]>
  }




  export type MEQSSupplierItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithAggregationInput | MEQSSupplierItemOrderByWithAggregationInput[]
    by: MEQSSupplierItemScalarFieldEnum[] | MEQSSupplierItemScalarFieldEnum
    having?: MEQSSupplierItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierItemCountAggregateInputType | true
    _avg?: MEQSSupplierItemAvgAggregateInputType
    _sum?: MEQSSupplierItemSumAggregateInputType
    _min?: MEQSSupplierItemMinAggregateInputType
    _max?: MEQSSupplierItemMaxAggregateInputType
  }

  export type MEQSSupplierItemGroupByOutputType = {
    id: string
    meqs_supplier_id: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded: boolean
    vat_type: number
    metadata: JsonValue | null
    _count: MEQSSupplierItemCountAggregateOutputType | null
    _avg: MEQSSupplierItemAvgAggregateOutputType | null
    _sum: MEQSSupplierItemSumAggregateOutputType | null
    _min: MEQSSupplierItemMinAggregateOutputType | null
    _max: MEQSSupplierItemMaxAggregateOutputType | null
  }

  type GetMEQSSupplierItemGroupByPayload<T extends MEQSSupplierItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierItemGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierItemGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_supplier_id?: boolean
    canvass_item_id?: boolean
    price?: boolean
    notes?: boolean
    is_awarded?: boolean
    vat_type?: boolean
    metadata?: boolean
    canvass_item?: boolean | CanvassItemDefaultArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
    rr_items?: boolean | MEQSSupplierItem$rr_itemsArgs<ExtArgs>
    _count?: boolean | MEQSSupplierItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplierItem"]>

  export type MEQSSupplierItemSelectScalar = {
    id?: boolean
    meqs_supplier_id?: boolean
    canvass_item_id?: boolean
    price?: boolean
    notes?: boolean
    is_awarded?: boolean
    vat_type?: boolean
    metadata?: boolean
  }

  export type MEQSSupplierItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_item?: boolean | CanvassItemDefaultArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
    rr_items?: boolean | MEQSSupplierItem$rr_itemsArgs<ExtArgs>
    _count?: boolean | MEQSSupplierItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplierItem"
    objects: {
      canvass_item: Prisma.$CanvassItemPayload<ExtArgs>
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs>
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_supplier_id: string
      canvass_item_id: string
      price: number
      notes: string
      is_awarded: boolean
      vat_type: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mEQSSupplierItem"]>
    composites: {}
  }


  type MEQSSupplierItemGetPayload<S extends boolean | null | undefined | MEQSSupplierItemDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierItemPayload, S>

  type MEQSSupplierItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierItemCountAggregateInputType | true
    }

  export interface MEQSSupplierItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplierItem'], meta: { name: 'MEQSSupplierItem' } }
    /**
     * Find zero or one MEQSSupplierItem that matches the filter.
     * @param {MEQSSupplierItemFindUniqueArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplierItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierItemFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplierItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindFirstArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplierItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSupplierItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSupplierItems
     * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany()
     * 
     * // Get first 10 MEQSSupplierItems
     * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierItemWithIdOnly = await prisma.mEQSSupplierItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplierItem.
     * @param {MEQSSupplierItemCreateArgs} args - Arguments to create a MEQSSupplierItem.
     * @example
     * // Create one MEQSSupplierItem
     * const MEQSSupplierItem = await prisma.mEQSSupplierItem.create({
     *   data: {
     *     // ... data to create a MEQSSupplierItem
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSupplierItems.
     *     @param {MEQSSupplierItemCreateManyArgs} args - Arguments to create many MEQSSupplierItems.
     *     @example
     *     // Create many MEQSSupplierItems
     *     const mEQSSupplierItem = await prisma.mEQSSupplierItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplierItem.
     * @param {MEQSSupplierItemDeleteArgs} args - Arguments to delete one MEQSSupplierItem.
     * @example
     * // Delete one MEQSSupplierItem
     * const MEQSSupplierItem = await prisma.mEQSSupplierItem.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplierItem
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplierItem.
     * @param {MEQSSupplierItemUpdateArgs} args - Arguments to update one MEQSSupplierItem.
     * @example
     * // Update one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSupplierItems.
     * @param {MEQSSupplierItemDeleteManyArgs} args - Arguments to filter MEQSSupplierItems to delete.
     * @example
     * // Delete a few MEQSSupplierItems
     * const { count } = await prisma.mEQSSupplierItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSupplierItems
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplierItem.
     * @param {MEQSSupplierItemUpsertArgs} args - Arguments to update or create a MEQSSupplierItem.
     * @example
     * // Update or create a MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplierItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplierItem we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemCountArgs} args - Arguments to filter MEQSSupplierItems to count.
     * @example
     * // Count the number of MEQSSupplierItems
     * const count = await prisma.mEQSSupplierItem.count({
     *   where: {
     *     // ... the filter for the MEQSSupplierItems we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierItemCountArgs>(
      args?: Subset<T, MEQSSupplierItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierItemAggregateArgs>(args: Subset<T, MEQSSupplierItemAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierItemAggregateType<T>>

    /**
     * Group by MEQSSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierItemGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplierItem model
   */
  readonly fields: MEQSSupplierItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplierItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_item<T extends CanvassItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItemDefaultArgs<ExtArgs>>): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meqs_supplier<T extends MEQSSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rr_items<T extends MEQSSupplierItem$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierItem$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplierItem model
   */ 
  interface MEQSSupplierItemFieldRefs {
    readonly id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly meqs_supplier_id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly canvass_item_id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly price: FieldRef<"MEQSSupplierItem", 'Float'>
    readonly notes: FieldRef<"MEQSSupplierItem", 'String'>
    readonly is_awarded: FieldRef<"MEQSSupplierItem", 'Boolean'>
    readonly vat_type: FieldRef<"MEQSSupplierItem", 'Int'>
    readonly metadata: FieldRef<"MEQSSupplierItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplierItem findUnique
   */
  export type MEQSSupplierItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem findUniqueOrThrow
   */
  export type MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem findFirst
   */
  export type MEQSSupplierItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierItems.
     */
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem findFirstOrThrow
   */
  export type MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierItems.
     */
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem findMany
   */
  export type MEQSSupplierItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItems to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem create
   */
  export type MEQSSupplierItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplierItem.
     */
    data: XOR<MEQSSupplierItemCreateInput, MEQSSupplierItemUncheckedCreateInput>
  }


  /**
   * MEQSSupplierItem createMany
   */
  export type MEQSSupplierItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSupplierItems.
     */
    data: MEQSSupplierItemCreateManyInput | MEQSSupplierItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplierItem update
   */
  export type MEQSSupplierItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplierItem.
     */
    data: XOR<MEQSSupplierItemUpdateInput, MEQSSupplierItemUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplierItem to update.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem updateMany
   */
  export type MEQSSupplierItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSupplierItems.
     */
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSupplierItems to update
     */
    where?: MEQSSupplierItemWhereInput
  }


  /**
   * MEQSSupplierItem upsert
   */
  export type MEQSSupplierItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplierItem to update in case it exists.
     */
    where: MEQSSupplierItemWhereUniqueInput
    /**
     * In case the MEQSSupplierItem found by the `where` argument doesn't exist, create a new MEQSSupplierItem with this data.
     */
    create: XOR<MEQSSupplierItemCreateInput, MEQSSupplierItemUncheckedCreateInput>
    /**
     * In case the MEQSSupplierItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierItemUpdateInput, MEQSSupplierItemUncheckedUpdateInput>
  }


  /**
   * MEQSSupplierItem delete
   */
  export type MEQSSupplierItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplierItem to delete.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem deleteMany
   */
  export type MEQSSupplierItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierItems to delete
     */
    where?: MEQSSupplierItemWhereInput
  }


  /**
   * MEQSSupplierItem.rr_items
   */
  export type MEQSSupplierItem$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem without action
   */
  export type MEQSSupplierItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplierAttachment
   */

  export type AggregateMEQSSupplierAttachment = {
    _count: MEQSSupplierAttachmentCountAggregateOutputType | null
    _min: MEQSSupplierAttachmentMinAggregateOutputType | null
    _max: MEQSSupplierAttachmentMaxAggregateOutputType | null
  }

  export type MEQSSupplierAttachmentMinAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    filename: string | null
    src: string | null
  }

  export type MEQSSupplierAttachmentMaxAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    filename: string | null
    src: string | null
  }

  export type MEQSSupplierAttachmentCountAggregateOutputType = {
    id: number
    meqs_supplier_id: number
    filename: number
    src: number
    metadata: number
    _all: number
  }


  export type MEQSSupplierAttachmentMinAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    filename?: true
    src?: true
  }

  export type MEQSSupplierAttachmentMaxAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    filename?: true
    src?: true
  }

  export type MEQSSupplierAttachmentCountAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    filename?: true
    src?: true
    metadata?: true
    _all?: true
  }

  export type MEQSSupplierAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierAttachment to aggregate.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSupplierAttachments
    **/
    _count?: true | MEQSSupplierAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierAttachmentMaxAggregateInputType
  }

  export type GetMEQSSupplierAttachmentAggregateType<T extends MEQSSupplierAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplierAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplierAttachment[P]>
      : GetScalarType<T[P], AggregateMEQSSupplierAttachment[P]>
  }




  export type MEQSSupplierAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierAttachmentWhereInput
    orderBy?: MEQSSupplierAttachmentOrderByWithAggregationInput | MEQSSupplierAttachmentOrderByWithAggregationInput[]
    by: MEQSSupplierAttachmentScalarFieldEnum[] | MEQSSupplierAttachmentScalarFieldEnum
    having?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierAttachmentCountAggregateInputType | true
    _min?: MEQSSupplierAttachmentMinAggregateInputType
    _max?: MEQSSupplierAttachmentMaxAggregateInputType
  }

  export type MEQSSupplierAttachmentGroupByOutputType = {
    id: string
    meqs_supplier_id: string
    filename: string
    src: string
    metadata: JsonValue | null
    _count: MEQSSupplierAttachmentCountAggregateOutputType | null
    _min: MEQSSupplierAttachmentMinAggregateOutputType | null
    _max: MEQSSupplierAttachmentMaxAggregateOutputType | null
  }

  type GetMEQSSupplierAttachmentGroupByPayload<T extends MEQSSupplierAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_supplier_id?: boolean
    filename?: boolean
    src?: boolean
    metadata?: boolean
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplierAttachment"]>

  export type MEQSSupplierAttachmentSelectScalar = {
    id?: boolean
    meqs_supplier_id?: boolean
    filename?: boolean
    src?: boolean
    metadata?: boolean
  }

  export type MEQSSupplierAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplierAttachment"
    objects: {
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_supplier_id: string
      filename: string
      src: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mEQSSupplierAttachment"]>
    composites: {}
  }


  type MEQSSupplierAttachmentGetPayload<S extends boolean | null | undefined | MEQSSupplierAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload, S>

  type MEQSSupplierAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierAttachmentCountAggregateInputType | true
    }

  export interface MEQSSupplierAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplierAttachment'], meta: { name: 'MEQSSupplierAttachment' } }
    /**
     * Find zero or one MEQSSupplierAttachment that matches the filter.
     * @param {MEQSSupplierAttachmentFindUniqueArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplierAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplierAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindFirstArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplierAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSupplierAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSupplierAttachments
     * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany()
     * 
     * // Get first 10 MEQSSupplierAttachments
     * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierAttachmentWithIdOnly = await prisma.mEQSSupplierAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentCreateArgs} args - Arguments to create a MEQSSupplierAttachment.
     * @example
     * // Create one MEQSSupplierAttachment
     * const MEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.create({
     *   data: {
     *     // ... data to create a MEQSSupplierAttachment
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSupplierAttachments.
     *     @param {MEQSSupplierAttachmentCreateManyArgs} args - Arguments to create many MEQSSupplierAttachments.
     *     @example
     *     // Create many MEQSSupplierAttachments
     *     const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentDeleteArgs} args - Arguments to delete one MEQSSupplierAttachment.
     * @example
     * // Delete one MEQSSupplierAttachment
     * const MEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplierAttachment
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentUpdateArgs} args - Arguments to update one MEQSSupplierAttachment.
     * @example
     * // Update one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSupplierAttachments.
     * @param {MEQSSupplierAttachmentDeleteManyArgs} args - Arguments to filter MEQSSupplierAttachments to delete.
     * @example
     * // Delete a few MEQSSupplierAttachments
     * const { count } = await prisma.mEQSSupplierAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSupplierAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSupplierAttachments
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentUpsertArgs} args - Arguments to update or create a MEQSSupplierAttachment.
     * @example
     * // Update or create a MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplierAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplierAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSupplierAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentCountArgs} args - Arguments to filter MEQSSupplierAttachments to count.
     * @example
     * // Count the number of MEQSSupplierAttachments
     * const count = await prisma.mEQSSupplierAttachment.count({
     *   where: {
     *     // ... the filter for the MEQSSupplierAttachments we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierAttachmentCountArgs>(
      args?: Subset<T, MEQSSupplierAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplierAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierAttachmentAggregateArgs>(args: Subset<T, MEQSSupplierAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierAttachmentAggregateType<T>>

    /**
     * Group by MEQSSupplierAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplierAttachment model
   */
  readonly fields: MEQSSupplierAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplierAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs_supplier<T extends MEQSSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplierAttachment model
   */ 
  interface MEQSSupplierAttachmentFieldRefs {
    readonly id: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly meqs_supplier_id: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly filename: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly src: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly metadata: FieldRef<"MEQSSupplierAttachment", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplierAttachment findUnique
   */
  export type MEQSSupplierAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment findUniqueOrThrow
   */
  export type MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment findFirst
   */
  export type MEQSSupplierAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierAttachments.
     */
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment findFirstOrThrow
   */
  export type MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierAttachments.
     */
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment findMany
   */
  export type MEQSSupplierAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachments to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment create
   */
  export type MEQSSupplierAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplierAttachment.
     */
    data: XOR<MEQSSupplierAttachmentCreateInput, MEQSSupplierAttachmentUncheckedCreateInput>
  }


  /**
   * MEQSSupplierAttachment createMany
   */
  export type MEQSSupplierAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSupplierAttachments.
     */
    data: MEQSSupplierAttachmentCreateManyInput | MEQSSupplierAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplierAttachment update
   */
  export type MEQSSupplierAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplierAttachment.
     */
    data: XOR<MEQSSupplierAttachmentUpdateInput, MEQSSupplierAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplierAttachment to update.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment updateMany
   */
  export type MEQSSupplierAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSupplierAttachments.
     */
    data: XOR<MEQSSupplierAttachmentUpdateManyMutationInput, MEQSSupplierAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSupplierAttachments to update
     */
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierAttachment upsert
   */
  export type MEQSSupplierAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplierAttachment to update in case it exists.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * In case the MEQSSupplierAttachment found by the `where` argument doesn't exist, create a new MEQSSupplierAttachment with this data.
     */
    create: XOR<MEQSSupplierAttachmentCreateInput, MEQSSupplierAttachmentUncheckedCreateInput>
    /**
     * In case the MEQSSupplierAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierAttachmentUpdateInput, MEQSSupplierAttachmentUncheckedUpdateInput>
  }


  /**
   * MEQSSupplierAttachment delete
   */
  export type MEQSSupplierAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplierAttachment to delete.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment deleteMany
   */
  export type MEQSSupplierAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierAttachments to delete
     */
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierAttachment without action
   */
  export type MEQSSupplierAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model MEQSApprover
   */

  export type AggregateMEQSApprover = {
    _count: MEQSApproverCountAggregateOutputType | null
    _avg: MEQSApproverAvgAggregateOutputType | null
    _sum: MEQSApproverSumAggregateOutputType | null
    _min: MEQSApproverMinAggregateOutputType | null
    _max: MEQSApproverMaxAggregateOutputType | null
  }

  export type MEQSApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MEQSApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MEQSApproverMinAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type MEQSApproverMaxAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type MEQSApproverCountAggregateOutputType = {
    id: number
    meqs_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    metadata: number
    _all: number
  }


  export type MEQSApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MEQSApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MEQSApproverMinAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type MEQSApproverMaxAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type MEQSApproverCountAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    metadata?: true
    _all?: true
  }

  export type MEQSApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSApprover to aggregate.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSApprovers
    **/
    _count?: true | MEQSApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEQSApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEQSApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSApproverMaxAggregateInputType
  }

  export type GetMEQSApproverAggregateType<T extends MEQSApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSApprover[P]>
      : GetScalarType<T[P], AggregateMEQSApprover[P]>
  }




  export type MEQSApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSApproverWhereInput
    orderBy?: MEQSApproverOrderByWithAggregationInput | MEQSApproverOrderByWithAggregationInput[]
    by: MEQSApproverScalarFieldEnum[] | MEQSApproverScalarFieldEnum
    having?: MEQSApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSApproverCountAggregateInputType | true
    _avg?: MEQSApproverAvgAggregateInputType
    _sum?: MEQSApproverSumAggregateInputType
    _min?: MEQSApproverMinAggregateInputType
    _max?: MEQSApproverMaxAggregateInputType
  }

  export type MEQSApproverGroupByOutputType = {
    id: string
    meqs_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    order: number
    metadata: JsonValue | null
    _count: MEQSApproverCountAggregateOutputType | null
    _avg: MEQSApproverAvgAggregateOutputType | null
    _sum: MEQSApproverSumAggregateOutputType | null
    _min: MEQSApproverMinAggregateOutputType | null
    _max: MEQSApproverMaxAggregateOutputType | null
  }

  type GetMEQSApproverGroupByPayload<T extends MEQSApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSApproverGroupByOutputType[P]>
        }
      >
    >


  export type MEQSApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSApprover"]>

  export type MEQSApproverSelectScalar = {
    id?: boolean
    meqs_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
  }

  export type MEQSApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
  }


  export type $MEQSApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSApprover"
    objects: {
      meqs: Prisma.$MEQSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      order: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mEQSApprover"]>
    composites: {}
  }


  type MEQSApproverGetPayload<S extends boolean | null | undefined | MEQSApproverDefaultArgs> = $Result.GetResult<Prisma.$MEQSApproverPayload, S>

  type MEQSApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSApproverCountAggregateInputType | true
    }

  export interface MEQSApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSApprover'], meta: { name: 'MEQSApprover' } }
    /**
     * Find zero or one MEQSApprover that matches the filter.
     * @param {MEQSApproverFindUniqueArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSApproverFindUniqueOrThrowArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindFirstArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindFirstOrThrowArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSApprovers
     * const mEQSApprovers = await prisma.mEQSApprover.findMany()
     * 
     * // Get first 10 MEQSApprovers
     * const mEQSApprovers = await prisma.mEQSApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSApproverWithIdOnly = await prisma.mEQSApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSApprover.
     * @param {MEQSApproverCreateArgs} args - Arguments to create a MEQSApprover.
     * @example
     * // Create one MEQSApprover
     * const MEQSApprover = await prisma.mEQSApprover.create({
     *   data: {
     *     // ... data to create a MEQSApprover
     *   }
     * })
     * 
    **/
    create<T extends MEQSApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverCreateArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSApprovers.
     *     @param {MEQSApproverCreateManyArgs} args - Arguments to create many MEQSApprovers.
     *     @example
     *     // Create many MEQSApprovers
     *     const mEQSApprover = await prisma.mEQSApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSApprover.
     * @param {MEQSApproverDeleteArgs} args - Arguments to delete one MEQSApprover.
     * @example
     * // Delete one MEQSApprover
     * const MEQSApprover = await prisma.mEQSApprover.delete({
     *   where: {
     *     // ... filter to delete one MEQSApprover
     *   }
     * })
     * 
    **/
    delete<T extends MEQSApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverDeleteArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSApprover.
     * @param {MEQSApproverUpdateArgs} args - Arguments to update one MEQSApprover.
     * @example
     * // Update one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpdateArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSApprovers.
     * @param {MEQSApproverDeleteManyArgs} args - Arguments to filter MEQSApprovers to delete.
     * @example
     * // Delete a few MEQSApprovers
     * const { count } = await prisma.mEQSApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSApprovers
     * const mEQSApprover = await prisma.mEQSApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSApprover.
     * @param {MEQSApproverUpsertArgs} args - Arguments to update or create a MEQSApprover.
     * @example
     * // Update or create a MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.upsert({
     *   create: {
     *     // ... data to create a MEQSApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpsertArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverCountArgs} args - Arguments to filter MEQSApprovers to count.
     * @example
     * // Count the number of MEQSApprovers
     * const count = await prisma.mEQSApprover.count({
     *   where: {
     *     // ... the filter for the MEQSApprovers we want to count
     *   }
     * })
    **/
    count<T extends MEQSApproverCountArgs>(
      args?: Subset<T, MEQSApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSApproverAggregateArgs>(args: Subset<T, MEQSApproverAggregateArgs>): Prisma.PrismaPromise<GetMEQSApproverAggregateType<T>>

    /**
     * Group by MEQSApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSApproverGroupByArgs['orderBy'] }
        : { orderBy?: MEQSApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSApprover model
   */
  readonly fields: MEQSApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs<T extends MEQSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSDefaultArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSApprover model
   */ 
  interface MEQSApproverFieldRefs {
    readonly id: FieldRef<"MEQSApprover", 'String'>
    readonly meqs_id: FieldRef<"MEQSApprover", 'String'>
    readonly approver_id: FieldRef<"MEQSApprover", 'String'>
    readonly date_approval: FieldRef<"MEQSApprover", 'DateTime'>
    readonly notes: FieldRef<"MEQSApprover", 'String'>
    readonly status: FieldRef<"MEQSApprover", 'Int'>
    readonly label: FieldRef<"MEQSApprover", 'String'>
    readonly order: FieldRef<"MEQSApprover", 'Int'>
    readonly metadata: FieldRef<"MEQSApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MEQSApprover findUnique
   */
  export type MEQSApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover findUniqueOrThrow
   */
  export type MEQSApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover findFirst
   */
  export type MEQSApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSApprovers.
     */
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover findFirstOrThrow
   */
  export type MEQSApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSApprovers.
     */
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover findMany
   */
  export type MEQSApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprovers to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover create
   */
  export type MEQSApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSApprover.
     */
    data: XOR<MEQSApproverCreateInput, MEQSApproverUncheckedCreateInput>
  }


  /**
   * MEQSApprover createMany
   */
  export type MEQSApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSApprovers.
     */
    data: MEQSApproverCreateManyInput | MEQSApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSApprover update
   */
  export type MEQSApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSApprover.
     */
    data: XOR<MEQSApproverUpdateInput, MEQSApproverUncheckedUpdateInput>
    /**
     * Choose, which MEQSApprover to update.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover updateMany
   */
  export type MEQSApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSApprovers.
     */
    data: XOR<MEQSApproverUpdateManyMutationInput, MEQSApproverUncheckedUpdateManyInput>
    /**
     * Filter which MEQSApprovers to update
     */
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSApprover upsert
   */
  export type MEQSApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSApprover to update in case it exists.
     */
    where: MEQSApproverWhereUniqueInput
    /**
     * In case the MEQSApprover found by the `where` argument doesn't exist, create a new MEQSApprover with this data.
     */
    create: XOR<MEQSApproverCreateInput, MEQSApproverUncheckedCreateInput>
    /**
     * In case the MEQSApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSApproverUpdateInput, MEQSApproverUncheckedUpdateInput>
  }


  /**
   * MEQSApprover delete
   */
  export type MEQSApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter which MEQSApprover to delete.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover deleteMany
   */
  export type MEQSApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSApprovers to delete
     */
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSApprover without action
   */
  export type MEQSApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
  }



  /**
   * Model PO
   */

  export type AggregatePO = {
    _count: POCountAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  export type POMinAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    meqs_number: string | null
    po_number: string | null
    fund_source_id: string | null
    po_date: Date | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type POMaxAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    meqs_number: string | null
    po_number: string | null
    fund_source_id: string | null
    po_date: Date | null
    notes: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type POCountAggregateOutputType = {
    id: number
    meqs_supplier_id: number
    meqs_number: number
    po_number: number
    fund_source_id: number
    po_date: number
    notes: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type POMinAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    meqs_number?: true
    po_number?: true
    fund_source_id?: true
    po_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type POMaxAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    meqs_number?: true
    po_number?: true
    fund_source_id?: true
    po_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type POCountAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    meqs_number?: true
    po_number?: true
    fund_source_id?: true
    po_date?: true
    notes?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type POAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PO to aggregate.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POS
    **/
    _count?: true | POCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POMaxAggregateInputType
  }

  export type GetPOAggregateType<T extends POAggregateArgs> = {
        [P in keyof T & keyof AggregatePO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePO[P]>
      : GetScalarType<T[P], AggregatePO[P]>
  }




  export type POGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POWhereInput
    orderBy?: POOrderByWithAggregationInput | POOrderByWithAggregationInput[]
    by: POScalarFieldEnum[] | POScalarFieldEnum
    having?: POScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POCountAggregateInputType | true
    _min?: POMinAggregateInputType
    _max?: POMaxAggregateInputType
  }

  export type POGroupByOutputType = {
    id: string
    meqs_supplier_id: string | null
    meqs_number: string
    po_number: string
    fund_source_id: string | null
    po_date: Date
    notes: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: POCountAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  type GetPOGroupByPayload<T extends POGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POGroupByOutputType[P]>
            : GetScalarType<T[P], POGroupByOutputType[P]>
        }
      >
    >


  export type POSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_supplier_id?: boolean
    meqs_number?: boolean
    po_number?: boolean
    fund_source_id?: boolean
    po_date?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    meqs_supplier?: boolean | PO$meqs_supplierArgs<ExtArgs>
    rrs?: boolean | PO$rrsArgs<ExtArgs>
    po_approvers?: boolean | PO$po_approversArgs<ExtArgs>
    _count?: boolean | POCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pO"]>

  export type POSelectScalar = {
    id?: boolean
    meqs_supplier_id?: boolean
    meqs_number?: boolean
    po_number?: boolean
    fund_source_id?: boolean
    po_date?: boolean
    notes?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type POInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier?: boolean | PO$meqs_supplierArgs<ExtArgs>
    rrs?: boolean | PO$rrsArgs<ExtArgs>
    po_approvers?: boolean | PO$po_approversArgs<ExtArgs>
    _count?: boolean | POCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $POPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PO"
    objects: {
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs> | null
      rrs: Prisma.$RRPayload<ExtArgs>[]
      po_approvers: Prisma.$POApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_supplier_id: string | null
      meqs_number: string
      po_number: string
      fund_source_id: string | null
      po_date: Date
      notes: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["pO"]>
    composites: {}
  }


  type POGetPayload<S extends boolean | null | undefined | PODefaultArgs> = $Result.GetResult<Prisma.$POPayload, S>

  type POCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POCountAggregateInputType | true
    }

  export interface PODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PO'], meta: { name: 'PO' } }
    /**
     * Find zero or one PO that matches the filter.
     * @param {POFindUniqueArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, POFindUniqueArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {POFindUniqueOrThrowArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends POFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindFirstArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindFirstArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindFirstOrThrowArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends POFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more POS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POS
     * const pOS = await prisma.pO.findMany()
     * 
     * // Get first 10 POS
     * const pOS = await prisma.pO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOWithIdOnly = await prisma.pO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PO.
     * @param {POCreateArgs} args - Arguments to create a PO.
     * @example
     * // Create one PO
     * const PO = await prisma.pO.create({
     *   data: {
     *     // ... data to create a PO
     *   }
     * })
     * 
    **/
    create<T extends POCreateArgs<ExtArgs>>(
      args: SelectSubset<T, POCreateArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many POS.
     *     @param {POCreateManyArgs} args - Arguments to create many POS.
     *     @example
     *     // Create many POS
     *     const pO = await prisma.pO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PO.
     * @param {PODeleteArgs} args - Arguments to delete one PO.
     * @example
     * // Delete one PO
     * const PO = await prisma.pO.delete({
     *   where: {
     *     // ... filter to delete one PO
     *   }
     * })
     * 
    **/
    delete<T extends PODeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PODeleteArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PO.
     * @param {POUpdateArgs} args - Arguments to update one PO.
     * @example
     * // Update one PO
     * const pO = await prisma.pO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, POUpdateArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more POS.
     * @param {PODeleteManyArgs} args - Arguments to filter POS to delete.
     * @example
     * // Delete a few POS
     * const { count } = await prisma.pO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PODeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PODeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POS
     * const pO = await prisma.pO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, POUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PO.
     * @param {POUpsertArgs} args - Arguments to update or create a PO.
     * @example
     * // Update or create a PO
     * const pO = await prisma.pO.upsert({
     *   create: {
     *     // ... data to create a PO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PO we want to update
     *   }
     * })
    **/
    upsert<T extends POUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, POUpsertArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POCountArgs} args - Arguments to filter POS to count.
     * @example
     * // Count the number of POS
     * const count = await prisma.pO.count({
     *   where: {
     *     // ... the filter for the POS we want to count
     *   }
     * })
    **/
    count<T extends POCountArgs>(
      args?: Subset<T, POCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POAggregateArgs>(args: Subset<T, POAggregateArgs>): Prisma.PrismaPromise<GetPOAggregateType<T>>

    /**
     * Group by PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POGroupByArgs['orderBy'] }
        : { orderBy?: POGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PO model
   */
  readonly fields: POFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs_supplier<T extends PO$meqs_supplierArgs<ExtArgs> = {}>(args?: Subset<T, PO$meqs_supplierArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rrs<T extends PO$rrsArgs<ExtArgs> = {}>(args?: Subset<T, PO$rrsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findMany'> | Null>;

    po_approvers<T extends PO$po_approversArgs<ExtArgs> = {}>(args?: Subset<T, PO$po_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PO model
   */ 
  interface POFieldRefs {
    readonly id: FieldRef<"PO", 'String'>
    readonly meqs_supplier_id: FieldRef<"PO", 'String'>
    readonly meqs_number: FieldRef<"PO", 'String'>
    readonly po_number: FieldRef<"PO", 'String'>
    readonly fund_source_id: FieldRef<"PO", 'String'>
    readonly po_date: FieldRef<"PO", 'DateTime'>
    readonly notes: FieldRef<"PO", 'String'>
    readonly cancelled_by: FieldRef<"PO", 'String'>
    readonly created_by: FieldRef<"PO", 'String'>
    readonly updated_by: FieldRef<"PO", 'String'>
    readonly cancelled_at: FieldRef<"PO", 'DateTime'>
    readonly created_at: FieldRef<"PO", 'DateTime'>
    readonly updated_at: FieldRef<"PO", 'DateTime'>
    readonly metadata: FieldRef<"PO", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * PO findUnique
   */
  export type POFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO findUniqueOrThrow
   */
  export type POFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO findFirst
   */
  export type POFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO findFirstOrThrow
   */
  export type POFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO findMany
   */
  export type POFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO create
   */
  export type POCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The data needed to create a PO.
     */
    data: XOR<POCreateInput, POUncheckedCreateInput>
  }


  /**
   * PO createMany
   */
  export type POCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POS.
     */
    data: POCreateManyInput | POCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PO update
   */
  export type POUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The data needed to update a PO.
     */
    data: XOR<POUpdateInput, POUncheckedUpdateInput>
    /**
     * Choose, which PO to update.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO updateMany
   */
  export type POUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POS.
     */
    data: XOR<POUpdateManyMutationInput, POUncheckedUpdateManyInput>
    /**
     * Filter which POS to update
     */
    where?: POWhereInput
  }


  /**
   * PO upsert
   */
  export type POUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The filter to search for the PO to update in case it exists.
     */
    where: POWhereUniqueInput
    /**
     * In case the PO found by the `where` argument doesn't exist, create a new PO with this data.
     */
    create: XOR<POCreateInput, POUncheckedCreateInput>
    /**
     * In case the PO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POUpdateInput, POUncheckedUpdateInput>
  }


  /**
   * PO delete
   */
  export type PODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter which PO to delete.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO deleteMany
   */
  export type PODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POS to delete
     */
    where?: POWhereInput
  }


  /**
   * PO.meqs_supplier
   */
  export type PO$meqs_supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    where?: MEQSSupplierWhereInput
  }


  /**
   * PO.rrs
   */
  export type PO$rrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    where?: RRWhereInput
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    cursor?: RRWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * PO.po_approvers
   */
  export type PO$po_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    where?: POApproverWhereInput
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    cursor?: POApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * PO without action
   */
  export type PODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
  }



  /**
   * Model POApprover
   */

  export type AggregatePOApprover = {
    _count: POApproverCountAggregateOutputType | null
    _avg: POApproverAvgAggregateOutputType | null
    _sum: POApproverSumAggregateOutputType | null
    _min: POApproverMinAggregateOutputType | null
    _max: POApproverMaxAggregateOutputType | null
  }

  export type POApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type POApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type POApproverMinAggregateOutputType = {
    id: string | null
    po_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type POApproverMaxAggregateOutputType = {
    id: string | null
    po_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type POApproverCountAggregateOutputType = {
    id: number
    po_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    metadata: number
    _all: number
  }


  export type POApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type POApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type POApproverMinAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type POApproverMaxAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type POApproverCountAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    metadata?: true
    _all?: true
  }

  export type POApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POApprover to aggregate.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POApprovers
    **/
    _count?: true | POApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POApproverMaxAggregateInputType
  }

  export type GetPOApproverAggregateType<T extends POApproverAggregateArgs> = {
        [P in keyof T & keyof AggregatePOApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOApprover[P]>
      : GetScalarType<T[P], AggregatePOApprover[P]>
  }




  export type POApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POApproverWhereInput
    orderBy?: POApproverOrderByWithAggregationInput | POApproverOrderByWithAggregationInput[]
    by: POApproverScalarFieldEnum[] | POApproverScalarFieldEnum
    having?: POApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POApproverCountAggregateInputType | true
    _avg?: POApproverAvgAggregateInputType
    _sum?: POApproverSumAggregateInputType
    _min?: POApproverMinAggregateInputType
    _max?: POApproverMaxAggregateInputType
  }

  export type POApproverGroupByOutputType = {
    id: string
    po_id: string
    approver_id: string
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    metadata: JsonValue | null
    _count: POApproverCountAggregateOutputType | null
    _avg: POApproverAvgAggregateOutputType | null
    _sum: POApproverSumAggregateOutputType | null
    _min: POApproverMinAggregateOutputType | null
    _max: POApproverMaxAggregateOutputType | null
  }

  type GetPOApproverGroupByPayload<T extends POApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POApproverGroupByOutputType[P]>
            : GetScalarType<T[P], POApproverGroupByOutputType[P]>
        }
      >
    >


  export type POApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
    po?: boolean | PODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOApprover"]>

  export type POApproverSelectScalar = {
    id?: boolean
    po_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
  }

  export type POApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PODefaultArgs<ExtArgs>
  }


  export type $POApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POApprover"
    objects: {
      po: Prisma.$POPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_id: string
      approver_id: string
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["pOApprover"]>
    composites: {}
  }


  type POApproverGetPayload<S extends boolean | null | undefined | POApproverDefaultArgs> = $Result.GetResult<Prisma.$POApproverPayload, S>

  type POApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POApproverCountAggregateInputType | true
    }

  export interface POApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POApprover'], meta: { name: 'POApprover' } }
    /**
     * Find zero or one POApprover that matches the filter.
     * @param {POApproverFindUniqueArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one POApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {POApproverFindUniqueOrThrowArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends POApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first POApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindFirstArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindFirstArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first POApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindFirstOrThrowArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends POApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more POApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POApprovers
     * const pOApprovers = await prisma.pOApprover.findMany()
     * 
     * // Get first 10 POApprovers
     * const pOApprovers = await prisma.pOApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOApproverWithIdOnly = await prisma.pOApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a POApprover.
     * @param {POApproverCreateArgs} args - Arguments to create a POApprover.
     * @example
     * // Create one POApprover
     * const POApprover = await prisma.pOApprover.create({
     *   data: {
     *     // ... data to create a POApprover
     *   }
     * })
     * 
    **/
    create<T extends POApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverCreateArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many POApprovers.
     *     @param {POApproverCreateManyArgs} args - Arguments to create many POApprovers.
     *     @example
     *     // Create many POApprovers
     *     const pOApprover = await prisma.pOApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a POApprover.
     * @param {POApproverDeleteArgs} args - Arguments to delete one POApprover.
     * @example
     * // Delete one POApprover
     * const POApprover = await prisma.pOApprover.delete({
     *   where: {
     *     // ... filter to delete one POApprover
     *   }
     * })
     * 
    **/
    delete<T extends POApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverDeleteArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one POApprover.
     * @param {POApproverUpdateArgs} args - Arguments to update one POApprover.
     * @example
     * // Update one POApprover
     * const pOApprover = await prisma.pOApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpdateArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more POApprovers.
     * @param {POApproverDeleteManyArgs} args - Arguments to filter POApprovers to delete.
     * @example
     * // Delete a few POApprovers
     * const { count } = await prisma.pOApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends POApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POApprovers
     * const pOApprover = await prisma.pOApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POApprover.
     * @param {POApproverUpsertArgs} args - Arguments to update or create a POApprover.
     * @example
     * // Update or create a POApprover
     * const pOApprover = await prisma.pOApprover.upsert({
     *   create: {
     *     // ... data to create a POApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POApprover we want to update
     *   }
     * })
    **/
    upsert<T extends POApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpsertArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of POApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverCountArgs} args - Arguments to filter POApprovers to count.
     * @example
     * // Count the number of POApprovers
     * const count = await prisma.pOApprover.count({
     *   where: {
     *     // ... the filter for the POApprovers we want to count
     *   }
     * })
    **/
    count<T extends POApproverCountArgs>(
      args?: Subset<T, POApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POApproverAggregateArgs>(args: Subset<T, POApproverAggregateArgs>): Prisma.PrismaPromise<GetPOApproverAggregateType<T>>

    /**
     * Group by POApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POApproverGroupByArgs['orderBy'] }
        : { orderBy?: POApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POApprover model
   */
  readonly fields: POApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    po<T extends PODefaultArgs<ExtArgs> = {}>(args?: Subset<T, PODefaultArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the POApprover model
   */ 
  interface POApproverFieldRefs {
    readonly id: FieldRef<"POApprover", 'String'>
    readonly po_id: FieldRef<"POApprover", 'String'>
    readonly approver_id: FieldRef<"POApprover", 'String'>
    readonly date_approval: FieldRef<"POApprover", 'DateTime'>
    readonly notes: FieldRef<"POApprover", 'String'>
    readonly status: FieldRef<"POApprover", 'Int'>
    readonly label: FieldRef<"POApprover", 'String'>
    readonly order: FieldRef<"POApprover", 'Int'>
    readonly metadata: FieldRef<"POApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * POApprover findUnique
   */
  export type POApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover findUniqueOrThrow
   */
  export type POApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover findFirst
   */
  export type POApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POApprovers.
     */
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover findFirstOrThrow
   */
  export type POApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POApprovers.
     */
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover findMany
   */
  export type POApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprovers to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover create
   */
  export type POApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a POApprover.
     */
    data: XOR<POApproverCreateInput, POApproverUncheckedCreateInput>
  }


  /**
   * POApprover createMany
   */
  export type POApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POApprovers.
     */
    data: POApproverCreateManyInput | POApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * POApprover update
   */
  export type POApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a POApprover.
     */
    data: XOR<POApproverUpdateInput, POApproverUncheckedUpdateInput>
    /**
     * Choose, which POApprover to update.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover updateMany
   */
  export type POApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POApprovers.
     */
    data: XOR<POApproverUpdateManyMutationInput, POApproverUncheckedUpdateManyInput>
    /**
     * Filter which POApprovers to update
     */
    where?: POApproverWhereInput
  }


  /**
   * POApprover upsert
   */
  export type POApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the POApprover to update in case it exists.
     */
    where: POApproverWhereUniqueInput
    /**
     * In case the POApprover found by the `where` argument doesn't exist, create a new POApprover with this data.
     */
    create: XOR<POApproverCreateInput, POApproverUncheckedCreateInput>
    /**
     * In case the POApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POApproverUpdateInput, POApproverUncheckedUpdateInput>
  }


  /**
   * POApprover delete
   */
  export type POApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter which POApprover to delete.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover deleteMany
   */
  export type POApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POApprovers to delete
     */
    where?: POApproverWhereInput
  }


  /**
   * POApprover without action
   */
  export type POApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
  }



  /**
   * Model RR
   */

  export type AggregateRR = {
    _count: RRCountAggregateOutputType | null
    _avg: RRAvgAggregateOutputType | null
    _sum: RRSumAggregateOutputType | null
    _min: RRMinAggregateOutputType | null
    _max: RRMaxAggregateOutputType | null
  }

  export type RRAvgAggregateOutputType = {
    delivery_charge: number | null
  }

  export type RRSumAggregateOutputType = {
    delivery_charge: number | null
  }

  export type RRMinAggregateOutputType = {
    id: string | null
    po_id: string | null
    po_number: string | null
    rr_number: string | null
    rr_date: Date | null
    received_by_id: string | null
    invoice_number: string | null
    delivery_number: string | null
    notes: string | null
    delivery_charge: number | null
    is_completed: boolean | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RRMaxAggregateOutputType = {
    id: string | null
    po_id: string | null
    po_number: string | null
    rr_number: string | null
    rr_date: Date | null
    received_by_id: string | null
    invoice_number: string | null
    delivery_number: string | null
    notes: string | null
    delivery_charge: number | null
    is_completed: boolean | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RRCountAggregateOutputType = {
    id: number
    po_id: number
    po_number: number
    rr_number: number
    rr_date: number
    received_by_id: number
    invoice_number: number
    delivery_number: number
    notes: number
    delivery_charge: number
    is_completed: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type RRAvgAggregateInputType = {
    delivery_charge?: true
  }

  export type RRSumAggregateInputType = {
    delivery_charge?: true
  }

  export type RRMinAggregateInputType = {
    id?: true
    po_id?: true
    po_number?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RRMaxAggregateInputType = {
    id?: true
    po_id?: true
    po_number?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RRCountAggregateInputType = {
    id?: true
    po_id?: true
    po_number?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type RRAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RR to aggregate.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRS
    **/
    _count?: true | RRCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRMaxAggregateInputType
  }

  export type GetRRAggregateType<T extends RRAggregateArgs> = {
        [P in keyof T & keyof AggregateRR]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRR[P]>
      : GetScalarType<T[P], AggregateRR[P]>
  }




  export type RRGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRWhereInput
    orderBy?: RROrderByWithAggregationInput | RROrderByWithAggregationInput[]
    by: RRScalarFieldEnum[] | RRScalarFieldEnum
    having?: RRScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRCountAggregateInputType | true
    _avg?: RRAvgAggregateInputType
    _sum?: RRSumAggregateInputType
    _min?: RRMinAggregateInputType
    _max?: RRMaxAggregateInputType
  }

  export type RRGroupByOutputType = {
    id: string
    po_id: string | null
    po_number: string
    rr_number: string
    rr_date: Date
    received_by_id: string
    invoice_number: string
    delivery_number: string | null
    notes: string
    delivery_charge: number
    is_completed: boolean
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: RRCountAggregateOutputType | null
    _avg: RRAvgAggregateOutputType | null
    _sum: RRSumAggregateOutputType | null
    _min: RRMinAggregateOutputType | null
    _max: RRMaxAggregateOutputType | null
  }

  type GetRRGroupByPayload<T extends RRGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRGroupByOutputType[P]>
            : GetScalarType<T[P], RRGroupByOutputType[P]>
        }
      >
    >


  export type RRSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_id?: boolean
    po_number?: boolean
    rr_number?: boolean
    rr_date?: boolean
    received_by_id?: boolean
    invoice_number?: boolean
    delivery_number?: boolean
    notes?: boolean
    delivery_charge?: boolean
    is_completed?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    po?: boolean | RR$poArgs<ExtArgs>
    rr_approvers?: boolean | RR$rr_approversArgs<ExtArgs>
    rr_items?: boolean | RR$rr_itemsArgs<ExtArgs>
    _count?: boolean | RRCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rR"]>

  export type RRSelectScalar = {
    id?: boolean
    po_id?: boolean
    po_number?: boolean
    rr_number?: boolean
    rr_date?: boolean
    received_by_id?: boolean
    invoice_number?: boolean
    delivery_number?: boolean
    notes?: boolean
    delivery_charge?: boolean
    is_completed?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type RRInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | RR$poArgs<ExtArgs>
    rr_approvers?: boolean | RR$rr_approversArgs<ExtArgs>
    rr_items?: boolean | RR$rr_itemsArgs<ExtArgs>
    _count?: boolean | RRCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RRPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RR"
    objects: {
      po: Prisma.$POPayload<ExtArgs> | null
      rr_approvers: Prisma.$RRApproverPayload<ExtArgs>[]
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_id: string | null
      po_number: string
      rr_number: string
      rr_date: Date
      received_by_id: string
      invoice_number: string
      delivery_number: string | null
      notes: string
      delivery_charge: number
      is_completed: boolean
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["rR"]>
    composites: {}
  }


  type RRGetPayload<S extends boolean | null | undefined | RRDefaultArgs> = $Result.GetResult<Prisma.$RRPayload, S>

  type RRCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRCountAggregateInputType | true
    }

  export interface RRDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RR'], meta: { name: 'RR' } }
    /**
     * Find zero or one RR that matches the filter.
     * @param {RRFindUniqueArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRFindUniqueArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RR that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRFindUniqueOrThrowArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RR that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindFirstArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindFirstArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RR that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindFirstOrThrowArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRS
     * const rRS = await prisma.rR.findMany()
     * 
     * // Get first 10 RRS
     * const rRS = await prisma.rR.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRWithIdOnly = await prisma.rR.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RR.
     * @param {RRCreateArgs} args - Arguments to create a RR.
     * @example
     * // Create one RR
     * const RR = await prisma.rR.create({
     *   data: {
     *     // ... data to create a RR
     *   }
     * })
     * 
    **/
    create<T extends RRCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRCreateArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRS.
     *     @param {RRCreateManyArgs} args - Arguments to create many RRS.
     *     @example
     *     // Create many RRS
     *     const rR = await prisma.rR.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RR.
     * @param {RRDeleteArgs} args - Arguments to delete one RR.
     * @example
     * // Delete one RR
     * const RR = await prisma.rR.delete({
     *   where: {
     *     // ... filter to delete one RR
     *   }
     * })
     * 
    **/
    delete<T extends RRDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRDeleteArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RR.
     * @param {RRUpdateArgs} args - Arguments to update one RR.
     * @example
     * // Update one RR
     * const rR = await prisma.rR.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpdateArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRS.
     * @param {RRDeleteManyArgs} args - Arguments to filter RRS to delete.
     * @example
     * // Delete a few RRS
     * const { count } = await prisma.rR.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRS
     * const rR = await prisma.rR.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RR.
     * @param {RRUpsertArgs} args - Arguments to update or create a RR.
     * @example
     * // Update or create a RR
     * const rR = await prisma.rR.upsert({
     *   create: {
     *     // ... data to create a RR
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RR we want to update
     *   }
     * })
    **/
    upsert<T extends RRUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpsertArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRCountArgs} args - Arguments to filter RRS to count.
     * @example
     * // Count the number of RRS
     * const count = await prisma.rR.count({
     *   where: {
     *     // ... the filter for the RRS we want to count
     *   }
     * })
    **/
    count<T extends RRCountArgs>(
      args?: Subset<T, RRCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRAggregateArgs>(args: Subset<T, RRAggregateArgs>): Prisma.PrismaPromise<GetRRAggregateType<T>>

    /**
     * Group by RR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRGroupByArgs['orderBy'] }
        : { orderBy?: RRGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RR model
   */
  readonly fields: RRFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RR.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    po<T extends RR$poArgs<ExtArgs> = {}>(args?: Subset<T, RR$poArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rr_approvers<T extends RR$rr_approversArgs<ExtArgs> = {}>(args?: Subset<T, RR$rr_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    rr_items<T extends RR$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, RR$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RR model
   */ 
  interface RRFieldRefs {
    readonly id: FieldRef<"RR", 'String'>
    readonly po_id: FieldRef<"RR", 'String'>
    readonly po_number: FieldRef<"RR", 'String'>
    readonly rr_number: FieldRef<"RR", 'String'>
    readonly rr_date: FieldRef<"RR", 'DateTime'>
    readonly received_by_id: FieldRef<"RR", 'String'>
    readonly invoice_number: FieldRef<"RR", 'String'>
    readonly delivery_number: FieldRef<"RR", 'String'>
    readonly notes: FieldRef<"RR", 'String'>
    readonly delivery_charge: FieldRef<"RR", 'Float'>
    readonly is_completed: FieldRef<"RR", 'Boolean'>
    readonly cancelled_by: FieldRef<"RR", 'String'>
    readonly created_by: FieldRef<"RR", 'String'>
    readonly updated_by: FieldRef<"RR", 'String'>
    readonly cancelled_at: FieldRef<"RR", 'DateTime'>
    readonly created_at: FieldRef<"RR", 'DateTime'>
    readonly updated_at: FieldRef<"RR", 'DateTime'>
    readonly metadata: FieldRef<"RR", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * RR findUnique
   */
  export type RRFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR findUniqueOrThrow
   */
  export type RRFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR findFirst
   */
  export type RRFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRS.
     */
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR findFirstOrThrow
   */
  export type RRFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRS.
     */
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR findMany
   */
  export type RRFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RRS to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR create
   */
  export type RRCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The data needed to create a RR.
     */
    data: XOR<RRCreateInput, RRUncheckedCreateInput>
  }


  /**
   * RR createMany
   */
  export type RRCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRS.
     */
    data: RRCreateManyInput | RRCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RR update
   */
  export type RRUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The data needed to update a RR.
     */
    data: XOR<RRUpdateInput, RRUncheckedUpdateInput>
    /**
     * Choose, which RR to update.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR updateMany
   */
  export type RRUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRS.
     */
    data: XOR<RRUpdateManyMutationInput, RRUncheckedUpdateManyInput>
    /**
     * Filter which RRS to update
     */
    where?: RRWhereInput
  }


  /**
   * RR upsert
   */
  export type RRUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The filter to search for the RR to update in case it exists.
     */
    where: RRWhereUniqueInput
    /**
     * In case the RR found by the `where` argument doesn't exist, create a new RR with this data.
     */
    create: XOR<RRCreateInput, RRUncheckedCreateInput>
    /**
     * In case the RR was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRUpdateInput, RRUncheckedUpdateInput>
  }


  /**
   * RR delete
   */
  export type RRDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter which RR to delete.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR deleteMany
   */
  export type RRDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRS to delete
     */
    where?: RRWhereInput
  }


  /**
   * RR.po
   */
  export type RR$poArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    where?: POWhereInput
  }


  /**
   * RR.rr_approvers
   */
  export type RR$rr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    where?: RRApproverWhereInput
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    cursor?: RRApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RR.rr_items
   */
  export type RR$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RR without action
   */
  export type RRDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
  }



  /**
   * Model RRApprover
   */

  export type AggregateRRApprover = {
    _count: RRApproverCountAggregateOutputType | null
    _avg: RRApproverAvgAggregateOutputType | null
    _sum: RRApproverSumAggregateOutputType | null
    _min: RRApproverMinAggregateOutputType | null
    _max: RRApproverMaxAggregateOutputType | null
  }

  export type RRApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RRApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RRApproverMinAggregateOutputType = {
    id: string | null
    rr_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type RRApproverMaxAggregateOutputType = {
    id: string | null
    rr_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
  }

  export type RRApproverCountAggregateOutputType = {
    id: number
    rr_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    metadata: number
    _all: number
  }


  export type RRApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type RRApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type RRApproverMinAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type RRApproverMaxAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
  }

  export type RRApproverCountAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    metadata?: true
    _all?: true
  }

  export type RRApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRApprover to aggregate.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRApprovers
    **/
    _count?: true | RRApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRApproverMaxAggregateInputType
  }

  export type GetRRApproverAggregateType<T extends RRApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateRRApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRRApprover[P]>
      : GetScalarType<T[P], AggregateRRApprover[P]>
  }




  export type RRApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRApproverWhereInput
    orderBy?: RRApproverOrderByWithAggregationInput | RRApproverOrderByWithAggregationInput[]
    by: RRApproverScalarFieldEnum[] | RRApproverScalarFieldEnum
    having?: RRApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRApproverCountAggregateInputType | true
    _avg?: RRApproverAvgAggregateInputType
    _sum?: RRApproverSumAggregateInputType
    _min?: RRApproverMinAggregateInputType
    _max?: RRApproverMaxAggregateInputType
  }

  export type RRApproverGroupByOutputType = {
    id: string
    rr_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    order: number
    metadata: JsonValue | null
    _count: RRApproverCountAggregateOutputType | null
    _avg: RRApproverAvgAggregateOutputType | null
    _sum: RRApproverSumAggregateOutputType | null
    _min: RRApproverMinAggregateOutputType | null
    _max: RRApproverMaxAggregateOutputType | null
  }

  type GetRRApproverGroupByPayload<T extends RRApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRApproverGroupByOutputType[P]>
            : GetScalarType<T[P], RRApproverGroupByOutputType[P]>
        }
      >
    >


  export type RRApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rr_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
    rr?: boolean | RRDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rRApprover"]>

  export type RRApproverSelectScalar = {
    id?: boolean
    rr_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    metadata?: boolean
  }

  export type RRApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr?: boolean | RRDefaultArgs<ExtArgs>
  }


  export type $RRApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RRApprover"
    objects: {
      rr: Prisma.$RRPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rr_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      order: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["rRApprover"]>
    composites: {}
  }


  type RRApproverGetPayload<S extends boolean | null | undefined | RRApproverDefaultArgs> = $Result.GetResult<Prisma.$RRApproverPayload, S>

  type RRApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRApproverCountAggregateInputType | true
    }

  export interface RRApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RRApprover'], meta: { name: 'RRApprover' } }
    /**
     * Find zero or one RRApprover that matches the filter.
     * @param {RRApproverFindUniqueArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RRApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRApproverFindUniqueOrThrowArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RRApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindFirstArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindFirstArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RRApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindFirstOrThrowArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRApprovers
     * const rRApprovers = await prisma.rRApprover.findMany()
     * 
     * // Get first 10 RRApprovers
     * const rRApprovers = await prisma.rRApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRApproverWithIdOnly = await prisma.rRApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RRApprover.
     * @param {RRApproverCreateArgs} args - Arguments to create a RRApprover.
     * @example
     * // Create one RRApprover
     * const RRApprover = await prisma.rRApprover.create({
     *   data: {
     *     // ... data to create a RRApprover
     *   }
     * })
     * 
    **/
    create<T extends RRApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverCreateArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRApprovers.
     *     @param {RRApproverCreateManyArgs} args - Arguments to create many RRApprovers.
     *     @example
     *     // Create many RRApprovers
     *     const rRApprover = await prisma.rRApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RRApprover.
     * @param {RRApproverDeleteArgs} args - Arguments to delete one RRApprover.
     * @example
     * // Delete one RRApprover
     * const RRApprover = await prisma.rRApprover.delete({
     *   where: {
     *     // ... filter to delete one RRApprover
     *   }
     * })
     * 
    **/
    delete<T extends RRApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverDeleteArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RRApprover.
     * @param {RRApproverUpdateArgs} args - Arguments to update one RRApprover.
     * @example
     * // Update one RRApprover
     * const rRApprover = await prisma.rRApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpdateArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRApprovers.
     * @param {RRApproverDeleteManyArgs} args - Arguments to filter RRApprovers to delete.
     * @example
     * // Delete a few RRApprovers
     * const { count } = await prisma.rRApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRApprovers
     * const rRApprover = await prisma.rRApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RRApprover.
     * @param {RRApproverUpsertArgs} args - Arguments to update or create a RRApprover.
     * @example
     * // Update or create a RRApprover
     * const rRApprover = await prisma.rRApprover.upsert({
     *   create: {
     *     // ... data to create a RRApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RRApprover we want to update
     *   }
     * })
    **/
    upsert<T extends RRApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpsertArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverCountArgs} args - Arguments to filter RRApprovers to count.
     * @example
     * // Count the number of RRApprovers
     * const count = await prisma.rRApprover.count({
     *   where: {
     *     // ... the filter for the RRApprovers we want to count
     *   }
     * })
    **/
    count<T extends RRApproverCountArgs>(
      args?: Subset<T, RRApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRApproverAggregateArgs>(args: Subset<T, RRApproverAggregateArgs>): Prisma.PrismaPromise<GetRRApproverAggregateType<T>>

    /**
     * Group by RRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRApproverGroupByArgs['orderBy'] }
        : { orderBy?: RRApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RRApprover model
   */
  readonly fields: RRApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RRApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rr<T extends RRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RRDefaultArgs<ExtArgs>>): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RRApprover model
   */ 
  interface RRApproverFieldRefs {
    readonly id: FieldRef<"RRApprover", 'String'>
    readonly rr_id: FieldRef<"RRApprover", 'String'>
    readonly approver_id: FieldRef<"RRApprover", 'String'>
    readonly date_approval: FieldRef<"RRApprover", 'DateTime'>
    readonly notes: FieldRef<"RRApprover", 'String'>
    readonly status: FieldRef<"RRApprover", 'Int'>
    readonly label: FieldRef<"RRApprover", 'String'>
    readonly order: FieldRef<"RRApprover", 'Int'>
    readonly metadata: FieldRef<"RRApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * RRApprover findUnique
   */
  export type RRApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover findUniqueOrThrow
   */
  export type RRApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover findFirst
   */
  export type RRApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRApprovers.
     */
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover findFirstOrThrow
   */
  export type RRApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRApprovers.
     */
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover findMany
   */
  export type RRApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprovers to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover create
   */
  export type RRApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a RRApprover.
     */
    data: XOR<RRApproverCreateInput, RRApproverUncheckedCreateInput>
  }


  /**
   * RRApprover createMany
   */
  export type RRApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRApprovers.
     */
    data: RRApproverCreateManyInput | RRApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RRApprover update
   */
  export type RRApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a RRApprover.
     */
    data: XOR<RRApproverUpdateInput, RRApproverUncheckedUpdateInput>
    /**
     * Choose, which RRApprover to update.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover updateMany
   */
  export type RRApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRApprovers.
     */
    data: XOR<RRApproverUpdateManyMutationInput, RRApproverUncheckedUpdateManyInput>
    /**
     * Filter which RRApprovers to update
     */
    where?: RRApproverWhereInput
  }


  /**
   * RRApprover upsert
   */
  export type RRApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the RRApprover to update in case it exists.
     */
    where: RRApproverWhereUniqueInput
    /**
     * In case the RRApprover found by the `where` argument doesn't exist, create a new RRApprover with this data.
     */
    create: XOR<RRApproverCreateInput, RRApproverUncheckedCreateInput>
    /**
     * In case the RRApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRApproverUpdateInput, RRApproverUncheckedUpdateInput>
  }


  /**
   * RRApprover delete
   */
  export type RRApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter which RRApprover to delete.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover deleteMany
   */
  export type RRApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRApprovers to delete
     */
    where?: RRApproverWhereInput
  }


  /**
   * RRApprover without action
   */
  export type RRApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
  }



  /**
   * Model RRItem
   */

  export type AggregateRRItem = {
    _count: RRItemCountAggregateOutputType | null
    _avg: RRItemAvgAggregateOutputType | null
    _sum: RRItemSumAggregateOutputType | null
    _min: RRItemMinAggregateOutputType | null
    _max: RRItemMaxAggregateOutputType | null
  }

  export type RRItemAvgAggregateOutputType = {
    quantity_accepted: number | null
  }

  export type RRItemSumAggregateOutputType = {
    quantity_accepted: number | null
  }

  export type RRItemMinAggregateOutputType = {
    id: string | null
    rr_id: string | null
    meqs_supplier_item_id: string | null
    quantity_accepted: number | null
  }

  export type RRItemMaxAggregateOutputType = {
    id: string | null
    rr_id: string | null
    meqs_supplier_item_id: string | null
    quantity_accepted: number | null
  }

  export type RRItemCountAggregateOutputType = {
    id: number
    rr_id: number
    meqs_supplier_item_id: number
    quantity_accepted: number
    metadata: number
    _all: number
  }


  export type RRItemAvgAggregateInputType = {
    quantity_accepted?: true
  }

  export type RRItemSumAggregateInputType = {
    quantity_accepted?: true
  }

  export type RRItemMinAggregateInputType = {
    id?: true
    rr_id?: true
    meqs_supplier_item_id?: true
    quantity_accepted?: true
  }

  export type RRItemMaxAggregateInputType = {
    id?: true
    rr_id?: true
    meqs_supplier_item_id?: true
    quantity_accepted?: true
  }

  export type RRItemCountAggregateInputType = {
    id?: true
    rr_id?: true
    meqs_supplier_item_id?: true
    quantity_accepted?: true
    metadata?: true
    _all?: true
  }

  export type RRItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRItem to aggregate.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRItems
    **/
    _count?: true | RRItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRItemMaxAggregateInputType
  }

  export type GetRRItemAggregateType<T extends RRItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRRItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRRItem[P]>
      : GetScalarType<T[P], AggregateRRItem[P]>
  }




  export type RRItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithAggregationInput | RRItemOrderByWithAggregationInput[]
    by: RRItemScalarFieldEnum[] | RRItemScalarFieldEnum
    having?: RRItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRItemCountAggregateInputType | true
    _avg?: RRItemAvgAggregateInputType
    _sum?: RRItemSumAggregateInputType
    _min?: RRItemMinAggregateInputType
    _max?: RRItemMaxAggregateInputType
  }

  export type RRItemGroupByOutputType = {
    id: string
    rr_id: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata: JsonValue | null
    _count: RRItemCountAggregateOutputType | null
    _avg: RRItemAvgAggregateOutputType | null
    _sum: RRItemSumAggregateOutputType | null
    _min: RRItemMinAggregateOutputType | null
    _max: RRItemMaxAggregateOutputType | null
  }

  type GetRRItemGroupByPayload<T extends RRItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRItemGroupByOutputType[P]>
            : GetScalarType<T[P], RRItemGroupByOutputType[P]>
        }
      >
    >


  export type RRItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rr_id?: boolean
    meqs_supplier_item_id?: boolean
    quantity_accepted?: boolean
    metadata?: boolean
    rr?: boolean | RRDefaultArgs<ExtArgs>
    item_transaction?: boolean | RRItem$item_transactionArgs<ExtArgs>
    meqs_supplier_item?: boolean | MEQSSupplierItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rRItem"]>

  export type RRItemSelectScalar = {
    id?: boolean
    rr_id?: boolean
    meqs_supplier_item_id?: boolean
    quantity_accepted?: boolean
    metadata?: boolean
  }

  export type RRItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr?: boolean | RRDefaultArgs<ExtArgs>
    item_transaction?: boolean | RRItem$item_transactionArgs<ExtArgs>
    meqs_supplier_item?: boolean | MEQSSupplierItemDefaultArgs<ExtArgs>
  }


  export type $RRItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RRItem"
    objects: {
      rr: Prisma.$RRPayload<ExtArgs>
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
      meqs_supplier_item: Prisma.$MEQSSupplierItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rr_id: string
      meqs_supplier_item_id: string
      quantity_accepted: number
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["rRItem"]>
    composites: {}
  }


  type RRItemGetPayload<S extends boolean | null | undefined | RRItemDefaultArgs> = $Result.GetResult<Prisma.$RRItemPayload, S>

  type RRItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRItemCountAggregateInputType | true
    }

  export interface RRItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RRItem'], meta: { name: 'RRItem' } }
    /**
     * Find zero or one RRItem that matches the filter.
     * @param {RRItemFindUniqueArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemFindUniqueArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RRItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRItemFindUniqueOrThrowArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RRItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindFirstArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindFirstArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RRItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindFirstOrThrowArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRItems
     * const rRItems = await prisma.rRItem.findMany()
     * 
     * // Get first 10 RRItems
     * const rRItems = await prisma.rRItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRItemWithIdOnly = await prisma.rRItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RRItem.
     * @param {RRItemCreateArgs} args - Arguments to create a RRItem.
     * @example
     * // Create one RRItem
     * const RRItem = await prisma.rRItem.create({
     *   data: {
     *     // ... data to create a RRItem
     *   }
     * })
     * 
    **/
    create<T extends RRItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemCreateArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRItems.
     *     @param {RRItemCreateManyArgs} args - Arguments to create many RRItems.
     *     @example
     *     // Create many RRItems
     *     const rRItem = await prisma.rRItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RRItem.
     * @param {RRItemDeleteArgs} args - Arguments to delete one RRItem.
     * @example
     * // Delete one RRItem
     * const RRItem = await prisma.rRItem.delete({
     *   where: {
     *     // ... filter to delete one RRItem
     *   }
     * })
     * 
    **/
    delete<T extends RRItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemDeleteArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RRItem.
     * @param {RRItemUpdateArgs} args - Arguments to update one RRItem.
     * @example
     * // Update one RRItem
     * const rRItem = await prisma.rRItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpdateArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRItems.
     * @param {RRItemDeleteManyArgs} args - Arguments to filter RRItems to delete.
     * @example
     * // Delete a few RRItems
     * const { count } = await prisma.rRItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRItems
     * const rRItem = await prisma.rRItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RRItem.
     * @param {RRItemUpsertArgs} args - Arguments to update or create a RRItem.
     * @example
     * // Update or create a RRItem
     * const rRItem = await prisma.rRItem.upsert({
     *   create: {
     *     // ... data to create a RRItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RRItem we want to update
     *   }
     * })
    **/
    upsert<T extends RRItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpsertArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemCountArgs} args - Arguments to filter RRItems to count.
     * @example
     * // Count the number of RRItems
     * const count = await prisma.rRItem.count({
     *   where: {
     *     // ... the filter for the RRItems we want to count
     *   }
     * })
    **/
    count<T extends RRItemCountArgs>(
      args?: Subset<T, RRItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RRItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRItemAggregateArgs>(args: Subset<T, RRItemAggregateArgs>): Prisma.PrismaPromise<GetRRItemAggregateType<T>>

    /**
     * Group by RRItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRItemGroupByArgs['orderBy'] }
        : { orderBy?: RRItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RRItem model
   */
  readonly fields: RRItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RRItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rr<T extends RRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RRDefaultArgs<ExtArgs>>): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transaction<T extends RRItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, RRItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs_supplier_item<T extends MEQSSupplierItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierItemDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RRItem model
   */ 
  interface RRItemFieldRefs {
    readonly id: FieldRef<"RRItem", 'String'>
    readonly rr_id: FieldRef<"RRItem", 'String'>
    readonly meqs_supplier_item_id: FieldRef<"RRItem", 'String'>
    readonly quantity_accepted: FieldRef<"RRItem", 'Int'>
    readonly metadata: FieldRef<"RRItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * RRItem findUnique
   */
  export type RRItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem findUniqueOrThrow
   */
  export type RRItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem findFirst
   */
  export type RRItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRItems.
     */
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem findFirstOrThrow
   */
  export type RRItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRItems.
     */
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem findMany
   */
  export type RRItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItems to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem create
   */
  export type RRItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RRItem.
     */
    data: XOR<RRItemCreateInput, RRItemUncheckedCreateInput>
  }


  /**
   * RRItem createMany
   */
  export type RRItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRItems.
     */
    data: RRItemCreateManyInput | RRItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RRItem update
   */
  export type RRItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RRItem.
     */
    data: XOR<RRItemUpdateInput, RRItemUncheckedUpdateInput>
    /**
     * Choose, which RRItem to update.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem updateMany
   */
  export type RRItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRItems.
     */
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyInput>
    /**
     * Filter which RRItems to update
     */
    where?: RRItemWhereInput
  }


  /**
   * RRItem upsert
   */
  export type RRItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RRItem to update in case it exists.
     */
    where: RRItemWhereUniqueInput
    /**
     * In case the RRItem found by the `where` argument doesn't exist, create a new RRItem with this data.
     */
    create: XOR<RRItemCreateInput, RRItemUncheckedCreateInput>
    /**
     * In case the RRItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRItemUpdateInput, RRItemUncheckedUpdateInput>
  }


  /**
   * RRItem delete
   */
  export type RRItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter which RRItem to delete.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem deleteMany
   */
  export type RRItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRItems to delete
     */
    where?: RRItemWhereInput
  }


  /**
   * RRItem.item_transaction
   */
  export type RRItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * RRItem without action
   */
  export type RRItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
  }



  /**
   * Model OSRIV
   */

  export type AggregateOSRIV = {
    _count: OSRIVCountAggregateOutputType | null
    _min: OSRIVMinAggregateOutputType | null
    _max: OSRIVMaxAggregateOutputType | null
  }

  export type OSRIVMinAggregateOutputType = {
    id: string | null
    osriv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    requested_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OSRIVMaxAggregateOutputType = {
    id: string | null
    osriv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    requested_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OSRIVCountAggregateOutputType = {
    id: number
    osriv_number: number
    date_requested: number
    exp_date: number
    purpose: number
    note: number
    is_completed: number
    requested_by_id: number
    item_from_id: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type OSRIVMinAggregateInputType = {
    id?: true
    osriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    requested_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OSRIVMaxAggregateInputType = {
    id?: true
    osriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    requested_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OSRIVCountAggregateInputType = {
    id?: true
    osriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    requested_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type OSRIVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIV to aggregate.
     */
    where?: OSRIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVS to fetch.
     */
    orderBy?: OSRIVOrderByWithRelationInput | OSRIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OSRIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OSRIVS
    **/
    _count?: true | OSRIVCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OSRIVMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OSRIVMaxAggregateInputType
  }

  export type GetOSRIVAggregateType<T extends OSRIVAggregateArgs> = {
        [P in keyof T & keyof AggregateOSRIV]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOSRIV[P]>
      : GetScalarType<T[P], AggregateOSRIV[P]>
  }




  export type OSRIVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVWhereInput
    orderBy?: OSRIVOrderByWithAggregationInput | OSRIVOrderByWithAggregationInput[]
    by: OSRIVScalarFieldEnum[] | OSRIVScalarFieldEnum
    having?: OSRIVScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OSRIVCountAggregateInputType | true
    _min?: OSRIVMinAggregateInputType
    _max?: OSRIVMaxAggregateInputType
  }

  export type OSRIVGroupByOutputType = {
    id: string
    osriv_number: string
    date_requested: Date
    exp_date: Date
    purpose: string
    note: string
    is_completed: boolean
    requested_by_id: string
    item_from_id: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: OSRIVCountAggregateOutputType | null
    _min: OSRIVMinAggregateOutputType | null
    _max: OSRIVMaxAggregateOutputType | null
  }

  type GetOSRIVGroupByPayload<T extends OSRIVGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OSRIVGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OSRIVGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OSRIVGroupByOutputType[P]>
            : GetScalarType<T[P], OSRIVGroupByOutputType[P]>
        }
      >
    >


  export type OSRIVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    osriv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    requested_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    osriv_approvers?: boolean | OSRIV$osriv_approversArgs<ExtArgs>
    osriv_items?: boolean | OSRIV$osriv_itemsArgs<ExtArgs>
    _count?: boolean | OSRIVCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oSRIV"]>

  export type OSRIVSelectScalar = {
    id?: boolean
    osriv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    requested_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type OSRIVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    osriv_approvers?: boolean | OSRIV$osriv_approversArgs<ExtArgs>
    osriv_items?: boolean | OSRIV$osriv_itemsArgs<ExtArgs>
    _count?: boolean | OSRIVCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OSRIVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OSRIV"
    objects: {
      item_from: Prisma.$StationPayload<ExtArgs>
      osriv_approvers: Prisma.$OSRIVApproverPayload<ExtArgs>[]
      osriv_items: Prisma.$OSRIVItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      osriv_number: string
      date_requested: Date
      exp_date: Date
      purpose: string
      note: string
      is_completed: boolean
      requested_by_id: string
      item_from_id: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["oSRIV"]>
    composites: {}
  }


  type OSRIVGetPayload<S extends boolean | null | undefined | OSRIVDefaultArgs> = $Result.GetResult<Prisma.$OSRIVPayload, S>

  type OSRIVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OSRIVFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OSRIVCountAggregateInputType | true
    }

  export interface OSRIVDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OSRIV'], meta: { name: 'OSRIV' } }
    /**
     * Find zero or one OSRIV that matches the filter.
     * @param {OSRIVFindUniqueArgs} args - Arguments to find a OSRIV
     * @example
     * // Get one OSRIV
     * const oSRIV = await prisma.oSRIV.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OSRIVFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVFindUniqueArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OSRIV that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OSRIVFindUniqueOrThrowArgs} args - Arguments to find a OSRIV
     * @example
     * // Get one OSRIV
     * const oSRIV = await prisma.oSRIV.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OSRIVFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OSRIV that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVFindFirstArgs} args - Arguments to find a OSRIV
     * @example
     * // Get one OSRIV
     * const oSRIV = await prisma.oSRIV.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OSRIVFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVFindFirstArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OSRIV that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVFindFirstOrThrowArgs} args - Arguments to find a OSRIV
     * @example
     * // Get one OSRIV
     * const oSRIV = await prisma.oSRIV.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OSRIVFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OSRIVS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OSRIVS
     * const oSRIVS = await prisma.oSRIV.findMany()
     * 
     * // Get first 10 OSRIVS
     * const oSRIVS = await prisma.oSRIV.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oSRIVWithIdOnly = await prisma.oSRIV.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OSRIVFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OSRIV.
     * @param {OSRIVCreateArgs} args - Arguments to create a OSRIV.
     * @example
     * // Create one OSRIV
     * const OSRIV = await prisma.oSRIV.create({
     *   data: {
     *     // ... data to create a OSRIV
     *   }
     * })
     * 
    **/
    create<T extends OSRIVCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVCreateArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OSRIVS.
     *     @param {OSRIVCreateManyArgs} args - Arguments to create many OSRIVS.
     *     @example
     *     // Create many OSRIVS
     *     const oSRIV = await prisma.oSRIV.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OSRIVCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OSRIV.
     * @param {OSRIVDeleteArgs} args - Arguments to delete one OSRIV.
     * @example
     * // Delete one OSRIV
     * const OSRIV = await prisma.oSRIV.delete({
     *   where: {
     *     // ... filter to delete one OSRIV
     *   }
     * })
     * 
    **/
    delete<T extends OSRIVDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVDeleteArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OSRIV.
     * @param {OSRIVUpdateArgs} args - Arguments to update one OSRIV.
     * @example
     * // Update one OSRIV
     * const oSRIV = await prisma.oSRIV.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OSRIVUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVUpdateArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OSRIVS.
     * @param {OSRIVDeleteManyArgs} args - Arguments to filter OSRIVS to delete.
     * @example
     * // Delete a few OSRIVS
     * const { count } = await prisma.oSRIV.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OSRIVDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OSRIVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OSRIVS
     * const oSRIV = await prisma.oSRIV.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OSRIVUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OSRIV.
     * @param {OSRIVUpsertArgs} args - Arguments to update or create a OSRIV.
     * @example
     * // Update or create a OSRIV
     * const oSRIV = await prisma.oSRIV.upsert({
     *   create: {
     *     // ... data to create a OSRIV
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OSRIV we want to update
     *   }
     * })
    **/
    upsert<T extends OSRIVUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVUpsertArgs<ExtArgs>>
    ): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OSRIVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVCountArgs} args - Arguments to filter OSRIVS to count.
     * @example
     * // Count the number of OSRIVS
     * const count = await prisma.oSRIV.count({
     *   where: {
     *     // ... the filter for the OSRIVS we want to count
     *   }
     * })
    **/
    count<T extends OSRIVCountArgs>(
      args?: Subset<T, OSRIVCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OSRIVCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OSRIV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OSRIVAggregateArgs>(args: Subset<T, OSRIVAggregateArgs>): Prisma.PrismaPromise<GetOSRIVAggregateType<T>>

    /**
     * Group by OSRIV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OSRIVGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OSRIVGroupByArgs['orderBy'] }
        : { orderBy?: OSRIVGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OSRIVGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOSRIVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OSRIV model
   */
  readonly fields: OSRIVFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OSRIV.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OSRIVClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item_from<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    osriv_approvers<T extends OSRIV$osriv_approversArgs<ExtArgs> = {}>(args?: Subset<T, OSRIV$osriv_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    osriv_items<T extends OSRIV$osriv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, OSRIV$osriv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OSRIV model
   */ 
  interface OSRIVFieldRefs {
    readonly id: FieldRef<"OSRIV", 'String'>
    readonly osriv_number: FieldRef<"OSRIV", 'String'>
    readonly date_requested: FieldRef<"OSRIV", 'DateTime'>
    readonly exp_date: FieldRef<"OSRIV", 'DateTime'>
    readonly purpose: FieldRef<"OSRIV", 'String'>
    readonly note: FieldRef<"OSRIV", 'String'>
    readonly is_completed: FieldRef<"OSRIV", 'Boolean'>
    readonly requested_by_id: FieldRef<"OSRIV", 'String'>
    readonly item_from_id: FieldRef<"OSRIV", 'String'>
    readonly cancelled_by: FieldRef<"OSRIV", 'String'>
    readonly created_by: FieldRef<"OSRIV", 'String'>
    readonly updated_by: FieldRef<"OSRIV", 'String'>
    readonly cancelled_at: FieldRef<"OSRIV", 'DateTime'>
    readonly created_at: FieldRef<"OSRIV", 'DateTime'>
    readonly updated_at: FieldRef<"OSRIV", 'DateTime'>
    readonly metadata: FieldRef<"OSRIV", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * OSRIV findUnique
   */
  export type OSRIVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter, which OSRIV to fetch.
     */
    where: OSRIVWhereUniqueInput
  }


  /**
   * OSRIV findUniqueOrThrow
   */
  export type OSRIVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter, which OSRIV to fetch.
     */
    where: OSRIVWhereUniqueInput
  }


  /**
   * OSRIV findFirst
   */
  export type OSRIVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter, which OSRIV to fetch.
     */
    where?: OSRIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVS to fetch.
     */
    orderBy?: OSRIVOrderByWithRelationInput | OSRIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVS.
     */
    cursor?: OSRIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVS.
     */
    distinct?: OSRIVScalarFieldEnum | OSRIVScalarFieldEnum[]
  }


  /**
   * OSRIV findFirstOrThrow
   */
  export type OSRIVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter, which OSRIV to fetch.
     */
    where?: OSRIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVS to fetch.
     */
    orderBy?: OSRIVOrderByWithRelationInput | OSRIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVS.
     */
    cursor?: OSRIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVS.
     */
    distinct?: OSRIVScalarFieldEnum | OSRIVScalarFieldEnum[]
  }


  /**
   * OSRIV findMany
   */
  export type OSRIVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVS to fetch.
     */
    where?: OSRIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVS to fetch.
     */
    orderBy?: OSRIVOrderByWithRelationInput | OSRIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OSRIVS.
     */
    cursor?: OSRIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVS.
     */
    skip?: number
    distinct?: OSRIVScalarFieldEnum | OSRIVScalarFieldEnum[]
  }


  /**
   * OSRIV create
   */
  export type OSRIVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * The data needed to create a OSRIV.
     */
    data: XOR<OSRIVCreateInput, OSRIVUncheckedCreateInput>
  }


  /**
   * OSRIV createMany
   */
  export type OSRIVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OSRIVS.
     */
    data: OSRIVCreateManyInput | OSRIVCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OSRIV update
   */
  export type OSRIVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * The data needed to update a OSRIV.
     */
    data: XOR<OSRIVUpdateInput, OSRIVUncheckedUpdateInput>
    /**
     * Choose, which OSRIV to update.
     */
    where: OSRIVWhereUniqueInput
  }


  /**
   * OSRIV updateMany
   */
  export type OSRIVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OSRIVS.
     */
    data: XOR<OSRIVUpdateManyMutationInput, OSRIVUncheckedUpdateManyInput>
    /**
     * Filter which OSRIVS to update
     */
    where?: OSRIVWhereInput
  }


  /**
   * OSRIV upsert
   */
  export type OSRIVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * The filter to search for the OSRIV to update in case it exists.
     */
    where: OSRIVWhereUniqueInput
    /**
     * In case the OSRIV found by the `where` argument doesn't exist, create a new OSRIV with this data.
     */
    create: XOR<OSRIVCreateInput, OSRIVUncheckedCreateInput>
    /**
     * In case the OSRIV was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OSRIVUpdateInput, OSRIVUncheckedUpdateInput>
  }


  /**
   * OSRIV delete
   */
  export type OSRIVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
    /**
     * Filter which OSRIV to delete.
     */
    where: OSRIVWhereUniqueInput
  }


  /**
   * OSRIV deleteMany
   */
  export type OSRIVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIVS to delete
     */
    where?: OSRIVWhereInput
  }


  /**
   * OSRIV.osriv_approvers
   */
  export type OSRIV$osriv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    where?: OSRIVApproverWhereInput
    orderBy?: OSRIVApproverOrderByWithRelationInput | OSRIVApproverOrderByWithRelationInput[]
    cursor?: OSRIVApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OSRIVApproverScalarFieldEnum | OSRIVApproverScalarFieldEnum[]
  }


  /**
   * OSRIV.osriv_items
   */
  export type OSRIV$osriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    where?: OSRIVItemWhereInput
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    cursor?: OSRIVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OSRIVItemScalarFieldEnum | OSRIVItemScalarFieldEnum[]
  }


  /**
   * OSRIV without action
   */
  export type OSRIVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIV
     */
    select?: OSRIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVInclude<ExtArgs> | null
  }



  /**
   * Model OSRIVApprover
   */

  export type AggregateOSRIVApprover = {
    _count: OSRIVApproverCountAggregateOutputType | null
    _avg: OSRIVApproverAvgAggregateOutputType | null
    _sum: OSRIVApproverSumAggregateOutputType | null
    _min: OSRIVApproverMinAggregateOutputType | null
    _max: OSRIVApproverMaxAggregateOutputType | null
  }

  export type OSRIVApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type OSRIVApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type OSRIVApproverMinAggregateOutputType = {
    id: string | null
    osriv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type OSRIVApproverMaxAggregateOutputType = {
    id: string | null
    osriv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type OSRIVApproverCountAggregateOutputType = {
    id: number
    osriv_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type OSRIVApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type OSRIVApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type OSRIVApproverMinAggregateInputType = {
    id?: true
    osriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type OSRIVApproverMaxAggregateInputType = {
    id?: true
    osriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type OSRIVApproverCountAggregateInputType = {
    id?: true
    osriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type OSRIVApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIVApprover to aggregate.
     */
    where?: OSRIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVApprovers to fetch.
     */
    orderBy?: OSRIVApproverOrderByWithRelationInput | OSRIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OSRIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OSRIVApprovers
    **/
    _count?: true | OSRIVApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OSRIVApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OSRIVApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OSRIVApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OSRIVApproverMaxAggregateInputType
  }

  export type GetOSRIVApproverAggregateType<T extends OSRIVApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateOSRIVApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOSRIVApprover[P]>
      : GetScalarType<T[P], AggregateOSRIVApprover[P]>
  }




  export type OSRIVApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVApproverWhereInput
    orderBy?: OSRIVApproverOrderByWithAggregationInput | OSRIVApproverOrderByWithAggregationInput[]
    by: OSRIVApproverScalarFieldEnum[] | OSRIVApproverScalarFieldEnum
    having?: OSRIVApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OSRIVApproverCountAggregateInputType | true
    _avg?: OSRIVApproverAvgAggregateInputType
    _sum?: OSRIVApproverSumAggregateInputType
    _min?: OSRIVApproverMinAggregateInputType
    _max?: OSRIVApproverMaxAggregateInputType
  }

  export type OSRIVApproverGroupByOutputType = {
    id: string
    osriv_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: OSRIVApproverCountAggregateOutputType | null
    _avg: OSRIVApproverAvgAggregateOutputType | null
    _sum: OSRIVApproverSumAggregateOutputType | null
    _min: OSRIVApproverMinAggregateOutputType | null
    _max: OSRIVApproverMaxAggregateOutputType | null
  }

  type GetOSRIVApproverGroupByPayload<T extends OSRIVApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OSRIVApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OSRIVApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OSRIVApproverGroupByOutputType[P]>
            : GetScalarType<T[P], OSRIVApproverGroupByOutputType[P]>
        }
      >
    >


  export type OSRIVApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    osriv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    osriv?: boolean | OSRIVDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oSRIVApprover"]>

  export type OSRIVApproverSelectScalar = {
    id?: boolean
    osriv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type OSRIVApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    osriv?: boolean | OSRIVDefaultArgs<ExtArgs>
  }


  export type $OSRIVApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OSRIVApprover"
    objects: {
      osriv: Prisma.$OSRIVPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      osriv_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["oSRIVApprover"]>
    composites: {}
  }


  type OSRIVApproverGetPayload<S extends boolean | null | undefined | OSRIVApproverDefaultArgs> = $Result.GetResult<Prisma.$OSRIVApproverPayload, S>

  type OSRIVApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OSRIVApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OSRIVApproverCountAggregateInputType | true
    }

  export interface OSRIVApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OSRIVApprover'], meta: { name: 'OSRIVApprover' } }
    /**
     * Find zero or one OSRIVApprover that matches the filter.
     * @param {OSRIVApproverFindUniqueArgs} args - Arguments to find a OSRIVApprover
     * @example
     * // Get one OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OSRIVApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OSRIVApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OSRIVApproverFindUniqueOrThrowArgs} args - Arguments to find a OSRIVApprover
     * @example
     * // Get one OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OSRIVApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OSRIVApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverFindFirstArgs} args - Arguments to find a OSRIVApprover
     * @example
     * // Get one OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OSRIVApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverFindFirstArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OSRIVApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverFindFirstOrThrowArgs} args - Arguments to find a OSRIVApprover
     * @example
     * // Get one OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OSRIVApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OSRIVApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OSRIVApprovers
     * const oSRIVApprovers = await prisma.oSRIVApprover.findMany()
     * 
     * // Get first 10 OSRIVApprovers
     * const oSRIVApprovers = await prisma.oSRIVApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oSRIVApproverWithIdOnly = await prisma.oSRIVApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OSRIVApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OSRIVApprover.
     * @param {OSRIVApproverCreateArgs} args - Arguments to create a OSRIVApprover.
     * @example
     * // Create one OSRIVApprover
     * const OSRIVApprover = await prisma.oSRIVApprover.create({
     *   data: {
     *     // ... data to create a OSRIVApprover
     *   }
     * })
     * 
    **/
    create<T extends OSRIVApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverCreateArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OSRIVApprovers.
     *     @param {OSRIVApproverCreateManyArgs} args - Arguments to create many OSRIVApprovers.
     *     @example
     *     // Create many OSRIVApprovers
     *     const oSRIVApprover = await prisma.oSRIVApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OSRIVApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OSRIVApprover.
     * @param {OSRIVApproverDeleteArgs} args - Arguments to delete one OSRIVApprover.
     * @example
     * // Delete one OSRIVApprover
     * const OSRIVApprover = await prisma.oSRIVApprover.delete({
     *   where: {
     *     // ... filter to delete one OSRIVApprover
     *   }
     * })
     * 
    **/
    delete<T extends OSRIVApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverDeleteArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OSRIVApprover.
     * @param {OSRIVApproverUpdateArgs} args - Arguments to update one OSRIVApprover.
     * @example
     * // Update one OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OSRIVApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverUpdateArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OSRIVApprovers.
     * @param {OSRIVApproverDeleteManyArgs} args - Arguments to filter OSRIVApprovers to delete.
     * @example
     * // Delete a few OSRIVApprovers
     * const { count } = await prisma.oSRIVApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OSRIVApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OSRIVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OSRIVApprovers
     * const oSRIVApprover = await prisma.oSRIVApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OSRIVApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OSRIVApprover.
     * @param {OSRIVApproverUpsertArgs} args - Arguments to update or create a OSRIVApprover.
     * @example
     * // Update or create a OSRIVApprover
     * const oSRIVApprover = await prisma.oSRIVApprover.upsert({
     *   create: {
     *     // ... data to create a OSRIVApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OSRIVApprover we want to update
     *   }
     * })
    **/
    upsert<T extends OSRIVApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVApproverUpsertArgs<ExtArgs>>
    ): Prisma__OSRIVApproverClient<$Result.GetResult<Prisma.$OSRIVApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OSRIVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverCountArgs} args - Arguments to filter OSRIVApprovers to count.
     * @example
     * // Count the number of OSRIVApprovers
     * const count = await prisma.oSRIVApprover.count({
     *   where: {
     *     // ... the filter for the OSRIVApprovers we want to count
     *   }
     * })
    **/
    count<T extends OSRIVApproverCountArgs>(
      args?: Subset<T, OSRIVApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OSRIVApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OSRIVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OSRIVApproverAggregateArgs>(args: Subset<T, OSRIVApproverAggregateArgs>): Prisma.PrismaPromise<GetOSRIVApproverAggregateType<T>>

    /**
     * Group by OSRIVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OSRIVApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OSRIVApproverGroupByArgs['orderBy'] }
        : { orderBy?: OSRIVApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OSRIVApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOSRIVApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OSRIVApprover model
   */
  readonly fields: OSRIVApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OSRIVApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OSRIVApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    osriv<T extends OSRIVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OSRIVDefaultArgs<ExtArgs>>): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OSRIVApprover model
   */ 
  interface OSRIVApproverFieldRefs {
    readonly id: FieldRef<"OSRIVApprover", 'String'>
    readonly osriv_id: FieldRef<"OSRIVApprover", 'String'>
    readonly approver_id: FieldRef<"OSRIVApprover", 'String'>
    readonly date_approval: FieldRef<"OSRIVApprover", 'DateTime'>
    readonly notes: FieldRef<"OSRIVApprover", 'String'>
    readonly status: FieldRef<"OSRIVApprover", 'Int'>
    readonly label: FieldRef<"OSRIVApprover", 'String'>
    readonly label_id: FieldRef<"OSRIVApprover", 'String'>
    readonly order: FieldRef<"OSRIVApprover", 'Int'>
    readonly updated_by: FieldRef<"OSRIVApprover", 'String'>
    readonly updated_at: FieldRef<"OSRIVApprover", 'DateTime'>
    readonly metadata: FieldRef<"OSRIVApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * OSRIVApprover findUnique
   */
  export type OSRIVApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVApprover to fetch.
     */
    where: OSRIVApproverWhereUniqueInput
  }


  /**
   * OSRIVApprover findUniqueOrThrow
   */
  export type OSRIVApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVApprover to fetch.
     */
    where: OSRIVApproverWhereUniqueInput
  }


  /**
   * OSRIVApprover findFirst
   */
  export type OSRIVApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVApprover to fetch.
     */
    where?: OSRIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVApprovers to fetch.
     */
    orderBy?: OSRIVApproverOrderByWithRelationInput | OSRIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVApprovers.
     */
    cursor?: OSRIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVApprovers.
     */
    distinct?: OSRIVApproverScalarFieldEnum | OSRIVApproverScalarFieldEnum[]
  }


  /**
   * OSRIVApprover findFirstOrThrow
   */
  export type OSRIVApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVApprover to fetch.
     */
    where?: OSRIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVApprovers to fetch.
     */
    orderBy?: OSRIVApproverOrderByWithRelationInput | OSRIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVApprovers.
     */
    cursor?: OSRIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVApprovers.
     */
    distinct?: OSRIVApproverScalarFieldEnum | OSRIVApproverScalarFieldEnum[]
  }


  /**
   * OSRIVApprover findMany
   */
  export type OSRIVApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVApprovers to fetch.
     */
    where?: OSRIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVApprovers to fetch.
     */
    orderBy?: OSRIVApproverOrderByWithRelationInput | OSRIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OSRIVApprovers.
     */
    cursor?: OSRIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVApprovers.
     */
    skip?: number
    distinct?: OSRIVApproverScalarFieldEnum | OSRIVApproverScalarFieldEnum[]
  }


  /**
   * OSRIVApprover create
   */
  export type OSRIVApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a OSRIVApprover.
     */
    data: XOR<OSRIVApproverCreateInput, OSRIVApproverUncheckedCreateInput>
  }


  /**
   * OSRIVApprover createMany
   */
  export type OSRIVApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OSRIVApprovers.
     */
    data: OSRIVApproverCreateManyInput | OSRIVApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OSRIVApprover update
   */
  export type OSRIVApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a OSRIVApprover.
     */
    data: XOR<OSRIVApproverUpdateInput, OSRIVApproverUncheckedUpdateInput>
    /**
     * Choose, which OSRIVApprover to update.
     */
    where: OSRIVApproverWhereUniqueInput
  }


  /**
   * OSRIVApprover updateMany
   */
  export type OSRIVApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OSRIVApprovers.
     */
    data: XOR<OSRIVApproverUpdateManyMutationInput, OSRIVApproverUncheckedUpdateManyInput>
    /**
     * Filter which OSRIVApprovers to update
     */
    where?: OSRIVApproverWhereInput
  }


  /**
   * OSRIVApprover upsert
   */
  export type OSRIVApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the OSRIVApprover to update in case it exists.
     */
    where: OSRIVApproverWhereUniqueInput
    /**
     * In case the OSRIVApprover found by the `where` argument doesn't exist, create a new OSRIVApprover with this data.
     */
    create: XOR<OSRIVApproverCreateInput, OSRIVApproverUncheckedCreateInput>
    /**
     * In case the OSRIVApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OSRIVApproverUpdateInput, OSRIVApproverUncheckedUpdateInput>
  }


  /**
   * OSRIVApprover delete
   */
  export type OSRIVApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
    /**
     * Filter which OSRIVApprover to delete.
     */
    where: OSRIVApproverWhereUniqueInput
  }


  /**
   * OSRIVApprover deleteMany
   */
  export type OSRIVApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIVApprovers to delete
     */
    where?: OSRIVApproverWhereInput
  }


  /**
   * OSRIVApprover without action
   */
  export type OSRIVApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVApprover
     */
    select?: OSRIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVApproverInclude<ExtArgs> | null
  }



  /**
   * Model OSRIVItem
   */

  export type AggregateOSRIVItem = {
    _count: OSRIVItemCountAggregateOutputType | null
    _avg: OSRIVItemAvgAggregateOutputType | null
    _sum: OSRIVItemSumAggregateOutputType | null
    _min: OSRIVItemMinAggregateOutputType | null
    _max: OSRIVItemMaxAggregateOutputType | null
  }

  export type OSRIVItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OSRIVItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OSRIVItemMinAggregateOutputType = {
    id: string | null
    osriv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type OSRIVItemMaxAggregateOutputType = {
    id: string | null
    osriv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type OSRIVItemCountAggregateOutputType = {
    id: number
    osriv_id: number
    item_id: number
    quantity: number
    price: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type OSRIVItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OSRIVItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OSRIVItemMinAggregateInputType = {
    id?: true
    osriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type OSRIVItemMaxAggregateInputType = {
    id?: true
    osriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type OSRIVItemCountAggregateInputType = {
    id?: true
    osriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type OSRIVItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIVItem to aggregate.
     */
    where?: OSRIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVItems to fetch.
     */
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OSRIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OSRIVItems
    **/
    _count?: true | OSRIVItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OSRIVItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OSRIVItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OSRIVItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OSRIVItemMaxAggregateInputType
  }

  export type GetOSRIVItemAggregateType<T extends OSRIVItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOSRIVItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOSRIVItem[P]>
      : GetScalarType<T[P], AggregateOSRIVItem[P]>
  }




  export type OSRIVItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OSRIVItemWhereInput
    orderBy?: OSRIVItemOrderByWithAggregationInput | OSRIVItemOrderByWithAggregationInput[]
    by: OSRIVItemScalarFieldEnum[] | OSRIVItemScalarFieldEnum
    having?: OSRIVItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OSRIVItemCountAggregateInputType | true
    _avg?: OSRIVItemAvgAggregateInputType
    _sum?: OSRIVItemSumAggregateInputType
    _min?: OSRIVItemMinAggregateInputType
    _max?: OSRIVItemMaxAggregateInputType
  }

  export type OSRIVItemGroupByOutputType = {
    id: string
    osriv_id: string
    item_id: string
    quantity: number
    price: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: OSRIVItemCountAggregateOutputType | null
    _avg: OSRIVItemAvgAggregateOutputType | null
    _sum: OSRIVItemSumAggregateOutputType | null
    _min: OSRIVItemMinAggregateOutputType | null
    _max: OSRIVItemMaxAggregateOutputType | null
  }

  type GetOSRIVItemGroupByPayload<T extends OSRIVItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OSRIVItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OSRIVItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OSRIVItemGroupByOutputType[P]>
            : GetScalarType<T[P], OSRIVItemGroupByOutputType[P]>
        }
      >
    >


  export type OSRIVItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    osriv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    osriv?: boolean | OSRIVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | OSRIVItem$item_transactionArgs<ExtArgs>
  }, ExtArgs["result"]["oSRIVItem"]>

  export type OSRIVItemSelectScalar = {
    id?: boolean
    osriv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type OSRIVItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    osriv?: boolean | OSRIVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | OSRIVItem$item_transactionArgs<ExtArgs>
  }


  export type $OSRIVItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OSRIVItem"
    objects: {
      osriv: Prisma.$OSRIVPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      osriv_id: string
      item_id: string
      quantity: number
      price: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["oSRIVItem"]>
    composites: {}
  }


  type OSRIVItemGetPayload<S extends boolean | null | undefined | OSRIVItemDefaultArgs> = $Result.GetResult<Prisma.$OSRIVItemPayload, S>

  type OSRIVItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OSRIVItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OSRIVItemCountAggregateInputType | true
    }

  export interface OSRIVItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OSRIVItem'], meta: { name: 'OSRIVItem' } }
    /**
     * Find zero or one OSRIVItem that matches the filter.
     * @param {OSRIVItemFindUniqueArgs} args - Arguments to find a OSRIVItem
     * @example
     * // Get one OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OSRIVItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemFindUniqueArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OSRIVItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OSRIVItemFindUniqueOrThrowArgs} args - Arguments to find a OSRIVItem
     * @example
     * // Get one OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OSRIVItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OSRIVItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemFindFirstArgs} args - Arguments to find a OSRIVItem
     * @example
     * // Get one OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OSRIVItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemFindFirstArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OSRIVItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemFindFirstOrThrowArgs} args - Arguments to find a OSRIVItem
     * @example
     * // Get one OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OSRIVItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OSRIVItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OSRIVItems
     * const oSRIVItems = await prisma.oSRIVItem.findMany()
     * 
     * // Get first 10 OSRIVItems
     * const oSRIVItems = await prisma.oSRIVItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oSRIVItemWithIdOnly = await prisma.oSRIVItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OSRIVItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OSRIVItem.
     * @param {OSRIVItemCreateArgs} args - Arguments to create a OSRIVItem.
     * @example
     * // Create one OSRIVItem
     * const OSRIVItem = await prisma.oSRIVItem.create({
     *   data: {
     *     // ... data to create a OSRIVItem
     *   }
     * })
     * 
    **/
    create<T extends OSRIVItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemCreateArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OSRIVItems.
     *     @param {OSRIVItemCreateManyArgs} args - Arguments to create many OSRIVItems.
     *     @example
     *     // Create many OSRIVItems
     *     const oSRIVItem = await prisma.oSRIVItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OSRIVItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OSRIVItem.
     * @param {OSRIVItemDeleteArgs} args - Arguments to delete one OSRIVItem.
     * @example
     * // Delete one OSRIVItem
     * const OSRIVItem = await prisma.oSRIVItem.delete({
     *   where: {
     *     // ... filter to delete one OSRIVItem
     *   }
     * })
     * 
    **/
    delete<T extends OSRIVItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemDeleteArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OSRIVItem.
     * @param {OSRIVItemUpdateArgs} args - Arguments to update one OSRIVItem.
     * @example
     * // Update one OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OSRIVItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemUpdateArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OSRIVItems.
     * @param {OSRIVItemDeleteManyArgs} args - Arguments to filter OSRIVItems to delete.
     * @example
     * // Delete a few OSRIVItems
     * const { count } = await prisma.oSRIVItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OSRIVItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OSRIVItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OSRIVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OSRIVItems
     * const oSRIVItem = await prisma.oSRIVItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OSRIVItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OSRIVItem.
     * @param {OSRIVItemUpsertArgs} args - Arguments to update or create a OSRIVItem.
     * @example
     * // Update or create a OSRIVItem
     * const oSRIVItem = await prisma.oSRIVItem.upsert({
     *   create: {
     *     // ... data to create a OSRIVItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OSRIVItem we want to update
     *   }
     * })
    **/
    upsert<T extends OSRIVItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OSRIVItemUpsertArgs<ExtArgs>>
    ): Prisma__OSRIVItemClient<$Result.GetResult<Prisma.$OSRIVItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OSRIVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemCountArgs} args - Arguments to filter OSRIVItems to count.
     * @example
     * // Count the number of OSRIVItems
     * const count = await prisma.oSRIVItem.count({
     *   where: {
     *     // ... the filter for the OSRIVItems we want to count
     *   }
     * })
    **/
    count<T extends OSRIVItemCountArgs>(
      args?: Subset<T, OSRIVItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OSRIVItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OSRIVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OSRIVItemAggregateArgs>(args: Subset<T, OSRIVItemAggregateArgs>): Prisma.PrismaPromise<GetOSRIVItemAggregateType<T>>

    /**
     * Group by OSRIVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OSRIVItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OSRIVItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OSRIVItemGroupByArgs['orderBy'] }
        : { orderBy?: OSRIVItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OSRIVItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOSRIVItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OSRIVItem model
   */
  readonly fields: OSRIVItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OSRIVItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OSRIVItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    osriv<T extends OSRIVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OSRIVDefaultArgs<ExtArgs>>): Prisma__OSRIVClient<$Result.GetResult<Prisma.$OSRIVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transaction<T extends OSRIVItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, OSRIVItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OSRIVItem model
   */ 
  interface OSRIVItemFieldRefs {
    readonly id: FieldRef<"OSRIVItem", 'String'>
    readonly osriv_id: FieldRef<"OSRIVItem", 'String'>
    readonly item_id: FieldRef<"OSRIVItem", 'String'>
    readonly quantity: FieldRef<"OSRIVItem", 'Int'>
    readonly price: FieldRef<"OSRIVItem", 'Float'>
    readonly created_by: FieldRef<"OSRIVItem", 'String'>
    readonly created_at: FieldRef<"OSRIVItem", 'DateTime'>
    readonly metadata: FieldRef<"OSRIVItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * OSRIVItem findUnique
   */
  export type OSRIVItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVItem to fetch.
     */
    where: OSRIVItemWhereUniqueInput
  }


  /**
   * OSRIVItem findUniqueOrThrow
   */
  export type OSRIVItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVItem to fetch.
     */
    where: OSRIVItemWhereUniqueInput
  }


  /**
   * OSRIVItem findFirst
   */
  export type OSRIVItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVItem to fetch.
     */
    where?: OSRIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVItems to fetch.
     */
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVItems.
     */
    cursor?: OSRIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVItems.
     */
    distinct?: OSRIVItemScalarFieldEnum | OSRIVItemScalarFieldEnum[]
  }


  /**
   * OSRIVItem findFirstOrThrow
   */
  export type OSRIVItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVItem to fetch.
     */
    where?: OSRIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVItems to fetch.
     */
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OSRIVItems.
     */
    cursor?: OSRIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OSRIVItems.
     */
    distinct?: OSRIVItemScalarFieldEnum | OSRIVItemScalarFieldEnum[]
  }


  /**
   * OSRIVItem findMany
   */
  export type OSRIVItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter, which OSRIVItems to fetch.
     */
    where?: OSRIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OSRIVItems to fetch.
     */
    orderBy?: OSRIVItemOrderByWithRelationInput | OSRIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OSRIVItems.
     */
    cursor?: OSRIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OSRIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OSRIVItems.
     */
    skip?: number
    distinct?: OSRIVItemScalarFieldEnum | OSRIVItemScalarFieldEnum[]
  }


  /**
   * OSRIVItem create
   */
  export type OSRIVItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OSRIVItem.
     */
    data: XOR<OSRIVItemCreateInput, OSRIVItemUncheckedCreateInput>
  }


  /**
   * OSRIVItem createMany
   */
  export type OSRIVItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OSRIVItems.
     */
    data: OSRIVItemCreateManyInput | OSRIVItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OSRIVItem update
   */
  export type OSRIVItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OSRIVItem.
     */
    data: XOR<OSRIVItemUpdateInput, OSRIVItemUncheckedUpdateInput>
    /**
     * Choose, which OSRIVItem to update.
     */
    where: OSRIVItemWhereUniqueInput
  }


  /**
   * OSRIVItem updateMany
   */
  export type OSRIVItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OSRIVItems.
     */
    data: XOR<OSRIVItemUpdateManyMutationInput, OSRIVItemUncheckedUpdateManyInput>
    /**
     * Filter which OSRIVItems to update
     */
    where?: OSRIVItemWhereInput
  }


  /**
   * OSRIVItem upsert
   */
  export type OSRIVItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OSRIVItem to update in case it exists.
     */
    where: OSRIVItemWhereUniqueInput
    /**
     * In case the OSRIVItem found by the `where` argument doesn't exist, create a new OSRIVItem with this data.
     */
    create: XOR<OSRIVItemCreateInput, OSRIVItemUncheckedCreateInput>
    /**
     * In case the OSRIVItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OSRIVItemUpdateInput, OSRIVItemUncheckedUpdateInput>
  }


  /**
   * OSRIVItem delete
   */
  export type OSRIVItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
    /**
     * Filter which OSRIVItem to delete.
     */
    where: OSRIVItemWhereUniqueInput
  }


  /**
   * OSRIVItem deleteMany
   */
  export type OSRIVItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OSRIVItems to delete
     */
    where?: OSRIVItemWhereInput
  }


  /**
   * OSRIVItem.item_transaction
   */
  export type OSRIVItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * OSRIVItem without action
   */
  export type OSRIVItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OSRIVItem
     */
    select?: OSRIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OSRIVItemInclude<ExtArgs> | null
  }



  /**
   * Model SERIV
   */

  export type AggregateSERIV = {
    _count: SERIVCountAggregateOutputType | null
    _avg: SERIVAvgAggregateOutputType | null
    _sum: SERIVSumAggregateOutputType | null
    _min: SERIVMinAggregateOutputType | null
    _max: SERIVMaxAggregateOutputType | null
  }

  export type SERIVAvgAggregateOutputType = {
    request_type: number | null
  }

  export type SERIVSumAggregateOutputType = {
    request_type: number | null
  }

  export type SERIVMinAggregateOutputType = {
    id: string | null
    seriv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    request_type: number | null
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string | null
    location: string | null
    requested_by_id: string | null
    withdrawn_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SERIVMaxAggregateOutputType = {
    id: string | null
    seriv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    request_type: number | null
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string | null
    location: string | null
    requested_by_id: string | null
    withdrawn_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SERIVCountAggregateOutputType = {
    id: number
    seriv_number: number
    date_requested: number
    exp_date: number
    purpose: number
    note: number
    is_completed: number
    request_type: number
    or_number: number
    mwo_number: number
    cwo_number: number
    jo_number: number
    consumer_name: number
    location: number
    requested_by_id: number
    withdrawn_by_id: number
    item_from_id: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type SERIVAvgAggregateInputType = {
    request_type?: true
  }

  export type SERIVSumAggregateInputType = {
    request_type?: true
  }

  export type SERIVMinAggregateInputType = {
    id?: true
    seriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type SERIVMaxAggregateInputType = {
    id?: true
    seriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type SERIVCountAggregateInputType = {
    id?: true
    seriv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type SERIVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIV to aggregate.
     */
    where?: SERIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVS to fetch.
     */
    orderBy?: SERIVOrderByWithRelationInput | SERIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SERIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SERIVS
    **/
    _count?: true | SERIVCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SERIVAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SERIVSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SERIVMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SERIVMaxAggregateInputType
  }

  export type GetSERIVAggregateType<T extends SERIVAggregateArgs> = {
        [P in keyof T & keyof AggregateSERIV]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSERIV[P]>
      : GetScalarType<T[P], AggregateSERIV[P]>
  }




  export type SERIVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVWhereInput
    orderBy?: SERIVOrderByWithAggregationInput | SERIVOrderByWithAggregationInput[]
    by: SERIVScalarFieldEnum[] | SERIVScalarFieldEnum
    having?: SERIVScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SERIVCountAggregateInputType | true
    _avg?: SERIVAvgAggregateInputType
    _sum?: SERIVSumAggregateInputType
    _min?: SERIVMinAggregateInputType
    _max?: SERIVMaxAggregateInputType
  }

  export type SERIVGroupByOutputType = {
    id: string
    seriv_number: string
    date_requested: Date
    exp_date: Date
    purpose: string
    note: string
    is_completed: boolean
    request_type: number
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: SERIVCountAggregateOutputType | null
    _avg: SERIVAvgAggregateOutputType | null
    _sum: SERIVSumAggregateOutputType | null
    _min: SERIVMinAggregateOutputType | null
    _max: SERIVMaxAggregateOutputType | null
  }

  type GetSERIVGroupByPayload<T extends SERIVGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SERIVGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SERIVGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SERIVGroupByOutputType[P]>
            : GetScalarType<T[P], SERIVGroupByOutputType[P]>
        }
      >
    >


  export type SERIVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    request_type?: boolean
    or_number?: boolean
    mwo_number?: boolean
    cwo_number?: boolean
    jo_number?: boolean
    consumer_name?: boolean
    location?: boolean
    requested_by_id?: boolean
    withdrawn_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    seriv_approvers?: boolean | SERIV$seriv_approversArgs<ExtArgs>
    seriv_items?: boolean | SERIV$seriv_itemsArgs<ExtArgs>
    mcrts?: boolean | SERIV$mcrtsArgs<ExtArgs>
    _count?: boolean | SERIVCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sERIV"]>

  export type SERIVSelectScalar = {
    id?: boolean
    seriv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    request_type?: boolean
    or_number?: boolean
    mwo_number?: boolean
    cwo_number?: boolean
    jo_number?: boolean
    consumer_name?: boolean
    location?: boolean
    requested_by_id?: boolean
    withdrawn_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type SERIVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    seriv_approvers?: boolean | SERIV$seriv_approversArgs<ExtArgs>
    seriv_items?: boolean | SERIV$seriv_itemsArgs<ExtArgs>
    mcrts?: boolean | SERIV$mcrtsArgs<ExtArgs>
    _count?: boolean | SERIVCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SERIVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SERIV"
    objects: {
      item_from: Prisma.$StationPayload<ExtArgs>
      seriv_approvers: Prisma.$SERIVApproverPayload<ExtArgs>[]
      seriv_items: Prisma.$SERIVItemPayload<ExtArgs>[]
      mcrts: Prisma.$MCRTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriv_number: string
      date_requested: Date
      exp_date: Date
      purpose: string
      note: string
      is_completed: boolean
      request_type: number
      or_number: string | null
      mwo_number: string | null
      cwo_number: string | null
      jo_number: string | null
      consumer_name: string
      location: string
      requested_by_id: string
      withdrawn_by_id: string
      item_from_id: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sERIV"]>
    composites: {}
  }


  type SERIVGetPayload<S extends boolean | null | undefined | SERIVDefaultArgs> = $Result.GetResult<Prisma.$SERIVPayload, S>

  type SERIVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SERIVFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SERIVCountAggregateInputType | true
    }

  export interface SERIVDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SERIV'], meta: { name: 'SERIV' } }
    /**
     * Find zero or one SERIV that matches the filter.
     * @param {SERIVFindUniqueArgs} args - Arguments to find a SERIV
     * @example
     * // Get one SERIV
     * const sERIV = await prisma.sERIV.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SERIVFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVFindUniqueArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SERIV that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SERIVFindUniqueOrThrowArgs} args - Arguments to find a SERIV
     * @example
     * // Get one SERIV
     * const sERIV = await prisma.sERIV.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SERIVFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SERIV that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVFindFirstArgs} args - Arguments to find a SERIV
     * @example
     * // Get one SERIV
     * const sERIV = await prisma.sERIV.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SERIVFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVFindFirstArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SERIV that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVFindFirstOrThrowArgs} args - Arguments to find a SERIV
     * @example
     * // Get one SERIV
     * const sERIV = await prisma.sERIV.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SERIVFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SERIVS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SERIVS
     * const sERIVS = await prisma.sERIV.findMany()
     * 
     * // Get first 10 SERIVS
     * const sERIVS = await prisma.sERIV.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sERIVWithIdOnly = await prisma.sERIV.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SERIVFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SERIV.
     * @param {SERIVCreateArgs} args - Arguments to create a SERIV.
     * @example
     * // Create one SERIV
     * const SERIV = await prisma.sERIV.create({
     *   data: {
     *     // ... data to create a SERIV
     *   }
     * })
     * 
    **/
    create<T extends SERIVCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVCreateArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SERIVS.
     *     @param {SERIVCreateManyArgs} args - Arguments to create many SERIVS.
     *     @example
     *     // Create many SERIVS
     *     const sERIV = await prisma.sERIV.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SERIVCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SERIV.
     * @param {SERIVDeleteArgs} args - Arguments to delete one SERIV.
     * @example
     * // Delete one SERIV
     * const SERIV = await prisma.sERIV.delete({
     *   where: {
     *     // ... filter to delete one SERIV
     *   }
     * })
     * 
    **/
    delete<T extends SERIVDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVDeleteArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SERIV.
     * @param {SERIVUpdateArgs} args - Arguments to update one SERIV.
     * @example
     * // Update one SERIV
     * const sERIV = await prisma.sERIV.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SERIVUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVUpdateArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SERIVS.
     * @param {SERIVDeleteManyArgs} args - Arguments to filter SERIVS to delete.
     * @example
     * // Delete a few SERIVS
     * const { count } = await prisma.sERIV.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SERIVDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SERIVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SERIVS
     * const sERIV = await prisma.sERIV.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SERIVUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SERIV.
     * @param {SERIVUpsertArgs} args - Arguments to update or create a SERIV.
     * @example
     * // Update or create a SERIV
     * const sERIV = await prisma.sERIV.upsert({
     *   create: {
     *     // ... data to create a SERIV
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SERIV we want to update
     *   }
     * })
    **/
    upsert<T extends SERIVUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVUpsertArgs<ExtArgs>>
    ): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SERIVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVCountArgs} args - Arguments to filter SERIVS to count.
     * @example
     * // Count the number of SERIVS
     * const count = await prisma.sERIV.count({
     *   where: {
     *     // ... the filter for the SERIVS we want to count
     *   }
     * })
    **/
    count<T extends SERIVCountArgs>(
      args?: Subset<T, SERIVCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SERIVCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SERIV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SERIVAggregateArgs>(args: Subset<T, SERIVAggregateArgs>): Prisma.PrismaPromise<GetSERIVAggregateType<T>>

    /**
     * Group by SERIV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SERIVGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SERIVGroupByArgs['orderBy'] }
        : { orderBy?: SERIVGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SERIVGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSERIVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SERIV model
   */
  readonly fields: SERIVFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SERIV.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SERIVClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item_from<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    seriv_approvers<T extends SERIV$seriv_approversArgs<ExtArgs> = {}>(args?: Subset<T, SERIV$seriv_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    seriv_items<T extends SERIV$seriv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, SERIV$seriv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mcrts<T extends SERIV$mcrtsArgs<ExtArgs> = {}>(args?: Subset<T, SERIV$mcrtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SERIV model
   */ 
  interface SERIVFieldRefs {
    readonly id: FieldRef<"SERIV", 'String'>
    readonly seriv_number: FieldRef<"SERIV", 'String'>
    readonly date_requested: FieldRef<"SERIV", 'DateTime'>
    readonly exp_date: FieldRef<"SERIV", 'DateTime'>
    readonly purpose: FieldRef<"SERIV", 'String'>
    readonly note: FieldRef<"SERIV", 'String'>
    readonly is_completed: FieldRef<"SERIV", 'Boolean'>
    readonly request_type: FieldRef<"SERIV", 'Int'>
    readonly or_number: FieldRef<"SERIV", 'String'>
    readonly mwo_number: FieldRef<"SERIV", 'String'>
    readonly cwo_number: FieldRef<"SERIV", 'String'>
    readonly jo_number: FieldRef<"SERIV", 'String'>
    readonly consumer_name: FieldRef<"SERIV", 'String'>
    readonly location: FieldRef<"SERIV", 'String'>
    readonly requested_by_id: FieldRef<"SERIV", 'String'>
    readonly withdrawn_by_id: FieldRef<"SERIV", 'String'>
    readonly item_from_id: FieldRef<"SERIV", 'String'>
    readonly cancelled_by: FieldRef<"SERIV", 'String'>
    readonly created_by: FieldRef<"SERIV", 'String'>
    readonly updated_by: FieldRef<"SERIV", 'String'>
    readonly cancelled_at: FieldRef<"SERIV", 'DateTime'>
    readonly created_at: FieldRef<"SERIV", 'DateTime'>
    readonly updated_at: FieldRef<"SERIV", 'DateTime'>
    readonly metadata: FieldRef<"SERIV", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SERIV findUnique
   */
  export type SERIVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter, which SERIV to fetch.
     */
    where: SERIVWhereUniqueInput
  }


  /**
   * SERIV findUniqueOrThrow
   */
  export type SERIVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter, which SERIV to fetch.
     */
    where: SERIVWhereUniqueInput
  }


  /**
   * SERIV findFirst
   */
  export type SERIVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter, which SERIV to fetch.
     */
    where?: SERIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVS to fetch.
     */
    orderBy?: SERIVOrderByWithRelationInput | SERIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVS.
     */
    cursor?: SERIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVS.
     */
    distinct?: SERIVScalarFieldEnum | SERIVScalarFieldEnum[]
  }


  /**
   * SERIV findFirstOrThrow
   */
  export type SERIVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter, which SERIV to fetch.
     */
    where?: SERIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVS to fetch.
     */
    orderBy?: SERIVOrderByWithRelationInput | SERIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVS.
     */
    cursor?: SERIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVS.
     */
    distinct?: SERIVScalarFieldEnum | SERIVScalarFieldEnum[]
  }


  /**
   * SERIV findMany
   */
  export type SERIVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter, which SERIVS to fetch.
     */
    where?: SERIVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVS to fetch.
     */
    orderBy?: SERIVOrderByWithRelationInput | SERIVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SERIVS.
     */
    cursor?: SERIVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVS.
     */
    skip?: number
    distinct?: SERIVScalarFieldEnum | SERIVScalarFieldEnum[]
  }


  /**
   * SERIV create
   */
  export type SERIVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * The data needed to create a SERIV.
     */
    data: XOR<SERIVCreateInput, SERIVUncheckedCreateInput>
  }


  /**
   * SERIV createMany
   */
  export type SERIVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SERIVS.
     */
    data: SERIVCreateManyInput | SERIVCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SERIV update
   */
  export type SERIVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * The data needed to update a SERIV.
     */
    data: XOR<SERIVUpdateInput, SERIVUncheckedUpdateInput>
    /**
     * Choose, which SERIV to update.
     */
    where: SERIVWhereUniqueInput
  }


  /**
   * SERIV updateMany
   */
  export type SERIVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SERIVS.
     */
    data: XOR<SERIVUpdateManyMutationInput, SERIVUncheckedUpdateManyInput>
    /**
     * Filter which SERIVS to update
     */
    where?: SERIVWhereInput
  }


  /**
   * SERIV upsert
   */
  export type SERIVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * The filter to search for the SERIV to update in case it exists.
     */
    where: SERIVWhereUniqueInput
    /**
     * In case the SERIV found by the `where` argument doesn't exist, create a new SERIV with this data.
     */
    create: XOR<SERIVCreateInput, SERIVUncheckedCreateInput>
    /**
     * In case the SERIV was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SERIVUpdateInput, SERIVUncheckedUpdateInput>
  }


  /**
   * SERIV delete
   */
  export type SERIVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    /**
     * Filter which SERIV to delete.
     */
    where: SERIVWhereUniqueInput
  }


  /**
   * SERIV deleteMany
   */
  export type SERIVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIVS to delete
     */
    where?: SERIVWhereInput
  }


  /**
   * SERIV.seriv_approvers
   */
  export type SERIV$seriv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    where?: SERIVApproverWhereInput
    orderBy?: SERIVApproverOrderByWithRelationInput | SERIVApproverOrderByWithRelationInput[]
    cursor?: SERIVApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SERIVApproverScalarFieldEnum | SERIVApproverScalarFieldEnum[]
  }


  /**
   * SERIV.seriv_items
   */
  export type SERIV$seriv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    where?: SERIVItemWhereInput
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    cursor?: SERIVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SERIVItemScalarFieldEnum | SERIVItemScalarFieldEnum[]
  }


  /**
   * SERIV.mcrts
   */
  export type SERIV$mcrtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    where?: MCRTWhereInput
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    cursor?: MCRTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCRTScalarFieldEnum | MCRTScalarFieldEnum[]
  }


  /**
   * SERIV without action
   */
  export type SERIVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
  }



  /**
   * Model SERIVApprover
   */

  export type AggregateSERIVApprover = {
    _count: SERIVApproverCountAggregateOutputType | null
    _avg: SERIVApproverAvgAggregateOutputType | null
    _sum: SERIVApproverSumAggregateOutputType | null
    _min: SERIVApproverMinAggregateOutputType | null
    _max: SERIVApproverMaxAggregateOutputType | null
  }

  export type SERIVApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SERIVApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SERIVApproverMinAggregateOutputType = {
    id: string | null
    seriv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type SERIVApproverMaxAggregateOutputType = {
    id: string | null
    seriv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type SERIVApproverCountAggregateOutputType = {
    id: number
    seriv_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type SERIVApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type SERIVApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type SERIVApproverMinAggregateInputType = {
    id?: true
    seriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type SERIVApproverMaxAggregateInputType = {
    id?: true
    seriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type SERIVApproverCountAggregateInputType = {
    id?: true
    seriv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type SERIVApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIVApprover to aggregate.
     */
    where?: SERIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVApprovers to fetch.
     */
    orderBy?: SERIVApproverOrderByWithRelationInput | SERIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SERIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SERIVApprovers
    **/
    _count?: true | SERIVApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SERIVApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SERIVApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SERIVApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SERIVApproverMaxAggregateInputType
  }

  export type GetSERIVApproverAggregateType<T extends SERIVApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateSERIVApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSERIVApprover[P]>
      : GetScalarType<T[P], AggregateSERIVApprover[P]>
  }




  export type SERIVApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVApproverWhereInput
    orderBy?: SERIVApproverOrderByWithAggregationInput | SERIVApproverOrderByWithAggregationInput[]
    by: SERIVApproverScalarFieldEnum[] | SERIVApproverScalarFieldEnum
    having?: SERIVApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SERIVApproverCountAggregateInputType | true
    _avg?: SERIVApproverAvgAggregateInputType
    _sum?: SERIVApproverSumAggregateInputType
    _min?: SERIVApproverMinAggregateInputType
    _max?: SERIVApproverMaxAggregateInputType
  }

  export type SERIVApproverGroupByOutputType = {
    id: string
    seriv_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: SERIVApproverCountAggregateOutputType | null
    _avg: SERIVApproverAvgAggregateOutputType | null
    _sum: SERIVApproverSumAggregateOutputType | null
    _min: SERIVApproverMinAggregateOutputType | null
    _max: SERIVApproverMaxAggregateOutputType | null
  }

  type GetSERIVApproverGroupByPayload<T extends SERIVApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SERIVApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SERIVApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SERIVApproverGroupByOutputType[P]>
            : GetScalarType<T[P], SERIVApproverGroupByOutputType[P]>
        }
      >
    >


  export type SERIVApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    seriv?: boolean | SERIVDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sERIVApprover"]>

  export type SERIVApproverSelectScalar = {
    id?: boolean
    seriv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type SERIVApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seriv?: boolean | SERIVDefaultArgs<ExtArgs>
  }


  export type $SERIVApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SERIVApprover"
    objects: {
      seriv: Prisma.$SERIVPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriv_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sERIVApprover"]>
    composites: {}
  }


  type SERIVApproverGetPayload<S extends boolean | null | undefined | SERIVApproverDefaultArgs> = $Result.GetResult<Prisma.$SERIVApproverPayload, S>

  type SERIVApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SERIVApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SERIVApproverCountAggregateInputType | true
    }

  export interface SERIVApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SERIVApprover'], meta: { name: 'SERIVApprover' } }
    /**
     * Find zero or one SERIVApprover that matches the filter.
     * @param {SERIVApproverFindUniqueArgs} args - Arguments to find a SERIVApprover
     * @example
     * // Get one SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SERIVApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SERIVApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SERIVApproverFindUniqueOrThrowArgs} args - Arguments to find a SERIVApprover
     * @example
     * // Get one SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SERIVApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SERIVApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverFindFirstArgs} args - Arguments to find a SERIVApprover
     * @example
     * // Get one SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SERIVApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverFindFirstArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SERIVApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverFindFirstOrThrowArgs} args - Arguments to find a SERIVApprover
     * @example
     * // Get one SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SERIVApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SERIVApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SERIVApprovers
     * const sERIVApprovers = await prisma.sERIVApprover.findMany()
     * 
     * // Get first 10 SERIVApprovers
     * const sERIVApprovers = await prisma.sERIVApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sERIVApproverWithIdOnly = await prisma.sERIVApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SERIVApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SERIVApprover.
     * @param {SERIVApproverCreateArgs} args - Arguments to create a SERIVApprover.
     * @example
     * // Create one SERIVApprover
     * const SERIVApprover = await prisma.sERIVApprover.create({
     *   data: {
     *     // ... data to create a SERIVApprover
     *   }
     * })
     * 
    **/
    create<T extends SERIVApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverCreateArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SERIVApprovers.
     *     @param {SERIVApproverCreateManyArgs} args - Arguments to create many SERIVApprovers.
     *     @example
     *     // Create many SERIVApprovers
     *     const sERIVApprover = await prisma.sERIVApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SERIVApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SERIVApprover.
     * @param {SERIVApproverDeleteArgs} args - Arguments to delete one SERIVApprover.
     * @example
     * // Delete one SERIVApprover
     * const SERIVApprover = await prisma.sERIVApprover.delete({
     *   where: {
     *     // ... filter to delete one SERIVApprover
     *   }
     * })
     * 
    **/
    delete<T extends SERIVApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverDeleteArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SERIVApprover.
     * @param {SERIVApproverUpdateArgs} args - Arguments to update one SERIVApprover.
     * @example
     * // Update one SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SERIVApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverUpdateArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SERIVApprovers.
     * @param {SERIVApproverDeleteManyArgs} args - Arguments to filter SERIVApprovers to delete.
     * @example
     * // Delete a few SERIVApprovers
     * const { count } = await prisma.sERIVApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SERIVApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SERIVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SERIVApprovers
     * const sERIVApprover = await prisma.sERIVApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SERIVApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SERIVApprover.
     * @param {SERIVApproverUpsertArgs} args - Arguments to update or create a SERIVApprover.
     * @example
     * // Update or create a SERIVApprover
     * const sERIVApprover = await prisma.sERIVApprover.upsert({
     *   create: {
     *     // ... data to create a SERIVApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SERIVApprover we want to update
     *   }
     * })
    **/
    upsert<T extends SERIVApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVApproverUpsertArgs<ExtArgs>>
    ): Prisma__SERIVApproverClient<$Result.GetResult<Prisma.$SERIVApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SERIVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverCountArgs} args - Arguments to filter SERIVApprovers to count.
     * @example
     * // Count the number of SERIVApprovers
     * const count = await prisma.sERIVApprover.count({
     *   where: {
     *     // ... the filter for the SERIVApprovers we want to count
     *   }
     * })
    **/
    count<T extends SERIVApproverCountArgs>(
      args?: Subset<T, SERIVApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SERIVApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SERIVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SERIVApproverAggregateArgs>(args: Subset<T, SERIVApproverAggregateArgs>): Prisma.PrismaPromise<GetSERIVApproverAggregateType<T>>

    /**
     * Group by SERIVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SERIVApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SERIVApproverGroupByArgs['orderBy'] }
        : { orderBy?: SERIVApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SERIVApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSERIVApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SERIVApprover model
   */
  readonly fields: SERIVApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SERIVApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SERIVApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    seriv<T extends SERIVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SERIVDefaultArgs<ExtArgs>>): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SERIVApprover model
   */ 
  interface SERIVApproverFieldRefs {
    readonly id: FieldRef<"SERIVApprover", 'String'>
    readonly seriv_id: FieldRef<"SERIVApprover", 'String'>
    readonly approver_id: FieldRef<"SERIVApprover", 'String'>
    readonly date_approval: FieldRef<"SERIVApprover", 'DateTime'>
    readonly notes: FieldRef<"SERIVApprover", 'String'>
    readonly status: FieldRef<"SERIVApprover", 'Int'>
    readonly label: FieldRef<"SERIVApprover", 'String'>
    readonly label_id: FieldRef<"SERIVApprover", 'String'>
    readonly order: FieldRef<"SERIVApprover", 'Int'>
    readonly updated_by: FieldRef<"SERIVApprover", 'String'>
    readonly updated_at: FieldRef<"SERIVApprover", 'DateTime'>
    readonly metadata: FieldRef<"SERIVApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SERIVApprover findUnique
   */
  export type SERIVApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which SERIVApprover to fetch.
     */
    where: SERIVApproverWhereUniqueInput
  }


  /**
   * SERIVApprover findUniqueOrThrow
   */
  export type SERIVApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which SERIVApprover to fetch.
     */
    where: SERIVApproverWhereUniqueInput
  }


  /**
   * SERIVApprover findFirst
   */
  export type SERIVApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which SERIVApprover to fetch.
     */
    where?: SERIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVApprovers to fetch.
     */
    orderBy?: SERIVApproverOrderByWithRelationInput | SERIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVApprovers.
     */
    cursor?: SERIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVApprovers.
     */
    distinct?: SERIVApproverScalarFieldEnum | SERIVApproverScalarFieldEnum[]
  }


  /**
   * SERIVApprover findFirstOrThrow
   */
  export type SERIVApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which SERIVApprover to fetch.
     */
    where?: SERIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVApprovers to fetch.
     */
    orderBy?: SERIVApproverOrderByWithRelationInput | SERIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVApprovers.
     */
    cursor?: SERIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVApprovers.
     */
    distinct?: SERIVApproverScalarFieldEnum | SERIVApproverScalarFieldEnum[]
  }


  /**
   * SERIVApprover findMany
   */
  export type SERIVApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter, which SERIVApprovers to fetch.
     */
    where?: SERIVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVApprovers to fetch.
     */
    orderBy?: SERIVApproverOrderByWithRelationInput | SERIVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SERIVApprovers.
     */
    cursor?: SERIVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVApprovers.
     */
    skip?: number
    distinct?: SERIVApproverScalarFieldEnum | SERIVApproverScalarFieldEnum[]
  }


  /**
   * SERIVApprover create
   */
  export type SERIVApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a SERIVApprover.
     */
    data: XOR<SERIVApproverCreateInput, SERIVApproverUncheckedCreateInput>
  }


  /**
   * SERIVApprover createMany
   */
  export type SERIVApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SERIVApprovers.
     */
    data: SERIVApproverCreateManyInput | SERIVApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SERIVApprover update
   */
  export type SERIVApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a SERIVApprover.
     */
    data: XOR<SERIVApproverUpdateInput, SERIVApproverUncheckedUpdateInput>
    /**
     * Choose, which SERIVApprover to update.
     */
    where: SERIVApproverWhereUniqueInput
  }


  /**
   * SERIVApprover updateMany
   */
  export type SERIVApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SERIVApprovers.
     */
    data: XOR<SERIVApproverUpdateManyMutationInput, SERIVApproverUncheckedUpdateManyInput>
    /**
     * Filter which SERIVApprovers to update
     */
    where?: SERIVApproverWhereInput
  }


  /**
   * SERIVApprover upsert
   */
  export type SERIVApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the SERIVApprover to update in case it exists.
     */
    where: SERIVApproverWhereUniqueInput
    /**
     * In case the SERIVApprover found by the `where` argument doesn't exist, create a new SERIVApprover with this data.
     */
    create: XOR<SERIVApproverCreateInput, SERIVApproverUncheckedCreateInput>
    /**
     * In case the SERIVApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SERIVApproverUpdateInput, SERIVApproverUncheckedUpdateInput>
  }


  /**
   * SERIVApprover delete
   */
  export type SERIVApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
    /**
     * Filter which SERIVApprover to delete.
     */
    where: SERIVApproverWhereUniqueInput
  }


  /**
   * SERIVApprover deleteMany
   */
  export type SERIVApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIVApprovers to delete
     */
    where?: SERIVApproverWhereInput
  }


  /**
   * SERIVApprover without action
   */
  export type SERIVApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVApprover
     */
    select?: SERIVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVApproverInclude<ExtArgs> | null
  }



  /**
   * Model SERIVItem
   */

  export type AggregateSERIVItem = {
    _count: SERIVItemCountAggregateOutputType | null
    _avg: SERIVItemAvgAggregateOutputType | null
    _sum: SERIVItemSumAggregateOutputType | null
    _min: SERIVItemMinAggregateOutputType | null
    _max: SERIVItemMaxAggregateOutputType | null
  }

  export type SERIVItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type SERIVItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type SERIVItemMinAggregateOutputType = {
    id: string | null
    seriv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type SERIVItemMaxAggregateOutputType = {
    id: string | null
    seriv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type SERIVItemCountAggregateOutputType = {
    id: number
    seriv_id: number
    item_id: number
    quantity: number
    price: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type SERIVItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type SERIVItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type SERIVItemMinAggregateInputType = {
    id?: true
    seriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type SERIVItemMaxAggregateInputType = {
    id?: true
    seriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type SERIVItemCountAggregateInputType = {
    id?: true
    seriv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type SERIVItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIVItem to aggregate.
     */
    where?: SERIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVItems to fetch.
     */
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SERIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SERIVItems
    **/
    _count?: true | SERIVItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SERIVItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SERIVItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SERIVItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SERIVItemMaxAggregateInputType
  }

  export type GetSERIVItemAggregateType<T extends SERIVItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSERIVItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSERIVItem[P]>
      : GetScalarType<T[P], AggregateSERIVItem[P]>
  }




  export type SERIVItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SERIVItemWhereInput
    orderBy?: SERIVItemOrderByWithAggregationInput | SERIVItemOrderByWithAggregationInput[]
    by: SERIVItemScalarFieldEnum[] | SERIVItemScalarFieldEnum
    having?: SERIVItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SERIVItemCountAggregateInputType | true
    _avg?: SERIVItemAvgAggregateInputType
    _sum?: SERIVItemSumAggregateInputType
    _min?: SERIVItemMinAggregateInputType
    _max?: SERIVItemMaxAggregateInputType
  }

  export type SERIVItemGroupByOutputType = {
    id: string
    seriv_id: string
    item_id: string
    quantity: number
    price: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: SERIVItemCountAggregateOutputType | null
    _avg: SERIVItemAvgAggregateOutputType | null
    _sum: SERIVItemSumAggregateOutputType | null
    _min: SERIVItemMinAggregateOutputType | null
    _max: SERIVItemMaxAggregateOutputType | null
  }

  type GetSERIVItemGroupByPayload<T extends SERIVItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SERIVItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SERIVItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SERIVItemGroupByOutputType[P]>
            : GetScalarType<T[P], SERIVItemGroupByOutputType[P]>
        }
      >
    >


  export type SERIVItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    seriv?: boolean | SERIVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | SERIVItem$item_transactionArgs<ExtArgs>
  }, ExtArgs["result"]["sERIVItem"]>

  export type SERIVItemSelectScalar = {
    id?: boolean
    seriv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type SERIVItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seriv?: boolean | SERIVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | SERIVItem$item_transactionArgs<ExtArgs>
  }


  export type $SERIVItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SERIVItem"
    objects: {
      seriv: Prisma.$SERIVPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriv_id: string
      item_id: string
      quantity: number
      price: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sERIVItem"]>
    composites: {}
  }


  type SERIVItemGetPayload<S extends boolean | null | undefined | SERIVItemDefaultArgs> = $Result.GetResult<Prisma.$SERIVItemPayload, S>

  type SERIVItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SERIVItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SERIVItemCountAggregateInputType | true
    }

  export interface SERIVItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SERIVItem'], meta: { name: 'SERIVItem' } }
    /**
     * Find zero or one SERIVItem that matches the filter.
     * @param {SERIVItemFindUniqueArgs} args - Arguments to find a SERIVItem
     * @example
     * // Get one SERIVItem
     * const sERIVItem = await prisma.sERIVItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SERIVItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemFindUniqueArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SERIVItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SERIVItemFindUniqueOrThrowArgs} args - Arguments to find a SERIVItem
     * @example
     * // Get one SERIVItem
     * const sERIVItem = await prisma.sERIVItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SERIVItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SERIVItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemFindFirstArgs} args - Arguments to find a SERIVItem
     * @example
     * // Get one SERIVItem
     * const sERIVItem = await prisma.sERIVItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SERIVItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemFindFirstArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SERIVItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemFindFirstOrThrowArgs} args - Arguments to find a SERIVItem
     * @example
     * // Get one SERIVItem
     * const sERIVItem = await prisma.sERIVItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SERIVItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SERIVItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SERIVItems
     * const sERIVItems = await prisma.sERIVItem.findMany()
     * 
     * // Get first 10 SERIVItems
     * const sERIVItems = await prisma.sERIVItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sERIVItemWithIdOnly = await prisma.sERIVItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SERIVItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SERIVItem.
     * @param {SERIVItemCreateArgs} args - Arguments to create a SERIVItem.
     * @example
     * // Create one SERIVItem
     * const SERIVItem = await prisma.sERIVItem.create({
     *   data: {
     *     // ... data to create a SERIVItem
     *   }
     * })
     * 
    **/
    create<T extends SERIVItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemCreateArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SERIVItems.
     *     @param {SERIVItemCreateManyArgs} args - Arguments to create many SERIVItems.
     *     @example
     *     // Create many SERIVItems
     *     const sERIVItem = await prisma.sERIVItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SERIVItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SERIVItem.
     * @param {SERIVItemDeleteArgs} args - Arguments to delete one SERIVItem.
     * @example
     * // Delete one SERIVItem
     * const SERIVItem = await prisma.sERIVItem.delete({
     *   where: {
     *     // ... filter to delete one SERIVItem
     *   }
     * })
     * 
    **/
    delete<T extends SERIVItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemDeleteArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SERIVItem.
     * @param {SERIVItemUpdateArgs} args - Arguments to update one SERIVItem.
     * @example
     * // Update one SERIVItem
     * const sERIVItem = await prisma.sERIVItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SERIVItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemUpdateArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SERIVItems.
     * @param {SERIVItemDeleteManyArgs} args - Arguments to filter SERIVItems to delete.
     * @example
     * // Delete a few SERIVItems
     * const { count } = await prisma.sERIVItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SERIVItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SERIVItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SERIVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SERIVItems
     * const sERIVItem = await prisma.sERIVItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SERIVItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SERIVItem.
     * @param {SERIVItemUpsertArgs} args - Arguments to update or create a SERIVItem.
     * @example
     * // Update or create a SERIVItem
     * const sERIVItem = await prisma.sERIVItem.upsert({
     *   create: {
     *     // ... data to create a SERIVItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SERIVItem we want to update
     *   }
     * })
    **/
    upsert<T extends SERIVItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SERIVItemUpsertArgs<ExtArgs>>
    ): Prisma__SERIVItemClient<$Result.GetResult<Prisma.$SERIVItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SERIVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemCountArgs} args - Arguments to filter SERIVItems to count.
     * @example
     * // Count the number of SERIVItems
     * const count = await prisma.sERIVItem.count({
     *   where: {
     *     // ... the filter for the SERIVItems we want to count
     *   }
     * })
    **/
    count<T extends SERIVItemCountArgs>(
      args?: Subset<T, SERIVItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SERIVItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SERIVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SERIVItemAggregateArgs>(args: Subset<T, SERIVItemAggregateArgs>): Prisma.PrismaPromise<GetSERIVItemAggregateType<T>>

    /**
     * Group by SERIVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SERIVItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SERIVItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SERIVItemGroupByArgs['orderBy'] }
        : { orderBy?: SERIVItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SERIVItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSERIVItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SERIVItem model
   */
  readonly fields: SERIVItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SERIVItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SERIVItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    seriv<T extends SERIVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SERIVDefaultArgs<ExtArgs>>): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transaction<T extends SERIVItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, SERIVItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SERIVItem model
   */ 
  interface SERIVItemFieldRefs {
    readonly id: FieldRef<"SERIVItem", 'String'>
    readonly seriv_id: FieldRef<"SERIVItem", 'String'>
    readonly item_id: FieldRef<"SERIVItem", 'String'>
    readonly quantity: FieldRef<"SERIVItem", 'Int'>
    readonly price: FieldRef<"SERIVItem", 'Float'>
    readonly created_by: FieldRef<"SERIVItem", 'String'>
    readonly created_at: FieldRef<"SERIVItem", 'DateTime'>
    readonly metadata: FieldRef<"SERIVItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SERIVItem findUnique
   */
  export type SERIVItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter, which SERIVItem to fetch.
     */
    where: SERIVItemWhereUniqueInput
  }


  /**
   * SERIVItem findUniqueOrThrow
   */
  export type SERIVItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter, which SERIVItem to fetch.
     */
    where: SERIVItemWhereUniqueInput
  }


  /**
   * SERIVItem findFirst
   */
  export type SERIVItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter, which SERIVItem to fetch.
     */
    where?: SERIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVItems to fetch.
     */
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVItems.
     */
    cursor?: SERIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVItems.
     */
    distinct?: SERIVItemScalarFieldEnum | SERIVItemScalarFieldEnum[]
  }


  /**
   * SERIVItem findFirstOrThrow
   */
  export type SERIVItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter, which SERIVItem to fetch.
     */
    where?: SERIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVItems to fetch.
     */
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SERIVItems.
     */
    cursor?: SERIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SERIVItems.
     */
    distinct?: SERIVItemScalarFieldEnum | SERIVItemScalarFieldEnum[]
  }


  /**
   * SERIVItem findMany
   */
  export type SERIVItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter, which SERIVItems to fetch.
     */
    where?: SERIVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SERIVItems to fetch.
     */
    orderBy?: SERIVItemOrderByWithRelationInput | SERIVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SERIVItems.
     */
    cursor?: SERIVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SERIVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SERIVItems.
     */
    skip?: number
    distinct?: SERIVItemScalarFieldEnum | SERIVItemScalarFieldEnum[]
  }


  /**
   * SERIVItem create
   */
  export type SERIVItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SERIVItem.
     */
    data: XOR<SERIVItemCreateInput, SERIVItemUncheckedCreateInput>
  }


  /**
   * SERIVItem createMany
   */
  export type SERIVItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SERIVItems.
     */
    data: SERIVItemCreateManyInput | SERIVItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SERIVItem update
   */
  export type SERIVItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SERIVItem.
     */
    data: XOR<SERIVItemUpdateInput, SERIVItemUncheckedUpdateInput>
    /**
     * Choose, which SERIVItem to update.
     */
    where: SERIVItemWhereUniqueInput
  }


  /**
   * SERIVItem updateMany
   */
  export type SERIVItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SERIVItems.
     */
    data: XOR<SERIVItemUpdateManyMutationInput, SERIVItemUncheckedUpdateManyInput>
    /**
     * Filter which SERIVItems to update
     */
    where?: SERIVItemWhereInput
  }


  /**
   * SERIVItem upsert
   */
  export type SERIVItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SERIVItem to update in case it exists.
     */
    where: SERIVItemWhereUniqueInput
    /**
     * In case the SERIVItem found by the `where` argument doesn't exist, create a new SERIVItem with this data.
     */
    create: XOR<SERIVItemCreateInput, SERIVItemUncheckedCreateInput>
    /**
     * In case the SERIVItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SERIVItemUpdateInput, SERIVItemUncheckedUpdateInput>
  }


  /**
   * SERIVItem delete
   */
  export type SERIVItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
    /**
     * Filter which SERIVItem to delete.
     */
    where: SERIVItemWhereUniqueInput
  }


  /**
   * SERIVItem deleteMany
   */
  export type SERIVItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SERIVItems to delete
     */
    where?: SERIVItemWhereInput
  }


  /**
   * SERIVItem.item_transaction
   */
  export type SERIVItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * SERIVItem without action
   */
  export type SERIVItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIVItem
     */
    select?: SERIVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVItemInclude<ExtArgs> | null
  }



  /**
   * Model MRV
   */

  export type AggregateMRV = {
    _count: MRVCountAggregateOutputType | null
    _avg: MRVAvgAggregateOutputType | null
    _sum: MRVSumAggregateOutputType | null
    _min: MRVMinAggregateOutputType | null
    _max: MRVMaxAggregateOutputType | null
  }

  export type MRVAvgAggregateOutputType = {
    request_type: number | null
  }

  export type MRVSumAggregateOutputType = {
    request_type: number | null
  }

  export type MRVMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    mrv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    request_type: number | null
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string | null
    location: string | null
    requested_by_id: string | null
    withdrawn_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MRVMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    mrv_number: string | null
    date_requested: Date | null
    exp_date: Date | null
    purpose: string | null
    note: string | null
    is_completed: boolean | null
    request_type: number | null
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string | null
    location: string | null
    requested_by_id: string | null
    withdrawn_by_id: string | null
    item_from_id: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MRVCountAggregateOutputType = {
    id: number
    project_id: number
    mrv_number: number
    date_requested: number
    exp_date: number
    purpose: number
    note: number
    is_completed: number
    request_type: number
    or_number: number
    mwo_number: number
    cwo_number: number
    jo_number: number
    consumer_name: number
    location: number
    requested_by_id: number
    withdrawn_by_id: number
    item_from_id: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MRVAvgAggregateInputType = {
    request_type?: true
  }

  export type MRVSumAggregateInputType = {
    request_type?: true
  }

  export type MRVMinAggregateInputType = {
    id?: true
    project_id?: true
    mrv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MRVMaxAggregateInputType = {
    id?: true
    project_id?: true
    mrv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MRVCountAggregateInputType = {
    id?: true
    project_id?: true
    mrv_number?: true
    date_requested?: true
    exp_date?: true
    purpose?: true
    note?: true
    is_completed?: true
    request_type?: true
    or_number?: true
    mwo_number?: true
    cwo_number?: true
    jo_number?: true
    consumer_name?: true
    location?: true
    requested_by_id?: true
    withdrawn_by_id?: true
    item_from_id?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MRVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRV to aggregate.
     */
    where?: MRVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVS to fetch.
     */
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MRVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MRVS
    **/
    _count?: true | MRVCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MRVAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MRVSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MRVMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MRVMaxAggregateInputType
  }

  export type GetMRVAggregateType<T extends MRVAggregateArgs> = {
        [P in keyof T & keyof AggregateMRV]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMRV[P]>
      : GetScalarType<T[P], AggregateMRV[P]>
  }




  export type MRVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVWhereInput
    orderBy?: MRVOrderByWithAggregationInput | MRVOrderByWithAggregationInput[]
    by: MRVScalarFieldEnum[] | MRVScalarFieldEnum
    having?: MRVScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MRVCountAggregateInputType | true
    _avg?: MRVAvgAggregateInputType
    _sum?: MRVSumAggregateInputType
    _min?: MRVMinAggregateInputType
    _max?: MRVMaxAggregateInputType
  }

  export type MRVGroupByOutputType = {
    id: string
    project_id: string
    mrv_number: string
    date_requested: Date
    exp_date: Date
    purpose: string
    note: string
    is_completed: boolean
    request_type: number
    or_number: string | null
    mwo_number: string | null
    cwo_number: string | null
    jo_number: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: MRVCountAggregateOutputType | null
    _avg: MRVAvgAggregateOutputType | null
    _sum: MRVSumAggregateOutputType | null
    _min: MRVMinAggregateOutputType | null
    _max: MRVMaxAggregateOutputType | null
  }

  type GetMRVGroupByPayload<T extends MRVGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MRVGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MRVGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MRVGroupByOutputType[P]>
            : GetScalarType<T[P], MRVGroupByOutputType[P]>
        }
      >
    >


  export type MRVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    mrv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    request_type?: boolean
    or_number?: boolean
    mwo_number?: boolean
    cwo_number?: boolean
    jo_number?: boolean
    consumer_name?: boolean
    location?: boolean
    requested_by_id?: boolean
    withdrawn_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    mrv_approvers?: boolean | MRV$mrv_approversArgs<ExtArgs>
    mrv_items?: boolean | MRV$mrv_itemsArgs<ExtArgs>
    mct?: boolean | MRV$mctArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | MRVCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mRV"]>

  export type MRVSelectScalar = {
    id?: boolean
    project_id?: boolean
    mrv_number?: boolean
    date_requested?: boolean
    exp_date?: boolean
    purpose?: boolean
    note?: boolean
    is_completed?: boolean
    request_type?: boolean
    or_number?: boolean
    mwo_number?: boolean
    cwo_number?: boolean
    jo_number?: boolean
    consumer_name?: boolean
    location?: boolean
    requested_by_id?: boolean
    withdrawn_by_id?: boolean
    item_from_id?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MRVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_from?: boolean | StationDefaultArgs<ExtArgs>
    mrv_approvers?: boolean | MRV$mrv_approversArgs<ExtArgs>
    mrv_items?: boolean | MRV$mrv_itemsArgs<ExtArgs>
    mct?: boolean | MRV$mctArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | MRVCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MRVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MRV"
    objects: {
      item_from: Prisma.$StationPayload<ExtArgs>
      mrv_approvers: Prisma.$MRVApproverPayload<ExtArgs>[]
      mrv_items: Prisma.$MRVItemPayload<ExtArgs>[]
      mct: Prisma.$MCTPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      mrv_number: string
      date_requested: Date
      exp_date: Date
      purpose: string
      note: string
      is_completed: boolean
      request_type: number
      or_number: string | null
      mwo_number: string | null
      cwo_number: string | null
      jo_number: string | null
      consumer_name: string
      location: string
      requested_by_id: string
      withdrawn_by_id: string
      item_from_id: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mRV"]>
    composites: {}
  }


  type MRVGetPayload<S extends boolean | null | undefined | MRVDefaultArgs> = $Result.GetResult<Prisma.$MRVPayload, S>

  type MRVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MRVFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MRVCountAggregateInputType | true
    }

  export interface MRVDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MRV'], meta: { name: 'MRV' } }
    /**
     * Find zero or one MRV that matches the filter.
     * @param {MRVFindUniqueArgs} args - Arguments to find a MRV
     * @example
     * // Get one MRV
     * const mRV = await prisma.mRV.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MRVFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MRVFindUniqueArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MRV that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MRVFindUniqueOrThrowArgs} args - Arguments to find a MRV
     * @example
     * // Get one MRV
     * const mRV = await prisma.mRV.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MRVFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MRV that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVFindFirstArgs} args - Arguments to find a MRV
     * @example
     * // Get one MRV
     * const mRV = await prisma.mRV.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MRVFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVFindFirstArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MRV that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVFindFirstOrThrowArgs} args - Arguments to find a MRV
     * @example
     * // Get one MRV
     * const mRV = await prisma.mRV.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MRVFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MRVS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MRVS
     * const mRVS = await prisma.mRV.findMany()
     * 
     * // Get first 10 MRVS
     * const mRVS = await prisma.mRV.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mRVWithIdOnly = await prisma.mRV.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MRVFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MRV.
     * @param {MRVCreateArgs} args - Arguments to create a MRV.
     * @example
     * // Create one MRV
     * const MRV = await prisma.mRV.create({
     *   data: {
     *     // ... data to create a MRV
     *   }
     * })
     * 
    **/
    create<T extends MRVCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVCreateArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MRVS.
     *     @param {MRVCreateManyArgs} args - Arguments to create many MRVS.
     *     @example
     *     // Create many MRVS
     *     const mRV = await prisma.mRV.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MRVCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MRV.
     * @param {MRVDeleteArgs} args - Arguments to delete one MRV.
     * @example
     * // Delete one MRV
     * const MRV = await prisma.mRV.delete({
     *   where: {
     *     // ... filter to delete one MRV
     *   }
     * })
     * 
    **/
    delete<T extends MRVDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MRVDeleteArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MRV.
     * @param {MRVUpdateArgs} args - Arguments to update one MRV.
     * @example
     * // Update one MRV
     * const mRV = await prisma.mRV.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MRVUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVUpdateArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MRVS.
     * @param {MRVDeleteManyArgs} args - Arguments to filter MRVS to delete.
     * @example
     * // Delete a few MRVS
     * const { count } = await prisma.mRV.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MRVDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MRVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MRVS
     * const mRV = await prisma.mRV.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MRVUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MRVUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MRV.
     * @param {MRVUpsertArgs} args - Arguments to update or create a MRV.
     * @example
     * // Update or create a MRV
     * const mRV = await prisma.mRV.upsert({
     *   create: {
     *     // ... data to create a MRV
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MRV we want to update
     *   }
     * })
    **/
    upsert<T extends MRVUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MRVUpsertArgs<ExtArgs>>
    ): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MRVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVCountArgs} args - Arguments to filter MRVS to count.
     * @example
     * // Count the number of MRVS
     * const count = await prisma.mRV.count({
     *   where: {
     *     // ... the filter for the MRVS we want to count
     *   }
     * })
    **/
    count<T extends MRVCountArgs>(
      args?: Subset<T, MRVCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MRVCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MRV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MRVAggregateArgs>(args: Subset<T, MRVAggregateArgs>): Prisma.PrismaPromise<GetMRVAggregateType<T>>

    /**
     * Group by MRV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MRVGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MRVGroupByArgs['orderBy'] }
        : { orderBy?: MRVGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MRVGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMRVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MRV model
   */
  readonly fields: MRVFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MRV.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MRVClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item_from<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    mrv_approvers<T extends MRV$mrv_approversArgs<ExtArgs> = {}>(args?: Subset<T, MRV$mrv_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    mrv_items<T extends MRV$mrv_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MRV$mrv_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mct<T extends MRV$mctArgs<ExtArgs> = {}>(args?: Subset<T, MRV$mctArgs<ExtArgs>>): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MRV model
   */ 
  interface MRVFieldRefs {
    readonly id: FieldRef<"MRV", 'String'>
    readonly project_id: FieldRef<"MRV", 'String'>
    readonly mrv_number: FieldRef<"MRV", 'String'>
    readonly date_requested: FieldRef<"MRV", 'DateTime'>
    readonly exp_date: FieldRef<"MRV", 'DateTime'>
    readonly purpose: FieldRef<"MRV", 'String'>
    readonly note: FieldRef<"MRV", 'String'>
    readonly is_completed: FieldRef<"MRV", 'Boolean'>
    readonly request_type: FieldRef<"MRV", 'Int'>
    readonly or_number: FieldRef<"MRV", 'String'>
    readonly mwo_number: FieldRef<"MRV", 'String'>
    readonly cwo_number: FieldRef<"MRV", 'String'>
    readonly jo_number: FieldRef<"MRV", 'String'>
    readonly consumer_name: FieldRef<"MRV", 'String'>
    readonly location: FieldRef<"MRV", 'String'>
    readonly requested_by_id: FieldRef<"MRV", 'String'>
    readonly withdrawn_by_id: FieldRef<"MRV", 'String'>
    readonly item_from_id: FieldRef<"MRV", 'String'>
    readonly cancelled_by: FieldRef<"MRV", 'String'>
    readonly created_by: FieldRef<"MRV", 'String'>
    readonly updated_by: FieldRef<"MRV", 'String'>
    readonly cancelled_at: FieldRef<"MRV", 'DateTime'>
    readonly created_at: FieldRef<"MRV", 'DateTime'>
    readonly updated_at: FieldRef<"MRV", 'DateTime'>
    readonly metadata: FieldRef<"MRV", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MRV findUnique
   */
  export type MRVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter, which MRV to fetch.
     */
    where: MRVWhereUniqueInput
  }


  /**
   * MRV findUniqueOrThrow
   */
  export type MRVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter, which MRV to fetch.
     */
    where: MRVWhereUniqueInput
  }


  /**
   * MRV findFirst
   */
  export type MRVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter, which MRV to fetch.
     */
    where?: MRVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVS to fetch.
     */
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVS.
     */
    cursor?: MRVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVS.
     */
    distinct?: MRVScalarFieldEnum | MRVScalarFieldEnum[]
  }


  /**
   * MRV findFirstOrThrow
   */
  export type MRVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter, which MRV to fetch.
     */
    where?: MRVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVS to fetch.
     */
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVS.
     */
    cursor?: MRVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVS.
     */
    distinct?: MRVScalarFieldEnum | MRVScalarFieldEnum[]
  }


  /**
   * MRV findMany
   */
  export type MRVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter, which MRVS to fetch.
     */
    where?: MRVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVS to fetch.
     */
    orderBy?: MRVOrderByWithRelationInput | MRVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MRVS.
     */
    cursor?: MRVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVS.
     */
    skip?: number
    distinct?: MRVScalarFieldEnum | MRVScalarFieldEnum[]
  }


  /**
   * MRV create
   */
  export type MRVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * The data needed to create a MRV.
     */
    data: XOR<MRVCreateInput, MRVUncheckedCreateInput>
  }


  /**
   * MRV createMany
   */
  export type MRVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MRVS.
     */
    data: MRVCreateManyInput | MRVCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MRV update
   */
  export type MRVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * The data needed to update a MRV.
     */
    data: XOR<MRVUpdateInput, MRVUncheckedUpdateInput>
    /**
     * Choose, which MRV to update.
     */
    where: MRVWhereUniqueInput
  }


  /**
   * MRV updateMany
   */
  export type MRVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MRVS.
     */
    data: XOR<MRVUpdateManyMutationInput, MRVUncheckedUpdateManyInput>
    /**
     * Filter which MRVS to update
     */
    where?: MRVWhereInput
  }


  /**
   * MRV upsert
   */
  export type MRVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * The filter to search for the MRV to update in case it exists.
     */
    where: MRVWhereUniqueInput
    /**
     * In case the MRV found by the `where` argument doesn't exist, create a new MRV with this data.
     */
    create: XOR<MRVCreateInput, MRVUncheckedCreateInput>
    /**
     * In case the MRV was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MRVUpdateInput, MRVUncheckedUpdateInput>
  }


  /**
   * MRV delete
   */
  export type MRVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    /**
     * Filter which MRV to delete.
     */
    where: MRVWhereUniqueInput
  }


  /**
   * MRV deleteMany
   */
  export type MRVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRVS to delete
     */
    where?: MRVWhereInput
  }


  /**
   * MRV.mrv_approvers
   */
  export type MRV$mrv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    where?: MRVApproverWhereInput
    orderBy?: MRVApproverOrderByWithRelationInput | MRVApproverOrderByWithRelationInput[]
    cursor?: MRVApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MRVApproverScalarFieldEnum | MRVApproverScalarFieldEnum[]
  }


  /**
   * MRV.mrv_items
   */
  export type MRV$mrv_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    where?: MRVItemWhereInput
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    cursor?: MRVItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MRVItemScalarFieldEnum | MRVItemScalarFieldEnum[]
  }


  /**
   * MRV.mct
   */
  export type MRV$mctArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    where?: MCTWhereInput
  }


  /**
   * MRV without action
   */
  export type MRVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
  }



  /**
   * Model MRVApprover
   */

  export type AggregateMRVApprover = {
    _count: MRVApproverCountAggregateOutputType | null
    _avg: MRVApproverAvgAggregateOutputType | null
    _sum: MRVApproverSumAggregateOutputType | null
    _min: MRVApproverMinAggregateOutputType | null
    _max: MRVApproverMaxAggregateOutputType | null
  }

  export type MRVApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MRVApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MRVApproverMinAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MRVApproverMaxAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MRVApproverCountAggregateOutputType = {
    id: number
    mrv_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MRVApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MRVApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MRVApproverMinAggregateInputType = {
    id?: true
    mrv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MRVApproverMaxAggregateInputType = {
    id?: true
    mrv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MRVApproverCountAggregateInputType = {
    id?: true
    mrv_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MRVApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRVApprover to aggregate.
     */
    where?: MRVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVApprovers to fetch.
     */
    orderBy?: MRVApproverOrderByWithRelationInput | MRVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MRVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MRVApprovers
    **/
    _count?: true | MRVApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MRVApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MRVApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MRVApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MRVApproverMaxAggregateInputType
  }

  export type GetMRVApproverAggregateType<T extends MRVApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMRVApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMRVApprover[P]>
      : GetScalarType<T[P], AggregateMRVApprover[P]>
  }




  export type MRVApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVApproverWhereInput
    orderBy?: MRVApproverOrderByWithAggregationInput | MRVApproverOrderByWithAggregationInput[]
    by: MRVApproverScalarFieldEnum[] | MRVApproverScalarFieldEnum
    having?: MRVApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MRVApproverCountAggregateInputType | true
    _avg?: MRVApproverAvgAggregateInputType
    _sum?: MRVApproverSumAggregateInputType
    _min?: MRVApproverMinAggregateInputType
    _max?: MRVApproverMaxAggregateInputType
  }

  export type MRVApproverGroupByOutputType = {
    id: string
    mrv_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: MRVApproverCountAggregateOutputType | null
    _avg: MRVApproverAvgAggregateOutputType | null
    _sum: MRVApproverSumAggregateOutputType | null
    _min: MRVApproverMinAggregateOutputType | null
    _max: MRVApproverMaxAggregateOutputType | null
  }

  type GetMRVApproverGroupByPayload<T extends MRVApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MRVApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MRVApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MRVApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MRVApproverGroupByOutputType[P]>
        }
      >
    >


  export type MRVApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    mrv?: boolean | MRVDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mRVApprover"]>

  export type MRVApproverSelectScalar = {
    id?: boolean
    mrv_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MRVApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv?: boolean | MRVDefaultArgs<ExtArgs>
  }


  export type $MRVApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MRVApprover"
    objects: {
      mrv: Prisma.$MRVPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mrv_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mRVApprover"]>
    composites: {}
  }


  type MRVApproverGetPayload<S extends boolean | null | undefined | MRVApproverDefaultArgs> = $Result.GetResult<Prisma.$MRVApproverPayload, S>

  type MRVApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MRVApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MRVApproverCountAggregateInputType | true
    }

  export interface MRVApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MRVApprover'], meta: { name: 'MRVApprover' } }
    /**
     * Find zero or one MRVApprover that matches the filter.
     * @param {MRVApproverFindUniqueArgs} args - Arguments to find a MRVApprover
     * @example
     * // Get one MRVApprover
     * const mRVApprover = await prisma.mRVApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MRVApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MRVApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MRVApproverFindUniqueOrThrowArgs} args - Arguments to find a MRVApprover
     * @example
     * // Get one MRVApprover
     * const mRVApprover = await prisma.mRVApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MRVApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MRVApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverFindFirstArgs} args - Arguments to find a MRVApprover
     * @example
     * // Get one MRVApprover
     * const mRVApprover = await prisma.mRVApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MRVApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MRVApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverFindFirstOrThrowArgs} args - Arguments to find a MRVApprover
     * @example
     * // Get one MRVApprover
     * const mRVApprover = await prisma.mRVApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MRVApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MRVApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MRVApprovers
     * const mRVApprovers = await prisma.mRVApprover.findMany()
     * 
     * // Get first 10 MRVApprovers
     * const mRVApprovers = await prisma.mRVApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mRVApproverWithIdOnly = await prisma.mRVApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MRVApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MRVApprover.
     * @param {MRVApproverCreateArgs} args - Arguments to create a MRVApprover.
     * @example
     * // Create one MRVApprover
     * const MRVApprover = await prisma.mRVApprover.create({
     *   data: {
     *     // ... data to create a MRVApprover
     *   }
     * })
     * 
    **/
    create<T extends MRVApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverCreateArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MRVApprovers.
     *     @param {MRVApproverCreateManyArgs} args - Arguments to create many MRVApprovers.
     *     @example
     *     // Create many MRVApprovers
     *     const mRVApprover = await prisma.mRVApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MRVApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MRVApprover.
     * @param {MRVApproverDeleteArgs} args - Arguments to delete one MRVApprover.
     * @example
     * // Delete one MRVApprover
     * const MRVApprover = await prisma.mRVApprover.delete({
     *   where: {
     *     // ... filter to delete one MRVApprover
     *   }
     * })
     * 
    **/
    delete<T extends MRVApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverDeleteArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MRVApprover.
     * @param {MRVApproverUpdateArgs} args - Arguments to update one MRVApprover.
     * @example
     * // Update one MRVApprover
     * const mRVApprover = await prisma.mRVApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MRVApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverUpdateArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MRVApprovers.
     * @param {MRVApproverDeleteManyArgs} args - Arguments to filter MRVApprovers to delete.
     * @example
     * // Delete a few MRVApprovers
     * const { count } = await prisma.mRVApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MRVApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MRVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MRVApprovers
     * const mRVApprover = await prisma.mRVApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MRVApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MRVApprover.
     * @param {MRVApproverUpsertArgs} args - Arguments to update or create a MRVApprover.
     * @example
     * // Update or create a MRVApprover
     * const mRVApprover = await prisma.mRVApprover.upsert({
     *   create: {
     *     // ... data to create a MRVApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MRVApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MRVApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MRVApproverUpsertArgs<ExtArgs>>
    ): Prisma__MRVApproverClient<$Result.GetResult<Prisma.$MRVApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MRVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverCountArgs} args - Arguments to filter MRVApprovers to count.
     * @example
     * // Count the number of MRVApprovers
     * const count = await prisma.mRVApprover.count({
     *   where: {
     *     // ... the filter for the MRVApprovers we want to count
     *   }
     * })
    **/
    count<T extends MRVApproverCountArgs>(
      args?: Subset<T, MRVApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MRVApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MRVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MRVApproverAggregateArgs>(args: Subset<T, MRVApproverAggregateArgs>): Prisma.PrismaPromise<GetMRVApproverAggregateType<T>>

    /**
     * Group by MRVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MRVApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MRVApproverGroupByArgs['orderBy'] }
        : { orderBy?: MRVApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MRVApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMRVApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MRVApprover model
   */
  readonly fields: MRVApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MRVApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MRVApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mrv<T extends MRVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MRVDefaultArgs<ExtArgs>>): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MRVApprover model
   */ 
  interface MRVApproverFieldRefs {
    readonly id: FieldRef<"MRVApprover", 'String'>
    readonly mrv_id: FieldRef<"MRVApprover", 'String'>
    readonly approver_id: FieldRef<"MRVApprover", 'String'>
    readonly date_approval: FieldRef<"MRVApprover", 'DateTime'>
    readonly notes: FieldRef<"MRVApprover", 'String'>
    readonly status: FieldRef<"MRVApprover", 'Int'>
    readonly label: FieldRef<"MRVApprover", 'String'>
    readonly label_id: FieldRef<"MRVApprover", 'String'>
    readonly order: FieldRef<"MRVApprover", 'Int'>
    readonly updated_by: FieldRef<"MRVApprover", 'String'>
    readonly updated_at: FieldRef<"MRVApprover", 'DateTime'>
    readonly metadata: FieldRef<"MRVApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MRVApprover findUnique
   */
  export type MRVApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter, which MRVApprover to fetch.
     */
    where: MRVApproverWhereUniqueInput
  }


  /**
   * MRVApprover findUniqueOrThrow
   */
  export type MRVApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter, which MRVApprover to fetch.
     */
    where: MRVApproverWhereUniqueInput
  }


  /**
   * MRVApprover findFirst
   */
  export type MRVApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter, which MRVApprover to fetch.
     */
    where?: MRVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVApprovers to fetch.
     */
    orderBy?: MRVApproverOrderByWithRelationInput | MRVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVApprovers.
     */
    cursor?: MRVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVApprovers.
     */
    distinct?: MRVApproverScalarFieldEnum | MRVApproverScalarFieldEnum[]
  }


  /**
   * MRVApprover findFirstOrThrow
   */
  export type MRVApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter, which MRVApprover to fetch.
     */
    where?: MRVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVApprovers to fetch.
     */
    orderBy?: MRVApproverOrderByWithRelationInput | MRVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVApprovers.
     */
    cursor?: MRVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVApprovers.
     */
    distinct?: MRVApproverScalarFieldEnum | MRVApproverScalarFieldEnum[]
  }


  /**
   * MRVApprover findMany
   */
  export type MRVApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter, which MRVApprovers to fetch.
     */
    where?: MRVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVApprovers to fetch.
     */
    orderBy?: MRVApproverOrderByWithRelationInput | MRVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MRVApprovers.
     */
    cursor?: MRVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVApprovers.
     */
    skip?: number
    distinct?: MRVApproverScalarFieldEnum | MRVApproverScalarFieldEnum[]
  }


  /**
   * MRVApprover create
   */
  export type MRVApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MRVApprover.
     */
    data: XOR<MRVApproverCreateInput, MRVApproverUncheckedCreateInput>
  }


  /**
   * MRVApprover createMany
   */
  export type MRVApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MRVApprovers.
     */
    data: MRVApproverCreateManyInput | MRVApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MRVApprover update
   */
  export type MRVApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MRVApprover.
     */
    data: XOR<MRVApproverUpdateInput, MRVApproverUncheckedUpdateInput>
    /**
     * Choose, which MRVApprover to update.
     */
    where: MRVApproverWhereUniqueInput
  }


  /**
   * MRVApprover updateMany
   */
  export type MRVApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MRVApprovers.
     */
    data: XOR<MRVApproverUpdateManyMutationInput, MRVApproverUncheckedUpdateManyInput>
    /**
     * Filter which MRVApprovers to update
     */
    where?: MRVApproverWhereInput
  }


  /**
   * MRVApprover upsert
   */
  export type MRVApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MRVApprover to update in case it exists.
     */
    where: MRVApproverWhereUniqueInput
    /**
     * In case the MRVApprover found by the `where` argument doesn't exist, create a new MRVApprover with this data.
     */
    create: XOR<MRVApproverCreateInput, MRVApproverUncheckedCreateInput>
    /**
     * In case the MRVApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MRVApproverUpdateInput, MRVApproverUncheckedUpdateInput>
  }


  /**
   * MRVApprover delete
   */
  export type MRVApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
    /**
     * Filter which MRVApprover to delete.
     */
    where: MRVApproverWhereUniqueInput
  }


  /**
   * MRVApprover deleteMany
   */
  export type MRVApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRVApprovers to delete
     */
    where?: MRVApproverWhereInput
  }


  /**
   * MRVApprover without action
   */
  export type MRVApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVApprover
     */
    select?: MRVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVApproverInclude<ExtArgs> | null
  }



  /**
   * Model MRVItem
   */

  export type AggregateMRVItem = {
    _count: MRVItemCountAggregateOutputType | null
    _avg: MRVItemAvgAggregateOutputType | null
    _sum: MRVItemSumAggregateOutputType | null
    _min: MRVItemMinAggregateOutputType | null
    _max: MRVItemMaxAggregateOutputType | null
  }

  export type MRVItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type MRVItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type MRVItemMinAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MRVItemMaxAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MRVItemCountAggregateOutputType = {
    id: number
    mrv_id: number
    item_id: number
    quantity: number
    price: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type MRVItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type MRVItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type MRVItemMinAggregateInputType = {
    id?: true
    mrv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type MRVItemMaxAggregateInputType = {
    id?: true
    mrv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type MRVItemCountAggregateInputType = {
    id?: true
    mrv_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type MRVItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRVItem to aggregate.
     */
    where?: MRVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVItems to fetch.
     */
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MRVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MRVItems
    **/
    _count?: true | MRVItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MRVItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MRVItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MRVItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MRVItemMaxAggregateInputType
  }

  export type GetMRVItemAggregateType<T extends MRVItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMRVItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMRVItem[P]>
      : GetScalarType<T[P], AggregateMRVItem[P]>
  }




  export type MRVItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MRVItemWhereInput
    orderBy?: MRVItemOrderByWithAggregationInput | MRVItemOrderByWithAggregationInput[]
    by: MRVItemScalarFieldEnum[] | MRVItemScalarFieldEnum
    having?: MRVItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MRVItemCountAggregateInputType | true
    _avg?: MRVItemAvgAggregateInputType
    _sum?: MRVItemSumAggregateInputType
    _min?: MRVItemMinAggregateInputType
    _max?: MRVItemMaxAggregateInputType
  }

  export type MRVItemGroupByOutputType = {
    id: string
    mrv_id: string
    item_id: string
    quantity: number
    price: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: MRVItemCountAggregateOutputType | null
    _avg: MRVItemAvgAggregateOutputType | null
    _sum: MRVItemSumAggregateOutputType | null
    _min: MRVItemMinAggregateOutputType | null
    _max: MRVItemMaxAggregateOutputType | null
  }

  type GetMRVItemGroupByPayload<T extends MRVItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MRVItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MRVItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MRVItemGroupByOutputType[P]>
            : GetScalarType<T[P], MRVItemGroupByOutputType[P]>
        }
      >
    >


  export type MRVItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    mrv?: boolean | MRVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | MRVItem$item_transactionArgs<ExtArgs>
  }, ExtArgs["result"]["mRVItem"]>

  export type MRVItemSelectScalar = {
    id?: boolean
    mrv_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type MRVItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv?: boolean | MRVDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | MRVItem$item_transactionArgs<ExtArgs>
  }


  export type $MRVItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MRVItem"
    objects: {
      mrv: Prisma.$MRVPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mrv_id: string
      item_id: string
      quantity: number
      price: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mRVItem"]>
    composites: {}
  }


  type MRVItemGetPayload<S extends boolean | null | undefined | MRVItemDefaultArgs> = $Result.GetResult<Prisma.$MRVItemPayload, S>

  type MRVItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MRVItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MRVItemCountAggregateInputType | true
    }

  export interface MRVItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MRVItem'], meta: { name: 'MRVItem' } }
    /**
     * Find zero or one MRVItem that matches the filter.
     * @param {MRVItemFindUniqueArgs} args - Arguments to find a MRVItem
     * @example
     * // Get one MRVItem
     * const mRVItem = await prisma.mRVItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MRVItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemFindUniqueArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MRVItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MRVItemFindUniqueOrThrowArgs} args - Arguments to find a MRVItem
     * @example
     * // Get one MRVItem
     * const mRVItem = await prisma.mRVItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MRVItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MRVItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemFindFirstArgs} args - Arguments to find a MRVItem
     * @example
     * // Get one MRVItem
     * const mRVItem = await prisma.mRVItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MRVItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemFindFirstArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MRVItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemFindFirstOrThrowArgs} args - Arguments to find a MRVItem
     * @example
     * // Get one MRVItem
     * const mRVItem = await prisma.mRVItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MRVItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MRVItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MRVItems
     * const mRVItems = await prisma.mRVItem.findMany()
     * 
     * // Get first 10 MRVItems
     * const mRVItems = await prisma.mRVItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mRVItemWithIdOnly = await prisma.mRVItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MRVItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MRVItem.
     * @param {MRVItemCreateArgs} args - Arguments to create a MRVItem.
     * @example
     * // Create one MRVItem
     * const MRVItem = await prisma.mRVItem.create({
     *   data: {
     *     // ... data to create a MRVItem
     *   }
     * })
     * 
    **/
    create<T extends MRVItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemCreateArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MRVItems.
     *     @param {MRVItemCreateManyArgs} args - Arguments to create many MRVItems.
     *     @example
     *     // Create many MRVItems
     *     const mRVItem = await prisma.mRVItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MRVItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MRVItem.
     * @param {MRVItemDeleteArgs} args - Arguments to delete one MRVItem.
     * @example
     * // Delete one MRVItem
     * const MRVItem = await prisma.mRVItem.delete({
     *   where: {
     *     // ... filter to delete one MRVItem
     *   }
     * })
     * 
    **/
    delete<T extends MRVItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemDeleteArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MRVItem.
     * @param {MRVItemUpdateArgs} args - Arguments to update one MRVItem.
     * @example
     * // Update one MRVItem
     * const mRVItem = await prisma.mRVItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MRVItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemUpdateArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MRVItems.
     * @param {MRVItemDeleteManyArgs} args - Arguments to filter MRVItems to delete.
     * @example
     * // Delete a few MRVItems
     * const { count } = await prisma.mRVItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MRVItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MRVItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MRVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MRVItems
     * const mRVItem = await prisma.mRVItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MRVItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MRVItem.
     * @param {MRVItemUpsertArgs} args - Arguments to update or create a MRVItem.
     * @example
     * // Update or create a MRVItem
     * const mRVItem = await prisma.mRVItem.upsert({
     *   create: {
     *     // ... data to create a MRVItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MRVItem we want to update
     *   }
     * })
    **/
    upsert<T extends MRVItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MRVItemUpsertArgs<ExtArgs>>
    ): Prisma__MRVItemClient<$Result.GetResult<Prisma.$MRVItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MRVItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemCountArgs} args - Arguments to filter MRVItems to count.
     * @example
     * // Count the number of MRVItems
     * const count = await prisma.mRVItem.count({
     *   where: {
     *     // ... the filter for the MRVItems we want to count
     *   }
     * })
    **/
    count<T extends MRVItemCountArgs>(
      args?: Subset<T, MRVItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MRVItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MRVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MRVItemAggregateArgs>(args: Subset<T, MRVItemAggregateArgs>): Prisma.PrismaPromise<GetMRVItemAggregateType<T>>

    /**
     * Group by MRVItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MRVItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MRVItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MRVItemGroupByArgs['orderBy'] }
        : { orderBy?: MRVItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MRVItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMRVItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MRVItem model
   */
  readonly fields: MRVItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MRVItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MRVItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mrv<T extends MRVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MRVDefaultArgs<ExtArgs>>): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transaction<T extends MRVItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, MRVItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MRVItem model
   */ 
  interface MRVItemFieldRefs {
    readonly id: FieldRef<"MRVItem", 'String'>
    readonly mrv_id: FieldRef<"MRVItem", 'String'>
    readonly item_id: FieldRef<"MRVItem", 'String'>
    readonly quantity: FieldRef<"MRVItem", 'Int'>
    readonly price: FieldRef<"MRVItem", 'Float'>
    readonly created_by: FieldRef<"MRVItem", 'String'>
    readonly created_at: FieldRef<"MRVItem", 'DateTime'>
    readonly metadata: FieldRef<"MRVItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MRVItem findUnique
   */
  export type MRVItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter, which MRVItem to fetch.
     */
    where: MRVItemWhereUniqueInput
  }


  /**
   * MRVItem findUniqueOrThrow
   */
  export type MRVItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter, which MRVItem to fetch.
     */
    where: MRVItemWhereUniqueInput
  }


  /**
   * MRVItem findFirst
   */
  export type MRVItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter, which MRVItem to fetch.
     */
    where?: MRVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVItems to fetch.
     */
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVItems.
     */
    cursor?: MRVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVItems.
     */
    distinct?: MRVItemScalarFieldEnum | MRVItemScalarFieldEnum[]
  }


  /**
   * MRVItem findFirstOrThrow
   */
  export type MRVItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter, which MRVItem to fetch.
     */
    where?: MRVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVItems to fetch.
     */
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MRVItems.
     */
    cursor?: MRVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MRVItems.
     */
    distinct?: MRVItemScalarFieldEnum | MRVItemScalarFieldEnum[]
  }


  /**
   * MRVItem findMany
   */
  export type MRVItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter, which MRVItems to fetch.
     */
    where?: MRVItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MRVItems to fetch.
     */
    orderBy?: MRVItemOrderByWithRelationInput | MRVItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MRVItems.
     */
    cursor?: MRVItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MRVItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MRVItems.
     */
    skip?: number
    distinct?: MRVItemScalarFieldEnum | MRVItemScalarFieldEnum[]
  }


  /**
   * MRVItem create
   */
  export type MRVItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MRVItem.
     */
    data: XOR<MRVItemCreateInput, MRVItemUncheckedCreateInput>
  }


  /**
   * MRVItem createMany
   */
  export type MRVItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MRVItems.
     */
    data: MRVItemCreateManyInput | MRVItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MRVItem update
   */
  export type MRVItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MRVItem.
     */
    data: XOR<MRVItemUpdateInput, MRVItemUncheckedUpdateInput>
    /**
     * Choose, which MRVItem to update.
     */
    where: MRVItemWhereUniqueInput
  }


  /**
   * MRVItem updateMany
   */
  export type MRVItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MRVItems.
     */
    data: XOR<MRVItemUpdateManyMutationInput, MRVItemUncheckedUpdateManyInput>
    /**
     * Filter which MRVItems to update
     */
    where?: MRVItemWhereInput
  }


  /**
   * MRVItem upsert
   */
  export type MRVItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MRVItem to update in case it exists.
     */
    where: MRVItemWhereUniqueInput
    /**
     * In case the MRVItem found by the `where` argument doesn't exist, create a new MRVItem with this data.
     */
    create: XOR<MRVItemCreateInput, MRVItemUncheckedCreateInput>
    /**
     * In case the MRVItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MRVItemUpdateInput, MRVItemUncheckedUpdateInput>
  }


  /**
   * MRVItem delete
   */
  export type MRVItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
    /**
     * Filter which MRVItem to delete.
     */
    where: MRVItemWhereUniqueInput
  }


  /**
   * MRVItem deleteMany
   */
  export type MRVItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MRVItems to delete
     */
    where?: MRVItemWhereInput
  }


  /**
   * MRVItem.item_transaction
   */
  export type MRVItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * MRVItem without action
   */
  export type MRVItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRVItem
     */
    select?: MRVItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVItemInclude<ExtArgs> | null
  }



  /**
   * Model MCT
   */

  export type AggregateMCT = {
    _count: MCTCountAggregateOutputType | null
    _min: MCTMinAggregateOutputType | null
    _max: MCTMaxAggregateOutputType | null
  }

  export type MCTMinAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    mrv_number: string | null
    mct_number: string | null
    mct_date: Date | null
    is_completed: boolean | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MCTMaxAggregateOutputType = {
    id: string | null
    mrv_id: string | null
    mrv_number: string | null
    mct_number: string | null
    mct_date: Date | null
    is_completed: boolean | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MCTCountAggregateOutputType = {
    id: number
    mrv_id: number
    mrv_number: number
    mct_number: number
    mct_date: number
    is_completed: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MCTMinAggregateInputType = {
    id?: true
    mrv_id?: true
    mrv_number?: true
    mct_number?: true
    mct_date?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MCTMaxAggregateInputType = {
    id?: true
    mrv_id?: true
    mrv_number?: true
    mct_number?: true
    mct_date?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MCTCountAggregateInputType = {
    id?: true
    mrv_id?: true
    mrv_number?: true
    mct_number?: true
    mct_date?: true
    is_completed?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MCTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCT to aggregate.
     */
    where?: MCTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTS to fetch.
     */
    orderBy?: MCTOrderByWithRelationInput | MCTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCTS
    **/
    _count?: true | MCTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCTMaxAggregateInputType
  }

  export type GetMCTAggregateType<T extends MCTAggregateArgs> = {
        [P in keyof T & keyof AggregateMCT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCT[P]>
      : GetScalarType<T[P], AggregateMCT[P]>
  }




  export type MCTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCTWhereInput
    orderBy?: MCTOrderByWithAggregationInput | MCTOrderByWithAggregationInput[]
    by: MCTScalarFieldEnum[] | MCTScalarFieldEnum
    having?: MCTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCTCountAggregateInputType | true
    _min?: MCTMinAggregateInputType
    _max?: MCTMaxAggregateInputType
  }

  export type MCTGroupByOutputType = {
    id: string
    mrv_id: string | null
    mrv_number: string
    mct_number: string
    mct_date: Date
    is_completed: boolean
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: MCTCountAggregateOutputType | null
    _min: MCTMinAggregateOutputType | null
    _max: MCTMaxAggregateOutputType | null
  }

  type GetMCTGroupByPayload<T extends MCTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCTGroupByOutputType[P]>
            : GetScalarType<T[P], MCTGroupByOutputType[P]>
        }
      >
    >


  export type MCTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrv_id?: boolean
    mrv_number?: boolean
    mct_number?: boolean
    mct_date?: boolean
    is_completed?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    mrv?: boolean | MCT$mrvArgs<ExtArgs>
    mct_approvers?: boolean | MCT$mct_approversArgs<ExtArgs>
    mcrts?: boolean | MCT$mcrtsArgs<ExtArgs>
    _count?: boolean | MCTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCT"]>

  export type MCTSelectScalar = {
    id?: boolean
    mrv_id?: boolean
    mrv_number?: boolean
    mct_number?: boolean
    mct_date?: boolean
    is_completed?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MCTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mrv?: boolean | MCT$mrvArgs<ExtArgs>
    mct_approvers?: boolean | MCT$mct_approversArgs<ExtArgs>
    mcrts?: boolean | MCT$mcrtsArgs<ExtArgs>
    _count?: boolean | MCTCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MCTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCT"
    objects: {
      mrv: Prisma.$MRVPayload<ExtArgs> | null
      mct_approvers: Prisma.$MCTApproverPayload<ExtArgs>[]
      mcrts: Prisma.$MCRTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mrv_id: string | null
      mrv_number: string
      mct_number: string
      mct_date: Date
      is_completed: boolean
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mCT"]>
    composites: {}
  }


  type MCTGetPayload<S extends boolean | null | undefined | MCTDefaultArgs> = $Result.GetResult<Prisma.$MCTPayload, S>

  type MCTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MCTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCTCountAggregateInputType | true
    }

  export interface MCTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCT'], meta: { name: 'MCT' } }
    /**
     * Find zero or one MCT that matches the filter.
     * @param {MCTFindUniqueArgs} args - Arguments to find a MCT
     * @example
     * // Get one MCT
     * const mCT = await prisma.mCT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCTFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCTFindUniqueArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCT that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCTFindUniqueOrThrowArgs} args - Arguments to find a MCT
     * @example
     * // Get one MCT
     * const mCT = await prisma.mCT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCTFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTFindFirstArgs} args - Arguments to find a MCT
     * @example
     * // Get one MCT
     * const mCT = await prisma.mCT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCTFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTFindFirstArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTFindFirstOrThrowArgs} args - Arguments to find a MCT
     * @example
     * // Get one MCT
     * const mCT = await prisma.mCT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCTFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCTS
     * const mCTS = await prisma.mCT.findMany()
     * 
     * // Get first 10 MCTS
     * const mCTS = await prisma.mCT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCTWithIdOnly = await prisma.mCT.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCTFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCT.
     * @param {MCTCreateArgs} args - Arguments to create a MCT.
     * @example
     * // Create one MCT
     * const MCT = await prisma.mCT.create({
     *   data: {
     *     // ... data to create a MCT
     *   }
     * })
     * 
    **/
    create<T extends MCTCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCTCreateArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCTS.
     *     @param {MCTCreateManyArgs} args - Arguments to create many MCTS.
     *     @example
     *     // Create many MCTS
     *     const mCT = await prisma.mCT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCTCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCT.
     * @param {MCTDeleteArgs} args - Arguments to delete one MCT.
     * @example
     * // Delete one MCT
     * const MCT = await prisma.mCT.delete({
     *   where: {
     *     // ... filter to delete one MCT
     *   }
     * })
     * 
    **/
    delete<T extends MCTDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCTDeleteArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCT.
     * @param {MCTUpdateArgs} args - Arguments to update one MCT.
     * @example
     * // Update one MCT
     * const mCT = await prisma.mCT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCTUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCTUpdateArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCTS.
     * @param {MCTDeleteManyArgs} args - Arguments to filter MCTS to delete.
     * @example
     * // Delete a few MCTS
     * const { count } = await prisma.mCT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCTDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCTS
     * const mCT = await prisma.mCT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCTUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCTUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCT.
     * @param {MCTUpsertArgs} args - Arguments to update or create a MCT.
     * @example
     * // Update or create a MCT
     * const mCT = await prisma.mCT.upsert({
     *   create: {
     *     // ... data to create a MCT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCT we want to update
     *   }
     * })
    **/
    upsert<T extends MCTUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCTUpsertArgs<ExtArgs>>
    ): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTCountArgs} args - Arguments to filter MCTS to count.
     * @example
     * // Count the number of MCTS
     * const count = await prisma.mCT.count({
     *   where: {
     *     // ... the filter for the MCTS we want to count
     *   }
     * })
    **/
    count<T extends MCTCountArgs>(
      args?: Subset<T, MCTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCTAggregateArgs>(args: Subset<T, MCTAggregateArgs>): Prisma.PrismaPromise<GetMCTAggregateType<T>>

    /**
     * Group by MCT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCTGroupByArgs['orderBy'] }
        : { orderBy?: MCTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCT model
   */
  readonly fields: MCTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mrv<T extends MCT$mrvArgs<ExtArgs> = {}>(args?: Subset<T, MCT$mrvArgs<ExtArgs>>): Prisma__MRVClient<$Result.GetResult<Prisma.$MRVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mct_approvers<T extends MCT$mct_approversArgs<ExtArgs> = {}>(args?: Subset<T, MCT$mct_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    mcrts<T extends MCT$mcrtsArgs<ExtArgs> = {}>(args?: Subset<T, MCT$mcrtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MCT model
   */ 
  interface MCTFieldRefs {
    readonly id: FieldRef<"MCT", 'String'>
    readonly mrv_id: FieldRef<"MCT", 'String'>
    readonly mrv_number: FieldRef<"MCT", 'String'>
    readonly mct_number: FieldRef<"MCT", 'String'>
    readonly mct_date: FieldRef<"MCT", 'DateTime'>
    readonly is_completed: FieldRef<"MCT", 'Boolean'>
    readonly cancelled_by: FieldRef<"MCT", 'String'>
    readonly created_by: FieldRef<"MCT", 'String'>
    readonly updated_by: FieldRef<"MCT", 'String'>
    readonly cancelled_at: FieldRef<"MCT", 'DateTime'>
    readonly created_at: FieldRef<"MCT", 'DateTime'>
    readonly updated_at: FieldRef<"MCT", 'DateTime'>
    readonly metadata: FieldRef<"MCT", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MCT findUnique
   */
  export type MCTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter, which MCT to fetch.
     */
    where: MCTWhereUniqueInput
  }


  /**
   * MCT findUniqueOrThrow
   */
  export type MCTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter, which MCT to fetch.
     */
    where: MCTWhereUniqueInput
  }


  /**
   * MCT findFirst
   */
  export type MCTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter, which MCT to fetch.
     */
    where?: MCTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTS to fetch.
     */
    orderBy?: MCTOrderByWithRelationInput | MCTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCTS.
     */
    cursor?: MCTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCTS.
     */
    distinct?: MCTScalarFieldEnum | MCTScalarFieldEnum[]
  }


  /**
   * MCT findFirstOrThrow
   */
  export type MCTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter, which MCT to fetch.
     */
    where?: MCTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTS to fetch.
     */
    orderBy?: MCTOrderByWithRelationInput | MCTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCTS.
     */
    cursor?: MCTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCTS.
     */
    distinct?: MCTScalarFieldEnum | MCTScalarFieldEnum[]
  }


  /**
   * MCT findMany
   */
  export type MCTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter, which MCTS to fetch.
     */
    where?: MCTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTS to fetch.
     */
    orderBy?: MCTOrderByWithRelationInput | MCTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCTS.
     */
    cursor?: MCTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTS.
     */
    skip?: number
    distinct?: MCTScalarFieldEnum | MCTScalarFieldEnum[]
  }


  /**
   * MCT create
   */
  export type MCTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * The data needed to create a MCT.
     */
    data: XOR<MCTCreateInput, MCTUncheckedCreateInput>
  }


  /**
   * MCT createMany
   */
  export type MCTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCTS.
     */
    data: MCTCreateManyInput | MCTCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCT update
   */
  export type MCTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * The data needed to update a MCT.
     */
    data: XOR<MCTUpdateInput, MCTUncheckedUpdateInput>
    /**
     * Choose, which MCT to update.
     */
    where: MCTWhereUniqueInput
  }


  /**
   * MCT updateMany
   */
  export type MCTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCTS.
     */
    data: XOR<MCTUpdateManyMutationInput, MCTUncheckedUpdateManyInput>
    /**
     * Filter which MCTS to update
     */
    where?: MCTWhereInput
  }


  /**
   * MCT upsert
   */
  export type MCTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * The filter to search for the MCT to update in case it exists.
     */
    where: MCTWhereUniqueInput
    /**
     * In case the MCT found by the `where` argument doesn't exist, create a new MCT with this data.
     */
    create: XOR<MCTCreateInput, MCTUncheckedCreateInput>
    /**
     * In case the MCT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCTUpdateInput, MCTUncheckedUpdateInput>
  }


  /**
   * MCT delete
   */
  export type MCTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    /**
     * Filter which MCT to delete.
     */
    where: MCTWhereUniqueInput
  }


  /**
   * MCT deleteMany
   */
  export type MCTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCTS to delete
     */
    where?: MCTWhereInput
  }


  /**
   * MCT.mrv
   */
  export type MCT$mrvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MRV
     */
    select?: MRVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MRVInclude<ExtArgs> | null
    where?: MRVWhereInput
  }


  /**
   * MCT.mct_approvers
   */
  export type MCT$mct_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    where?: MCTApproverWhereInput
    orderBy?: MCTApproverOrderByWithRelationInput | MCTApproverOrderByWithRelationInput[]
    cursor?: MCTApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCTApproverScalarFieldEnum | MCTApproverScalarFieldEnum[]
  }


  /**
   * MCT.mcrts
   */
  export type MCT$mcrtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    where?: MCRTWhereInput
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    cursor?: MCRTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCRTScalarFieldEnum | MCRTScalarFieldEnum[]
  }


  /**
   * MCT without action
   */
  export type MCTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
  }



  /**
   * Model MCTApprover
   */

  export type AggregateMCTApprover = {
    _count: MCTApproverCountAggregateOutputType | null
    _avg: MCTApproverAvgAggregateOutputType | null
    _sum: MCTApproverSumAggregateOutputType | null
    _min: MCTApproverMinAggregateOutputType | null
    _max: MCTApproverMaxAggregateOutputType | null
  }

  export type MCTApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MCTApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MCTApproverMinAggregateOutputType = {
    id: string | null
    mct_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MCTApproverMaxAggregateOutputType = {
    id: string | null
    mct_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MCTApproverCountAggregateOutputType = {
    id: number
    mct_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MCTApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MCTApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MCTApproverMinAggregateInputType = {
    id?: true
    mct_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MCTApproverMaxAggregateInputType = {
    id?: true
    mct_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MCTApproverCountAggregateInputType = {
    id?: true
    mct_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MCTApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCTApprover to aggregate.
     */
    where?: MCTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTApprovers to fetch.
     */
    orderBy?: MCTApproverOrderByWithRelationInput | MCTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCTApprovers
    **/
    _count?: true | MCTApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCTApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCTApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCTApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCTApproverMaxAggregateInputType
  }

  export type GetMCTApproverAggregateType<T extends MCTApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMCTApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCTApprover[P]>
      : GetScalarType<T[P], AggregateMCTApprover[P]>
  }




  export type MCTApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCTApproverWhereInput
    orderBy?: MCTApproverOrderByWithAggregationInput | MCTApproverOrderByWithAggregationInput[]
    by: MCTApproverScalarFieldEnum[] | MCTApproverScalarFieldEnum
    having?: MCTApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCTApproverCountAggregateInputType | true
    _avg?: MCTApproverAvgAggregateInputType
    _sum?: MCTApproverSumAggregateInputType
    _min?: MCTApproverMinAggregateInputType
    _max?: MCTApproverMaxAggregateInputType
  }

  export type MCTApproverGroupByOutputType = {
    id: string
    mct_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: MCTApproverCountAggregateOutputType | null
    _avg: MCTApproverAvgAggregateOutputType | null
    _sum: MCTApproverSumAggregateOutputType | null
    _min: MCTApproverMinAggregateOutputType | null
    _max: MCTApproverMaxAggregateOutputType | null
  }

  type GetMCTApproverGroupByPayload<T extends MCTApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCTApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCTApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCTApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MCTApproverGroupByOutputType[P]>
        }
      >
    >


  export type MCTApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mct_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    mct?: boolean | MCTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCTApprover"]>

  export type MCTApproverSelectScalar = {
    id?: boolean
    mct_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MCTApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mct?: boolean | MCTDefaultArgs<ExtArgs>
  }


  export type $MCTApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCTApprover"
    objects: {
      mct: Prisma.$MCTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mct_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mCTApprover"]>
    composites: {}
  }


  type MCTApproverGetPayload<S extends boolean | null | undefined | MCTApproverDefaultArgs> = $Result.GetResult<Prisma.$MCTApproverPayload, S>

  type MCTApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MCTApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCTApproverCountAggregateInputType | true
    }

  export interface MCTApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCTApprover'], meta: { name: 'MCTApprover' } }
    /**
     * Find zero or one MCTApprover that matches the filter.
     * @param {MCTApproverFindUniqueArgs} args - Arguments to find a MCTApprover
     * @example
     * // Get one MCTApprover
     * const mCTApprover = await prisma.mCTApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCTApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCTApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCTApproverFindUniqueOrThrowArgs} args - Arguments to find a MCTApprover
     * @example
     * // Get one MCTApprover
     * const mCTApprover = await prisma.mCTApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCTApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCTApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverFindFirstArgs} args - Arguments to find a MCTApprover
     * @example
     * // Get one MCTApprover
     * const mCTApprover = await prisma.mCTApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCTApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCTApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverFindFirstOrThrowArgs} args - Arguments to find a MCTApprover
     * @example
     * // Get one MCTApprover
     * const mCTApprover = await prisma.mCTApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCTApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCTApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCTApprovers
     * const mCTApprovers = await prisma.mCTApprover.findMany()
     * 
     * // Get first 10 MCTApprovers
     * const mCTApprovers = await prisma.mCTApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCTApproverWithIdOnly = await prisma.mCTApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCTApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCTApprover.
     * @param {MCTApproverCreateArgs} args - Arguments to create a MCTApprover.
     * @example
     * // Create one MCTApprover
     * const MCTApprover = await prisma.mCTApprover.create({
     *   data: {
     *     // ... data to create a MCTApprover
     *   }
     * })
     * 
    **/
    create<T extends MCTApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverCreateArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCTApprovers.
     *     @param {MCTApproverCreateManyArgs} args - Arguments to create many MCTApprovers.
     *     @example
     *     // Create many MCTApprovers
     *     const mCTApprover = await prisma.mCTApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCTApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCTApprover.
     * @param {MCTApproverDeleteArgs} args - Arguments to delete one MCTApprover.
     * @example
     * // Delete one MCTApprover
     * const MCTApprover = await prisma.mCTApprover.delete({
     *   where: {
     *     // ... filter to delete one MCTApprover
     *   }
     * })
     * 
    **/
    delete<T extends MCTApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverDeleteArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCTApprover.
     * @param {MCTApproverUpdateArgs} args - Arguments to update one MCTApprover.
     * @example
     * // Update one MCTApprover
     * const mCTApprover = await prisma.mCTApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCTApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverUpdateArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCTApprovers.
     * @param {MCTApproverDeleteManyArgs} args - Arguments to filter MCTApprovers to delete.
     * @example
     * // Delete a few MCTApprovers
     * const { count } = await prisma.mCTApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCTApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCTApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCTApprovers
     * const mCTApprover = await prisma.mCTApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCTApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCTApprover.
     * @param {MCTApproverUpsertArgs} args - Arguments to update or create a MCTApprover.
     * @example
     * // Update or create a MCTApprover
     * const mCTApprover = await prisma.mCTApprover.upsert({
     *   create: {
     *     // ... data to create a MCTApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCTApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MCTApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCTApproverUpsertArgs<ExtArgs>>
    ): Prisma__MCTApproverClient<$Result.GetResult<Prisma.$MCTApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverCountArgs} args - Arguments to filter MCTApprovers to count.
     * @example
     * // Count the number of MCTApprovers
     * const count = await prisma.mCTApprover.count({
     *   where: {
     *     // ... the filter for the MCTApprovers we want to count
     *   }
     * })
    **/
    count<T extends MCTApproverCountArgs>(
      args?: Subset<T, MCTApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCTApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCTApproverAggregateArgs>(args: Subset<T, MCTApproverAggregateArgs>): Prisma.PrismaPromise<GetMCTApproverAggregateType<T>>

    /**
     * Group by MCTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCTApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCTApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCTApproverGroupByArgs['orderBy'] }
        : { orderBy?: MCTApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCTApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCTApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCTApprover model
   */
  readonly fields: MCTApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCTApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCTApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mct<T extends MCTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MCTDefaultArgs<ExtArgs>>): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MCTApprover model
   */ 
  interface MCTApproverFieldRefs {
    readonly id: FieldRef<"MCTApprover", 'String'>
    readonly mct_id: FieldRef<"MCTApprover", 'String'>
    readonly approver_id: FieldRef<"MCTApprover", 'String'>
    readonly date_approval: FieldRef<"MCTApprover", 'DateTime'>
    readonly notes: FieldRef<"MCTApprover", 'String'>
    readonly status: FieldRef<"MCTApprover", 'Int'>
    readonly label: FieldRef<"MCTApprover", 'String'>
    readonly label_id: FieldRef<"MCTApprover", 'String'>
    readonly order: FieldRef<"MCTApprover", 'Int'>
    readonly updated_by: FieldRef<"MCTApprover", 'String'>
    readonly updated_at: FieldRef<"MCTApprover", 'DateTime'>
    readonly metadata: FieldRef<"MCTApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MCTApprover findUnique
   */
  export type MCTApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCTApprover to fetch.
     */
    where: MCTApproverWhereUniqueInput
  }


  /**
   * MCTApprover findUniqueOrThrow
   */
  export type MCTApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCTApprover to fetch.
     */
    where: MCTApproverWhereUniqueInput
  }


  /**
   * MCTApprover findFirst
   */
  export type MCTApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCTApprover to fetch.
     */
    where?: MCTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTApprovers to fetch.
     */
    orderBy?: MCTApproverOrderByWithRelationInput | MCTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCTApprovers.
     */
    cursor?: MCTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCTApprovers.
     */
    distinct?: MCTApproverScalarFieldEnum | MCTApproverScalarFieldEnum[]
  }


  /**
   * MCTApprover findFirstOrThrow
   */
  export type MCTApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCTApprover to fetch.
     */
    where?: MCTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTApprovers to fetch.
     */
    orderBy?: MCTApproverOrderByWithRelationInput | MCTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCTApprovers.
     */
    cursor?: MCTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCTApprovers.
     */
    distinct?: MCTApproverScalarFieldEnum | MCTApproverScalarFieldEnum[]
  }


  /**
   * MCTApprover findMany
   */
  export type MCTApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCTApprovers to fetch.
     */
    where?: MCTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCTApprovers to fetch.
     */
    orderBy?: MCTApproverOrderByWithRelationInput | MCTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCTApprovers.
     */
    cursor?: MCTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCTApprovers.
     */
    skip?: number
    distinct?: MCTApproverScalarFieldEnum | MCTApproverScalarFieldEnum[]
  }


  /**
   * MCTApprover create
   */
  export type MCTApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MCTApprover.
     */
    data: XOR<MCTApproverCreateInput, MCTApproverUncheckedCreateInput>
  }


  /**
   * MCTApprover createMany
   */
  export type MCTApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCTApprovers.
     */
    data: MCTApproverCreateManyInput | MCTApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCTApprover update
   */
  export type MCTApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MCTApprover.
     */
    data: XOR<MCTApproverUpdateInput, MCTApproverUncheckedUpdateInput>
    /**
     * Choose, which MCTApprover to update.
     */
    where: MCTApproverWhereUniqueInput
  }


  /**
   * MCTApprover updateMany
   */
  export type MCTApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCTApprovers.
     */
    data: XOR<MCTApproverUpdateManyMutationInput, MCTApproverUncheckedUpdateManyInput>
    /**
     * Filter which MCTApprovers to update
     */
    where?: MCTApproverWhereInput
  }


  /**
   * MCTApprover upsert
   */
  export type MCTApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MCTApprover to update in case it exists.
     */
    where: MCTApproverWhereUniqueInput
    /**
     * In case the MCTApprover found by the `where` argument doesn't exist, create a new MCTApprover with this data.
     */
    create: XOR<MCTApproverCreateInput, MCTApproverUncheckedCreateInput>
    /**
     * In case the MCTApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCTApproverUpdateInput, MCTApproverUncheckedUpdateInput>
  }


  /**
   * MCTApprover delete
   */
  export type MCTApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
    /**
     * Filter which MCTApprover to delete.
     */
    where: MCTApproverWhereUniqueInput
  }


  /**
   * MCTApprover deleteMany
   */
  export type MCTApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCTApprovers to delete
     */
    where?: MCTApproverWhereInput
  }


  /**
   * MCTApprover without action
   */
  export type MCTApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCTApprover
     */
    select?: MCTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTApproverInclude<ExtArgs> | null
  }



  /**
   * Model MCRT
   */

  export type AggregateMCRT = {
    _count: MCRTCountAggregateOutputType | null
    _min: MCRTMinAggregateOutputType | null
    _max: MCRTMaxAggregateOutputType | null
  }

  export type MCRTMinAggregateOutputType = {
    id: string | null
    mct_id: string | null
    mct_number: string | null
    seriv_id: string | null
    seriv_number: string | null
    mcrt_number: string | null
    mcrt_date: Date | null
    is_completed: boolean | null
    returned_by_id: string | null
    wo_number: string | null
    mo_number: string | null
    jo_number: string | null
    note: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MCRTMaxAggregateOutputType = {
    id: string | null
    mct_id: string | null
    mct_number: string | null
    seriv_id: string | null
    seriv_number: string | null
    mcrt_number: string | null
    mcrt_date: Date | null
    is_completed: boolean | null
    returned_by_id: string | null
    wo_number: string | null
    mo_number: string | null
    jo_number: string | null
    note: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MCRTCountAggregateOutputType = {
    id: number
    mct_id: number
    mct_number: number
    seriv_id: number
    seriv_number: number
    mcrt_number: number
    mcrt_date: number
    is_completed: number
    returned_by_id: number
    wo_number: number
    mo_number: number
    jo_number: number
    note: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MCRTMinAggregateInputType = {
    id?: true
    mct_id?: true
    mct_number?: true
    seriv_id?: true
    seriv_number?: true
    mcrt_number?: true
    mcrt_date?: true
    is_completed?: true
    returned_by_id?: true
    wo_number?: true
    mo_number?: true
    jo_number?: true
    note?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MCRTMaxAggregateInputType = {
    id?: true
    mct_id?: true
    mct_number?: true
    seriv_id?: true
    seriv_number?: true
    mcrt_number?: true
    mcrt_date?: true
    is_completed?: true
    returned_by_id?: true
    wo_number?: true
    mo_number?: true
    jo_number?: true
    note?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MCRTCountAggregateInputType = {
    id?: true
    mct_id?: true
    mct_number?: true
    seriv_id?: true
    seriv_number?: true
    mcrt_number?: true
    mcrt_date?: true
    is_completed?: true
    returned_by_id?: true
    wo_number?: true
    mo_number?: true
    jo_number?: true
    note?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MCRTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRT to aggregate.
     */
    where?: MCRTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTS to fetch.
     */
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCRTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCRTS
    **/
    _count?: true | MCRTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCRTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCRTMaxAggregateInputType
  }

  export type GetMCRTAggregateType<T extends MCRTAggregateArgs> = {
        [P in keyof T & keyof AggregateMCRT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCRT[P]>
      : GetScalarType<T[P], AggregateMCRT[P]>
  }




  export type MCRTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTWhereInput
    orderBy?: MCRTOrderByWithAggregationInput | MCRTOrderByWithAggregationInput[]
    by: MCRTScalarFieldEnum[] | MCRTScalarFieldEnum
    having?: MCRTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCRTCountAggregateInputType | true
    _min?: MCRTMinAggregateInputType
    _max?: MCRTMaxAggregateInputType
  }

  export type MCRTGroupByOutputType = {
    id: string
    mct_id: string | null
    mct_number: string | null
    seriv_id: string | null
    seriv_number: string | null
    mcrt_number: string
    mcrt_date: Date
    is_completed: boolean
    returned_by_id: string
    wo_number: string | null
    mo_number: string | null
    jo_number: string | null
    note: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: MCRTCountAggregateOutputType | null
    _min: MCRTMinAggregateOutputType | null
    _max: MCRTMaxAggregateOutputType | null
  }

  type GetMCRTGroupByPayload<T extends MCRTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCRTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCRTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCRTGroupByOutputType[P]>
            : GetScalarType<T[P], MCRTGroupByOutputType[P]>
        }
      >
    >


  export type MCRTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mct_id?: boolean
    mct_number?: boolean
    seriv_id?: boolean
    seriv_number?: boolean
    mcrt_number?: boolean
    mcrt_date?: boolean
    is_completed?: boolean
    returned_by_id?: boolean
    wo_number?: boolean
    mo_number?: boolean
    jo_number?: boolean
    note?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    mct?: boolean | MCRT$mctArgs<ExtArgs>
    seriv?: boolean | MCRT$serivArgs<ExtArgs>
    mcrt_approvers?: boolean | MCRT$mcrt_approversArgs<ExtArgs>
    mcrt_items?: boolean | MCRT$mcrt_itemsArgs<ExtArgs>
    _count?: boolean | MCRTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCRT"]>

  export type MCRTSelectScalar = {
    id?: boolean
    mct_id?: boolean
    mct_number?: boolean
    seriv_id?: boolean
    seriv_number?: boolean
    mcrt_number?: boolean
    mcrt_date?: boolean
    is_completed?: boolean
    returned_by_id?: boolean
    wo_number?: boolean
    mo_number?: boolean
    jo_number?: boolean
    note?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MCRTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mct?: boolean | MCRT$mctArgs<ExtArgs>
    seriv?: boolean | MCRT$serivArgs<ExtArgs>
    mcrt_approvers?: boolean | MCRT$mcrt_approversArgs<ExtArgs>
    mcrt_items?: boolean | MCRT$mcrt_itemsArgs<ExtArgs>
    _count?: boolean | MCRTCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MCRTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCRT"
    objects: {
      mct: Prisma.$MCTPayload<ExtArgs> | null
      seriv: Prisma.$SERIVPayload<ExtArgs> | null
      mcrt_approvers: Prisma.$MCRTApproverPayload<ExtArgs>[]
      mcrt_items: Prisma.$MCRTItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mct_id: string | null
      mct_number: string | null
      seriv_id: string | null
      seriv_number: string | null
      mcrt_number: string
      mcrt_date: Date
      is_completed: boolean
      returned_by_id: string
      wo_number: string | null
      mo_number: string | null
      jo_number: string | null
      note: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mCRT"]>
    composites: {}
  }


  type MCRTGetPayload<S extends boolean | null | undefined | MCRTDefaultArgs> = $Result.GetResult<Prisma.$MCRTPayload, S>

  type MCRTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MCRTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCRTCountAggregateInputType | true
    }

  export interface MCRTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCRT'], meta: { name: 'MCRT' } }
    /**
     * Find zero or one MCRT that matches the filter.
     * @param {MCRTFindUniqueArgs} args - Arguments to find a MCRT
     * @example
     * // Get one MCRT
     * const mCRT = await prisma.mCRT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCRTFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTFindUniqueArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCRT that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCRTFindUniqueOrThrowArgs} args - Arguments to find a MCRT
     * @example
     * // Get one MCRT
     * const mCRT = await prisma.mCRT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCRTFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCRT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTFindFirstArgs} args - Arguments to find a MCRT
     * @example
     * // Get one MCRT
     * const mCRT = await prisma.mCRT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCRTFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTFindFirstArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCRT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTFindFirstOrThrowArgs} args - Arguments to find a MCRT
     * @example
     * // Get one MCRT
     * const mCRT = await prisma.mCRT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCRTFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCRTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCRTS
     * const mCRTS = await prisma.mCRT.findMany()
     * 
     * // Get first 10 MCRTS
     * const mCRTS = await prisma.mCRT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCRTWithIdOnly = await prisma.mCRT.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCRTFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCRT.
     * @param {MCRTCreateArgs} args - Arguments to create a MCRT.
     * @example
     * // Create one MCRT
     * const MCRT = await prisma.mCRT.create({
     *   data: {
     *     // ... data to create a MCRT
     *   }
     * })
     * 
    **/
    create<T extends MCRTCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTCreateArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCRTS.
     *     @param {MCRTCreateManyArgs} args - Arguments to create many MCRTS.
     *     @example
     *     // Create many MCRTS
     *     const mCRT = await prisma.mCRT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCRTCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCRT.
     * @param {MCRTDeleteArgs} args - Arguments to delete one MCRT.
     * @example
     * // Delete one MCRT
     * const MCRT = await prisma.mCRT.delete({
     *   where: {
     *     // ... filter to delete one MCRT
     *   }
     * })
     * 
    **/
    delete<T extends MCRTDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTDeleteArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCRT.
     * @param {MCRTUpdateArgs} args - Arguments to update one MCRT.
     * @example
     * // Update one MCRT
     * const mCRT = await prisma.mCRT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCRTUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTUpdateArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCRTS.
     * @param {MCRTDeleteManyArgs} args - Arguments to filter MCRTS to delete.
     * @example
     * // Delete a few MCRTS
     * const { count } = await prisma.mCRT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCRTDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCRTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCRTS
     * const mCRT = await prisma.mCRT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCRTUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCRT.
     * @param {MCRTUpsertArgs} args - Arguments to update or create a MCRT.
     * @example
     * // Update or create a MCRT
     * const mCRT = await prisma.mCRT.upsert({
     *   create: {
     *     // ... data to create a MCRT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCRT we want to update
     *   }
     * })
    **/
    upsert<T extends MCRTUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTUpsertArgs<ExtArgs>>
    ): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCRTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTCountArgs} args - Arguments to filter MCRTS to count.
     * @example
     * // Count the number of MCRTS
     * const count = await prisma.mCRT.count({
     *   where: {
     *     // ... the filter for the MCRTS we want to count
     *   }
     * })
    **/
    count<T extends MCRTCountArgs>(
      args?: Subset<T, MCRTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCRTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCRT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCRTAggregateArgs>(args: Subset<T, MCRTAggregateArgs>): Prisma.PrismaPromise<GetMCRTAggregateType<T>>

    /**
     * Group by MCRT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCRTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCRTGroupByArgs['orderBy'] }
        : { orderBy?: MCRTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCRTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCRTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCRT model
   */
  readonly fields: MCRTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCRT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCRTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mct<T extends MCRT$mctArgs<ExtArgs> = {}>(args?: Subset<T, MCRT$mctArgs<ExtArgs>>): Prisma__MCTClient<$Result.GetResult<Prisma.$MCTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    seriv<T extends MCRT$serivArgs<ExtArgs> = {}>(args?: Subset<T, MCRT$serivArgs<ExtArgs>>): Prisma__SERIVClient<$Result.GetResult<Prisma.$SERIVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    mcrt_approvers<T extends MCRT$mcrt_approversArgs<ExtArgs> = {}>(args?: Subset<T, MCRT$mcrt_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    mcrt_items<T extends MCRT$mcrt_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MCRT$mcrt_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MCRT model
   */ 
  interface MCRTFieldRefs {
    readonly id: FieldRef<"MCRT", 'String'>
    readonly mct_id: FieldRef<"MCRT", 'String'>
    readonly mct_number: FieldRef<"MCRT", 'String'>
    readonly seriv_id: FieldRef<"MCRT", 'String'>
    readonly seriv_number: FieldRef<"MCRT", 'String'>
    readonly mcrt_number: FieldRef<"MCRT", 'String'>
    readonly mcrt_date: FieldRef<"MCRT", 'DateTime'>
    readonly is_completed: FieldRef<"MCRT", 'Boolean'>
    readonly returned_by_id: FieldRef<"MCRT", 'String'>
    readonly wo_number: FieldRef<"MCRT", 'String'>
    readonly mo_number: FieldRef<"MCRT", 'String'>
    readonly jo_number: FieldRef<"MCRT", 'String'>
    readonly note: FieldRef<"MCRT", 'String'>
    readonly cancelled_by: FieldRef<"MCRT", 'String'>
    readonly created_by: FieldRef<"MCRT", 'String'>
    readonly updated_by: FieldRef<"MCRT", 'String'>
    readonly cancelled_at: FieldRef<"MCRT", 'DateTime'>
    readonly created_at: FieldRef<"MCRT", 'DateTime'>
    readonly updated_at: FieldRef<"MCRT", 'DateTime'>
    readonly metadata: FieldRef<"MCRT", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MCRT findUnique
   */
  export type MCRTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter, which MCRT to fetch.
     */
    where: MCRTWhereUniqueInput
  }


  /**
   * MCRT findUniqueOrThrow
   */
  export type MCRTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter, which MCRT to fetch.
     */
    where: MCRTWhereUniqueInput
  }


  /**
   * MCRT findFirst
   */
  export type MCRTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter, which MCRT to fetch.
     */
    where?: MCRTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTS to fetch.
     */
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTS.
     */
    cursor?: MCRTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTS.
     */
    distinct?: MCRTScalarFieldEnum | MCRTScalarFieldEnum[]
  }


  /**
   * MCRT findFirstOrThrow
   */
  export type MCRTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter, which MCRT to fetch.
     */
    where?: MCRTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTS to fetch.
     */
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTS.
     */
    cursor?: MCRTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTS.
     */
    distinct?: MCRTScalarFieldEnum | MCRTScalarFieldEnum[]
  }


  /**
   * MCRT findMany
   */
  export type MCRTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter, which MCRTS to fetch.
     */
    where?: MCRTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTS to fetch.
     */
    orderBy?: MCRTOrderByWithRelationInput | MCRTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCRTS.
     */
    cursor?: MCRTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTS.
     */
    skip?: number
    distinct?: MCRTScalarFieldEnum | MCRTScalarFieldEnum[]
  }


  /**
   * MCRT create
   */
  export type MCRTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * The data needed to create a MCRT.
     */
    data: XOR<MCRTCreateInput, MCRTUncheckedCreateInput>
  }


  /**
   * MCRT createMany
   */
  export type MCRTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCRTS.
     */
    data: MCRTCreateManyInput | MCRTCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCRT update
   */
  export type MCRTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * The data needed to update a MCRT.
     */
    data: XOR<MCRTUpdateInput, MCRTUncheckedUpdateInput>
    /**
     * Choose, which MCRT to update.
     */
    where: MCRTWhereUniqueInput
  }


  /**
   * MCRT updateMany
   */
  export type MCRTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCRTS.
     */
    data: XOR<MCRTUpdateManyMutationInput, MCRTUncheckedUpdateManyInput>
    /**
     * Filter which MCRTS to update
     */
    where?: MCRTWhereInput
  }


  /**
   * MCRT upsert
   */
  export type MCRTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * The filter to search for the MCRT to update in case it exists.
     */
    where: MCRTWhereUniqueInput
    /**
     * In case the MCRT found by the `where` argument doesn't exist, create a new MCRT with this data.
     */
    create: XOR<MCRTCreateInput, MCRTUncheckedCreateInput>
    /**
     * In case the MCRT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCRTUpdateInput, MCRTUncheckedUpdateInput>
  }


  /**
   * MCRT delete
   */
  export type MCRTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
    /**
     * Filter which MCRT to delete.
     */
    where: MCRTWhereUniqueInput
  }


  /**
   * MCRT deleteMany
   */
  export type MCRTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRTS to delete
     */
    where?: MCRTWhereInput
  }


  /**
   * MCRT.mct
   */
  export type MCRT$mctArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCT
     */
    select?: MCTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCTInclude<ExtArgs> | null
    where?: MCTWhereInput
  }


  /**
   * MCRT.seriv
   */
  export type MCRT$serivArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SERIV
     */
    select?: SERIVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SERIVInclude<ExtArgs> | null
    where?: SERIVWhereInput
  }


  /**
   * MCRT.mcrt_approvers
   */
  export type MCRT$mcrt_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    where?: MCRTApproverWhereInput
    orderBy?: MCRTApproverOrderByWithRelationInput | MCRTApproverOrderByWithRelationInput[]
    cursor?: MCRTApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCRTApproverScalarFieldEnum | MCRTApproverScalarFieldEnum[]
  }


  /**
   * MCRT.mcrt_items
   */
  export type MCRT$mcrt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    where?: MCRTItemWhereInput
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    cursor?: MCRTItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCRTItemScalarFieldEnum | MCRTItemScalarFieldEnum[]
  }


  /**
   * MCRT without action
   */
  export type MCRTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRT
     */
    select?: MCRTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTInclude<ExtArgs> | null
  }



  /**
   * Model MCRTApprover
   */

  export type AggregateMCRTApprover = {
    _count: MCRTApproverCountAggregateOutputType | null
    _avg: MCRTApproverAvgAggregateOutputType | null
    _sum: MCRTApproverSumAggregateOutputType | null
    _min: MCRTApproverMinAggregateOutputType | null
    _max: MCRTApproverMaxAggregateOutputType | null
  }

  export type MCRTApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MCRTApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MCRTApproverMinAggregateOutputType = {
    id: string | null
    mcrt_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MCRTApproverMaxAggregateOutputType = {
    id: string | null
    mcrt_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MCRTApproverCountAggregateOutputType = {
    id: number
    mcrt_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MCRTApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MCRTApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MCRTApproverMinAggregateInputType = {
    id?: true
    mcrt_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MCRTApproverMaxAggregateInputType = {
    id?: true
    mcrt_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MCRTApproverCountAggregateInputType = {
    id?: true
    mcrt_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MCRTApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRTApprover to aggregate.
     */
    where?: MCRTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTApprovers to fetch.
     */
    orderBy?: MCRTApproverOrderByWithRelationInput | MCRTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCRTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCRTApprovers
    **/
    _count?: true | MCRTApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCRTApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCRTApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCRTApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCRTApproverMaxAggregateInputType
  }

  export type GetMCRTApproverAggregateType<T extends MCRTApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMCRTApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCRTApprover[P]>
      : GetScalarType<T[P], AggregateMCRTApprover[P]>
  }




  export type MCRTApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTApproverWhereInput
    orderBy?: MCRTApproverOrderByWithAggregationInput | MCRTApproverOrderByWithAggregationInput[]
    by: MCRTApproverScalarFieldEnum[] | MCRTApproverScalarFieldEnum
    having?: MCRTApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCRTApproverCountAggregateInputType | true
    _avg?: MCRTApproverAvgAggregateInputType
    _sum?: MCRTApproverSumAggregateInputType
    _min?: MCRTApproverMinAggregateInputType
    _max?: MCRTApproverMaxAggregateInputType
  }

  export type MCRTApproverGroupByOutputType = {
    id: string
    mcrt_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: MCRTApproverCountAggregateOutputType | null
    _avg: MCRTApproverAvgAggregateOutputType | null
    _sum: MCRTApproverSumAggregateOutputType | null
    _min: MCRTApproverMinAggregateOutputType | null
    _max: MCRTApproverMaxAggregateOutputType | null
  }

  type GetMCRTApproverGroupByPayload<T extends MCRTApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCRTApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCRTApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCRTApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MCRTApproverGroupByOutputType[P]>
        }
      >
    >


  export type MCRTApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mcrt_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    mcrt?: boolean | MCRTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCRTApprover"]>

  export type MCRTApproverSelectScalar = {
    id?: boolean
    mcrt_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MCRTApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcrt?: boolean | MCRTDefaultArgs<ExtArgs>
  }


  export type $MCRTApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCRTApprover"
    objects: {
      mcrt: Prisma.$MCRTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mcrt_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mCRTApprover"]>
    composites: {}
  }


  type MCRTApproverGetPayload<S extends boolean | null | undefined | MCRTApproverDefaultArgs> = $Result.GetResult<Prisma.$MCRTApproverPayload, S>

  type MCRTApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MCRTApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCRTApproverCountAggregateInputType | true
    }

  export interface MCRTApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCRTApprover'], meta: { name: 'MCRTApprover' } }
    /**
     * Find zero or one MCRTApprover that matches the filter.
     * @param {MCRTApproverFindUniqueArgs} args - Arguments to find a MCRTApprover
     * @example
     * // Get one MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCRTApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCRTApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCRTApproverFindUniqueOrThrowArgs} args - Arguments to find a MCRTApprover
     * @example
     * // Get one MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCRTApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCRTApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverFindFirstArgs} args - Arguments to find a MCRTApprover
     * @example
     * // Get one MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCRTApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCRTApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverFindFirstOrThrowArgs} args - Arguments to find a MCRTApprover
     * @example
     * // Get one MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCRTApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCRTApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCRTApprovers
     * const mCRTApprovers = await prisma.mCRTApprover.findMany()
     * 
     * // Get first 10 MCRTApprovers
     * const mCRTApprovers = await prisma.mCRTApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCRTApproverWithIdOnly = await prisma.mCRTApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCRTApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCRTApprover.
     * @param {MCRTApproverCreateArgs} args - Arguments to create a MCRTApprover.
     * @example
     * // Create one MCRTApprover
     * const MCRTApprover = await prisma.mCRTApprover.create({
     *   data: {
     *     // ... data to create a MCRTApprover
     *   }
     * })
     * 
    **/
    create<T extends MCRTApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverCreateArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCRTApprovers.
     *     @param {MCRTApproverCreateManyArgs} args - Arguments to create many MCRTApprovers.
     *     @example
     *     // Create many MCRTApprovers
     *     const mCRTApprover = await prisma.mCRTApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCRTApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCRTApprover.
     * @param {MCRTApproverDeleteArgs} args - Arguments to delete one MCRTApprover.
     * @example
     * // Delete one MCRTApprover
     * const MCRTApprover = await prisma.mCRTApprover.delete({
     *   where: {
     *     // ... filter to delete one MCRTApprover
     *   }
     * })
     * 
    **/
    delete<T extends MCRTApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverDeleteArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCRTApprover.
     * @param {MCRTApproverUpdateArgs} args - Arguments to update one MCRTApprover.
     * @example
     * // Update one MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCRTApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverUpdateArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCRTApprovers.
     * @param {MCRTApproverDeleteManyArgs} args - Arguments to filter MCRTApprovers to delete.
     * @example
     * // Delete a few MCRTApprovers
     * const { count } = await prisma.mCRTApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCRTApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCRTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCRTApprovers
     * const mCRTApprover = await prisma.mCRTApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCRTApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCRTApprover.
     * @param {MCRTApproverUpsertArgs} args - Arguments to update or create a MCRTApprover.
     * @example
     * // Update or create a MCRTApprover
     * const mCRTApprover = await prisma.mCRTApprover.upsert({
     *   create: {
     *     // ... data to create a MCRTApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCRTApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MCRTApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTApproverUpsertArgs<ExtArgs>>
    ): Prisma__MCRTApproverClient<$Result.GetResult<Prisma.$MCRTApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCRTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverCountArgs} args - Arguments to filter MCRTApprovers to count.
     * @example
     * // Count the number of MCRTApprovers
     * const count = await prisma.mCRTApprover.count({
     *   where: {
     *     // ... the filter for the MCRTApprovers we want to count
     *   }
     * })
    **/
    count<T extends MCRTApproverCountArgs>(
      args?: Subset<T, MCRTApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCRTApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCRTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCRTApproverAggregateArgs>(args: Subset<T, MCRTApproverAggregateArgs>): Prisma.PrismaPromise<GetMCRTApproverAggregateType<T>>

    /**
     * Group by MCRTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCRTApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCRTApproverGroupByArgs['orderBy'] }
        : { orderBy?: MCRTApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCRTApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCRTApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCRTApprover model
   */
  readonly fields: MCRTApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCRTApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCRTApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mcrt<T extends MCRTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MCRTDefaultArgs<ExtArgs>>): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MCRTApprover model
   */ 
  interface MCRTApproverFieldRefs {
    readonly id: FieldRef<"MCRTApprover", 'String'>
    readonly mcrt_id: FieldRef<"MCRTApprover", 'String'>
    readonly approver_id: FieldRef<"MCRTApprover", 'String'>
    readonly date_approval: FieldRef<"MCRTApprover", 'DateTime'>
    readonly notes: FieldRef<"MCRTApprover", 'String'>
    readonly status: FieldRef<"MCRTApprover", 'Int'>
    readonly label: FieldRef<"MCRTApprover", 'String'>
    readonly label_id: FieldRef<"MCRTApprover", 'String'>
    readonly order: FieldRef<"MCRTApprover", 'Int'>
    readonly updated_by: FieldRef<"MCRTApprover", 'String'>
    readonly updated_at: FieldRef<"MCRTApprover", 'DateTime'>
    readonly metadata: FieldRef<"MCRTApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MCRTApprover findUnique
   */
  export type MCRTApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCRTApprover to fetch.
     */
    where: MCRTApproverWhereUniqueInput
  }


  /**
   * MCRTApprover findUniqueOrThrow
   */
  export type MCRTApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCRTApprover to fetch.
     */
    where: MCRTApproverWhereUniqueInput
  }


  /**
   * MCRTApprover findFirst
   */
  export type MCRTApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCRTApprover to fetch.
     */
    where?: MCRTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTApprovers to fetch.
     */
    orderBy?: MCRTApproverOrderByWithRelationInput | MCRTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTApprovers.
     */
    cursor?: MCRTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTApprovers.
     */
    distinct?: MCRTApproverScalarFieldEnum | MCRTApproverScalarFieldEnum[]
  }


  /**
   * MCRTApprover findFirstOrThrow
   */
  export type MCRTApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCRTApprover to fetch.
     */
    where?: MCRTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTApprovers to fetch.
     */
    orderBy?: MCRTApproverOrderByWithRelationInput | MCRTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTApprovers.
     */
    cursor?: MCRTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTApprovers.
     */
    distinct?: MCRTApproverScalarFieldEnum | MCRTApproverScalarFieldEnum[]
  }


  /**
   * MCRTApprover findMany
   */
  export type MCRTApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MCRTApprovers to fetch.
     */
    where?: MCRTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTApprovers to fetch.
     */
    orderBy?: MCRTApproverOrderByWithRelationInput | MCRTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCRTApprovers.
     */
    cursor?: MCRTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTApprovers.
     */
    skip?: number
    distinct?: MCRTApproverScalarFieldEnum | MCRTApproverScalarFieldEnum[]
  }


  /**
   * MCRTApprover create
   */
  export type MCRTApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MCRTApprover.
     */
    data: XOR<MCRTApproverCreateInput, MCRTApproverUncheckedCreateInput>
  }


  /**
   * MCRTApprover createMany
   */
  export type MCRTApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCRTApprovers.
     */
    data: MCRTApproverCreateManyInput | MCRTApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCRTApprover update
   */
  export type MCRTApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MCRTApprover.
     */
    data: XOR<MCRTApproverUpdateInput, MCRTApproverUncheckedUpdateInput>
    /**
     * Choose, which MCRTApprover to update.
     */
    where: MCRTApproverWhereUniqueInput
  }


  /**
   * MCRTApprover updateMany
   */
  export type MCRTApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCRTApprovers.
     */
    data: XOR<MCRTApproverUpdateManyMutationInput, MCRTApproverUncheckedUpdateManyInput>
    /**
     * Filter which MCRTApprovers to update
     */
    where?: MCRTApproverWhereInput
  }


  /**
   * MCRTApprover upsert
   */
  export type MCRTApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MCRTApprover to update in case it exists.
     */
    where: MCRTApproverWhereUniqueInput
    /**
     * In case the MCRTApprover found by the `where` argument doesn't exist, create a new MCRTApprover with this data.
     */
    create: XOR<MCRTApproverCreateInput, MCRTApproverUncheckedCreateInput>
    /**
     * In case the MCRTApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCRTApproverUpdateInput, MCRTApproverUncheckedUpdateInput>
  }


  /**
   * MCRTApprover delete
   */
  export type MCRTApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
    /**
     * Filter which MCRTApprover to delete.
     */
    where: MCRTApproverWhereUniqueInput
  }


  /**
   * MCRTApprover deleteMany
   */
  export type MCRTApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRTApprovers to delete
     */
    where?: MCRTApproverWhereInput
  }


  /**
   * MCRTApprover without action
   */
  export type MCRTApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTApprover
     */
    select?: MCRTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTApproverInclude<ExtArgs> | null
  }



  /**
   * Model MCRTItem
   */

  export type AggregateMCRTItem = {
    _count: MCRTItemCountAggregateOutputType | null
    _avg: MCRTItemAvgAggregateOutputType | null
    _sum: MCRTItemSumAggregateOutputType | null
    _min: MCRTItemMinAggregateOutputType | null
    _max: MCRTItemMaxAggregateOutputType | null
  }

  export type MCRTItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type MCRTItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type MCRTItemMinAggregateOutputType = {
    id: string | null
    mcrt_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MCRTItemMaxAggregateOutputType = {
    id: string | null
    mcrt_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MCRTItemCountAggregateOutputType = {
    id: number
    mcrt_id: number
    item_id: number
    quantity: number
    price: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type MCRTItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type MCRTItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type MCRTItemMinAggregateInputType = {
    id?: true
    mcrt_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type MCRTItemMaxAggregateInputType = {
    id?: true
    mcrt_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
  }

  export type MCRTItemCountAggregateInputType = {
    id?: true
    mcrt_id?: true
    item_id?: true
    quantity?: true
    price?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type MCRTItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRTItem to aggregate.
     */
    where?: MCRTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTItems to fetch.
     */
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCRTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCRTItems
    **/
    _count?: true | MCRTItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCRTItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCRTItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCRTItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCRTItemMaxAggregateInputType
  }

  export type GetMCRTItemAggregateType<T extends MCRTItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMCRTItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCRTItem[P]>
      : GetScalarType<T[P], AggregateMCRTItem[P]>
  }




  export type MCRTItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCRTItemWhereInput
    orderBy?: MCRTItemOrderByWithAggregationInput | MCRTItemOrderByWithAggregationInput[]
    by: MCRTItemScalarFieldEnum[] | MCRTItemScalarFieldEnum
    having?: MCRTItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCRTItemCountAggregateInputType | true
    _avg?: MCRTItemAvgAggregateInputType
    _sum?: MCRTItemSumAggregateInputType
    _min?: MCRTItemMinAggregateInputType
    _max?: MCRTItemMaxAggregateInputType
  }

  export type MCRTItemGroupByOutputType = {
    id: string
    mcrt_id: string
    item_id: string
    quantity: number
    price: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: MCRTItemCountAggregateOutputType | null
    _avg: MCRTItemAvgAggregateOutputType | null
    _sum: MCRTItemSumAggregateOutputType | null
    _min: MCRTItemMinAggregateOutputType | null
    _max: MCRTItemMaxAggregateOutputType | null
  }

  type GetMCRTItemGroupByPayload<T extends MCRTItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCRTItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCRTItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCRTItemGroupByOutputType[P]>
            : GetScalarType<T[P], MCRTItemGroupByOutputType[P]>
        }
      >
    >


  export type MCRTItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mcrt_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    mcrt?: boolean | MCRTDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | MCRTItem$item_transactionArgs<ExtArgs>
  }, ExtArgs["result"]["mCRTItem"]>

  export type MCRTItemSelectScalar = {
    id?: boolean
    mcrt_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type MCRTItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcrt?: boolean | MCRTDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    item_transaction?: boolean | MCRTItem$item_transactionArgs<ExtArgs>
  }


  export type $MCRTItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCRTItem"
    objects: {
      mcrt: Prisma.$MCRTPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mcrt_id: string
      item_id: string
      quantity: number
      price: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mCRTItem"]>
    composites: {}
  }


  type MCRTItemGetPayload<S extends boolean | null | undefined | MCRTItemDefaultArgs> = $Result.GetResult<Prisma.$MCRTItemPayload, S>

  type MCRTItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MCRTItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCRTItemCountAggregateInputType | true
    }

  export interface MCRTItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCRTItem'], meta: { name: 'MCRTItem' } }
    /**
     * Find zero or one MCRTItem that matches the filter.
     * @param {MCRTItemFindUniqueArgs} args - Arguments to find a MCRTItem
     * @example
     * // Get one MCRTItem
     * const mCRTItem = await prisma.mCRTItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCRTItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemFindUniqueArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCRTItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCRTItemFindUniqueOrThrowArgs} args - Arguments to find a MCRTItem
     * @example
     * // Get one MCRTItem
     * const mCRTItem = await prisma.mCRTItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCRTItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCRTItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemFindFirstArgs} args - Arguments to find a MCRTItem
     * @example
     * // Get one MCRTItem
     * const mCRTItem = await prisma.mCRTItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCRTItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemFindFirstArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCRTItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemFindFirstOrThrowArgs} args - Arguments to find a MCRTItem
     * @example
     * // Get one MCRTItem
     * const mCRTItem = await prisma.mCRTItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCRTItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCRTItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCRTItems
     * const mCRTItems = await prisma.mCRTItem.findMany()
     * 
     * // Get first 10 MCRTItems
     * const mCRTItems = await prisma.mCRTItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCRTItemWithIdOnly = await prisma.mCRTItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCRTItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCRTItem.
     * @param {MCRTItemCreateArgs} args - Arguments to create a MCRTItem.
     * @example
     * // Create one MCRTItem
     * const MCRTItem = await prisma.mCRTItem.create({
     *   data: {
     *     // ... data to create a MCRTItem
     *   }
     * })
     * 
    **/
    create<T extends MCRTItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemCreateArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCRTItems.
     *     @param {MCRTItemCreateManyArgs} args - Arguments to create many MCRTItems.
     *     @example
     *     // Create many MCRTItems
     *     const mCRTItem = await prisma.mCRTItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCRTItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCRTItem.
     * @param {MCRTItemDeleteArgs} args - Arguments to delete one MCRTItem.
     * @example
     * // Delete one MCRTItem
     * const MCRTItem = await prisma.mCRTItem.delete({
     *   where: {
     *     // ... filter to delete one MCRTItem
     *   }
     * })
     * 
    **/
    delete<T extends MCRTItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemDeleteArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCRTItem.
     * @param {MCRTItemUpdateArgs} args - Arguments to update one MCRTItem.
     * @example
     * // Update one MCRTItem
     * const mCRTItem = await prisma.mCRTItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCRTItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemUpdateArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCRTItems.
     * @param {MCRTItemDeleteManyArgs} args - Arguments to filter MCRTItems to delete.
     * @example
     * // Delete a few MCRTItems
     * const { count } = await prisma.mCRTItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCRTItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCRTItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCRTItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCRTItems
     * const mCRTItem = await prisma.mCRTItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCRTItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCRTItem.
     * @param {MCRTItemUpsertArgs} args - Arguments to update or create a MCRTItem.
     * @example
     * // Update or create a MCRTItem
     * const mCRTItem = await prisma.mCRTItem.upsert({
     *   create: {
     *     // ... data to create a MCRTItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCRTItem we want to update
     *   }
     * })
    **/
    upsert<T extends MCRTItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCRTItemUpsertArgs<ExtArgs>>
    ): Prisma__MCRTItemClient<$Result.GetResult<Prisma.$MCRTItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCRTItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemCountArgs} args - Arguments to filter MCRTItems to count.
     * @example
     * // Count the number of MCRTItems
     * const count = await prisma.mCRTItem.count({
     *   where: {
     *     // ... the filter for the MCRTItems we want to count
     *   }
     * })
    **/
    count<T extends MCRTItemCountArgs>(
      args?: Subset<T, MCRTItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCRTItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCRTItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCRTItemAggregateArgs>(args: Subset<T, MCRTItemAggregateArgs>): Prisma.PrismaPromise<GetMCRTItemAggregateType<T>>

    /**
     * Group by MCRTItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCRTItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCRTItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCRTItemGroupByArgs['orderBy'] }
        : { orderBy?: MCRTItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCRTItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCRTItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCRTItem model
   */
  readonly fields: MCRTItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCRTItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCRTItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mcrt<T extends MCRTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MCRTDefaultArgs<ExtArgs>>): Prisma__MCRTClient<$Result.GetResult<Prisma.$MCRTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transaction<T extends MCRTItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, MCRTItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MCRTItem model
   */ 
  interface MCRTItemFieldRefs {
    readonly id: FieldRef<"MCRTItem", 'String'>
    readonly mcrt_id: FieldRef<"MCRTItem", 'String'>
    readonly item_id: FieldRef<"MCRTItem", 'String'>
    readonly quantity: FieldRef<"MCRTItem", 'Int'>
    readonly price: FieldRef<"MCRTItem", 'Float'>
    readonly created_by: FieldRef<"MCRTItem", 'String'>
    readonly created_at: FieldRef<"MCRTItem", 'DateTime'>
    readonly metadata: FieldRef<"MCRTItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MCRTItem findUnique
   */
  export type MCRTItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter, which MCRTItem to fetch.
     */
    where: MCRTItemWhereUniqueInput
  }


  /**
   * MCRTItem findUniqueOrThrow
   */
  export type MCRTItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter, which MCRTItem to fetch.
     */
    where: MCRTItemWhereUniqueInput
  }


  /**
   * MCRTItem findFirst
   */
  export type MCRTItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter, which MCRTItem to fetch.
     */
    where?: MCRTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTItems to fetch.
     */
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTItems.
     */
    cursor?: MCRTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTItems.
     */
    distinct?: MCRTItemScalarFieldEnum | MCRTItemScalarFieldEnum[]
  }


  /**
   * MCRTItem findFirstOrThrow
   */
  export type MCRTItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter, which MCRTItem to fetch.
     */
    where?: MCRTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTItems to fetch.
     */
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCRTItems.
     */
    cursor?: MCRTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCRTItems.
     */
    distinct?: MCRTItemScalarFieldEnum | MCRTItemScalarFieldEnum[]
  }


  /**
   * MCRTItem findMany
   */
  export type MCRTItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter, which MCRTItems to fetch.
     */
    where?: MCRTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCRTItems to fetch.
     */
    orderBy?: MCRTItemOrderByWithRelationInput | MCRTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCRTItems.
     */
    cursor?: MCRTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCRTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCRTItems.
     */
    skip?: number
    distinct?: MCRTItemScalarFieldEnum | MCRTItemScalarFieldEnum[]
  }


  /**
   * MCRTItem create
   */
  export type MCRTItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MCRTItem.
     */
    data: XOR<MCRTItemCreateInput, MCRTItemUncheckedCreateInput>
  }


  /**
   * MCRTItem createMany
   */
  export type MCRTItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCRTItems.
     */
    data: MCRTItemCreateManyInput | MCRTItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCRTItem update
   */
  export type MCRTItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MCRTItem.
     */
    data: XOR<MCRTItemUpdateInput, MCRTItemUncheckedUpdateInput>
    /**
     * Choose, which MCRTItem to update.
     */
    where: MCRTItemWhereUniqueInput
  }


  /**
   * MCRTItem updateMany
   */
  export type MCRTItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCRTItems.
     */
    data: XOR<MCRTItemUpdateManyMutationInput, MCRTItemUncheckedUpdateManyInput>
    /**
     * Filter which MCRTItems to update
     */
    where?: MCRTItemWhereInput
  }


  /**
   * MCRTItem upsert
   */
  export type MCRTItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MCRTItem to update in case it exists.
     */
    where: MCRTItemWhereUniqueInput
    /**
     * In case the MCRTItem found by the `where` argument doesn't exist, create a new MCRTItem with this data.
     */
    create: XOR<MCRTItemCreateInput, MCRTItemUncheckedCreateInput>
    /**
     * In case the MCRTItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCRTItemUpdateInput, MCRTItemUncheckedUpdateInput>
  }


  /**
   * MCRTItem delete
   */
  export type MCRTItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
    /**
     * Filter which MCRTItem to delete.
     */
    where: MCRTItemWhereUniqueInput
  }


  /**
   * MCRTItem deleteMany
   */
  export type MCRTItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCRTItems to delete
     */
    where?: MCRTItemWhereInput
  }


  /**
   * MCRTItem.item_transaction
   */
  export type MCRTItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * MCRTItem without action
   */
  export type MCRTItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCRTItem
     */
    select?: MCRTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCRTItemInclude<ExtArgs> | null
  }



  /**
   * Model MST
   */

  export type AggregateMST = {
    _count: MSTCountAggregateOutputType | null
    _min: MSTMinAggregateOutputType | null
    _max: MSTMaxAggregateOutputType | null
  }

  export type MSTMinAggregateOutputType = {
    id: string | null
    mst_number: string | null
    mst_date: Date | null
    returned_by_id: string | null
    cwo_number: string | null
    mwo_number: string | null
    jo_number: string | null
    remarks: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MSTMaxAggregateOutputType = {
    id: string | null
    mst_number: string | null
    mst_date: Date | null
    returned_by_id: string | null
    cwo_number: string | null
    mwo_number: string | null
    jo_number: string | null
    remarks: string | null
    cancelled_by: string | null
    created_by: string | null
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MSTCountAggregateOutputType = {
    id: number
    mst_number: number
    mst_date: number
    returned_by_id: number
    cwo_number: number
    mwo_number: number
    jo_number: number
    remarks: number
    cancelled_by: number
    created_by: number
    updated_by: number
    cancelled_at: number
    created_at: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MSTMinAggregateInputType = {
    id?: true
    mst_number?: true
    mst_date?: true
    returned_by_id?: true
    cwo_number?: true
    mwo_number?: true
    jo_number?: true
    remarks?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MSTMaxAggregateInputType = {
    id?: true
    mst_number?: true
    mst_date?: true
    returned_by_id?: true
    cwo_number?: true
    mwo_number?: true
    jo_number?: true
    remarks?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type MSTCountAggregateInputType = {
    id?: true
    mst_number?: true
    mst_date?: true
    returned_by_id?: true
    cwo_number?: true
    mwo_number?: true
    jo_number?: true
    remarks?: true
    cancelled_by?: true
    created_by?: true
    updated_by?: true
    cancelled_at?: true
    created_at?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MSTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MST to aggregate.
     */
    where?: MSTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTS to fetch.
     */
    orderBy?: MSTOrderByWithRelationInput | MSTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MSTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MSTS
    **/
    _count?: true | MSTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MSTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MSTMaxAggregateInputType
  }

  export type GetMSTAggregateType<T extends MSTAggregateArgs> = {
        [P in keyof T & keyof AggregateMST]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMST[P]>
      : GetScalarType<T[P], AggregateMST[P]>
  }




  export type MSTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTWhereInput
    orderBy?: MSTOrderByWithAggregationInput | MSTOrderByWithAggregationInput[]
    by: MSTScalarFieldEnum[] | MSTScalarFieldEnum
    having?: MSTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MSTCountAggregateInputType | true
    _min?: MSTMinAggregateInputType
    _max?: MSTMaxAggregateInputType
  }

  export type MSTGroupByOutputType = {
    id: string
    mst_number: string
    mst_date: Date
    returned_by_id: string
    cwo_number: string | null
    mwo_number: string | null
    jo_number: string | null
    remarks: string
    cancelled_by: string | null
    created_by: string
    updated_by: string | null
    cancelled_at: Date | null
    created_at: Date
    updated_at: Date
    metadata: JsonValue | null
    _count: MSTCountAggregateOutputType | null
    _min: MSTMinAggregateOutputType | null
    _max: MSTMaxAggregateOutputType | null
  }

  type GetMSTGroupByPayload<T extends MSTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MSTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MSTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MSTGroupByOutputType[P]>
            : GetScalarType<T[P], MSTGroupByOutputType[P]>
        }
      >
    >


  export type MSTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mst_number?: boolean
    mst_date?: boolean
    returned_by_id?: boolean
    cwo_number?: boolean
    mwo_number?: boolean
    jo_number?: boolean
    remarks?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
    mst_approvers?: boolean | MST$mst_approversArgs<ExtArgs>
    mst_items?: boolean | MST$mst_itemsArgs<ExtArgs>
    _count?: boolean | MSTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mST"]>

  export type MSTSelectScalar = {
    id?: boolean
    mst_number?: boolean
    mst_date?: boolean
    returned_by_id?: boolean
    cwo_number?: boolean
    mwo_number?: boolean
    jo_number?: boolean
    remarks?: boolean
    cancelled_by?: boolean
    created_by?: boolean
    updated_by?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MSTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mst_approvers?: boolean | MST$mst_approversArgs<ExtArgs>
    mst_items?: boolean | MST$mst_itemsArgs<ExtArgs>
    _count?: boolean | MSTCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MSTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MST"
    objects: {
      mst_approvers: Prisma.$MSTApproverPayload<ExtArgs>[]
      mst_items: Prisma.$MSTItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mst_number: string
      mst_date: Date
      returned_by_id: string
      cwo_number: string | null
      mwo_number: string | null
      jo_number: string | null
      remarks: string
      cancelled_by: string | null
      created_by: string
      updated_by: string | null
      cancelled_at: Date | null
      created_at: Date
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mST"]>
    composites: {}
  }


  type MSTGetPayload<S extends boolean | null | undefined | MSTDefaultArgs> = $Result.GetResult<Prisma.$MSTPayload, S>

  type MSTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MSTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MSTCountAggregateInputType | true
    }

  export interface MSTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MST'], meta: { name: 'MST' } }
    /**
     * Find zero or one MST that matches the filter.
     * @param {MSTFindUniqueArgs} args - Arguments to find a MST
     * @example
     * // Get one MST
     * const mST = await prisma.mST.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MSTFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MSTFindUniqueArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MST that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MSTFindUniqueOrThrowArgs} args - Arguments to find a MST
     * @example
     * // Get one MST
     * const mST = await prisma.mST.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MSTFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MST that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTFindFirstArgs} args - Arguments to find a MST
     * @example
     * // Get one MST
     * const mST = await prisma.mST.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MSTFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTFindFirstArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MST that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTFindFirstOrThrowArgs} args - Arguments to find a MST
     * @example
     * // Get one MST
     * const mST = await prisma.mST.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MSTFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MSTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MSTS
     * const mSTS = await prisma.mST.findMany()
     * 
     * // Get first 10 MSTS
     * const mSTS = await prisma.mST.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mSTWithIdOnly = await prisma.mST.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MSTFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MST.
     * @param {MSTCreateArgs} args - Arguments to create a MST.
     * @example
     * // Create one MST
     * const MST = await prisma.mST.create({
     *   data: {
     *     // ... data to create a MST
     *   }
     * })
     * 
    **/
    create<T extends MSTCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTCreateArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MSTS.
     *     @param {MSTCreateManyArgs} args - Arguments to create many MSTS.
     *     @example
     *     // Create many MSTS
     *     const mST = await prisma.mST.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MSTCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MST.
     * @param {MSTDeleteArgs} args - Arguments to delete one MST.
     * @example
     * // Delete one MST
     * const MST = await prisma.mST.delete({
     *   where: {
     *     // ... filter to delete one MST
     *   }
     * })
     * 
    **/
    delete<T extends MSTDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MSTDeleteArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MST.
     * @param {MSTUpdateArgs} args - Arguments to update one MST.
     * @example
     * // Update one MST
     * const mST = await prisma.mST.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MSTUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTUpdateArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MSTS.
     * @param {MSTDeleteManyArgs} args - Arguments to filter MSTS to delete.
     * @example
     * // Delete a few MSTS
     * const { count } = await prisma.mST.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MSTDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MSTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MSTS
     * const mST = await prisma.mST.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MSTUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MSTUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MST.
     * @param {MSTUpsertArgs} args - Arguments to update or create a MST.
     * @example
     * // Update or create a MST
     * const mST = await prisma.mST.upsert({
     *   create: {
     *     // ... data to create a MST
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MST we want to update
     *   }
     * })
    **/
    upsert<T extends MSTUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MSTUpsertArgs<ExtArgs>>
    ): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MSTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTCountArgs} args - Arguments to filter MSTS to count.
     * @example
     * // Count the number of MSTS
     * const count = await prisma.mST.count({
     *   where: {
     *     // ... the filter for the MSTS we want to count
     *   }
     * })
    **/
    count<T extends MSTCountArgs>(
      args?: Subset<T, MSTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MSTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MST.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MSTAggregateArgs>(args: Subset<T, MSTAggregateArgs>): Prisma.PrismaPromise<GetMSTAggregateType<T>>

    /**
     * Group by MST.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MSTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MSTGroupByArgs['orderBy'] }
        : { orderBy?: MSTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MSTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMSTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MST model
   */
  readonly fields: MSTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MST.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MSTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mst_approvers<T extends MST$mst_approversArgs<ExtArgs> = {}>(args?: Subset<T, MST$mst_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    mst_items<T extends MST$mst_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MST$mst_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MST model
   */ 
  interface MSTFieldRefs {
    readonly id: FieldRef<"MST", 'String'>
    readonly mst_number: FieldRef<"MST", 'String'>
    readonly mst_date: FieldRef<"MST", 'DateTime'>
    readonly returned_by_id: FieldRef<"MST", 'String'>
    readonly cwo_number: FieldRef<"MST", 'String'>
    readonly mwo_number: FieldRef<"MST", 'String'>
    readonly jo_number: FieldRef<"MST", 'String'>
    readonly remarks: FieldRef<"MST", 'String'>
    readonly cancelled_by: FieldRef<"MST", 'String'>
    readonly created_by: FieldRef<"MST", 'String'>
    readonly updated_by: FieldRef<"MST", 'String'>
    readonly cancelled_at: FieldRef<"MST", 'DateTime'>
    readonly created_at: FieldRef<"MST", 'DateTime'>
    readonly updated_at: FieldRef<"MST", 'DateTime'>
    readonly metadata: FieldRef<"MST", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MST findUnique
   */
  export type MSTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter, which MST to fetch.
     */
    where: MSTWhereUniqueInput
  }


  /**
   * MST findUniqueOrThrow
   */
  export type MSTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter, which MST to fetch.
     */
    where: MSTWhereUniqueInput
  }


  /**
   * MST findFirst
   */
  export type MSTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter, which MST to fetch.
     */
    where?: MSTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTS to fetch.
     */
    orderBy?: MSTOrderByWithRelationInput | MSTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTS.
     */
    cursor?: MSTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTS.
     */
    distinct?: MSTScalarFieldEnum | MSTScalarFieldEnum[]
  }


  /**
   * MST findFirstOrThrow
   */
  export type MSTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter, which MST to fetch.
     */
    where?: MSTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTS to fetch.
     */
    orderBy?: MSTOrderByWithRelationInput | MSTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTS.
     */
    cursor?: MSTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTS.
     */
    distinct?: MSTScalarFieldEnum | MSTScalarFieldEnum[]
  }


  /**
   * MST findMany
   */
  export type MSTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter, which MSTS to fetch.
     */
    where?: MSTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTS to fetch.
     */
    orderBy?: MSTOrderByWithRelationInput | MSTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MSTS.
     */
    cursor?: MSTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTS.
     */
    skip?: number
    distinct?: MSTScalarFieldEnum | MSTScalarFieldEnum[]
  }


  /**
   * MST create
   */
  export type MSTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * The data needed to create a MST.
     */
    data: XOR<MSTCreateInput, MSTUncheckedCreateInput>
  }


  /**
   * MST createMany
   */
  export type MSTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MSTS.
     */
    data: MSTCreateManyInput | MSTCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MST update
   */
  export type MSTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * The data needed to update a MST.
     */
    data: XOR<MSTUpdateInput, MSTUncheckedUpdateInput>
    /**
     * Choose, which MST to update.
     */
    where: MSTWhereUniqueInput
  }


  /**
   * MST updateMany
   */
  export type MSTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MSTS.
     */
    data: XOR<MSTUpdateManyMutationInput, MSTUncheckedUpdateManyInput>
    /**
     * Filter which MSTS to update
     */
    where?: MSTWhereInput
  }


  /**
   * MST upsert
   */
  export type MSTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * The filter to search for the MST to update in case it exists.
     */
    where: MSTWhereUniqueInput
    /**
     * In case the MST found by the `where` argument doesn't exist, create a new MST with this data.
     */
    create: XOR<MSTCreateInput, MSTUncheckedCreateInput>
    /**
     * In case the MST was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MSTUpdateInput, MSTUncheckedUpdateInput>
  }


  /**
   * MST delete
   */
  export type MSTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
    /**
     * Filter which MST to delete.
     */
    where: MSTWhereUniqueInput
  }


  /**
   * MST deleteMany
   */
  export type MSTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MSTS to delete
     */
    where?: MSTWhereInput
  }


  /**
   * MST.mst_approvers
   */
  export type MST$mst_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    where?: MSTApproverWhereInput
    orderBy?: MSTApproverOrderByWithRelationInput | MSTApproverOrderByWithRelationInput[]
    cursor?: MSTApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MSTApproverScalarFieldEnum | MSTApproverScalarFieldEnum[]
  }


  /**
   * MST.mst_items
   */
  export type MST$mst_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    where?: MSTItemWhereInput
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    cursor?: MSTItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MSTItemScalarFieldEnum | MSTItemScalarFieldEnum[]
  }


  /**
   * MST without action
   */
  export type MSTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MST
     */
    select?: MSTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTInclude<ExtArgs> | null
  }



  /**
   * Model MSTApprover
   */

  export type AggregateMSTApprover = {
    _count: MSTApproverCountAggregateOutputType | null
    _avg: MSTApproverAvgAggregateOutputType | null
    _sum: MSTApproverSumAggregateOutputType | null
    _min: MSTApproverMinAggregateOutputType | null
    _max: MSTApproverMaxAggregateOutputType | null
  }

  export type MSTApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MSTApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MSTApproverMinAggregateOutputType = {
    id: string | null
    mst_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MSTApproverMaxAggregateOutputType = {
    id: string | null
    mst_id: string | null
    approver_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    label_id: string | null
    order: number | null
    updated_by: string | null
    updated_at: Date | null
  }

  export type MSTApproverCountAggregateOutputType = {
    id: number
    mst_id: number
    approver_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    label_id: number
    order: number
    updated_by: number
    updated_at: number
    metadata: number
    _all: number
  }


  export type MSTApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MSTApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MSTApproverMinAggregateInputType = {
    id?: true
    mst_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MSTApproverMaxAggregateInputType = {
    id?: true
    mst_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
  }

  export type MSTApproverCountAggregateInputType = {
    id?: true
    mst_id?: true
    approver_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    label_id?: true
    order?: true
    updated_by?: true
    updated_at?: true
    metadata?: true
    _all?: true
  }

  export type MSTApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MSTApprover to aggregate.
     */
    where?: MSTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTApprovers to fetch.
     */
    orderBy?: MSTApproverOrderByWithRelationInput | MSTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MSTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MSTApprovers
    **/
    _count?: true | MSTApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MSTApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MSTApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MSTApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MSTApproverMaxAggregateInputType
  }

  export type GetMSTApproverAggregateType<T extends MSTApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMSTApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMSTApprover[P]>
      : GetScalarType<T[P], AggregateMSTApprover[P]>
  }




  export type MSTApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTApproverWhereInput
    orderBy?: MSTApproverOrderByWithAggregationInput | MSTApproverOrderByWithAggregationInput[]
    by: MSTApproverScalarFieldEnum[] | MSTApproverScalarFieldEnum
    having?: MSTApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MSTApproverCountAggregateInputType | true
    _avg?: MSTApproverAvgAggregateInputType
    _sum?: MSTApproverSumAggregateInputType
    _min?: MSTApproverMinAggregateInputType
    _max?: MSTApproverMaxAggregateInputType
  }

  export type MSTApproverGroupByOutputType = {
    id: string
    mst_id: string
    approver_id: string
    date_approval: Date | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by: string | null
    updated_at: Date
    metadata: JsonValue | null
    _count: MSTApproverCountAggregateOutputType | null
    _avg: MSTApproverAvgAggregateOutputType | null
    _sum: MSTApproverSumAggregateOutputType | null
    _min: MSTApproverMinAggregateOutputType | null
    _max: MSTApproverMaxAggregateOutputType | null
  }

  type GetMSTApproverGroupByPayload<T extends MSTApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MSTApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MSTApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MSTApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MSTApproverGroupByOutputType[P]>
        }
      >
    >


  export type MSTApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mst_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
    mst?: boolean | MSTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mSTApprover"]>

  export type MSTApproverSelectScalar = {
    id?: boolean
    mst_id?: boolean
    approver_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    label_id?: boolean
    order?: boolean
    updated_by?: boolean
    updated_at?: boolean
    metadata?: boolean
  }

  export type MSTApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mst?: boolean | MSTDefaultArgs<ExtArgs>
  }


  export type $MSTApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MSTApprover"
    objects: {
      mst: Prisma.$MSTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mst_id: string
      approver_id: string
      date_approval: Date | null
      notes: string
      status: number
      label: string
      label_id: string
      order: number
      updated_by: string | null
      updated_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mSTApprover"]>
    composites: {}
  }


  type MSTApproverGetPayload<S extends boolean | null | undefined | MSTApproverDefaultArgs> = $Result.GetResult<Prisma.$MSTApproverPayload, S>

  type MSTApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MSTApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MSTApproverCountAggregateInputType | true
    }

  export interface MSTApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MSTApprover'], meta: { name: 'MSTApprover' } }
    /**
     * Find zero or one MSTApprover that matches the filter.
     * @param {MSTApproverFindUniqueArgs} args - Arguments to find a MSTApprover
     * @example
     * // Get one MSTApprover
     * const mSTApprover = await prisma.mSTApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MSTApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MSTApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MSTApproverFindUniqueOrThrowArgs} args - Arguments to find a MSTApprover
     * @example
     * // Get one MSTApprover
     * const mSTApprover = await prisma.mSTApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MSTApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MSTApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverFindFirstArgs} args - Arguments to find a MSTApprover
     * @example
     * // Get one MSTApprover
     * const mSTApprover = await prisma.mSTApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MSTApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MSTApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverFindFirstOrThrowArgs} args - Arguments to find a MSTApprover
     * @example
     * // Get one MSTApprover
     * const mSTApprover = await prisma.mSTApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MSTApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MSTApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MSTApprovers
     * const mSTApprovers = await prisma.mSTApprover.findMany()
     * 
     * // Get first 10 MSTApprovers
     * const mSTApprovers = await prisma.mSTApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mSTApproverWithIdOnly = await prisma.mSTApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MSTApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MSTApprover.
     * @param {MSTApproverCreateArgs} args - Arguments to create a MSTApprover.
     * @example
     * // Create one MSTApprover
     * const MSTApprover = await prisma.mSTApprover.create({
     *   data: {
     *     // ... data to create a MSTApprover
     *   }
     * })
     * 
    **/
    create<T extends MSTApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverCreateArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MSTApprovers.
     *     @param {MSTApproverCreateManyArgs} args - Arguments to create many MSTApprovers.
     *     @example
     *     // Create many MSTApprovers
     *     const mSTApprover = await prisma.mSTApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MSTApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MSTApprover.
     * @param {MSTApproverDeleteArgs} args - Arguments to delete one MSTApprover.
     * @example
     * // Delete one MSTApprover
     * const MSTApprover = await prisma.mSTApprover.delete({
     *   where: {
     *     // ... filter to delete one MSTApprover
     *   }
     * })
     * 
    **/
    delete<T extends MSTApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverDeleteArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MSTApprover.
     * @param {MSTApproverUpdateArgs} args - Arguments to update one MSTApprover.
     * @example
     * // Update one MSTApprover
     * const mSTApprover = await prisma.mSTApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MSTApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverUpdateArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MSTApprovers.
     * @param {MSTApproverDeleteManyArgs} args - Arguments to filter MSTApprovers to delete.
     * @example
     * // Delete a few MSTApprovers
     * const { count } = await prisma.mSTApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MSTApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MSTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MSTApprovers
     * const mSTApprover = await prisma.mSTApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MSTApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MSTApprover.
     * @param {MSTApproverUpsertArgs} args - Arguments to update or create a MSTApprover.
     * @example
     * // Update or create a MSTApprover
     * const mSTApprover = await prisma.mSTApprover.upsert({
     *   create: {
     *     // ... data to create a MSTApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MSTApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MSTApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MSTApproverUpsertArgs<ExtArgs>>
    ): Prisma__MSTApproverClient<$Result.GetResult<Prisma.$MSTApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MSTApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverCountArgs} args - Arguments to filter MSTApprovers to count.
     * @example
     * // Count the number of MSTApprovers
     * const count = await prisma.mSTApprover.count({
     *   where: {
     *     // ... the filter for the MSTApprovers we want to count
     *   }
     * })
    **/
    count<T extends MSTApproverCountArgs>(
      args?: Subset<T, MSTApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MSTApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MSTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MSTApproverAggregateArgs>(args: Subset<T, MSTApproverAggregateArgs>): Prisma.PrismaPromise<GetMSTApproverAggregateType<T>>

    /**
     * Group by MSTApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MSTApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MSTApproverGroupByArgs['orderBy'] }
        : { orderBy?: MSTApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MSTApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMSTApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MSTApprover model
   */
  readonly fields: MSTApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MSTApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MSTApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mst<T extends MSTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MSTDefaultArgs<ExtArgs>>): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MSTApprover model
   */ 
  interface MSTApproverFieldRefs {
    readonly id: FieldRef<"MSTApprover", 'String'>
    readonly mst_id: FieldRef<"MSTApprover", 'String'>
    readonly approver_id: FieldRef<"MSTApprover", 'String'>
    readonly date_approval: FieldRef<"MSTApprover", 'DateTime'>
    readonly notes: FieldRef<"MSTApprover", 'String'>
    readonly status: FieldRef<"MSTApprover", 'Int'>
    readonly label: FieldRef<"MSTApprover", 'String'>
    readonly label_id: FieldRef<"MSTApprover", 'String'>
    readonly order: FieldRef<"MSTApprover", 'Int'>
    readonly updated_by: FieldRef<"MSTApprover", 'String'>
    readonly updated_at: FieldRef<"MSTApprover", 'DateTime'>
    readonly metadata: FieldRef<"MSTApprover", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MSTApprover findUnique
   */
  export type MSTApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MSTApprover to fetch.
     */
    where: MSTApproverWhereUniqueInput
  }


  /**
   * MSTApprover findUniqueOrThrow
   */
  export type MSTApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MSTApprover to fetch.
     */
    where: MSTApproverWhereUniqueInput
  }


  /**
   * MSTApprover findFirst
   */
  export type MSTApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MSTApprover to fetch.
     */
    where?: MSTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTApprovers to fetch.
     */
    orderBy?: MSTApproverOrderByWithRelationInput | MSTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTApprovers.
     */
    cursor?: MSTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTApprovers.
     */
    distinct?: MSTApproverScalarFieldEnum | MSTApproverScalarFieldEnum[]
  }


  /**
   * MSTApprover findFirstOrThrow
   */
  export type MSTApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MSTApprover to fetch.
     */
    where?: MSTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTApprovers to fetch.
     */
    orderBy?: MSTApproverOrderByWithRelationInput | MSTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTApprovers.
     */
    cursor?: MSTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTApprovers.
     */
    distinct?: MSTApproverScalarFieldEnum | MSTApproverScalarFieldEnum[]
  }


  /**
   * MSTApprover findMany
   */
  export type MSTApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter, which MSTApprovers to fetch.
     */
    where?: MSTApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTApprovers to fetch.
     */
    orderBy?: MSTApproverOrderByWithRelationInput | MSTApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MSTApprovers.
     */
    cursor?: MSTApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTApprovers.
     */
    skip?: number
    distinct?: MSTApproverScalarFieldEnum | MSTApproverScalarFieldEnum[]
  }


  /**
   * MSTApprover create
   */
  export type MSTApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MSTApprover.
     */
    data: XOR<MSTApproverCreateInput, MSTApproverUncheckedCreateInput>
  }


  /**
   * MSTApprover createMany
   */
  export type MSTApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MSTApprovers.
     */
    data: MSTApproverCreateManyInput | MSTApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MSTApprover update
   */
  export type MSTApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MSTApprover.
     */
    data: XOR<MSTApproverUpdateInput, MSTApproverUncheckedUpdateInput>
    /**
     * Choose, which MSTApprover to update.
     */
    where: MSTApproverWhereUniqueInput
  }


  /**
   * MSTApprover updateMany
   */
  export type MSTApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MSTApprovers.
     */
    data: XOR<MSTApproverUpdateManyMutationInput, MSTApproverUncheckedUpdateManyInput>
    /**
     * Filter which MSTApprovers to update
     */
    where?: MSTApproverWhereInput
  }


  /**
   * MSTApprover upsert
   */
  export type MSTApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MSTApprover to update in case it exists.
     */
    where: MSTApproverWhereUniqueInput
    /**
     * In case the MSTApprover found by the `where` argument doesn't exist, create a new MSTApprover with this data.
     */
    create: XOR<MSTApproverCreateInput, MSTApproverUncheckedCreateInput>
    /**
     * In case the MSTApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MSTApproverUpdateInput, MSTApproverUncheckedUpdateInput>
  }


  /**
   * MSTApprover delete
   */
  export type MSTApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
    /**
     * Filter which MSTApprover to delete.
     */
    where: MSTApproverWhereUniqueInput
  }


  /**
   * MSTApprover deleteMany
   */
  export type MSTApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MSTApprovers to delete
     */
    where?: MSTApproverWhereInput
  }


  /**
   * MSTApprover without action
   */
  export type MSTApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTApprover
     */
    select?: MSTApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTApproverInclude<ExtArgs> | null
  }



  /**
   * Model MSTItem
   */

  export type AggregateMSTItem = {
    _count: MSTItemCountAggregateOutputType | null
    _avg: MSTItemAvgAggregateOutputType | null
    _sum: MSTItemSumAggregateOutputType | null
    _min: MSTItemMinAggregateOutputType | null
    _max: MSTItemMaxAggregateOutputType | null
  }

  export type MSTItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    status: number | null
  }

  export type MSTItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    status: number | null
  }

  export type MSTItemMinAggregateOutputType = {
    id: string | null
    mst_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    status: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MSTItemMaxAggregateOutputType = {
    id: string | null
    mst_id: string | null
    item_id: string | null
    quantity: number | null
    price: number | null
    status: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type MSTItemCountAggregateOutputType = {
    id: number
    mst_id: number
    item_id: number
    quantity: number
    price: number
    status: number
    created_by: number
    created_at: number
    metadata: number
    _all: number
  }


  export type MSTItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    status?: true
  }

  export type MSTItemSumAggregateInputType = {
    quantity?: true
    price?: true
    status?: true
  }

  export type MSTItemMinAggregateInputType = {
    id?: true
    mst_id?: true
    item_id?: true
    quantity?: true
    price?: true
    status?: true
    created_by?: true
    created_at?: true
  }

  export type MSTItemMaxAggregateInputType = {
    id?: true
    mst_id?: true
    item_id?: true
    quantity?: true
    price?: true
    status?: true
    created_by?: true
    created_at?: true
  }

  export type MSTItemCountAggregateInputType = {
    id?: true
    mst_id?: true
    item_id?: true
    quantity?: true
    price?: true
    status?: true
    created_by?: true
    created_at?: true
    metadata?: true
    _all?: true
  }

  export type MSTItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MSTItem to aggregate.
     */
    where?: MSTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTItems to fetch.
     */
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MSTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MSTItems
    **/
    _count?: true | MSTItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MSTItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MSTItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MSTItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MSTItemMaxAggregateInputType
  }

  export type GetMSTItemAggregateType<T extends MSTItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMSTItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMSTItem[P]>
      : GetScalarType<T[P], AggregateMSTItem[P]>
  }




  export type MSTItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MSTItemWhereInput
    orderBy?: MSTItemOrderByWithAggregationInput | MSTItemOrderByWithAggregationInput[]
    by: MSTItemScalarFieldEnum[] | MSTItemScalarFieldEnum
    having?: MSTItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MSTItemCountAggregateInputType | true
    _avg?: MSTItemAvgAggregateInputType
    _sum?: MSTItemSumAggregateInputType
    _min?: MSTItemMinAggregateInputType
    _max?: MSTItemMaxAggregateInputType
  }

  export type MSTItemGroupByOutputType = {
    id: string
    mst_id: string
    item_id: string
    quantity: number
    price: number
    status: number
    created_by: string
    created_at: Date
    metadata: JsonValue | null
    _count: MSTItemCountAggregateOutputType | null
    _avg: MSTItemAvgAggregateOutputType | null
    _sum: MSTItemSumAggregateOutputType | null
    _min: MSTItemMinAggregateOutputType | null
    _max: MSTItemMaxAggregateOutputType | null
  }

  type GetMSTItemGroupByPayload<T extends MSTItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MSTItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MSTItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MSTItemGroupByOutputType[P]>
            : GetScalarType<T[P], MSTItemGroupByOutputType[P]>
        }
      >
    >


  export type MSTItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mst_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
    mst?: boolean | MSTDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mSTItem"]>

  export type MSTItemSelectScalar = {
    id?: boolean
    mst_id?: boolean
    item_id?: boolean
    quantity?: boolean
    price?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    metadata?: boolean
  }

  export type MSTItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mst?: boolean | MSTDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }


  export type $MSTItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MSTItem"
    objects: {
      mst: Prisma.$MSTPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mst_id: string
      item_id: string
      quantity: number
      price: number
      status: number
      created_by: string
      created_at: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["mSTItem"]>
    composites: {}
  }


  type MSTItemGetPayload<S extends boolean | null | undefined | MSTItemDefaultArgs> = $Result.GetResult<Prisma.$MSTItemPayload, S>

  type MSTItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MSTItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MSTItemCountAggregateInputType | true
    }

  export interface MSTItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MSTItem'], meta: { name: 'MSTItem' } }
    /**
     * Find zero or one MSTItem that matches the filter.
     * @param {MSTItemFindUniqueArgs} args - Arguments to find a MSTItem
     * @example
     * // Get one MSTItem
     * const mSTItem = await prisma.mSTItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MSTItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemFindUniqueArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MSTItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MSTItemFindUniqueOrThrowArgs} args - Arguments to find a MSTItem
     * @example
     * // Get one MSTItem
     * const mSTItem = await prisma.mSTItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MSTItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MSTItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemFindFirstArgs} args - Arguments to find a MSTItem
     * @example
     * // Get one MSTItem
     * const mSTItem = await prisma.mSTItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MSTItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemFindFirstArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MSTItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemFindFirstOrThrowArgs} args - Arguments to find a MSTItem
     * @example
     * // Get one MSTItem
     * const mSTItem = await prisma.mSTItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MSTItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MSTItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MSTItems
     * const mSTItems = await prisma.mSTItem.findMany()
     * 
     * // Get first 10 MSTItems
     * const mSTItems = await prisma.mSTItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mSTItemWithIdOnly = await prisma.mSTItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MSTItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MSTItem.
     * @param {MSTItemCreateArgs} args - Arguments to create a MSTItem.
     * @example
     * // Create one MSTItem
     * const MSTItem = await prisma.mSTItem.create({
     *   data: {
     *     // ... data to create a MSTItem
     *   }
     * })
     * 
    **/
    create<T extends MSTItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemCreateArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MSTItems.
     *     @param {MSTItemCreateManyArgs} args - Arguments to create many MSTItems.
     *     @example
     *     // Create many MSTItems
     *     const mSTItem = await prisma.mSTItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MSTItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MSTItem.
     * @param {MSTItemDeleteArgs} args - Arguments to delete one MSTItem.
     * @example
     * // Delete one MSTItem
     * const MSTItem = await prisma.mSTItem.delete({
     *   where: {
     *     // ... filter to delete one MSTItem
     *   }
     * })
     * 
    **/
    delete<T extends MSTItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemDeleteArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MSTItem.
     * @param {MSTItemUpdateArgs} args - Arguments to update one MSTItem.
     * @example
     * // Update one MSTItem
     * const mSTItem = await prisma.mSTItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MSTItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemUpdateArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MSTItems.
     * @param {MSTItemDeleteManyArgs} args - Arguments to filter MSTItems to delete.
     * @example
     * // Delete a few MSTItems
     * const { count } = await prisma.mSTItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MSTItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MSTItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MSTItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MSTItems
     * const mSTItem = await prisma.mSTItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MSTItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MSTItem.
     * @param {MSTItemUpsertArgs} args - Arguments to update or create a MSTItem.
     * @example
     * // Update or create a MSTItem
     * const mSTItem = await prisma.mSTItem.upsert({
     *   create: {
     *     // ... data to create a MSTItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MSTItem we want to update
     *   }
     * })
    **/
    upsert<T extends MSTItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MSTItemUpsertArgs<ExtArgs>>
    ): Prisma__MSTItemClient<$Result.GetResult<Prisma.$MSTItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MSTItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemCountArgs} args - Arguments to filter MSTItems to count.
     * @example
     * // Count the number of MSTItems
     * const count = await prisma.mSTItem.count({
     *   where: {
     *     // ... the filter for the MSTItems we want to count
     *   }
     * })
    **/
    count<T extends MSTItemCountArgs>(
      args?: Subset<T, MSTItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MSTItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MSTItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MSTItemAggregateArgs>(args: Subset<T, MSTItemAggregateArgs>): Prisma.PrismaPromise<GetMSTItemAggregateType<T>>

    /**
     * Group by MSTItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MSTItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MSTItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MSTItemGroupByArgs['orderBy'] }
        : { orderBy?: MSTItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MSTItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMSTItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MSTItem model
   */
  readonly fields: MSTItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MSTItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MSTItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mst<T extends MSTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MSTDefaultArgs<ExtArgs>>): Prisma__MSTClient<$Result.GetResult<Prisma.$MSTPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MSTItem model
   */ 
  interface MSTItemFieldRefs {
    readonly id: FieldRef<"MSTItem", 'String'>
    readonly mst_id: FieldRef<"MSTItem", 'String'>
    readonly item_id: FieldRef<"MSTItem", 'String'>
    readonly quantity: FieldRef<"MSTItem", 'Int'>
    readonly price: FieldRef<"MSTItem", 'Float'>
    readonly status: FieldRef<"MSTItem", 'Int'>
    readonly created_by: FieldRef<"MSTItem", 'String'>
    readonly created_at: FieldRef<"MSTItem", 'DateTime'>
    readonly metadata: FieldRef<"MSTItem", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * MSTItem findUnique
   */
  export type MSTItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter, which MSTItem to fetch.
     */
    where: MSTItemWhereUniqueInput
  }


  /**
   * MSTItem findUniqueOrThrow
   */
  export type MSTItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter, which MSTItem to fetch.
     */
    where: MSTItemWhereUniqueInput
  }


  /**
   * MSTItem findFirst
   */
  export type MSTItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter, which MSTItem to fetch.
     */
    where?: MSTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTItems to fetch.
     */
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTItems.
     */
    cursor?: MSTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTItems.
     */
    distinct?: MSTItemScalarFieldEnum | MSTItemScalarFieldEnum[]
  }


  /**
   * MSTItem findFirstOrThrow
   */
  export type MSTItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter, which MSTItem to fetch.
     */
    where?: MSTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTItems to fetch.
     */
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MSTItems.
     */
    cursor?: MSTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MSTItems.
     */
    distinct?: MSTItemScalarFieldEnum | MSTItemScalarFieldEnum[]
  }


  /**
   * MSTItem findMany
   */
  export type MSTItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter, which MSTItems to fetch.
     */
    where?: MSTItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MSTItems to fetch.
     */
    orderBy?: MSTItemOrderByWithRelationInput | MSTItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MSTItems.
     */
    cursor?: MSTItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MSTItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MSTItems.
     */
    skip?: number
    distinct?: MSTItemScalarFieldEnum | MSTItemScalarFieldEnum[]
  }


  /**
   * MSTItem create
   */
  export type MSTItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MSTItem.
     */
    data: XOR<MSTItemCreateInput, MSTItemUncheckedCreateInput>
  }


  /**
   * MSTItem createMany
   */
  export type MSTItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MSTItems.
     */
    data: MSTItemCreateManyInput | MSTItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MSTItem update
   */
  export type MSTItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MSTItem.
     */
    data: XOR<MSTItemUpdateInput, MSTItemUncheckedUpdateInput>
    /**
     * Choose, which MSTItem to update.
     */
    where: MSTItemWhereUniqueInput
  }


  /**
   * MSTItem updateMany
   */
  export type MSTItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MSTItems.
     */
    data: XOR<MSTItemUpdateManyMutationInput, MSTItemUncheckedUpdateManyInput>
    /**
     * Filter which MSTItems to update
     */
    where?: MSTItemWhereInput
  }


  /**
   * MSTItem upsert
   */
  export type MSTItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MSTItem to update in case it exists.
     */
    where: MSTItemWhereUniqueInput
    /**
     * In case the MSTItem found by the `where` argument doesn't exist, create a new MSTItem with this data.
     */
    create: XOR<MSTItemCreateInput, MSTItemUncheckedCreateInput>
    /**
     * In case the MSTItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MSTItemUpdateInput, MSTItemUncheckedUpdateInput>
  }


  /**
   * MSTItem delete
   */
  export type MSTItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
    /**
     * Filter which MSTItem to delete.
     */
    where: MSTItemWhereUniqueInput
  }


  /**
   * MSTItem deleteMany
   */
  export type MSTItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MSTItems to delete
     */
    where?: MSTItemWhereInput
  }


  /**
   * MSTItem without action
   */
  export type MSTItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MSTItem
     */
    select?: MSTItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MSTItemInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    tin: 'tin',
    address: 'address',
    vat_type: 'vat_type',
    is_vat_registered: 'is_vat_registered',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plate_number: 'plate_number',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const StationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type StationScalarFieldEnum = (typeof StationScalarFieldEnum)[keyof typeof StationScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const PendingScalarFieldEnum: {
    id: 'id',
    approver_id: 'approver_id',
    reference_number: 'reference_number',
    reference_table: 'reference_table',
    description: 'description',
    transaction_date: 'transaction_date'
  };

  export type PendingScalarFieldEnum = (typeof PendingScalarFieldEnum)[keyof typeof PendingScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    item_type_id: 'item_type_id',
    unit_id: 'unit_id',
    code: 'code',
    description: 'description',
    total_quantity: 'total_quantity',
    quantity_on_queue: 'quantity_on_queue',
    initial_quantity: 'initial_quantity',
    alert_level: 'alert_level',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemLocationScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    station_id: 'station_id',
    quantity_on_hand: 'quantity_on_hand',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type ItemLocationScalarFieldEnum = (typeof ItemLocationScalarFieldEnum)[keyof typeof ItemLocationScalarFieldEnum]


  export const ItemMovementScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    destination_id: 'destination_id',
    quantity_moved: 'quantity_moved',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type ItemMovementScalarFieldEnum = (typeof ItemMovementScalarFieldEnum)[keyof typeof ItemMovementScalarFieldEnum]


  export const ItemTransactionScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    rr_item_id: 'rr_item_id',
    osriv_item_id: 'osriv_item_id',
    seriv_item_id: 'seriv_item_id',
    mrv_item_id: 'mrv_item_id',
    mcrt_item_id: 'mcrt_item_id',
    type: 'type',
    quantity: 'quantity',
    price: 'price',
    remarks: 'remarks',
    is_initial: 'is_initial',
    created_at: 'created_at',
    created_by: 'created_by',
    metadata: 'metadata'
  };

  export type ItemTransactionScalarFieldEnum = (typeof ItemTransactionScalarFieldEnum)[keyof typeof ItemTransactionScalarFieldEnum]


  export const ItemCodeTrackerScalarFieldEnum: {
    id: 'id',
    item_code: 'item_code',
    year: 'year',
    last_incremental: 'last_incremental'
  };

  export type ItemCodeTrackerScalarFieldEnum = (typeof ItemCodeTrackerScalarFieldEnum)[keyof typeof ItemCodeTrackerScalarFieldEnum]


  export const CanvassScalarFieldEnum: {
    id: 'id',
    rc_number: 'rc_number',
    date_requested: 'date_requested',
    purpose: 'purpose',
    notes: 'notes',
    requested_by_id: 'requested_by_id',
    created_by: 'created_by',
    updated_by: 'updated_by',
    deleted_by: 'deleted_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    metadata: 'metadata'
  };

  export type CanvassScalarFieldEnum = (typeof CanvassScalarFieldEnum)[keyof typeof CanvassScalarFieldEnum]


  export const CanvassItemScalarFieldEnum: {
    id: 'id',
    canvass_id: 'canvass_id',
    unit_id: 'unit_id',
    item_id: 'item_id',
    description: 'description',
    quantity: 'quantity',
    metadata: 'metadata'
  };

  export type CanvassItemScalarFieldEnum = (typeof CanvassItemScalarFieldEnum)[keyof typeof CanvassItemScalarFieldEnum]


  export const RVScalarFieldEnum: {
    id: 'id',
    rv_number: 'rv_number',
    canvass_id: 'canvass_id',
    classification_id: 'classification_id',
    supervisor_id: 'supervisor_id',
    date_requested: 'date_requested',
    work_order_no: 'work_order_no',
    work_order_date: 'work_order_date',
    notes: 'notes',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type RVScalarFieldEnum = (typeof RVScalarFieldEnum)[keyof typeof RVScalarFieldEnum]


  export const RVApproverScalarFieldEnum: {
    id: 'id',
    rv_id: 'rv_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    is_supervisor: 'is_supervisor',
    metadata: 'metadata'
  };

  export type RVApproverScalarFieldEnum = (typeof RVApproverScalarFieldEnum)[keyof typeof RVApproverScalarFieldEnum]


  export const JOScalarFieldEnum: {
    id: 'id',
    jo_number: 'jo_number',
    date_requested: 'date_requested',
    canvass_id: 'canvass_id',
    equipment: 'equipment',
    classification_id: 'classification_id',
    department_id: 'department_id',
    supervisor_id: 'supervisor_id',
    notes: 'notes',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type JOScalarFieldEnum = (typeof JOScalarFieldEnum)[keyof typeof JOScalarFieldEnum]


  export const JOApproverScalarFieldEnum: {
    id: 'id',
    jo_id: 'jo_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    is_supervisor: 'is_supervisor',
    metadata: 'metadata'
  };

  export type JOApproverScalarFieldEnum = (typeof JOApproverScalarFieldEnum)[keyof typeof JOApproverScalarFieldEnum]


  export const SPRScalarFieldEnum: {
    id: 'id',
    spr_number: 'spr_number',
    date_requested: 'date_requested',
    canvass_id: 'canvass_id',
    vehicle_id: 'vehicle_id',
    classification_id: 'classification_id',
    supervisor_id: 'supervisor_id',
    notes: 'notes',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type SPRScalarFieldEnum = (typeof SPRScalarFieldEnum)[keyof typeof SPRScalarFieldEnum]


  export const SPRApproverScalarFieldEnum: {
    id: 'id',
    spr_id: 'spr_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    is_supervisor: 'is_supervisor',
    metadata: 'metadata'
  };

  export type SPRApproverScalarFieldEnum = (typeof SPRApproverScalarFieldEnum)[keyof typeof SPRApproverScalarFieldEnum]


  export const MEQSScalarFieldEnum: {
    id: 'id',
    jo_id: 'jo_id',
    jo_number: 'jo_number',
    rv_id: 'rv_id',
    rv_number: 'rv_number',
    spr_id: 'spr_id',
    spr_number: 'spr_number',
    meqs_number: 'meqs_number',
    meqs_date: 'meqs_date',
    notes: 'notes',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_by: 'cancelled_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    cancelled_at: 'cancelled_at',
    metadata: 'metadata'
  };

  export type MEQSScalarFieldEnum = (typeof MEQSScalarFieldEnum)[keyof typeof MEQSScalarFieldEnum]


  export const MEQSSupplierScalarFieldEnum: {
    id: 'id',
    meqs_id: 'meqs_id',
    supplier_id: 'supplier_id',
    payment_terms: 'payment_terms',
    metadata: 'metadata'
  };

  export type MEQSSupplierScalarFieldEnum = (typeof MEQSSupplierScalarFieldEnum)[keyof typeof MEQSSupplierScalarFieldEnum]


  export const MEQSSupplierItemScalarFieldEnum: {
    id: 'id',
    meqs_supplier_id: 'meqs_supplier_id',
    canvass_item_id: 'canvass_item_id',
    price: 'price',
    notes: 'notes',
    is_awarded: 'is_awarded',
    vat_type: 'vat_type',
    metadata: 'metadata'
  };

  export type MEQSSupplierItemScalarFieldEnum = (typeof MEQSSupplierItemScalarFieldEnum)[keyof typeof MEQSSupplierItemScalarFieldEnum]


  export const MEQSSupplierAttachmentScalarFieldEnum: {
    id: 'id',
    meqs_supplier_id: 'meqs_supplier_id',
    filename: 'filename',
    src: 'src',
    metadata: 'metadata'
  };

  export type MEQSSupplierAttachmentScalarFieldEnum = (typeof MEQSSupplierAttachmentScalarFieldEnum)[keyof typeof MEQSSupplierAttachmentScalarFieldEnum]


  export const MEQSApproverScalarFieldEnum: {
    id: 'id',
    meqs_id: 'meqs_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    metadata: 'metadata'
  };

  export type MEQSApproverScalarFieldEnum = (typeof MEQSApproverScalarFieldEnum)[keyof typeof MEQSApproverScalarFieldEnum]


  export const POScalarFieldEnum: {
    id: 'id',
    meqs_supplier_id: 'meqs_supplier_id',
    meqs_number: 'meqs_number',
    po_number: 'po_number',
    fund_source_id: 'fund_source_id',
    po_date: 'po_date',
    notes: 'notes',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type POScalarFieldEnum = (typeof POScalarFieldEnum)[keyof typeof POScalarFieldEnum]


  export const POApproverScalarFieldEnum: {
    id: 'id',
    po_id: 'po_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    metadata: 'metadata'
  };

  export type POApproverScalarFieldEnum = (typeof POApproverScalarFieldEnum)[keyof typeof POApproverScalarFieldEnum]


  export const RRScalarFieldEnum: {
    id: 'id',
    po_id: 'po_id',
    po_number: 'po_number',
    rr_number: 'rr_number',
    rr_date: 'rr_date',
    received_by_id: 'received_by_id',
    invoice_number: 'invoice_number',
    delivery_number: 'delivery_number',
    notes: 'notes',
    delivery_charge: 'delivery_charge',
    is_completed: 'is_completed',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type RRScalarFieldEnum = (typeof RRScalarFieldEnum)[keyof typeof RRScalarFieldEnum]


  export const RRApproverScalarFieldEnum: {
    id: 'id',
    rr_id: 'rr_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    metadata: 'metadata'
  };

  export type RRApproverScalarFieldEnum = (typeof RRApproverScalarFieldEnum)[keyof typeof RRApproverScalarFieldEnum]


  export const RRItemScalarFieldEnum: {
    id: 'id',
    rr_id: 'rr_id',
    meqs_supplier_item_id: 'meqs_supplier_item_id',
    quantity_accepted: 'quantity_accepted',
    metadata: 'metadata'
  };

  export type RRItemScalarFieldEnum = (typeof RRItemScalarFieldEnum)[keyof typeof RRItemScalarFieldEnum]


  export const OSRIVScalarFieldEnum: {
    id: 'id',
    osriv_number: 'osriv_number',
    date_requested: 'date_requested',
    exp_date: 'exp_date',
    purpose: 'purpose',
    note: 'note',
    is_completed: 'is_completed',
    requested_by_id: 'requested_by_id',
    item_from_id: 'item_from_id',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type OSRIVScalarFieldEnum = (typeof OSRIVScalarFieldEnum)[keyof typeof OSRIVScalarFieldEnum]


  export const OSRIVApproverScalarFieldEnum: {
    id: 'id',
    osriv_id: 'osriv_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type OSRIVApproverScalarFieldEnum = (typeof OSRIVApproverScalarFieldEnum)[keyof typeof OSRIVApproverScalarFieldEnum]


  export const OSRIVItemScalarFieldEnum: {
    id: 'id',
    osriv_id: 'osriv_id',
    item_id: 'item_id',
    quantity: 'quantity',
    price: 'price',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type OSRIVItemScalarFieldEnum = (typeof OSRIVItemScalarFieldEnum)[keyof typeof OSRIVItemScalarFieldEnum]


  export const SERIVScalarFieldEnum: {
    id: 'id',
    seriv_number: 'seriv_number',
    date_requested: 'date_requested',
    exp_date: 'exp_date',
    purpose: 'purpose',
    note: 'note',
    is_completed: 'is_completed',
    request_type: 'request_type',
    or_number: 'or_number',
    mwo_number: 'mwo_number',
    cwo_number: 'cwo_number',
    jo_number: 'jo_number',
    consumer_name: 'consumer_name',
    location: 'location',
    requested_by_id: 'requested_by_id',
    withdrawn_by_id: 'withdrawn_by_id',
    item_from_id: 'item_from_id',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type SERIVScalarFieldEnum = (typeof SERIVScalarFieldEnum)[keyof typeof SERIVScalarFieldEnum]


  export const SERIVApproverScalarFieldEnum: {
    id: 'id',
    seriv_id: 'seriv_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type SERIVApproverScalarFieldEnum = (typeof SERIVApproverScalarFieldEnum)[keyof typeof SERIVApproverScalarFieldEnum]


  export const SERIVItemScalarFieldEnum: {
    id: 'id',
    seriv_id: 'seriv_id',
    item_id: 'item_id',
    quantity: 'quantity',
    price: 'price',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type SERIVItemScalarFieldEnum = (typeof SERIVItemScalarFieldEnum)[keyof typeof SERIVItemScalarFieldEnum]


  export const MRVScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    mrv_number: 'mrv_number',
    date_requested: 'date_requested',
    exp_date: 'exp_date',
    purpose: 'purpose',
    note: 'note',
    is_completed: 'is_completed',
    request_type: 'request_type',
    or_number: 'or_number',
    mwo_number: 'mwo_number',
    cwo_number: 'cwo_number',
    jo_number: 'jo_number',
    consumer_name: 'consumer_name',
    location: 'location',
    requested_by_id: 'requested_by_id',
    withdrawn_by_id: 'withdrawn_by_id',
    item_from_id: 'item_from_id',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MRVScalarFieldEnum = (typeof MRVScalarFieldEnum)[keyof typeof MRVScalarFieldEnum]


  export const MRVApproverScalarFieldEnum: {
    id: 'id',
    mrv_id: 'mrv_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MRVApproverScalarFieldEnum = (typeof MRVApproverScalarFieldEnum)[keyof typeof MRVApproverScalarFieldEnum]


  export const MRVItemScalarFieldEnum: {
    id: 'id',
    mrv_id: 'mrv_id',
    item_id: 'item_id',
    quantity: 'quantity',
    price: 'price',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type MRVItemScalarFieldEnum = (typeof MRVItemScalarFieldEnum)[keyof typeof MRVItemScalarFieldEnum]


  export const MCTScalarFieldEnum: {
    id: 'id',
    mrv_id: 'mrv_id',
    mrv_number: 'mrv_number',
    mct_number: 'mct_number',
    mct_date: 'mct_date',
    is_completed: 'is_completed',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MCTScalarFieldEnum = (typeof MCTScalarFieldEnum)[keyof typeof MCTScalarFieldEnum]


  export const MCTApproverScalarFieldEnum: {
    id: 'id',
    mct_id: 'mct_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MCTApproverScalarFieldEnum = (typeof MCTApproverScalarFieldEnum)[keyof typeof MCTApproverScalarFieldEnum]


  export const MCRTScalarFieldEnum: {
    id: 'id',
    mct_id: 'mct_id',
    mct_number: 'mct_number',
    seriv_id: 'seriv_id',
    seriv_number: 'seriv_number',
    mcrt_number: 'mcrt_number',
    mcrt_date: 'mcrt_date',
    is_completed: 'is_completed',
    returned_by_id: 'returned_by_id',
    wo_number: 'wo_number',
    mo_number: 'mo_number',
    jo_number: 'jo_number',
    note: 'note',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MCRTScalarFieldEnum = (typeof MCRTScalarFieldEnum)[keyof typeof MCRTScalarFieldEnum]


  export const MCRTApproverScalarFieldEnum: {
    id: 'id',
    mcrt_id: 'mcrt_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MCRTApproverScalarFieldEnum = (typeof MCRTApproverScalarFieldEnum)[keyof typeof MCRTApproverScalarFieldEnum]


  export const MCRTItemScalarFieldEnum: {
    id: 'id',
    mcrt_id: 'mcrt_id',
    item_id: 'item_id',
    quantity: 'quantity',
    price: 'price',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type MCRTItemScalarFieldEnum = (typeof MCRTItemScalarFieldEnum)[keyof typeof MCRTItemScalarFieldEnum]


  export const MSTScalarFieldEnum: {
    id: 'id',
    mst_number: 'mst_number',
    mst_date: 'mst_date',
    returned_by_id: 'returned_by_id',
    cwo_number: 'cwo_number',
    mwo_number: 'mwo_number',
    jo_number: 'jo_number',
    remarks: 'remarks',
    cancelled_by: 'cancelled_by',
    created_by: 'created_by',
    updated_by: 'updated_by',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MSTScalarFieldEnum = (typeof MSTScalarFieldEnum)[keyof typeof MSTScalarFieldEnum]


  export const MSTApproverScalarFieldEnum: {
    id: 'id',
    mst_id: 'mst_id',
    approver_id: 'approver_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    label_id: 'label_id',
    order: 'order',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    metadata: 'metadata'
  };

  export type MSTApproverScalarFieldEnum = (typeof MSTApproverScalarFieldEnum)[keyof typeof MSTApproverScalarFieldEnum]


  export const MSTItemScalarFieldEnum: {
    id: 'id',
    mst_id: 'mst_id',
    item_id: 'item_id',
    quantity: 'quantity',
    price: 'price',
    status: 'status',
    created_by: 'created_by',
    created_at: 'created_at',
    metadata: 'metadata'
  };

  export type MSTItemScalarFieldEnum = (typeof MSTItemScalarFieldEnum)[keyof typeof MSTItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: IntFilter<"ItemType"> | number
    code?: StringFilter<"ItemType"> | string
    name?: StringFilter<"ItemType"> | string
    items?: ItemListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    name?: StringFilter<"ItemType"> | string
    items?: ItemListRelationFilter
  }, "id" | "code">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _avg?: ItemTypeAvgOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
    _sum?: ItemTypeSumOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemType"> | number
    code?: StringWithAggregatesFilter<"ItemType"> | string
    name?: StringWithAggregatesFilter<"ItemType"> | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringFilter<"Supplier"> | string
    tin?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    vat_type?: IntFilter<"Supplier"> | number
    is_vat_registered?: BoolFilter<"Supplier"> | boolean
    created_by?: StringFilter<"Supplier"> | string
    updated_by?: StringNullableFilter<"Supplier"> | string | null
    deleted_by?: StringNullableFilter<"Supplier"> | string | null
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    metadata?: JsonNullableFilter<"Supplier">
    MEQSSupplier?: MEQSSupplierListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    tin?: SortOrder
    address?: SortOrder
    vat_type?: SortOrder
    is_vat_registered?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    MEQSSupplier?: MEQSSupplierOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contact?: StringFilter<"Supplier"> | string
    tin?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    vat_type?: IntFilter<"Supplier"> | number
    is_vat_registered?: BoolFilter<"Supplier"> | boolean
    created_by?: StringFilter<"Supplier"> | string
    updated_by?: StringNullableFilter<"Supplier"> | string | null
    deleted_by?: StringNullableFilter<"Supplier"> | string | null
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    metadata?: JsonNullableFilter<"Supplier">
    MEQSSupplier?: MEQSSupplierListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    tin?: SortOrder
    address?: SortOrder
    vat_type?: SortOrder
    is_vat_registered?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact?: StringWithAggregatesFilter<"Supplier"> | string
    tin?: StringWithAggregatesFilter<"Supplier"> | string
    address?: StringWithAggregatesFilter<"Supplier"> | string
    vat_type?: IntWithAggregatesFilter<"Supplier"> | number
    is_vat_registered?: BoolWithAggregatesFilter<"Supplier"> | boolean
    created_by?: StringWithAggregatesFilter<"Supplier"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Supplier">
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    created_by?: StringFilter<"Unit"> | string
    updated_by?: StringNullableFilter<"Unit"> | string | null
    deleted_by?: StringNullableFilter<"Unit"> | string | null
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Unit"> | Date | string | null
    metadata?: JsonNullableFilter<"Unit">
    canvass_items?: CanvassItemListRelationFilter
    items?: ItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    created_by?: StringFilter<"Unit"> | string
    updated_by?: StringNullableFilter<"Unit"> | string | null
    deleted_by?: StringNullableFilter<"Unit"> | string | null
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Unit"> | Date | string | null
    metadata?: JsonNullableFilter<"Unit">
    canvass_items?: CanvassItemListRelationFilter
    items?: ItemListRelationFilter
  }, "id" | "name">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    created_by?: StringWithAggregatesFilter<"Unit"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Unit">
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    name?: StringFilter<"Vehicle"> | string
    plate_number?: StringFilter<"Vehicle"> | string
    created_by?: StringFilter<"Vehicle"> | string
    updated_by?: StringNullableFilter<"Vehicle"> | string | null
    deleted_by?: StringNullableFilter<"Vehicle"> | string | null
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    metadata?: JsonNullableFilter<"Vehicle">
    sprs?: SPRListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sprs?: SPROrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    name?: StringFilter<"Vehicle"> | string
    plate_number?: StringFilter<"Vehicle"> | string
    created_by?: StringFilter<"Vehicle"> | string
    updated_by?: StringNullableFilter<"Vehicle"> | string | null
    deleted_by?: StringNullableFilter<"Vehicle"> | string | null
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    metadata?: JsonNullableFilter<"Vehicle">
    sprs?: SPRListRelationFilter
  }, "id">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    name?: StringWithAggregatesFilter<"Vehicle"> | string
    plate_number?: StringWithAggregatesFilter<"Vehicle"> | string
    created_by?: StringWithAggregatesFilter<"Vehicle"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Vehicle">
  }

  export type StationWhereInput = {
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    id?: StringFilter<"Station"> | string
    name?: StringFilter<"Station"> | string
    location?: StringFilter<"Station"> | string
    created_by?: StringFilter<"Station"> | string
    updated_by?: StringNullableFilter<"Station"> | string | null
    deleted_by?: StringNullableFilter<"Station"> | string | null
    created_at?: DateTimeFilter<"Station"> | Date | string
    updated_at?: DateTimeFilter<"Station"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Station"> | Date | string | null
    metadata?: JsonNullableFilter<"Station">
    items?: ItemLocationListRelationFilter
    osrivs?: OSRIVListRelationFilter
    mrvs?: MRVListRelationFilter
    serivs?: SERIVListRelationFilter
  }

  export type StationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    items?: ItemLocationOrderByRelationAggregateInput
    osrivs?: OSRIVOrderByRelationAggregateInput
    mrvs?: MRVOrderByRelationAggregateInput
    serivs?: SERIVOrderByRelationAggregateInput
  }

  export type StationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    name?: StringFilter<"Station"> | string
    location?: StringFilter<"Station"> | string
    created_by?: StringFilter<"Station"> | string
    updated_by?: StringNullableFilter<"Station"> | string | null
    deleted_by?: StringNullableFilter<"Station"> | string | null
    created_at?: DateTimeFilter<"Station"> | Date | string
    updated_at?: DateTimeFilter<"Station"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Station"> | Date | string | null
    metadata?: JsonNullableFilter<"Station">
    items?: ItemLocationListRelationFilter
    osrivs?: OSRIVListRelationFilter
    mrvs?: MRVListRelationFilter
    serivs?: SERIVListRelationFilter
  }, "id">

  export type StationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: StationCountOrderByAggregateInput
    _max?: StationMaxOrderByAggregateInput
    _min?: StationMinOrderByAggregateInput
  }

  export type StationScalarWhereWithAggregatesInput = {
    AND?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    OR?: StationScalarWhereWithAggregatesInput[]
    NOT?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Station"> | string
    name?: StringWithAggregatesFilter<"Station"> | string
    location?: StringWithAggregatesFilter<"Station"> | string
    created_by?: StringWithAggregatesFilter<"Station"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Station"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Station"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Station"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Station"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Station"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Station">
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    created_by?: StringFilter<"Project"> | string
    updated_by?: StringNullableFilter<"Project"> | string | null
    deleted_by?: StringNullableFilter<"Project"> | string | null
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Project"> | Date | string | null
    metadata?: JsonNullableFilter<"Project">
    mrv?: MRVListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    mrv?: MRVOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    created_by?: StringFilter<"Project"> | string
    updated_by?: StringNullableFilter<"Project"> | string | null
    deleted_by?: StringNullableFilter<"Project"> | string | null
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Project"> | Date | string | null
    metadata?: JsonNullableFilter<"Project">
    mrv?: MRVListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    created_by?: StringWithAggregatesFilter<"Project"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Project"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Project"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Project">
  }

  export type PendingWhereInput = {
    AND?: PendingWhereInput | PendingWhereInput[]
    OR?: PendingWhereInput[]
    NOT?: PendingWhereInput | PendingWhereInput[]
    id?: IntFilter<"Pending"> | number
    approver_id?: StringFilter<"Pending"> | string
    reference_number?: StringFilter<"Pending"> | string
    reference_table?: StringFilter<"Pending"> | string
    description?: StringFilter<"Pending"> | string
    transaction_date?: DateTimeFilter<"Pending"> | Date | string
  }

  export type PendingOrderByWithRelationInput = {
    id?: SortOrder
    approver_id?: SortOrder
    reference_number?: SortOrder
    reference_table?: SortOrder
    description?: SortOrder
    transaction_date?: SortOrder
  }

  export type PendingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    approver_id_reference_number_reference_table?: PendingApprover_idReference_numberReference_tableCompoundUniqueInput
    AND?: PendingWhereInput | PendingWhereInput[]
    OR?: PendingWhereInput[]
    NOT?: PendingWhereInput | PendingWhereInput[]
    approver_id?: StringFilter<"Pending"> | string
    reference_number?: StringFilter<"Pending"> | string
    reference_table?: StringFilter<"Pending"> | string
    description?: StringFilter<"Pending"> | string
    transaction_date?: DateTimeFilter<"Pending"> | Date | string
  }, "id" | "approver_id_reference_number_reference_table">

  export type PendingOrderByWithAggregationInput = {
    id?: SortOrder
    approver_id?: SortOrder
    reference_number?: SortOrder
    reference_table?: SortOrder
    description?: SortOrder
    transaction_date?: SortOrder
    _count?: PendingCountOrderByAggregateInput
    _avg?: PendingAvgOrderByAggregateInput
    _max?: PendingMaxOrderByAggregateInput
    _min?: PendingMinOrderByAggregateInput
    _sum?: PendingSumOrderByAggregateInput
  }

  export type PendingScalarWhereWithAggregatesInput = {
    AND?: PendingScalarWhereWithAggregatesInput | PendingScalarWhereWithAggregatesInput[]
    OR?: PendingScalarWhereWithAggregatesInput[]
    NOT?: PendingScalarWhereWithAggregatesInput | PendingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pending"> | number
    approver_id?: StringWithAggregatesFilter<"Pending"> | string
    reference_number?: StringWithAggregatesFilter<"Pending"> | string
    reference_table?: StringWithAggregatesFilter<"Pending"> | string
    description?: StringWithAggregatesFilter<"Pending"> | string
    transaction_date?: DateTimeWithAggregatesFilter<"Pending"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: IntFilter<"Setting"> | number
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _avg?: SettingAvgOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
    _sum?: SettingSumOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Setting"> | number
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    item_type_id?: IntFilter<"Item"> | number
    unit_id?: StringFilter<"Item"> | string
    code?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    total_quantity?: IntFilter<"Item"> | number
    quantity_on_queue?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    alert_level?: IntFilter<"Item"> | number
    created_by?: StringFilter<"Item"> | string
    updated_by?: StringNullableFilter<"Item"> | string | null
    deleted_by?: StringNullableFilter<"Item"> | string | null
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    metadata?: JsonNullableFilter<"Item">
    item_type?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    item_transactions?: ItemTransactionListRelationFilter
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    canvass_items?: CanvassItemListRelationFilter
    item_locations?: ItemLocationListRelationFilter
    osriv_items?: OSRIVItemListRelationFilter
    seriv_items?: SERIVItemListRelationFilter
    mrv_items?: MRVItemListRelationFilter
    mcrt_items?: MCRTItemListRelationFilter
    mst_items?: MSTItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    item_type?: ItemTypeOrderByWithRelationInput
    item_transactions?: ItemTransactionOrderByRelationAggregateInput
    unit?: UnitOrderByWithRelationInput
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    item_locations?: ItemLocationOrderByRelationAggregateInput
    osriv_items?: OSRIVItemOrderByRelationAggregateInput
    seriv_items?: SERIVItemOrderByRelationAggregateInput
    mrv_items?: MRVItemOrderByRelationAggregateInput
    mcrt_items?: MCRTItemOrderByRelationAggregateInput
    mst_items?: MSTItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    item_type_id?: IntFilter<"Item"> | number
    unit_id?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    total_quantity?: IntFilter<"Item"> | number
    quantity_on_queue?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    alert_level?: IntFilter<"Item"> | number
    created_by?: StringFilter<"Item"> | string
    updated_by?: StringNullableFilter<"Item"> | string | null
    deleted_by?: StringNullableFilter<"Item"> | string | null
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    metadata?: JsonNullableFilter<"Item">
    item_type?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    item_transactions?: ItemTransactionListRelationFilter
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    canvass_items?: CanvassItemListRelationFilter
    item_locations?: ItemLocationListRelationFilter
    osriv_items?: OSRIVItemListRelationFilter
    seriv_items?: SERIVItemListRelationFilter
    mrv_items?: MRVItemListRelationFilter
    mcrt_items?: MCRTItemListRelationFilter
    mst_items?: MSTItemListRelationFilter
  }, "id" | "code">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    item_type_id?: IntWithAggregatesFilter<"Item"> | number
    unit_id?: StringWithAggregatesFilter<"Item"> | string
    code?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    total_quantity?: IntWithAggregatesFilter<"Item"> | number
    quantity_on_queue?: IntWithAggregatesFilter<"Item"> | number
    initial_quantity?: IntWithAggregatesFilter<"Item"> | number
    alert_level?: IntWithAggregatesFilter<"Item"> | number
    created_by?: StringWithAggregatesFilter<"Item"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Item"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Item"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Item">
  }

  export type ItemLocationWhereInput = {
    AND?: ItemLocationWhereInput | ItemLocationWhereInput[]
    OR?: ItemLocationWhereInput[]
    NOT?: ItemLocationWhereInput | ItemLocationWhereInput[]
    id?: StringFilter<"ItemLocation"> | string
    item_id?: StringFilter<"ItemLocation"> | string
    station_id?: StringFilter<"ItemLocation"> | string
    quantity_on_hand?: IntFilter<"ItemLocation"> | number
    created_by?: StringFilter<"ItemLocation"> | string
    created_at?: DateTimeFilter<"ItemLocation"> | Date | string
    metadata?: JsonNullableFilter<"ItemLocation">
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    station?: XOR<StationRelationFilter, StationWhereInput>
    origin_movements?: ItemMovementListRelationFilter
    destination_movements?: ItemMovementListRelationFilter
  }

  export type ItemLocationOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    station_id?: SortOrder
    quantity_on_hand?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    station?: StationOrderByWithRelationInput
    origin_movements?: ItemMovementOrderByRelationAggregateInput
    destination_movements?: ItemMovementOrderByRelationAggregateInput
  }

  export type ItemLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemLocationWhereInput | ItemLocationWhereInput[]
    OR?: ItemLocationWhereInput[]
    NOT?: ItemLocationWhereInput | ItemLocationWhereInput[]
    item_id?: StringFilter<"ItemLocation"> | string
    station_id?: StringFilter<"ItemLocation"> | string
    quantity_on_hand?: IntFilter<"ItemLocation"> | number
    created_by?: StringFilter<"ItemLocation"> | string
    created_at?: DateTimeFilter<"ItemLocation"> | Date | string
    metadata?: JsonNullableFilter<"ItemLocation">
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    station?: XOR<StationRelationFilter, StationWhereInput>
    origin_movements?: ItemMovementListRelationFilter
    destination_movements?: ItemMovementListRelationFilter
  }, "id">

  export type ItemLocationOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    station_id?: SortOrder
    quantity_on_hand?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ItemLocationCountOrderByAggregateInput
    _avg?: ItemLocationAvgOrderByAggregateInput
    _max?: ItemLocationMaxOrderByAggregateInput
    _min?: ItemLocationMinOrderByAggregateInput
    _sum?: ItemLocationSumOrderByAggregateInput
  }

  export type ItemLocationScalarWhereWithAggregatesInput = {
    AND?: ItemLocationScalarWhereWithAggregatesInput | ItemLocationScalarWhereWithAggregatesInput[]
    OR?: ItemLocationScalarWhereWithAggregatesInput[]
    NOT?: ItemLocationScalarWhereWithAggregatesInput | ItemLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemLocation"> | string
    item_id?: StringWithAggregatesFilter<"ItemLocation"> | string
    station_id?: StringWithAggregatesFilter<"ItemLocation"> | string
    quantity_on_hand?: IntWithAggregatesFilter<"ItemLocation"> | number
    created_by?: StringWithAggregatesFilter<"ItemLocation"> | string
    created_at?: DateTimeWithAggregatesFilter<"ItemLocation"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ItemLocation">
  }

  export type ItemMovementWhereInput = {
    AND?: ItemMovementWhereInput | ItemMovementWhereInput[]
    OR?: ItemMovementWhereInput[]
    NOT?: ItemMovementWhereInput | ItemMovementWhereInput[]
    id?: StringFilter<"ItemMovement"> | string
    origin_id?: StringFilter<"ItemMovement"> | string
    destination_id?: StringFilter<"ItemMovement"> | string
    quantity_moved?: IntFilter<"ItemMovement"> | number
    created_by?: StringFilter<"ItemMovement"> | string
    created_at?: DateTimeFilter<"ItemMovement"> | Date | string
    metadata?: JsonNullableFilter<"ItemMovement">
    origin?: XOR<ItemLocationRelationFilter, ItemLocationWhereInput>
    destination?: XOR<ItemLocationRelationFilter, ItemLocationWhereInput>
  }

  export type ItemMovementOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    quantity_moved?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    origin?: ItemLocationOrderByWithRelationInput
    destination?: ItemLocationOrderByWithRelationInput
  }

  export type ItemMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemMovementWhereInput | ItemMovementWhereInput[]
    OR?: ItemMovementWhereInput[]
    NOT?: ItemMovementWhereInput | ItemMovementWhereInput[]
    origin_id?: StringFilter<"ItemMovement"> | string
    destination_id?: StringFilter<"ItemMovement"> | string
    quantity_moved?: IntFilter<"ItemMovement"> | number
    created_by?: StringFilter<"ItemMovement"> | string
    created_at?: DateTimeFilter<"ItemMovement"> | Date | string
    metadata?: JsonNullableFilter<"ItemMovement">
    origin?: XOR<ItemLocationRelationFilter, ItemLocationWhereInput>
    destination?: XOR<ItemLocationRelationFilter, ItemLocationWhereInput>
  }, "id">

  export type ItemMovementOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    quantity_moved?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ItemMovementCountOrderByAggregateInput
    _avg?: ItemMovementAvgOrderByAggregateInput
    _max?: ItemMovementMaxOrderByAggregateInput
    _min?: ItemMovementMinOrderByAggregateInput
    _sum?: ItemMovementSumOrderByAggregateInput
  }

  export type ItemMovementScalarWhereWithAggregatesInput = {
    AND?: ItemMovementScalarWhereWithAggregatesInput | ItemMovementScalarWhereWithAggregatesInput[]
    OR?: ItemMovementScalarWhereWithAggregatesInput[]
    NOT?: ItemMovementScalarWhereWithAggregatesInput | ItemMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemMovement"> | string
    origin_id?: StringWithAggregatesFilter<"ItemMovement"> | string
    destination_id?: StringWithAggregatesFilter<"ItemMovement"> | string
    quantity_moved?: IntWithAggregatesFilter<"ItemMovement"> | number
    created_by?: StringWithAggregatesFilter<"ItemMovement"> | string
    created_at?: DateTimeWithAggregatesFilter<"ItemMovement"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ItemMovement">
  }

  export type ItemTransactionWhereInput = {
    AND?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    OR?: ItemTransactionWhereInput[]
    NOT?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    id?: IntFilter<"ItemTransaction"> | number
    item_id?: StringFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    osriv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    seriv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    mrv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    mcrt_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: IntFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    created_by?: StringFilter<"ItemTransaction"> | string
    metadata?: JsonNullableFilter<"ItemTransaction">
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    rr_item?: XOR<RRItemNullableRelationFilter, RRItemWhereInput> | null
    osriv_item?: XOR<OSRIVItemNullableRelationFilter, OSRIVItemWhereInput> | null
    seriv_item?: XOR<SERIVItemNullableRelationFilter, SERIVItemWhereInput> | null
    mrv_item?: XOR<MRVItemNullableRelationFilter, MRVItemWhereInput> | null
    mcrt_item?: XOR<MCRTItemNullableRelationFilter, MCRTItemWhereInput> | null
  }

  export type ItemTransactionOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrderInput | SortOrder
    osriv_item_id?: SortOrderInput | SortOrder
    seriv_item_id?: SortOrderInput | SortOrder
    mrv_item_id?: SortOrderInput | SortOrder
    mcrt_item_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrderInput | SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    metadata?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    rr_item?: RRItemOrderByWithRelationInput
    osriv_item?: OSRIVItemOrderByWithRelationInput
    seriv_item?: SERIVItemOrderByWithRelationInput
    mrv_item?: MRVItemOrderByWithRelationInput
    mcrt_item?: MCRTItemOrderByWithRelationInput
  }

  export type ItemTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rr_item_id?: string
    osriv_item_id?: string
    seriv_item_id?: string
    mrv_item_id?: string
    mcrt_item_id?: string
    AND?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    OR?: ItemTransactionWhereInput[]
    NOT?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    item_id?: StringFilter<"ItemTransaction"> | string
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: IntFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    created_by?: StringFilter<"ItemTransaction"> | string
    metadata?: JsonNullableFilter<"ItemTransaction">
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    rr_item?: XOR<RRItemNullableRelationFilter, RRItemWhereInput> | null
    osriv_item?: XOR<OSRIVItemNullableRelationFilter, OSRIVItemWhereInput> | null
    seriv_item?: XOR<SERIVItemNullableRelationFilter, SERIVItemWhereInput> | null
    mrv_item?: XOR<MRVItemNullableRelationFilter, MRVItemWhereInput> | null
    mcrt_item?: XOR<MCRTItemNullableRelationFilter, MCRTItemWhereInput> | null
  }, "id" | "rr_item_id" | "osriv_item_id" | "seriv_item_id" | "mrv_item_id" | "mcrt_item_id">

  export type ItemTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrderInput | SortOrder
    osriv_item_id?: SortOrderInput | SortOrder
    seriv_item_id?: SortOrderInput | SortOrder
    mrv_item_id?: SortOrderInput | SortOrder
    mcrt_item_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrderInput | SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ItemTransactionCountOrderByAggregateInput
    _avg?: ItemTransactionAvgOrderByAggregateInput
    _max?: ItemTransactionMaxOrderByAggregateInput
    _min?: ItemTransactionMinOrderByAggregateInput
    _sum?: ItemTransactionSumOrderByAggregateInput
  }

  export type ItemTransactionScalarWhereWithAggregatesInput = {
    AND?: ItemTransactionScalarWhereWithAggregatesInput | ItemTransactionScalarWhereWithAggregatesInput[]
    OR?: ItemTransactionScalarWhereWithAggregatesInput[]
    NOT?: ItemTransactionScalarWhereWithAggregatesInput | ItemTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemTransaction"> | number
    item_id?: StringWithAggregatesFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    osriv_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    seriv_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    mrv_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    mcrt_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    type?: IntWithAggregatesFilter<"ItemTransaction"> | number
    quantity?: IntWithAggregatesFilter<"ItemTransaction"> | number
    price?: FloatWithAggregatesFilter<"ItemTransaction"> | number
    remarks?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    is_initial?: BoolWithAggregatesFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ItemTransaction"> | Date | string
    created_by?: StringWithAggregatesFilter<"ItemTransaction"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ItemTransaction">
  }

  export type ItemCodeTrackerWhereInput = {
    AND?: ItemCodeTrackerWhereInput | ItemCodeTrackerWhereInput[]
    OR?: ItemCodeTrackerWhereInput[]
    NOT?: ItemCodeTrackerWhereInput | ItemCodeTrackerWhereInput[]
    id?: IntFilter<"ItemCodeTracker"> | number
    item_code?: StringFilter<"ItemCodeTracker"> | string
    year?: IntFilter<"ItemCodeTracker"> | number
    last_incremental?: IntFilter<"ItemCodeTracker"> | number
  }

  export type ItemCodeTrackerOrderByWithRelationInput = {
    id?: SortOrder
    item_code?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type ItemCodeTrackerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    item_code?: string
    AND?: ItemCodeTrackerWhereInput | ItemCodeTrackerWhereInput[]
    OR?: ItemCodeTrackerWhereInput[]
    NOT?: ItemCodeTrackerWhereInput | ItemCodeTrackerWhereInput[]
    year?: IntFilter<"ItemCodeTracker"> | number
    last_incremental?: IntFilter<"ItemCodeTracker"> | number
  }, "id" | "item_code">

  export type ItemCodeTrackerOrderByWithAggregationInput = {
    id?: SortOrder
    item_code?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
    _count?: ItemCodeTrackerCountOrderByAggregateInput
    _avg?: ItemCodeTrackerAvgOrderByAggregateInput
    _max?: ItemCodeTrackerMaxOrderByAggregateInput
    _min?: ItemCodeTrackerMinOrderByAggregateInput
    _sum?: ItemCodeTrackerSumOrderByAggregateInput
  }

  export type ItemCodeTrackerScalarWhereWithAggregatesInput = {
    AND?: ItemCodeTrackerScalarWhereWithAggregatesInput | ItemCodeTrackerScalarWhereWithAggregatesInput[]
    OR?: ItemCodeTrackerScalarWhereWithAggregatesInput[]
    NOT?: ItemCodeTrackerScalarWhereWithAggregatesInput | ItemCodeTrackerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemCodeTracker"> | number
    item_code?: StringWithAggregatesFilter<"ItemCodeTracker"> | string
    year?: IntWithAggregatesFilter<"ItemCodeTracker"> | number
    last_incremental?: IntWithAggregatesFilter<"ItemCodeTracker"> | number
  }

  export type CanvassWhereInput = {
    AND?: CanvassWhereInput | CanvassWhereInput[]
    OR?: CanvassWhereInput[]
    NOT?: CanvassWhereInput | CanvassWhereInput[]
    id?: StringFilter<"Canvass"> | string
    rc_number?: StringFilter<"Canvass"> | string
    date_requested?: DateTimeFilter<"Canvass"> | Date | string
    purpose?: StringFilter<"Canvass"> | string
    notes?: StringNullableFilter<"Canvass"> | string | null
    requested_by_id?: StringFilter<"Canvass"> | string
    created_by?: StringFilter<"Canvass"> | string
    updated_by?: StringNullableFilter<"Canvass"> | string | null
    deleted_by?: StringNullableFilter<"Canvass"> | string | null
    created_at?: DateTimeFilter<"Canvass"> | Date | string
    updated_at?: DateTimeFilter<"Canvass"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Canvass"> | Date | string | null
    metadata?: JsonNullableFilter<"Canvass">
    canvass_items?: CanvassItemListRelationFilter
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
  }

  export type CanvassOrderByWithRelationInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrderInput | SortOrder
    requested_by_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    jo?: JOOrderByWithRelationInput
    rv?: RVOrderByWithRelationInput
    spr?: SPROrderByWithRelationInput
  }

  export type CanvassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rc_number?: string
    AND?: CanvassWhereInput | CanvassWhereInput[]
    OR?: CanvassWhereInput[]
    NOT?: CanvassWhereInput | CanvassWhereInput[]
    date_requested?: DateTimeFilter<"Canvass"> | Date | string
    purpose?: StringFilter<"Canvass"> | string
    notes?: StringNullableFilter<"Canvass"> | string | null
    requested_by_id?: StringFilter<"Canvass"> | string
    created_by?: StringFilter<"Canvass"> | string
    updated_by?: StringNullableFilter<"Canvass"> | string | null
    deleted_by?: StringNullableFilter<"Canvass"> | string | null
    created_at?: DateTimeFilter<"Canvass"> | Date | string
    updated_at?: DateTimeFilter<"Canvass"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Canvass"> | Date | string | null
    metadata?: JsonNullableFilter<"Canvass">
    canvass_items?: CanvassItemListRelationFilter
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
  }, "id" | "rc_number">

  export type CanvassOrderByWithAggregationInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrderInput | SortOrder
    requested_by_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CanvassCountOrderByAggregateInput
    _max?: CanvassMaxOrderByAggregateInput
    _min?: CanvassMinOrderByAggregateInput
  }

  export type CanvassScalarWhereWithAggregatesInput = {
    AND?: CanvassScalarWhereWithAggregatesInput | CanvassScalarWhereWithAggregatesInput[]
    OR?: CanvassScalarWhereWithAggregatesInput[]
    NOT?: CanvassScalarWhereWithAggregatesInput | CanvassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Canvass"> | string
    rc_number?: StringWithAggregatesFilter<"Canvass"> | string
    date_requested?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    purpose?: StringWithAggregatesFilter<"Canvass"> | string
    notes?: StringNullableWithAggregatesFilter<"Canvass"> | string | null
    requested_by_id?: StringWithAggregatesFilter<"Canvass"> | string
    created_by?: StringWithAggregatesFilter<"Canvass"> | string
    updated_by?: StringNullableWithAggregatesFilter<"Canvass"> | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Canvass"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Canvass"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Canvass">
  }

  export type CanvassItemWhereInput = {
    AND?: CanvassItemWhereInput | CanvassItemWhereInput[]
    OR?: CanvassItemWhereInput[]
    NOT?: CanvassItemWhereInput | CanvassItemWhereInput[]
    id?: StringFilter<"CanvassItem"> | string
    canvass_id?: StringFilter<"CanvassItem"> | string
    unit_id?: StringNullableFilter<"CanvassItem"> | string | null
    item_id?: StringNullableFilter<"CanvassItem"> | string | null
    description?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    metadata?: JsonNullableFilter<"CanvassItem">
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }

  export type CanvassItemOrderByWithRelationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    unit_id?: SortOrderInput | SortOrder
    item_id?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    meqs_supplier_items?: MEQSSupplierItemOrderByRelationAggregateInput
    canvass?: CanvassOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type CanvassItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CanvassItemWhereInput | CanvassItemWhereInput[]
    OR?: CanvassItemWhereInput[]
    NOT?: CanvassItemWhereInput | CanvassItemWhereInput[]
    canvass_id?: StringFilter<"CanvassItem"> | string
    unit_id?: StringNullableFilter<"CanvassItem"> | string | null
    item_id?: StringNullableFilter<"CanvassItem"> | string | null
    description?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    metadata?: JsonNullableFilter<"CanvassItem">
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }, "id">

  export type CanvassItemOrderByWithAggregationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    unit_id?: SortOrderInput | SortOrder
    item_id?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CanvassItemCountOrderByAggregateInput
    _avg?: CanvassItemAvgOrderByAggregateInput
    _max?: CanvassItemMaxOrderByAggregateInput
    _min?: CanvassItemMinOrderByAggregateInput
    _sum?: CanvassItemSumOrderByAggregateInput
  }

  export type CanvassItemScalarWhereWithAggregatesInput = {
    AND?: CanvassItemScalarWhereWithAggregatesInput | CanvassItemScalarWhereWithAggregatesInput[]
    OR?: CanvassItemScalarWhereWithAggregatesInput[]
    NOT?: CanvassItemScalarWhereWithAggregatesInput | CanvassItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvassItem"> | string
    canvass_id?: StringWithAggregatesFilter<"CanvassItem"> | string
    unit_id?: StringNullableWithAggregatesFilter<"CanvassItem"> | string | null
    item_id?: StringNullableWithAggregatesFilter<"CanvassItem"> | string | null
    description?: StringWithAggregatesFilter<"CanvassItem"> | string
    quantity?: IntWithAggregatesFilter<"CanvassItem"> | number
    metadata?: JsonNullableWithAggregatesFilter<"CanvassItem">
  }

  export type RVWhereInput = {
    AND?: RVWhereInput | RVWhereInput[]
    OR?: RVWhereInput[]
    NOT?: RVWhereInput | RVWhereInput[]
    id?: StringFilter<"RV"> | string
    rv_number?: StringFilter<"RV"> | string
    canvass_id?: StringNullableFilter<"RV"> | string | null
    classification_id?: StringNullableFilter<"RV"> | string | null
    supervisor_id?: StringFilter<"RV"> | string
    date_requested?: DateTimeFilter<"RV"> | Date | string
    work_order_no?: StringNullableFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableFilter<"RV"> | Date | string | null
    notes?: StringFilter<"RV"> | string
    cancelled_by?: StringNullableFilter<"RV"> | string | null
    created_by?: StringFilter<"RV"> | string
    updated_by?: StringNullableFilter<"RV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"RV"> | Date | string | null
    created_at?: DateTimeFilter<"RV"> | Date | string
    updated_at?: DateTimeFilter<"RV"> | Date | string
    metadata?: JsonNullableFilter<"RV">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    rv_approvers?: RVApproverListRelationFilter
  }

  export type RVOrderByWithRelationInput = {
    id?: SortOrder
    rv_number?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrderInput | SortOrder
    work_order_date?: SortOrderInput | SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass?: CanvassOrderByWithRelationInput
    meqs?: MEQSOrderByWithRelationInput
    rv_approvers?: RVApproverOrderByRelationAggregateInput
  }

  export type RVWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rv_number?: string
    canvass_id?: string
    AND?: RVWhereInput | RVWhereInput[]
    OR?: RVWhereInput[]
    NOT?: RVWhereInput | RVWhereInput[]
    classification_id?: StringNullableFilter<"RV"> | string | null
    supervisor_id?: StringFilter<"RV"> | string
    date_requested?: DateTimeFilter<"RV"> | Date | string
    work_order_no?: StringNullableFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableFilter<"RV"> | Date | string | null
    notes?: StringFilter<"RV"> | string
    cancelled_by?: StringNullableFilter<"RV"> | string | null
    created_by?: StringFilter<"RV"> | string
    updated_by?: StringNullableFilter<"RV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"RV"> | Date | string | null
    created_at?: DateTimeFilter<"RV"> | Date | string
    updated_at?: DateTimeFilter<"RV"> | Date | string
    metadata?: JsonNullableFilter<"RV">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    rv_approvers?: RVApproverListRelationFilter
  }, "id" | "rv_number" | "canvass_id">

  export type RVOrderByWithAggregationInput = {
    id?: SortOrder
    rv_number?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrderInput | SortOrder
    work_order_date?: SortOrderInput | SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: RVCountOrderByAggregateInput
    _max?: RVMaxOrderByAggregateInput
    _min?: RVMinOrderByAggregateInput
  }

  export type RVScalarWhereWithAggregatesInput = {
    AND?: RVScalarWhereWithAggregatesInput | RVScalarWhereWithAggregatesInput[]
    OR?: RVScalarWhereWithAggregatesInput[]
    NOT?: RVScalarWhereWithAggregatesInput | RVScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RV"> | string
    rv_number?: StringWithAggregatesFilter<"RV"> | string
    canvass_id?: StringNullableWithAggregatesFilter<"RV"> | string | null
    classification_id?: StringNullableWithAggregatesFilter<"RV"> | string | null
    supervisor_id?: StringWithAggregatesFilter<"RV"> | string
    date_requested?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    work_order_no?: StringNullableWithAggregatesFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableWithAggregatesFilter<"RV"> | Date | string | null
    notes?: StringWithAggregatesFilter<"RV"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"RV"> | string | null
    created_by?: StringWithAggregatesFilter<"RV"> | string
    updated_by?: StringNullableWithAggregatesFilter<"RV"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"RV"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"RV">
  }

  export type RVApproverWhereInput = {
    AND?: RVApproverWhereInput | RVApproverWhereInput[]
    OR?: RVApproverWhereInput[]
    NOT?: RVApproverWhereInput | RVApproverWhereInput[]
    id?: StringFilter<"RVApprover"> | string
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringFilter<"RVApprover"> | string
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    is_supervisor?: BoolFilter<"RVApprover"> | boolean
    metadata?: JsonNullableFilter<"RVApprover">
    rv?: XOR<RVRelationFilter, RVWhereInput>
  }

  export type RVApproverOrderByWithRelationInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    rv?: RVOrderByWithRelationInput
  }

  export type RVApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RVApproverWhereInput | RVApproverWhereInput[]
    OR?: RVApproverWhereInput[]
    NOT?: RVApproverWhereInput | RVApproverWhereInput[]
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringFilter<"RVApprover"> | string
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    is_supervisor?: BoolFilter<"RVApprover"> | boolean
    metadata?: JsonNullableFilter<"RVApprover">
    rv?: XOR<RVRelationFilter, RVWhereInput>
  }, "id">

  export type RVApproverOrderByWithAggregationInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: RVApproverCountOrderByAggregateInput
    _avg?: RVApproverAvgOrderByAggregateInput
    _max?: RVApproverMaxOrderByAggregateInput
    _min?: RVApproverMinOrderByAggregateInput
    _sum?: RVApproverSumOrderByAggregateInput
  }

  export type RVApproverScalarWhereWithAggregatesInput = {
    AND?: RVApproverScalarWhereWithAggregatesInput | RVApproverScalarWhereWithAggregatesInput[]
    OR?: RVApproverScalarWhereWithAggregatesInput[]
    NOT?: RVApproverScalarWhereWithAggregatesInput | RVApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RVApprover"> | string
    rv_id?: StringWithAggregatesFilter<"RVApprover"> | string
    approver_id?: StringWithAggregatesFilter<"RVApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"RVApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"RVApprover"> | string
    status?: IntWithAggregatesFilter<"RVApprover"> | number
    label?: StringWithAggregatesFilter<"RVApprover"> | string
    order?: IntWithAggregatesFilter<"RVApprover"> | number
    is_supervisor?: BoolWithAggregatesFilter<"RVApprover"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"RVApprover">
  }

  export type JOWhereInput = {
    AND?: JOWhereInput | JOWhereInput[]
    OR?: JOWhereInput[]
    NOT?: JOWhereInput | JOWhereInput[]
    id?: StringFilter<"JO"> | string
    jo_number?: StringFilter<"JO"> | string
    date_requested?: DateTimeFilter<"JO"> | Date | string
    canvass_id?: StringNullableFilter<"JO"> | string | null
    equipment?: StringFilter<"JO"> | string
    classification_id?: StringNullableFilter<"JO"> | string | null
    department_id?: StringFilter<"JO"> | string
    supervisor_id?: StringFilter<"JO"> | string
    notes?: StringFilter<"JO"> | string
    cancelled_by?: StringNullableFilter<"JO"> | string | null
    created_by?: StringFilter<"JO"> | string
    updated_by?: StringNullableFilter<"JO"> | string | null
    cancelled_at?: DateTimeNullableFilter<"JO"> | Date | string | null
    created_at?: DateTimeFilter<"JO"> | Date | string
    updated_at?: DateTimeFilter<"JO"> | Date | string
    metadata?: JsonNullableFilter<"JO">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    jo_approvers?: JOApproverListRelationFilter
  }

  export type JOOrderByWithRelationInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    equipment?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass?: CanvassOrderByWithRelationInput
    meqs?: MEQSOrderByWithRelationInput
    jo_approvers?: JOApproverOrderByRelationAggregateInput
  }

  export type JOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jo_number?: string
    canvass_id?: string
    AND?: JOWhereInput | JOWhereInput[]
    OR?: JOWhereInput[]
    NOT?: JOWhereInput | JOWhereInput[]
    date_requested?: DateTimeFilter<"JO"> | Date | string
    equipment?: StringFilter<"JO"> | string
    classification_id?: StringNullableFilter<"JO"> | string | null
    department_id?: StringFilter<"JO"> | string
    supervisor_id?: StringFilter<"JO"> | string
    notes?: StringFilter<"JO"> | string
    cancelled_by?: StringNullableFilter<"JO"> | string | null
    created_by?: StringFilter<"JO"> | string
    updated_by?: StringNullableFilter<"JO"> | string | null
    cancelled_at?: DateTimeNullableFilter<"JO"> | Date | string | null
    created_at?: DateTimeFilter<"JO"> | Date | string
    updated_at?: DateTimeFilter<"JO"> | Date | string
    metadata?: JsonNullableFilter<"JO">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    jo_approvers?: JOApproverListRelationFilter
  }, "id" | "jo_number" | "canvass_id">

  export type JOOrderByWithAggregationInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    equipment?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: JOCountOrderByAggregateInput
    _max?: JOMaxOrderByAggregateInput
    _min?: JOMinOrderByAggregateInput
  }

  export type JOScalarWhereWithAggregatesInput = {
    AND?: JOScalarWhereWithAggregatesInput | JOScalarWhereWithAggregatesInput[]
    OR?: JOScalarWhereWithAggregatesInput[]
    NOT?: JOScalarWhereWithAggregatesInput | JOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JO"> | string
    jo_number?: StringWithAggregatesFilter<"JO"> | string
    date_requested?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    canvass_id?: StringNullableWithAggregatesFilter<"JO"> | string | null
    equipment?: StringWithAggregatesFilter<"JO"> | string
    classification_id?: StringNullableWithAggregatesFilter<"JO"> | string | null
    department_id?: StringWithAggregatesFilter<"JO"> | string
    supervisor_id?: StringWithAggregatesFilter<"JO"> | string
    notes?: StringWithAggregatesFilter<"JO"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"JO"> | string | null
    created_by?: StringWithAggregatesFilter<"JO"> | string
    updated_by?: StringNullableWithAggregatesFilter<"JO"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"JO"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"JO">
  }

  export type JOApproverWhereInput = {
    AND?: JOApproverWhereInput | JOApproverWhereInput[]
    OR?: JOApproverWhereInput[]
    NOT?: JOApproverWhereInput | JOApproverWhereInput[]
    id?: StringFilter<"JOApprover"> | string
    jo_id?: StringFilter<"JOApprover"> | string
    approver_id?: StringFilter<"JOApprover"> | string
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringFilter<"JOApprover"> | string
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    is_supervisor?: BoolFilter<"JOApprover"> | boolean
    metadata?: JsonNullableFilter<"JOApprover">
    jo?: XOR<JORelationFilter, JOWhereInput>
  }

  export type JOApproverOrderByWithRelationInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    jo?: JOOrderByWithRelationInput
  }

  export type JOApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JOApproverWhereInput | JOApproverWhereInput[]
    OR?: JOApproverWhereInput[]
    NOT?: JOApproverWhereInput | JOApproverWhereInput[]
    jo_id?: StringFilter<"JOApprover"> | string
    approver_id?: StringFilter<"JOApprover"> | string
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringFilter<"JOApprover"> | string
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    is_supervisor?: BoolFilter<"JOApprover"> | boolean
    metadata?: JsonNullableFilter<"JOApprover">
    jo?: XOR<JORelationFilter, JOWhereInput>
  }, "id">

  export type JOApproverOrderByWithAggregationInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: JOApproverCountOrderByAggregateInput
    _avg?: JOApproverAvgOrderByAggregateInput
    _max?: JOApproverMaxOrderByAggregateInput
    _min?: JOApproverMinOrderByAggregateInput
    _sum?: JOApproverSumOrderByAggregateInput
  }

  export type JOApproverScalarWhereWithAggregatesInput = {
    AND?: JOApproverScalarWhereWithAggregatesInput | JOApproverScalarWhereWithAggregatesInput[]
    OR?: JOApproverScalarWhereWithAggregatesInput[]
    NOT?: JOApproverScalarWhereWithAggregatesInput | JOApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JOApprover"> | string
    jo_id?: StringWithAggregatesFilter<"JOApprover"> | string
    approver_id?: StringWithAggregatesFilter<"JOApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"JOApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"JOApprover"> | string
    status?: IntWithAggregatesFilter<"JOApprover"> | number
    label?: StringWithAggregatesFilter<"JOApprover"> | string
    order?: IntWithAggregatesFilter<"JOApprover"> | number
    is_supervisor?: BoolWithAggregatesFilter<"JOApprover"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"JOApprover">
  }

  export type SPRWhereInput = {
    AND?: SPRWhereInput | SPRWhereInput[]
    OR?: SPRWhereInput[]
    NOT?: SPRWhereInput | SPRWhereInput[]
    id?: StringFilter<"SPR"> | string
    spr_number?: StringFilter<"SPR"> | string
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    canvass_id?: StringNullableFilter<"SPR"> | string | null
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    notes?: StringFilter<"SPR"> | string
    cancelled_by?: StringNullableFilter<"SPR"> | string | null
    created_by?: StringFilter<"SPR"> | string
    updated_by?: StringNullableFilter<"SPR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SPR"> | Date | string | null
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    metadata?: JsonNullableFilter<"SPR">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    spr_approvers?: SPRApproverListRelationFilter
  }

  export type SPROrderByWithRelationInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass?: CanvassOrderByWithRelationInput
    meqs?: MEQSOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    spr_approvers?: SPRApproverOrderByRelationAggregateInput
  }

  export type SPRWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    spr_number?: string
    canvass_id?: string
    AND?: SPRWhereInput | SPRWhereInput[]
    OR?: SPRWhereInput[]
    NOT?: SPRWhereInput | SPRWhereInput[]
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    notes?: StringFilter<"SPR"> | string
    cancelled_by?: StringNullableFilter<"SPR"> | string | null
    created_by?: StringFilter<"SPR"> | string
    updated_by?: StringNullableFilter<"SPR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SPR"> | Date | string | null
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    metadata?: JsonNullableFilter<"SPR">
    canvass?: XOR<CanvassNullableRelationFilter, CanvassWhereInput> | null
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    spr_approvers?: SPRApproverListRelationFilter
  }, "id" | "spr_number" | "canvass_id">

  export type SPROrderByWithAggregationInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrderInput | SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SPRCountOrderByAggregateInput
    _max?: SPRMaxOrderByAggregateInput
    _min?: SPRMinOrderByAggregateInput
  }

  export type SPRScalarWhereWithAggregatesInput = {
    AND?: SPRScalarWhereWithAggregatesInput | SPRScalarWhereWithAggregatesInput[]
    OR?: SPRScalarWhereWithAggregatesInput[]
    NOT?: SPRScalarWhereWithAggregatesInput | SPRScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SPR"> | string
    spr_number?: StringWithAggregatesFilter<"SPR"> | string
    date_requested?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    canvass_id?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    vehicle_id?: StringWithAggregatesFilter<"SPR"> | string
    classification_id?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    supervisor_id?: StringWithAggregatesFilter<"SPR"> | string
    notes?: StringWithAggregatesFilter<"SPR"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    created_by?: StringWithAggregatesFilter<"SPR"> | string
    updated_by?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"SPR"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"SPR">
  }

  export type SPRApproverWhereInput = {
    AND?: SPRApproverWhereInput | SPRApproverWhereInput[]
    OR?: SPRApproverWhereInput[]
    NOT?: SPRApproverWhereInput | SPRApproverWhereInput[]
    id?: StringFilter<"SPRApprover"> | string
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringFilter<"SPRApprover"> | string
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    is_supervisor?: BoolFilter<"SPRApprover"> | boolean
    metadata?: JsonNullableFilter<"SPRApprover">
    spr?: XOR<SPRRelationFilter, SPRWhereInput>
  }

  export type SPRApproverOrderByWithRelationInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    spr?: SPROrderByWithRelationInput
  }

  export type SPRApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SPRApproverWhereInput | SPRApproverWhereInput[]
    OR?: SPRApproverWhereInput[]
    NOT?: SPRApproverWhereInput | SPRApproverWhereInput[]
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringFilter<"SPRApprover"> | string
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    is_supervisor?: BoolFilter<"SPRApprover"> | boolean
    metadata?: JsonNullableFilter<"SPRApprover">
    spr?: XOR<SPRRelationFilter, SPRWhereInput>
  }, "id">

  export type SPRApproverOrderByWithAggregationInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SPRApproverCountOrderByAggregateInput
    _avg?: SPRApproverAvgOrderByAggregateInput
    _max?: SPRApproverMaxOrderByAggregateInput
    _min?: SPRApproverMinOrderByAggregateInput
    _sum?: SPRApproverSumOrderByAggregateInput
  }

  export type SPRApproverScalarWhereWithAggregatesInput = {
    AND?: SPRApproverScalarWhereWithAggregatesInput | SPRApproverScalarWhereWithAggregatesInput[]
    OR?: SPRApproverScalarWhereWithAggregatesInput[]
    NOT?: SPRApproverScalarWhereWithAggregatesInput | SPRApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SPRApprover"> | string
    spr_id?: StringWithAggregatesFilter<"SPRApprover"> | string
    approver_id?: StringWithAggregatesFilter<"SPRApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"SPRApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"SPRApprover"> | string
    status?: IntWithAggregatesFilter<"SPRApprover"> | number
    label?: StringWithAggregatesFilter<"SPRApprover"> | string
    order?: IntWithAggregatesFilter<"SPRApprover"> | number
    is_supervisor?: BoolWithAggregatesFilter<"SPRApprover"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"SPRApprover">
  }

  export type MEQSWhereInput = {
    AND?: MEQSWhereInput | MEQSWhereInput[]
    OR?: MEQSWhereInput[]
    NOT?: MEQSWhereInput | MEQSWhereInput[]
    id?: StringFilter<"MEQS"> | string
    jo_id?: StringNullableFilter<"MEQS"> | string | null
    jo_number?: StringNullableFilter<"MEQS"> | string | null
    rv_id?: StringNullableFilter<"MEQS"> | string | null
    rv_number?: StringNullableFilter<"MEQS"> | string | null
    spr_id?: StringNullableFilter<"MEQS"> | string | null
    spr_number?: StringNullableFilter<"MEQS"> | string | null
    meqs_number?: StringFilter<"MEQS"> | string
    meqs_date?: DateTimeFilter<"MEQS"> | Date | string
    notes?: StringFilter<"MEQS"> | string
    created_by?: StringFilter<"MEQS"> | string
    updated_by?: StringNullableFilter<"MEQS"> | string | null
    cancelled_by?: StringNullableFilter<"MEQS"> | string | null
    created_at?: DateTimeFilter<"MEQS"> | Date | string
    updated_at?: DateTimeFilter<"MEQS"> | Date | string
    cancelled_at?: DateTimeNullableFilter<"MEQS"> | Date | string | null
    metadata?: JsonNullableFilter<"MEQS">
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
    meqs_approvers?: MEQSApproverListRelationFilter
    meqs_suppliers?: MEQSSupplierListRelationFilter
  }

  export type MEQSOrderByWithRelationInput = {
    id?: SortOrder
    jo_id?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    rv_id?: SortOrderInput | SortOrder
    rv_number?: SortOrderInput | SortOrder
    spr_id?: SortOrderInput | SortOrder
    spr_number?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    meqs_date?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    jo?: JOOrderByWithRelationInput
    rv?: RVOrderByWithRelationInput
    spr?: SPROrderByWithRelationInput
    meqs_approvers?: MEQSApproverOrderByRelationAggregateInput
    meqs_suppliers?: MEQSSupplierOrderByRelationAggregateInput
  }

  export type MEQSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jo_id?: string
    rv_id?: string
    spr_id?: string
    meqs_number?: string
    AND?: MEQSWhereInput | MEQSWhereInput[]
    OR?: MEQSWhereInput[]
    NOT?: MEQSWhereInput | MEQSWhereInput[]
    jo_number?: StringNullableFilter<"MEQS"> | string | null
    rv_number?: StringNullableFilter<"MEQS"> | string | null
    spr_number?: StringNullableFilter<"MEQS"> | string | null
    meqs_date?: DateTimeFilter<"MEQS"> | Date | string
    notes?: StringFilter<"MEQS"> | string
    created_by?: StringFilter<"MEQS"> | string
    updated_by?: StringNullableFilter<"MEQS"> | string | null
    cancelled_by?: StringNullableFilter<"MEQS"> | string | null
    created_at?: DateTimeFilter<"MEQS"> | Date | string
    updated_at?: DateTimeFilter<"MEQS"> | Date | string
    cancelled_at?: DateTimeNullableFilter<"MEQS"> | Date | string | null
    metadata?: JsonNullableFilter<"MEQS">
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
    meqs_approvers?: MEQSApproverListRelationFilter
    meqs_suppliers?: MEQSSupplierListRelationFilter
  }, "id" | "jo_id" | "rv_id" | "spr_id" | "meqs_number">

  export type MEQSOrderByWithAggregationInput = {
    id?: SortOrder
    jo_id?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    rv_id?: SortOrderInput | SortOrder
    rv_number?: SortOrderInput | SortOrder
    spr_id?: SortOrderInput | SortOrder
    spr_number?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    meqs_date?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MEQSCountOrderByAggregateInput
    _max?: MEQSMaxOrderByAggregateInput
    _min?: MEQSMinOrderByAggregateInput
  }

  export type MEQSScalarWhereWithAggregatesInput = {
    AND?: MEQSScalarWhereWithAggregatesInput | MEQSScalarWhereWithAggregatesInput[]
    OR?: MEQSScalarWhereWithAggregatesInput[]
    NOT?: MEQSScalarWhereWithAggregatesInput | MEQSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQS"> | string
    jo_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    jo_number?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    rv_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    rv_number?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    spr_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    spr_number?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    meqs_number?: StringWithAggregatesFilter<"MEQS"> | string
    meqs_date?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    notes?: StringWithAggregatesFilter<"MEQS"> | string
    created_by?: StringWithAggregatesFilter<"MEQS"> | string
    updated_by?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    cancelled_by?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"MEQS"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"MEQS">
  }

  export type MEQSSupplierWhereInput = {
    AND?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    OR?: MEQSSupplierWhereInput[]
    NOT?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    id?: StringFilter<"MEQSSupplier"> | string
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    metadata?: JsonNullableFilter<"MEQSSupplier">
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    attachments?: MEQSSupplierAttachmentListRelationFilter
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
  }

  export type MEQSSupplierOrderByWithRelationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    metadata?: SortOrderInput | SortOrder
    meqs?: MEQSOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    attachments?: MEQSSupplierAttachmentOrderByRelationAggregateInput
    meqs_supplier_items?: MEQSSupplierItemOrderByRelationAggregateInput
    po?: POOrderByWithRelationInput
  }

  export type MEQSSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meqs_id_supplier_id?: MEQSSupplierMeqs_idSupplier_idCompoundUniqueInput
    AND?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    OR?: MEQSSupplierWhereInput[]
    NOT?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    metadata?: JsonNullableFilter<"MEQSSupplier">
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    attachments?: MEQSSupplierAttachmentListRelationFilter
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
  }, "id" | "meqs_id_supplier_id">

  export type MEQSSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MEQSSupplierCountOrderByAggregateInput
    _max?: MEQSSupplierMaxOrderByAggregateInput
    _min?: MEQSSupplierMinOrderByAggregateInput
  }

  export type MEQSSupplierScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierScalarWhereWithAggregatesInput | MEQSSupplierScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierScalarWhereWithAggregatesInput | MEQSSupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    meqs_id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    supplier_id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    payment_terms?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    metadata?: JsonNullableWithAggregatesFilter<"MEQSSupplier">
  }

  export type MEQSSupplierItemWhereInput = {
    AND?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    OR?: MEQSSupplierItemWhereInput[]
    NOT?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    id?: StringFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    notes?: StringFilter<"MEQSSupplierItem"> | string
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    metadata?: JsonNullableFilter<"MEQSSupplierItem">
    canvass_item?: XOR<CanvassItemRelationFilter, CanvassItemWhereInput>
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
    rr_items?: RRItemListRelationFilter
  }

  export type MEQSSupplierItemOrderByWithRelationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    canvass_item_id?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    is_awarded?: SortOrder
    vat_type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    canvass_item?: CanvassItemOrderByWithRelationInput
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
    rr_items?: RRItemOrderByRelationAggregateInput
  }

  export type MEQSSupplierItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    OR?: MEQSSupplierItemWhereInput[]
    NOT?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    notes?: StringFilter<"MEQSSupplierItem"> | string
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    metadata?: JsonNullableFilter<"MEQSSupplierItem">
    canvass_item?: XOR<CanvassItemRelationFilter, CanvassItemWhereInput>
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
    rr_items?: RRItemListRelationFilter
  }, "id">

  export type MEQSSupplierItemOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    canvass_item_id?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    is_awarded?: SortOrder
    vat_type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MEQSSupplierItemCountOrderByAggregateInput
    _avg?: MEQSSupplierItemAvgOrderByAggregateInput
    _max?: MEQSSupplierItemMaxOrderByAggregateInput
    _min?: MEQSSupplierItemMinOrderByAggregateInput
    _sum?: MEQSSupplierItemSumOrderByAggregateInput
  }

  export type MEQSSupplierItemScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierItemScalarWhereWithAggregatesInput | MEQSSupplierItemScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierItemScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierItemScalarWhereWithAggregatesInput | MEQSSupplierItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    price?: FloatWithAggregatesFilter<"MEQSSupplierItem"> | number
    notes?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    is_awarded?: BoolWithAggregatesFilter<"MEQSSupplierItem"> | boolean
    vat_type?: IntWithAggregatesFilter<"MEQSSupplierItem"> | number
    metadata?: JsonNullableWithAggregatesFilter<"MEQSSupplierItem">
  }

  export type MEQSSupplierAttachmentWhereInput = {
    AND?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    OR?: MEQSSupplierAttachmentWhereInput[]
    NOT?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    id?: StringFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    filename?: StringFilter<"MEQSSupplierAttachment"> | string
    src?: StringFilter<"MEQSSupplierAttachment"> | string
    metadata?: JsonNullableFilter<"MEQSSupplierAttachment">
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }

  export type MEQSSupplierAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    filename?: SortOrder
    src?: SortOrder
    metadata?: SortOrderInput | SortOrder
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
  }

  export type MEQSSupplierAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    src?: string
    AND?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    OR?: MEQSSupplierAttachmentWhereInput[]
    NOT?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    filename?: StringFilter<"MEQSSupplierAttachment"> | string
    metadata?: JsonNullableFilter<"MEQSSupplierAttachment">
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }, "id" | "src">

  export type MEQSSupplierAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    filename?: SortOrder
    src?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MEQSSupplierAttachmentCountOrderByAggregateInput
    _max?: MEQSSupplierAttachmentMaxOrderByAggregateInput
    _min?: MEQSSupplierAttachmentMinOrderByAggregateInput
  }

  export type MEQSSupplierAttachmentScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput | MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput | MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    filename?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    src?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    metadata?: JsonNullableWithAggregatesFilter<"MEQSSupplierAttachment">
  }

  export type MEQSApproverWhereInput = {
    AND?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    OR?: MEQSApproverWhereInput[]
    NOT?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    id?: StringFilter<"MEQSApprover"> | string
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringFilter<"MEQSApprover"> | string
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    metadata?: JsonNullableFilter<"MEQSApprover">
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
  }

  export type MEQSApproverOrderByWithRelationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    meqs?: MEQSOrderByWithRelationInput
  }

  export type MEQSApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    OR?: MEQSApproverWhereInput[]
    NOT?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringFilter<"MEQSApprover"> | string
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    metadata?: JsonNullableFilter<"MEQSApprover">
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
  }, "id">

  export type MEQSApproverOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MEQSApproverCountOrderByAggregateInput
    _avg?: MEQSApproverAvgOrderByAggregateInput
    _max?: MEQSApproverMaxOrderByAggregateInput
    _min?: MEQSApproverMinOrderByAggregateInput
    _sum?: MEQSApproverSumOrderByAggregateInput
  }

  export type MEQSApproverScalarWhereWithAggregatesInput = {
    AND?: MEQSApproverScalarWhereWithAggregatesInput | MEQSApproverScalarWhereWithAggregatesInput[]
    OR?: MEQSApproverScalarWhereWithAggregatesInput[]
    NOT?: MEQSApproverScalarWhereWithAggregatesInput | MEQSApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    meqs_id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"MEQSApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"MEQSApprover"> | string
    status?: IntWithAggregatesFilter<"MEQSApprover"> | number
    label?: StringWithAggregatesFilter<"MEQSApprover"> | string
    order?: IntWithAggregatesFilter<"MEQSApprover"> | number
    metadata?: JsonNullableWithAggregatesFilter<"MEQSApprover">
  }

  export type POWhereInput = {
    AND?: POWhereInput | POWhereInput[]
    OR?: POWhereInput[]
    NOT?: POWhereInput | POWhereInput[]
    id?: StringFilter<"PO"> | string
    meqs_supplier_id?: StringNullableFilter<"PO"> | string | null
    meqs_number?: StringFilter<"PO"> | string
    po_number?: StringFilter<"PO"> | string
    fund_source_id?: StringNullableFilter<"PO"> | string | null
    po_date?: DateTimeFilter<"PO"> | Date | string
    notes?: StringFilter<"PO"> | string
    cancelled_by?: StringNullableFilter<"PO"> | string | null
    created_by?: StringFilter<"PO"> | string
    updated_by?: StringNullableFilter<"PO"> | string | null
    cancelled_at?: DateTimeNullableFilter<"PO"> | Date | string | null
    created_at?: DateTimeFilter<"PO"> | Date | string
    updated_at?: DateTimeFilter<"PO"> | Date | string
    metadata?: JsonNullableFilter<"PO">
    meqs_supplier?: XOR<MEQSSupplierNullableRelationFilter, MEQSSupplierWhereInput> | null
    rrs?: RRListRelationFilter
    po_approvers?: POApproverListRelationFilter
  }

  export type POOrderByWithRelationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    po_number?: SortOrder
    fund_source_id?: SortOrderInput | SortOrder
    po_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
    rrs?: RROrderByRelationAggregateInput
    po_approvers?: POApproverOrderByRelationAggregateInput
  }

  export type POWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meqs_supplier_id?: string
    po_number?: string
    AND?: POWhereInput | POWhereInput[]
    OR?: POWhereInput[]
    NOT?: POWhereInput | POWhereInput[]
    meqs_number?: StringFilter<"PO"> | string
    fund_source_id?: StringNullableFilter<"PO"> | string | null
    po_date?: DateTimeFilter<"PO"> | Date | string
    notes?: StringFilter<"PO"> | string
    cancelled_by?: StringNullableFilter<"PO"> | string | null
    created_by?: StringFilter<"PO"> | string
    updated_by?: StringNullableFilter<"PO"> | string | null
    cancelled_at?: DateTimeNullableFilter<"PO"> | Date | string | null
    created_at?: DateTimeFilter<"PO"> | Date | string
    updated_at?: DateTimeFilter<"PO"> | Date | string
    metadata?: JsonNullableFilter<"PO">
    meqs_supplier?: XOR<MEQSSupplierNullableRelationFilter, MEQSSupplierWhereInput> | null
    rrs?: RRListRelationFilter
    po_approvers?: POApproverListRelationFilter
  }, "id" | "meqs_supplier_id" | "po_number">

  export type POOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    po_number?: SortOrder
    fund_source_id?: SortOrderInput | SortOrder
    po_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: POCountOrderByAggregateInput
    _max?: POMaxOrderByAggregateInput
    _min?: POMinOrderByAggregateInput
  }

  export type POScalarWhereWithAggregatesInput = {
    AND?: POScalarWhereWithAggregatesInput | POScalarWhereWithAggregatesInput[]
    OR?: POScalarWhereWithAggregatesInput[]
    NOT?: POScalarWhereWithAggregatesInput | POScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PO"> | string
    meqs_supplier_id?: StringNullableWithAggregatesFilter<"PO"> | string | null
    meqs_number?: StringWithAggregatesFilter<"PO"> | string
    po_number?: StringWithAggregatesFilter<"PO"> | string
    fund_source_id?: StringNullableWithAggregatesFilter<"PO"> | string | null
    po_date?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    notes?: StringWithAggregatesFilter<"PO"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"PO"> | string | null
    created_by?: StringWithAggregatesFilter<"PO"> | string
    updated_by?: StringNullableWithAggregatesFilter<"PO"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"PO"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"PO">
  }

  export type POApproverWhereInput = {
    AND?: POApproverWhereInput | POApproverWhereInput[]
    OR?: POApproverWhereInput[]
    NOT?: POApproverWhereInput | POApproverWhereInput[]
    id?: StringFilter<"POApprover"> | string
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    metadata?: JsonNullableFilter<"POApprover">
    po?: XOR<PORelationFilter, POWhereInput>
  }

  export type POApproverOrderByWithRelationInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    po?: POOrderByWithRelationInput
  }

  export type POApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POApproverWhereInput | POApproverWhereInput[]
    OR?: POApproverWhereInput[]
    NOT?: POApproverWhereInput | POApproverWhereInput[]
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    metadata?: JsonNullableFilter<"POApprover">
    po?: XOR<PORelationFilter, POWhereInput>
  }, "id">

  export type POApproverOrderByWithAggregationInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: POApproverCountOrderByAggregateInput
    _avg?: POApproverAvgOrderByAggregateInput
    _max?: POApproverMaxOrderByAggregateInput
    _min?: POApproverMinOrderByAggregateInput
    _sum?: POApproverSumOrderByAggregateInput
  }

  export type POApproverScalarWhereWithAggregatesInput = {
    AND?: POApproverScalarWhereWithAggregatesInput | POApproverScalarWhereWithAggregatesInput[]
    OR?: POApproverScalarWhereWithAggregatesInput[]
    NOT?: POApproverScalarWhereWithAggregatesInput | POApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POApprover"> | string
    po_id?: StringWithAggregatesFilter<"POApprover"> | string
    approver_id?: StringWithAggregatesFilter<"POApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"POApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"POApprover"> | string | null
    status?: IntWithAggregatesFilter<"POApprover"> | number
    label?: StringWithAggregatesFilter<"POApprover"> | string
    order?: IntWithAggregatesFilter<"POApprover"> | number
    metadata?: JsonNullableWithAggregatesFilter<"POApprover">
  }

  export type RRWhereInput = {
    AND?: RRWhereInput | RRWhereInput[]
    OR?: RRWhereInput[]
    NOT?: RRWhereInput | RRWhereInput[]
    id?: StringFilter<"RR"> | string
    po_id?: StringNullableFilter<"RR"> | string | null
    po_number?: StringFilter<"RR"> | string
    rr_number?: StringFilter<"RR"> | string
    rr_date?: DateTimeFilter<"RR"> | Date | string
    received_by_id?: StringFilter<"RR"> | string
    invoice_number?: StringFilter<"RR"> | string
    delivery_number?: StringNullableFilter<"RR"> | string | null
    notes?: StringFilter<"RR"> | string
    delivery_charge?: FloatFilter<"RR"> | number
    is_completed?: BoolFilter<"RR"> | boolean
    cancelled_by?: StringNullableFilter<"RR"> | string | null
    created_by?: StringFilter<"RR"> | string
    updated_by?: StringNullableFilter<"RR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"RR"> | Date | string | null
    created_at?: DateTimeFilter<"RR"> | Date | string
    updated_at?: DateTimeFilter<"RR"> | Date | string
    metadata?: JsonNullableFilter<"RR">
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
    rr_approvers?: RRApproverListRelationFilter
    rr_items?: RRItemListRelationFilter
  }

  export type RROrderByWithRelationInput = {
    id?: SortOrder
    po_id?: SortOrderInput | SortOrder
    po_number?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrderInput | SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    po?: POOrderByWithRelationInput
    rr_approvers?: RRApproverOrderByRelationAggregateInput
    rr_items?: RRItemOrderByRelationAggregateInput
  }

  export type RRWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rr_number?: string
    invoice_number?: string
    AND?: RRWhereInput | RRWhereInput[]
    OR?: RRWhereInput[]
    NOT?: RRWhereInput | RRWhereInput[]
    po_id?: StringNullableFilter<"RR"> | string | null
    po_number?: StringFilter<"RR"> | string
    rr_date?: DateTimeFilter<"RR"> | Date | string
    received_by_id?: StringFilter<"RR"> | string
    delivery_number?: StringNullableFilter<"RR"> | string | null
    notes?: StringFilter<"RR"> | string
    delivery_charge?: FloatFilter<"RR"> | number
    is_completed?: BoolFilter<"RR"> | boolean
    cancelled_by?: StringNullableFilter<"RR"> | string | null
    created_by?: StringFilter<"RR"> | string
    updated_by?: StringNullableFilter<"RR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"RR"> | Date | string | null
    created_at?: DateTimeFilter<"RR"> | Date | string
    updated_at?: DateTimeFilter<"RR"> | Date | string
    metadata?: JsonNullableFilter<"RR">
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
    rr_approvers?: RRApproverListRelationFilter
    rr_items?: RRItemListRelationFilter
  }, "id" | "rr_number" | "invoice_number">

  export type RROrderByWithAggregationInput = {
    id?: SortOrder
    po_id?: SortOrderInput | SortOrder
    po_number?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrderInput | SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: RRCountOrderByAggregateInput
    _avg?: RRAvgOrderByAggregateInput
    _max?: RRMaxOrderByAggregateInput
    _min?: RRMinOrderByAggregateInput
    _sum?: RRSumOrderByAggregateInput
  }

  export type RRScalarWhereWithAggregatesInput = {
    AND?: RRScalarWhereWithAggregatesInput | RRScalarWhereWithAggregatesInput[]
    OR?: RRScalarWhereWithAggregatesInput[]
    NOT?: RRScalarWhereWithAggregatesInput | RRScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RR"> | string
    po_id?: StringNullableWithAggregatesFilter<"RR"> | string | null
    po_number?: StringWithAggregatesFilter<"RR"> | string
    rr_number?: StringWithAggregatesFilter<"RR"> | string
    rr_date?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    received_by_id?: StringWithAggregatesFilter<"RR"> | string
    invoice_number?: StringWithAggregatesFilter<"RR"> | string
    delivery_number?: StringNullableWithAggregatesFilter<"RR"> | string | null
    notes?: StringWithAggregatesFilter<"RR"> | string
    delivery_charge?: FloatWithAggregatesFilter<"RR"> | number
    is_completed?: BoolWithAggregatesFilter<"RR"> | boolean
    cancelled_by?: StringNullableWithAggregatesFilter<"RR"> | string | null
    created_by?: StringWithAggregatesFilter<"RR"> | string
    updated_by?: StringNullableWithAggregatesFilter<"RR"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"RR"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"RR">
  }

  export type RRApproverWhereInput = {
    AND?: RRApproverWhereInput | RRApproverWhereInput[]
    OR?: RRApproverWhereInput[]
    NOT?: RRApproverWhereInput | RRApproverWhereInput[]
    id?: StringFilter<"RRApprover"> | string
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringFilter<"RRApprover"> | string
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    metadata?: JsonNullableFilter<"RRApprover">
    rr?: XOR<RRRelationFilter, RRWhereInput>
  }

  export type RRApproverOrderByWithRelationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    rr?: RROrderByWithRelationInput
  }

  export type RRApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RRApproverWhereInput | RRApproverWhereInput[]
    OR?: RRApproverWhereInput[]
    NOT?: RRApproverWhereInput | RRApproverWhereInput[]
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringFilter<"RRApprover"> | string
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    metadata?: JsonNullableFilter<"RRApprover">
    rr?: XOR<RRRelationFilter, RRWhereInput>
  }, "id">

  export type RRApproverOrderByWithAggregationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: RRApproverCountOrderByAggregateInput
    _avg?: RRApproverAvgOrderByAggregateInput
    _max?: RRApproverMaxOrderByAggregateInput
    _min?: RRApproverMinOrderByAggregateInput
    _sum?: RRApproverSumOrderByAggregateInput
  }

  export type RRApproverScalarWhereWithAggregatesInput = {
    AND?: RRApproverScalarWhereWithAggregatesInput | RRApproverScalarWhereWithAggregatesInput[]
    OR?: RRApproverScalarWhereWithAggregatesInput[]
    NOT?: RRApproverScalarWhereWithAggregatesInput | RRApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RRApprover"> | string
    rr_id?: StringWithAggregatesFilter<"RRApprover"> | string
    approver_id?: StringWithAggregatesFilter<"RRApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"RRApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"RRApprover"> | string
    status?: IntWithAggregatesFilter<"RRApprover"> | number
    label?: StringWithAggregatesFilter<"RRApprover"> | string
    order?: IntWithAggregatesFilter<"RRApprover"> | number
    metadata?: JsonNullableWithAggregatesFilter<"RRApprover">
  }

  export type RRItemWhereInput = {
    AND?: RRItemWhereInput | RRItemWhereInput[]
    OR?: RRItemWhereInput[]
    NOT?: RRItemWhereInput | RRItemWhereInput[]
    id?: StringFilter<"RRItem"> | string
    rr_id?: StringFilter<"RRItem"> | string
    meqs_supplier_item_id?: StringFilter<"RRItem"> | string
    quantity_accepted?: IntFilter<"RRItem"> | number
    metadata?: JsonNullableFilter<"RRItem">
    rr?: XOR<RRRelationFilter, RRWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
    meqs_supplier_item?: XOR<MEQSSupplierItemRelationFilter, MEQSSupplierItemWhereInput>
  }

  export type RRItemOrderByWithRelationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    meqs_supplier_item_id?: SortOrder
    quantity_accepted?: SortOrder
    metadata?: SortOrderInput | SortOrder
    rr?: RROrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
    meqs_supplier_item?: MEQSSupplierItemOrderByWithRelationInput
  }

  export type RRItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RRItemWhereInput | RRItemWhereInput[]
    OR?: RRItemWhereInput[]
    NOT?: RRItemWhereInput | RRItemWhereInput[]
    rr_id?: StringFilter<"RRItem"> | string
    meqs_supplier_item_id?: StringFilter<"RRItem"> | string
    quantity_accepted?: IntFilter<"RRItem"> | number
    metadata?: JsonNullableFilter<"RRItem">
    rr?: XOR<RRRelationFilter, RRWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
    meqs_supplier_item?: XOR<MEQSSupplierItemRelationFilter, MEQSSupplierItemWhereInput>
  }, "id">

  export type RRItemOrderByWithAggregationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    meqs_supplier_item_id?: SortOrder
    quantity_accepted?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: RRItemCountOrderByAggregateInput
    _avg?: RRItemAvgOrderByAggregateInput
    _max?: RRItemMaxOrderByAggregateInput
    _min?: RRItemMinOrderByAggregateInput
    _sum?: RRItemSumOrderByAggregateInput
  }

  export type RRItemScalarWhereWithAggregatesInput = {
    AND?: RRItemScalarWhereWithAggregatesInput | RRItemScalarWhereWithAggregatesInput[]
    OR?: RRItemScalarWhereWithAggregatesInput[]
    NOT?: RRItemScalarWhereWithAggregatesInput | RRItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RRItem"> | string
    rr_id?: StringWithAggregatesFilter<"RRItem"> | string
    meqs_supplier_item_id?: StringWithAggregatesFilter<"RRItem"> | string
    quantity_accepted?: IntWithAggregatesFilter<"RRItem"> | number
    metadata?: JsonNullableWithAggregatesFilter<"RRItem">
  }

  export type OSRIVWhereInput = {
    AND?: OSRIVWhereInput | OSRIVWhereInput[]
    OR?: OSRIVWhereInput[]
    NOT?: OSRIVWhereInput | OSRIVWhereInput[]
    id?: StringFilter<"OSRIV"> | string
    osriv_number?: StringFilter<"OSRIV"> | string
    date_requested?: DateTimeFilter<"OSRIV"> | Date | string
    exp_date?: DateTimeFilter<"OSRIV"> | Date | string
    purpose?: StringFilter<"OSRIV"> | string
    note?: StringFilter<"OSRIV"> | string
    is_completed?: BoolFilter<"OSRIV"> | boolean
    requested_by_id?: StringFilter<"OSRIV"> | string
    item_from_id?: StringFilter<"OSRIV"> | string
    cancelled_by?: StringNullableFilter<"OSRIV"> | string | null
    created_by?: StringFilter<"OSRIV"> | string
    updated_by?: StringNullableFilter<"OSRIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"OSRIV"> | Date | string | null
    created_at?: DateTimeFilter<"OSRIV"> | Date | string
    updated_at?: DateTimeFilter<"OSRIV"> | Date | string
    metadata?: JsonNullableFilter<"OSRIV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    osriv_approvers?: OSRIVApproverListRelationFilter
    osriv_items?: OSRIVItemListRelationFilter
  }

  export type OSRIVOrderByWithRelationInput = {
    id?: SortOrder
    osriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    requested_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    item_from?: StationOrderByWithRelationInput
    osriv_approvers?: OSRIVApproverOrderByRelationAggregateInput
    osriv_items?: OSRIVItemOrderByRelationAggregateInput
  }

  export type OSRIVWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    osriv_number?: string
    AND?: OSRIVWhereInput | OSRIVWhereInput[]
    OR?: OSRIVWhereInput[]
    NOT?: OSRIVWhereInput | OSRIVWhereInput[]
    date_requested?: DateTimeFilter<"OSRIV"> | Date | string
    exp_date?: DateTimeFilter<"OSRIV"> | Date | string
    purpose?: StringFilter<"OSRIV"> | string
    note?: StringFilter<"OSRIV"> | string
    is_completed?: BoolFilter<"OSRIV"> | boolean
    requested_by_id?: StringFilter<"OSRIV"> | string
    item_from_id?: StringFilter<"OSRIV"> | string
    cancelled_by?: StringNullableFilter<"OSRIV"> | string | null
    created_by?: StringFilter<"OSRIV"> | string
    updated_by?: StringNullableFilter<"OSRIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"OSRIV"> | Date | string | null
    created_at?: DateTimeFilter<"OSRIV"> | Date | string
    updated_at?: DateTimeFilter<"OSRIV"> | Date | string
    metadata?: JsonNullableFilter<"OSRIV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    osriv_approvers?: OSRIVApproverListRelationFilter
    osriv_items?: OSRIVItemListRelationFilter
  }, "id" | "osriv_number">

  export type OSRIVOrderByWithAggregationInput = {
    id?: SortOrder
    osriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    requested_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OSRIVCountOrderByAggregateInput
    _max?: OSRIVMaxOrderByAggregateInput
    _min?: OSRIVMinOrderByAggregateInput
  }

  export type OSRIVScalarWhereWithAggregatesInput = {
    AND?: OSRIVScalarWhereWithAggregatesInput | OSRIVScalarWhereWithAggregatesInput[]
    OR?: OSRIVScalarWhereWithAggregatesInput[]
    NOT?: OSRIVScalarWhereWithAggregatesInput | OSRIVScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OSRIV"> | string
    osriv_number?: StringWithAggregatesFilter<"OSRIV"> | string
    date_requested?: DateTimeWithAggregatesFilter<"OSRIV"> | Date | string
    exp_date?: DateTimeWithAggregatesFilter<"OSRIV"> | Date | string
    purpose?: StringWithAggregatesFilter<"OSRIV"> | string
    note?: StringWithAggregatesFilter<"OSRIV"> | string
    is_completed?: BoolWithAggregatesFilter<"OSRIV"> | boolean
    requested_by_id?: StringWithAggregatesFilter<"OSRIV"> | string
    item_from_id?: StringWithAggregatesFilter<"OSRIV"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"OSRIV"> | string | null
    created_by?: StringWithAggregatesFilter<"OSRIV"> | string
    updated_by?: StringNullableWithAggregatesFilter<"OSRIV"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"OSRIV"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"OSRIV"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"OSRIV"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"OSRIV">
  }

  export type OSRIVApproverWhereInput = {
    AND?: OSRIVApproverWhereInput | OSRIVApproverWhereInput[]
    OR?: OSRIVApproverWhereInput[]
    NOT?: OSRIVApproverWhereInput | OSRIVApproverWhereInput[]
    id?: StringFilter<"OSRIVApprover"> | string
    osriv_id?: StringFilter<"OSRIVApprover"> | string
    approver_id?: StringFilter<"OSRIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"OSRIVApprover"> | Date | string | null
    notes?: StringFilter<"OSRIVApprover"> | string
    status?: IntFilter<"OSRIVApprover"> | number
    label?: StringFilter<"OSRIVApprover"> | string
    label_id?: StringFilter<"OSRIVApprover"> | string
    order?: IntFilter<"OSRIVApprover"> | number
    updated_by?: StringNullableFilter<"OSRIVApprover"> | string | null
    updated_at?: DateTimeFilter<"OSRIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVApprover">
    osriv?: XOR<OSRIVRelationFilter, OSRIVWhereInput>
  }

  export type OSRIVApproverOrderByWithRelationInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    osriv?: OSRIVOrderByWithRelationInput
  }

  export type OSRIVApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    osriv_id_label_id?: OSRIVApproverOsriv_idLabel_idCompoundUniqueInput
    AND?: OSRIVApproverWhereInput | OSRIVApproverWhereInput[]
    OR?: OSRIVApproverWhereInput[]
    NOT?: OSRIVApproverWhereInput | OSRIVApproverWhereInput[]
    osriv_id?: StringFilter<"OSRIVApprover"> | string
    approver_id?: StringFilter<"OSRIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"OSRIVApprover"> | Date | string | null
    notes?: StringFilter<"OSRIVApprover"> | string
    status?: IntFilter<"OSRIVApprover"> | number
    label?: StringFilter<"OSRIVApprover"> | string
    label_id?: StringFilter<"OSRIVApprover"> | string
    order?: IntFilter<"OSRIVApprover"> | number
    updated_by?: StringNullableFilter<"OSRIVApprover"> | string | null
    updated_at?: DateTimeFilter<"OSRIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVApprover">
    osriv?: XOR<OSRIVRelationFilter, OSRIVWhereInput>
  }, "id" | "osriv_id_label_id">

  export type OSRIVApproverOrderByWithAggregationInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OSRIVApproverCountOrderByAggregateInput
    _avg?: OSRIVApproverAvgOrderByAggregateInput
    _max?: OSRIVApproverMaxOrderByAggregateInput
    _min?: OSRIVApproverMinOrderByAggregateInput
    _sum?: OSRIVApproverSumOrderByAggregateInput
  }

  export type OSRIVApproverScalarWhereWithAggregatesInput = {
    AND?: OSRIVApproverScalarWhereWithAggregatesInput | OSRIVApproverScalarWhereWithAggregatesInput[]
    OR?: OSRIVApproverScalarWhereWithAggregatesInput[]
    NOT?: OSRIVApproverScalarWhereWithAggregatesInput | OSRIVApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    osriv_id?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    approver_id?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"OSRIVApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    status?: IntWithAggregatesFilter<"OSRIVApprover"> | number
    label?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    label_id?: StringWithAggregatesFilter<"OSRIVApprover"> | string
    order?: IntWithAggregatesFilter<"OSRIVApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"OSRIVApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"OSRIVApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"OSRIVApprover">
  }

  export type OSRIVItemWhereInput = {
    AND?: OSRIVItemWhereInput | OSRIVItemWhereInput[]
    OR?: OSRIVItemWhereInput[]
    NOT?: OSRIVItemWhereInput | OSRIVItemWhereInput[]
    id?: StringFilter<"OSRIVItem"> | string
    osriv_id?: StringFilter<"OSRIVItem"> | string
    item_id?: StringFilter<"OSRIVItem"> | string
    quantity?: IntFilter<"OSRIVItem"> | number
    price?: FloatFilter<"OSRIVItem"> | number
    created_by?: StringFilter<"OSRIVItem"> | string
    created_at?: DateTimeFilter<"OSRIVItem"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVItem">
    osriv?: XOR<OSRIVRelationFilter, OSRIVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }

  export type OSRIVItemOrderByWithRelationInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    osriv?: OSRIVOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
  }

  export type OSRIVItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OSRIVItemWhereInput | OSRIVItemWhereInput[]
    OR?: OSRIVItemWhereInput[]
    NOT?: OSRIVItemWhereInput | OSRIVItemWhereInput[]
    osriv_id?: StringFilter<"OSRIVItem"> | string
    item_id?: StringFilter<"OSRIVItem"> | string
    quantity?: IntFilter<"OSRIVItem"> | number
    price?: FloatFilter<"OSRIVItem"> | number
    created_by?: StringFilter<"OSRIVItem"> | string
    created_at?: DateTimeFilter<"OSRIVItem"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVItem">
    osriv?: XOR<OSRIVRelationFilter, OSRIVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }, "id">

  export type OSRIVItemOrderByWithAggregationInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OSRIVItemCountOrderByAggregateInput
    _avg?: OSRIVItemAvgOrderByAggregateInput
    _max?: OSRIVItemMaxOrderByAggregateInput
    _min?: OSRIVItemMinOrderByAggregateInput
    _sum?: OSRIVItemSumOrderByAggregateInput
  }

  export type OSRIVItemScalarWhereWithAggregatesInput = {
    AND?: OSRIVItemScalarWhereWithAggregatesInput | OSRIVItemScalarWhereWithAggregatesInput[]
    OR?: OSRIVItemScalarWhereWithAggregatesInput[]
    NOT?: OSRIVItemScalarWhereWithAggregatesInput | OSRIVItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OSRIVItem"> | string
    osriv_id?: StringWithAggregatesFilter<"OSRIVItem"> | string
    item_id?: StringWithAggregatesFilter<"OSRIVItem"> | string
    quantity?: IntWithAggregatesFilter<"OSRIVItem"> | number
    price?: FloatWithAggregatesFilter<"OSRIVItem"> | number
    created_by?: StringWithAggregatesFilter<"OSRIVItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"OSRIVItem"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"OSRIVItem">
  }

  export type SERIVWhereInput = {
    AND?: SERIVWhereInput | SERIVWhereInput[]
    OR?: SERIVWhereInput[]
    NOT?: SERIVWhereInput | SERIVWhereInput[]
    id?: StringFilter<"SERIV"> | string
    seriv_number?: StringFilter<"SERIV"> | string
    date_requested?: DateTimeFilter<"SERIV"> | Date | string
    exp_date?: DateTimeFilter<"SERIV"> | Date | string
    purpose?: StringFilter<"SERIV"> | string
    note?: StringFilter<"SERIV"> | string
    is_completed?: BoolFilter<"SERIV"> | boolean
    request_type?: IntFilter<"SERIV"> | number
    or_number?: StringNullableFilter<"SERIV"> | string | null
    mwo_number?: StringNullableFilter<"SERIV"> | string | null
    cwo_number?: StringNullableFilter<"SERIV"> | string | null
    jo_number?: StringNullableFilter<"SERIV"> | string | null
    consumer_name?: StringFilter<"SERIV"> | string
    location?: StringFilter<"SERIV"> | string
    requested_by_id?: StringFilter<"SERIV"> | string
    withdrawn_by_id?: StringFilter<"SERIV"> | string
    item_from_id?: StringFilter<"SERIV"> | string
    cancelled_by?: StringNullableFilter<"SERIV"> | string | null
    created_by?: StringFilter<"SERIV"> | string
    updated_by?: StringNullableFilter<"SERIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SERIV"> | Date | string | null
    created_at?: DateTimeFilter<"SERIV"> | Date | string
    updated_at?: DateTimeFilter<"SERIV"> | Date | string
    metadata?: JsonNullableFilter<"SERIV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    seriv_approvers?: SERIVApproverListRelationFilter
    seriv_items?: SERIVItemListRelationFilter
    mcrts?: MCRTListRelationFilter
  }

  export type SERIVOrderByWithRelationInput = {
    id?: SortOrder
    seriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    cwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    item_from?: StationOrderByWithRelationInput
    seriv_approvers?: SERIVApproverOrderByRelationAggregateInput
    seriv_items?: SERIVItemOrderByRelationAggregateInput
    mcrts?: MCRTOrderByRelationAggregateInput
  }

  export type SERIVWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seriv_number?: string
    AND?: SERIVWhereInput | SERIVWhereInput[]
    OR?: SERIVWhereInput[]
    NOT?: SERIVWhereInput | SERIVWhereInput[]
    date_requested?: DateTimeFilter<"SERIV"> | Date | string
    exp_date?: DateTimeFilter<"SERIV"> | Date | string
    purpose?: StringFilter<"SERIV"> | string
    note?: StringFilter<"SERIV"> | string
    is_completed?: BoolFilter<"SERIV"> | boolean
    request_type?: IntFilter<"SERIV"> | number
    or_number?: StringNullableFilter<"SERIV"> | string | null
    mwo_number?: StringNullableFilter<"SERIV"> | string | null
    cwo_number?: StringNullableFilter<"SERIV"> | string | null
    jo_number?: StringNullableFilter<"SERIV"> | string | null
    consumer_name?: StringFilter<"SERIV"> | string
    location?: StringFilter<"SERIV"> | string
    requested_by_id?: StringFilter<"SERIV"> | string
    withdrawn_by_id?: StringFilter<"SERIV"> | string
    item_from_id?: StringFilter<"SERIV"> | string
    cancelled_by?: StringNullableFilter<"SERIV"> | string | null
    created_by?: StringFilter<"SERIV"> | string
    updated_by?: StringNullableFilter<"SERIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SERIV"> | Date | string | null
    created_at?: DateTimeFilter<"SERIV"> | Date | string
    updated_at?: DateTimeFilter<"SERIV"> | Date | string
    metadata?: JsonNullableFilter<"SERIV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    seriv_approvers?: SERIVApproverListRelationFilter
    seriv_items?: SERIVItemListRelationFilter
    mcrts?: MCRTListRelationFilter
  }, "id" | "seriv_number">

  export type SERIVOrderByWithAggregationInput = {
    id?: SortOrder
    seriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    cwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SERIVCountOrderByAggregateInput
    _avg?: SERIVAvgOrderByAggregateInput
    _max?: SERIVMaxOrderByAggregateInput
    _min?: SERIVMinOrderByAggregateInput
    _sum?: SERIVSumOrderByAggregateInput
  }

  export type SERIVScalarWhereWithAggregatesInput = {
    AND?: SERIVScalarWhereWithAggregatesInput | SERIVScalarWhereWithAggregatesInput[]
    OR?: SERIVScalarWhereWithAggregatesInput[]
    NOT?: SERIVScalarWhereWithAggregatesInput | SERIVScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SERIV"> | string
    seriv_number?: StringWithAggregatesFilter<"SERIV"> | string
    date_requested?: DateTimeWithAggregatesFilter<"SERIV"> | Date | string
    exp_date?: DateTimeWithAggregatesFilter<"SERIV"> | Date | string
    purpose?: StringWithAggregatesFilter<"SERIV"> | string
    note?: StringWithAggregatesFilter<"SERIV"> | string
    is_completed?: BoolWithAggregatesFilter<"SERIV"> | boolean
    request_type?: IntWithAggregatesFilter<"SERIV"> | number
    or_number?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    mwo_number?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    cwo_number?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    jo_number?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    consumer_name?: StringWithAggregatesFilter<"SERIV"> | string
    location?: StringWithAggregatesFilter<"SERIV"> | string
    requested_by_id?: StringWithAggregatesFilter<"SERIV"> | string
    withdrawn_by_id?: StringWithAggregatesFilter<"SERIV"> | string
    item_from_id?: StringWithAggregatesFilter<"SERIV"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    created_by?: StringWithAggregatesFilter<"SERIV"> | string
    updated_by?: StringNullableWithAggregatesFilter<"SERIV"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"SERIV"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"SERIV"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SERIV"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"SERIV">
  }

  export type SERIVApproverWhereInput = {
    AND?: SERIVApproverWhereInput | SERIVApproverWhereInput[]
    OR?: SERIVApproverWhereInput[]
    NOT?: SERIVApproverWhereInput | SERIVApproverWhereInput[]
    id?: StringFilter<"SERIVApprover"> | string
    seriv_id?: StringFilter<"SERIVApprover"> | string
    approver_id?: StringFilter<"SERIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"SERIVApprover"> | Date | string | null
    notes?: StringFilter<"SERIVApprover"> | string
    status?: IntFilter<"SERIVApprover"> | number
    label?: StringFilter<"SERIVApprover"> | string
    label_id?: StringFilter<"SERIVApprover"> | string
    order?: IntFilter<"SERIVApprover"> | number
    updated_by?: StringNullableFilter<"SERIVApprover"> | string | null
    updated_at?: DateTimeFilter<"SERIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"SERIVApprover">
    seriv?: XOR<SERIVRelationFilter, SERIVWhereInput>
  }

  export type SERIVApproverOrderByWithRelationInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    seriv?: SERIVOrderByWithRelationInput
  }

  export type SERIVApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seriv_id_label_id?: SERIVApproverSeriv_idLabel_idCompoundUniqueInput
    AND?: SERIVApproverWhereInput | SERIVApproverWhereInput[]
    OR?: SERIVApproverWhereInput[]
    NOT?: SERIVApproverWhereInput | SERIVApproverWhereInput[]
    seriv_id?: StringFilter<"SERIVApprover"> | string
    approver_id?: StringFilter<"SERIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"SERIVApprover"> | Date | string | null
    notes?: StringFilter<"SERIVApprover"> | string
    status?: IntFilter<"SERIVApprover"> | number
    label?: StringFilter<"SERIVApprover"> | string
    label_id?: StringFilter<"SERIVApprover"> | string
    order?: IntFilter<"SERIVApprover"> | number
    updated_by?: StringNullableFilter<"SERIVApprover"> | string | null
    updated_at?: DateTimeFilter<"SERIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"SERIVApprover">
    seriv?: XOR<SERIVRelationFilter, SERIVWhereInput>
  }, "id" | "seriv_id_label_id">

  export type SERIVApproverOrderByWithAggregationInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SERIVApproverCountOrderByAggregateInput
    _avg?: SERIVApproverAvgOrderByAggregateInput
    _max?: SERIVApproverMaxOrderByAggregateInput
    _min?: SERIVApproverMinOrderByAggregateInput
    _sum?: SERIVApproverSumOrderByAggregateInput
  }

  export type SERIVApproverScalarWhereWithAggregatesInput = {
    AND?: SERIVApproverScalarWhereWithAggregatesInput | SERIVApproverScalarWhereWithAggregatesInput[]
    OR?: SERIVApproverScalarWhereWithAggregatesInput[]
    NOT?: SERIVApproverScalarWhereWithAggregatesInput | SERIVApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SERIVApprover"> | string
    seriv_id?: StringWithAggregatesFilter<"SERIVApprover"> | string
    approver_id?: StringWithAggregatesFilter<"SERIVApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"SERIVApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"SERIVApprover"> | string
    status?: IntWithAggregatesFilter<"SERIVApprover"> | number
    label?: StringWithAggregatesFilter<"SERIVApprover"> | string
    label_id?: StringWithAggregatesFilter<"SERIVApprover"> | string
    order?: IntWithAggregatesFilter<"SERIVApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"SERIVApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"SERIVApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"SERIVApprover">
  }

  export type SERIVItemWhereInput = {
    AND?: SERIVItemWhereInput | SERIVItemWhereInput[]
    OR?: SERIVItemWhereInput[]
    NOT?: SERIVItemWhereInput | SERIVItemWhereInput[]
    id?: StringFilter<"SERIVItem"> | string
    seriv_id?: StringFilter<"SERIVItem"> | string
    item_id?: StringFilter<"SERIVItem"> | string
    quantity?: IntFilter<"SERIVItem"> | number
    price?: FloatFilter<"SERIVItem"> | number
    created_by?: StringFilter<"SERIVItem"> | string
    created_at?: DateTimeFilter<"SERIVItem"> | Date | string
    metadata?: JsonNullableFilter<"SERIVItem">
    seriv?: XOR<SERIVRelationFilter, SERIVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }

  export type SERIVItemOrderByWithRelationInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    seriv?: SERIVOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
  }

  export type SERIVItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SERIVItemWhereInput | SERIVItemWhereInput[]
    OR?: SERIVItemWhereInput[]
    NOT?: SERIVItemWhereInput | SERIVItemWhereInput[]
    seriv_id?: StringFilter<"SERIVItem"> | string
    item_id?: StringFilter<"SERIVItem"> | string
    quantity?: IntFilter<"SERIVItem"> | number
    price?: FloatFilter<"SERIVItem"> | number
    created_by?: StringFilter<"SERIVItem"> | string
    created_at?: DateTimeFilter<"SERIVItem"> | Date | string
    metadata?: JsonNullableFilter<"SERIVItem">
    seriv?: XOR<SERIVRelationFilter, SERIVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }, "id">

  export type SERIVItemOrderByWithAggregationInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SERIVItemCountOrderByAggregateInput
    _avg?: SERIVItemAvgOrderByAggregateInput
    _max?: SERIVItemMaxOrderByAggregateInput
    _min?: SERIVItemMinOrderByAggregateInput
    _sum?: SERIVItemSumOrderByAggregateInput
  }

  export type SERIVItemScalarWhereWithAggregatesInput = {
    AND?: SERIVItemScalarWhereWithAggregatesInput | SERIVItemScalarWhereWithAggregatesInput[]
    OR?: SERIVItemScalarWhereWithAggregatesInput[]
    NOT?: SERIVItemScalarWhereWithAggregatesInput | SERIVItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SERIVItem"> | string
    seriv_id?: StringWithAggregatesFilter<"SERIVItem"> | string
    item_id?: StringWithAggregatesFilter<"SERIVItem"> | string
    quantity?: IntWithAggregatesFilter<"SERIVItem"> | number
    price?: FloatWithAggregatesFilter<"SERIVItem"> | number
    created_by?: StringWithAggregatesFilter<"SERIVItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"SERIVItem"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"SERIVItem">
  }

  export type MRVWhereInput = {
    AND?: MRVWhereInput | MRVWhereInput[]
    OR?: MRVWhereInput[]
    NOT?: MRVWhereInput | MRVWhereInput[]
    id?: StringFilter<"MRV"> | string
    project_id?: StringFilter<"MRV"> | string
    mrv_number?: StringFilter<"MRV"> | string
    date_requested?: DateTimeFilter<"MRV"> | Date | string
    exp_date?: DateTimeFilter<"MRV"> | Date | string
    purpose?: StringFilter<"MRV"> | string
    note?: StringFilter<"MRV"> | string
    is_completed?: BoolFilter<"MRV"> | boolean
    request_type?: IntFilter<"MRV"> | number
    or_number?: StringNullableFilter<"MRV"> | string | null
    mwo_number?: StringNullableFilter<"MRV"> | string | null
    cwo_number?: StringNullableFilter<"MRV"> | string | null
    jo_number?: StringNullableFilter<"MRV"> | string | null
    consumer_name?: StringFilter<"MRV"> | string
    location?: StringFilter<"MRV"> | string
    requested_by_id?: StringFilter<"MRV"> | string
    withdrawn_by_id?: StringFilter<"MRV"> | string
    item_from_id?: StringFilter<"MRV"> | string
    cancelled_by?: StringNullableFilter<"MRV"> | string | null
    created_by?: StringFilter<"MRV"> | string
    updated_by?: StringNullableFilter<"MRV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MRV"> | Date | string | null
    created_at?: DateTimeFilter<"MRV"> | Date | string
    updated_at?: DateTimeFilter<"MRV"> | Date | string
    metadata?: JsonNullableFilter<"MRV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    mrv_approvers?: MRVApproverListRelationFilter
    mrv_items?: MRVItemListRelationFilter
    mct?: XOR<MCTNullableRelationFilter, MCTWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type MRVOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    mrv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    cwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    item_from?: StationOrderByWithRelationInput
    mrv_approvers?: MRVApproverOrderByRelationAggregateInput
    mrv_items?: MRVItemOrderByRelationAggregateInput
    mct?: MCTOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type MRVWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mrv_number?: string
    AND?: MRVWhereInput | MRVWhereInput[]
    OR?: MRVWhereInput[]
    NOT?: MRVWhereInput | MRVWhereInput[]
    project_id?: StringFilter<"MRV"> | string
    date_requested?: DateTimeFilter<"MRV"> | Date | string
    exp_date?: DateTimeFilter<"MRV"> | Date | string
    purpose?: StringFilter<"MRV"> | string
    note?: StringFilter<"MRV"> | string
    is_completed?: BoolFilter<"MRV"> | boolean
    request_type?: IntFilter<"MRV"> | number
    or_number?: StringNullableFilter<"MRV"> | string | null
    mwo_number?: StringNullableFilter<"MRV"> | string | null
    cwo_number?: StringNullableFilter<"MRV"> | string | null
    jo_number?: StringNullableFilter<"MRV"> | string | null
    consumer_name?: StringFilter<"MRV"> | string
    location?: StringFilter<"MRV"> | string
    requested_by_id?: StringFilter<"MRV"> | string
    withdrawn_by_id?: StringFilter<"MRV"> | string
    item_from_id?: StringFilter<"MRV"> | string
    cancelled_by?: StringNullableFilter<"MRV"> | string | null
    created_by?: StringFilter<"MRV"> | string
    updated_by?: StringNullableFilter<"MRV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MRV"> | Date | string | null
    created_at?: DateTimeFilter<"MRV"> | Date | string
    updated_at?: DateTimeFilter<"MRV"> | Date | string
    metadata?: JsonNullableFilter<"MRV">
    item_from?: XOR<StationRelationFilter, StationWhereInput>
    mrv_approvers?: MRVApproverListRelationFilter
    mrv_items?: MRVItemListRelationFilter
    mct?: XOR<MCTNullableRelationFilter, MCTWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "mrv_number">

  export type MRVOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    mrv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    cwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MRVCountOrderByAggregateInput
    _avg?: MRVAvgOrderByAggregateInput
    _max?: MRVMaxOrderByAggregateInput
    _min?: MRVMinOrderByAggregateInput
    _sum?: MRVSumOrderByAggregateInput
  }

  export type MRVScalarWhereWithAggregatesInput = {
    AND?: MRVScalarWhereWithAggregatesInput | MRVScalarWhereWithAggregatesInput[]
    OR?: MRVScalarWhereWithAggregatesInput[]
    NOT?: MRVScalarWhereWithAggregatesInput | MRVScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MRV"> | string
    project_id?: StringWithAggregatesFilter<"MRV"> | string
    mrv_number?: StringWithAggregatesFilter<"MRV"> | string
    date_requested?: DateTimeWithAggregatesFilter<"MRV"> | Date | string
    exp_date?: DateTimeWithAggregatesFilter<"MRV"> | Date | string
    purpose?: StringWithAggregatesFilter<"MRV"> | string
    note?: StringWithAggregatesFilter<"MRV"> | string
    is_completed?: BoolWithAggregatesFilter<"MRV"> | boolean
    request_type?: IntWithAggregatesFilter<"MRV"> | number
    or_number?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    mwo_number?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    cwo_number?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    jo_number?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    consumer_name?: StringWithAggregatesFilter<"MRV"> | string
    location?: StringWithAggregatesFilter<"MRV"> | string
    requested_by_id?: StringWithAggregatesFilter<"MRV"> | string
    withdrawn_by_id?: StringWithAggregatesFilter<"MRV"> | string
    item_from_id?: StringWithAggregatesFilter<"MRV"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    created_by?: StringWithAggregatesFilter<"MRV"> | string
    updated_by?: StringNullableWithAggregatesFilter<"MRV"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"MRV"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MRV"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MRV"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MRV">
  }

  export type MRVApproverWhereInput = {
    AND?: MRVApproverWhereInput | MRVApproverWhereInput[]
    OR?: MRVApproverWhereInput[]
    NOT?: MRVApproverWhereInput | MRVApproverWhereInput[]
    id?: StringFilter<"MRVApprover"> | string
    mrv_id?: StringFilter<"MRVApprover"> | string
    approver_id?: StringFilter<"MRVApprover"> | string
    date_approval?: DateTimeNullableFilter<"MRVApprover"> | Date | string | null
    notes?: StringFilter<"MRVApprover"> | string
    status?: IntFilter<"MRVApprover"> | number
    label?: StringFilter<"MRVApprover"> | string
    label_id?: StringFilter<"MRVApprover"> | string
    order?: IntFilter<"MRVApprover"> | number
    updated_by?: StringNullableFilter<"MRVApprover"> | string | null
    updated_at?: DateTimeFilter<"MRVApprover"> | Date | string
    metadata?: JsonNullableFilter<"MRVApprover">
    mrv?: XOR<MRVRelationFilter, MRVWhereInput>
  }

  export type MRVApproverOrderByWithRelationInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mrv?: MRVOrderByWithRelationInput
  }

  export type MRVApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mrv_id_label_id?: MRVApproverMrv_idLabel_idCompoundUniqueInput
    AND?: MRVApproverWhereInput | MRVApproverWhereInput[]
    OR?: MRVApproverWhereInput[]
    NOT?: MRVApproverWhereInput | MRVApproverWhereInput[]
    mrv_id?: StringFilter<"MRVApprover"> | string
    approver_id?: StringFilter<"MRVApprover"> | string
    date_approval?: DateTimeNullableFilter<"MRVApprover"> | Date | string | null
    notes?: StringFilter<"MRVApprover"> | string
    status?: IntFilter<"MRVApprover"> | number
    label?: StringFilter<"MRVApprover"> | string
    label_id?: StringFilter<"MRVApprover"> | string
    order?: IntFilter<"MRVApprover"> | number
    updated_by?: StringNullableFilter<"MRVApprover"> | string | null
    updated_at?: DateTimeFilter<"MRVApprover"> | Date | string
    metadata?: JsonNullableFilter<"MRVApprover">
    mrv?: XOR<MRVRelationFilter, MRVWhereInput>
  }, "id" | "mrv_id_label_id">

  export type MRVApproverOrderByWithAggregationInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MRVApproverCountOrderByAggregateInput
    _avg?: MRVApproverAvgOrderByAggregateInput
    _max?: MRVApproverMaxOrderByAggregateInput
    _min?: MRVApproverMinOrderByAggregateInput
    _sum?: MRVApproverSumOrderByAggregateInput
  }

  export type MRVApproverScalarWhereWithAggregatesInput = {
    AND?: MRVApproverScalarWhereWithAggregatesInput | MRVApproverScalarWhereWithAggregatesInput[]
    OR?: MRVApproverScalarWhereWithAggregatesInput[]
    NOT?: MRVApproverScalarWhereWithAggregatesInput | MRVApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MRVApprover"> | string
    mrv_id?: StringWithAggregatesFilter<"MRVApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MRVApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"MRVApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"MRVApprover"> | string
    status?: IntWithAggregatesFilter<"MRVApprover"> | number
    label?: StringWithAggregatesFilter<"MRVApprover"> | string
    label_id?: StringWithAggregatesFilter<"MRVApprover"> | string
    order?: IntWithAggregatesFilter<"MRVApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"MRVApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"MRVApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MRVApprover">
  }

  export type MRVItemWhereInput = {
    AND?: MRVItemWhereInput | MRVItemWhereInput[]
    OR?: MRVItemWhereInput[]
    NOT?: MRVItemWhereInput | MRVItemWhereInput[]
    id?: StringFilter<"MRVItem"> | string
    mrv_id?: StringFilter<"MRVItem"> | string
    item_id?: StringFilter<"MRVItem"> | string
    quantity?: IntFilter<"MRVItem"> | number
    price?: FloatFilter<"MRVItem"> | number
    created_by?: StringFilter<"MRVItem"> | string
    created_at?: DateTimeFilter<"MRVItem"> | Date | string
    metadata?: JsonNullableFilter<"MRVItem">
    mrv?: XOR<MRVRelationFilter, MRVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }

  export type MRVItemOrderByWithRelationInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mrv?: MRVOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
  }

  export type MRVItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MRVItemWhereInput | MRVItemWhereInput[]
    OR?: MRVItemWhereInput[]
    NOT?: MRVItemWhereInput | MRVItemWhereInput[]
    mrv_id?: StringFilter<"MRVItem"> | string
    item_id?: StringFilter<"MRVItem"> | string
    quantity?: IntFilter<"MRVItem"> | number
    price?: FloatFilter<"MRVItem"> | number
    created_by?: StringFilter<"MRVItem"> | string
    created_at?: DateTimeFilter<"MRVItem"> | Date | string
    metadata?: JsonNullableFilter<"MRVItem">
    mrv?: XOR<MRVRelationFilter, MRVWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }, "id">

  export type MRVItemOrderByWithAggregationInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MRVItemCountOrderByAggregateInput
    _avg?: MRVItemAvgOrderByAggregateInput
    _max?: MRVItemMaxOrderByAggregateInput
    _min?: MRVItemMinOrderByAggregateInput
    _sum?: MRVItemSumOrderByAggregateInput
  }

  export type MRVItemScalarWhereWithAggregatesInput = {
    AND?: MRVItemScalarWhereWithAggregatesInput | MRVItemScalarWhereWithAggregatesInput[]
    OR?: MRVItemScalarWhereWithAggregatesInput[]
    NOT?: MRVItemScalarWhereWithAggregatesInput | MRVItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MRVItem"> | string
    mrv_id?: StringWithAggregatesFilter<"MRVItem"> | string
    item_id?: StringWithAggregatesFilter<"MRVItem"> | string
    quantity?: IntWithAggregatesFilter<"MRVItem"> | number
    price?: FloatWithAggregatesFilter<"MRVItem"> | number
    created_by?: StringWithAggregatesFilter<"MRVItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"MRVItem"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MRVItem">
  }

  export type MCTWhereInput = {
    AND?: MCTWhereInput | MCTWhereInput[]
    OR?: MCTWhereInput[]
    NOT?: MCTWhereInput | MCTWhereInput[]
    id?: StringFilter<"MCT"> | string
    mrv_id?: StringNullableFilter<"MCT"> | string | null
    mrv_number?: StringFilter<"MCT"> | string
    mct_number?: StringFilter<"MCT"> | string
    mct_date?: DateTimeFilter<"MCT"> | Date | string
    is_completed?: BoolFilter<"MCT"> | boolean
    cancelled_by?: StringNullableFilter<"MCT"> | string | null
    created_by?: StringFilter<"MCT"> | string
    updated_by?: StringNullableFilter<"MCT"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MCT"> | Date | string | null
    created_at?: DateTimeFilter<"MCT"> | Date | string
    updated_at?: DateTimeFilter<"MCT"> | Date | string
    metadata?: JsonNullableFilter<"MCT">
    mrv?: XOR<MRVNullableRelationFilter, MRVWhereInput> | null
    mct_approvers?: MCTApproverListRelationFilter
    mcrts?: MCRTListRelationFilter
  }

  export type MCTOrderByWithRelationInput = {
    id?: SortOrder
    mrv_id?: SortOrderInput | SortOrder
    mrv_number?: SortOrder
    mct_number?: SortOrder
    mct_date?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mrv?: MRVOrderByWithRelationInput
    mct_approvers?: MCTApproverOrderByRelationAggregateInput
    mcrts?: MCRTOrderByRelationAggregateInput
  }

  export type MCTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mrv_id?: string
    mct_number?: string
    AND?: MCTWhereInput | MCTWhereInput[]
    OR?: MCTWhereInput[]
    NOT?: MCTWhereInput | MCTWhereInput[]
    mrv_number?: StringFilter<"MCT"> | string
    mct_date?: DateTimeFilter<"MCT"> | Date | string
    is_completed?: BoolFilter<"MCT"> | boolean
    cancelled_by?: StringNullableFilter<"MCT"> | string | null
    created_by?: StringFilter<"MCT"> | string
    updated_by?: StringNullableFilter<"MCT"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MCT"> | Date | string | null
    created_at?: DateTimeFilter<"MCT"> | Date | string
    updated_at?: DateTimeFilter<"MCT"> | Date | string
    metadata?: JsonNullableFilter<"MCT">
    mrv?: XOR<MRVNullableRelationFilter, MRVWhereInput> | null
    mct_approvers?: MCTApproverListRelationFilter
    mcrts?: MCRTListRelationFilter
  }, "id" | "mrv_id" | "mct_number">

  export type MCTOrderByWithAggregationInput = {
    id?: SortOrder
    mrv_id?: SortOrderInput | SortOrder
    mrv_number?: SortOrder
    mct_number?: SortOrder
    mct_date?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MCTCountOrderByAggregateInput
    _max?: MCTMaxOrderByAggregateInput
    _min?: MCTMinOrderByAggregateInput
  }

  export type MCTScalarWhereWithAggregatesInput = {
    AND?: MCTScalarWhereWithAggregatesInput | MCTScalarWhereWithAggregatesInput[]
    OR?: MCTScalarWhereWithAggregatesInput[]
    NOT?: MCTScalarWhereWithAggregatesInput | MCTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCT"> | string
    mrv_id?: StringNullableWithAggregatesFilter<"MCT"> | string | null
    mrv_number?: StringWithAggregatesFilter<"MCT"> | string
    mct_number?: StringWithAggregatesFilter<"MCT"> | string
    mct_date?: DateTimeWithAggregatesFilter<"MCT"> | Date | string
    is_completed?: BoolWithAggregatesFilter<"MCT"> | boolean
    cancelled_by?: StringNullableWithAggregatesFilter<"MCT"> | string | null
    created_by?: StringWithAggregatesFilter<"MCT"> | string
    updated_by?: StringNullableWithAggregatesFilter<"MCT"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"MCT"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MCT"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MCT"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MCT">
  }

  export type MCTApproverWhereInput = {
    AND?: MCTApproverWhereInput | MCTApproverWhereInput[]
    OR?: MCTApproverWhereInput[]
    NOT?: MCTApproverWhereInput | MCTApproverWhereInput[]
    id?: StringFilter<"MCTApprover"> | string
    mct_id?: StringFilter<"MCTApprover"> | string
    approver_id?: StringFilter<"MCTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCTApprover"> | Date | string | null
    notes?: StringFilter<"MCTApprover"> | string
    status?: IntFilter<"MCTApprover"> | number
    label?: StringFilter<"MCTApprover"> | string
    label_id?: StringFilter<"MCTApprover"> | string
    order?: IntFilter<"MCTApprover"> | number
    updated_by?: StringNullableFilter<"MCTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCTApprover">
    mct?: XOR<MCTRelationFilter, MCTWhereInput>
  }

  export type MCTApproverOrderByWithRelationInput = {
    id?: SortOrder
    mct_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mct?: MCTOrderByWithRelationInput
  }

  export type MCTApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MCTApproverWhereInput | MCTApproverWhereInput[]
    OR?: MCTApproverWhereInput[]
    NOT?: MCTApproverWhereInput | MCTApproverWhereInput[]
    mct_id?: StringFilter<"MCTApprover"> | string
    approver_id?: StringFilter<"MCTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCTApprover"> | Date | string | null
    notes?: StringFilter<"MCTApprover"> | string
    status?: IntFilter<"MCTApprover"> | number
    label?: StringFilter<"MCTApprover"> | string
    label_id?: StringFilter<"MCTApprover"> | string
    order?: IntFilter<"MCTApprover"> | number
    updated_by?: StringNullableFilter<"MCTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCTApprover">
    mct?: XOR<MCTRelationFilter, MCTWhereInput>
  }, "id">

  export type MCTApproverOrderByWithAggregationInput = {
    id?: SortOrder
    mct_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MCTApproverCountOrderByAggregateInput
    _avg?: MCTApproverAvgOrderByAggregateInput
    _max?: MCTApproverMaxOrderByAggregateInput
    _min?: MCTApproverMinOrderByAggregateInput
    _sum?: MCTApproverSumOrderByAggregateInput
  }

  export type MCTApproverScalarWhereWithAggregatesInput = {
    AND?: MCTApproverScalarWhereWithAggregatesInput | MCTApproverScalarWhereWithAggregatesInput[]
    OR?: MCTApproverScalarWhereWithAggregatesInput[]
    NOT?: MCTApproverScalarWhereWithAggregatesInput | MCTApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCTApprover"> | string
    mct_id?: StringWithAggregatesFilter<"MCTApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MCTApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"MCTApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"MCTApprover"> | string
    status?: IntWithAggregatesFilter<"MCTApprover"> | number
    label?: StringWithAggregatesFilter<"MCTApprover"> | string
    label_id?: StringWithAggregatesFilter<"MCTApprover"> | string
    order?: IntWithAggregatesFilter<"MCTApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"MCTApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"MCTApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MCTApprover">
  }

  export type MCRTWhereInput = {
    AND?: MCRTWhereInput | MCRTWhereInput[]
    OR?: MCRTWhereInput[]
    NOT?: MCRTWhereInput | MCRTWhereInput[]
    id?: StringFilter<"MCRT"> | string
    mct_id?: StringNullableFilter<"MCRT"> | string | null
    mct_number?: StringNullableFilter<"MCRT"> | string | null
    seriv_id?: StringNullableFilter<"MCRT"> | string | null
    seriv_number?: StringNullableFilter<"MCRT"> | string | null
    mcrt_number?: StringFilter<"MCRT"> | string
    mcrt_date?: DateTimeFilter<"MCRT"> | Date | string
    is_completed?: BoolFilter<"MCRT"> | boolean
    returned_by_id?: StringFilter<"MCRT"> | string
    wo_number?: StringNullableFilter<"MCRT"> | string | null
    mo_number?: StringNullableFilter<"MCRT"> | string | null
    jo_number?: StringNullableFilter<"MCRT"> | string | null
    note?: StringFilter<"MCRT"> | string
    cancelled_by?: StringNullableFilter<"MCRT"> | string | null
    created_by?: StringFilter<"MCRT"> | string
    updated_by?: StringNullableFilter<"MCRT"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MCRT"> | Date | string | null
    created_at?: DateTimeFilter<"MCRT"> | Date | string
    updated_at?: DateTimeFilter<"MCRT"> | Date | string
    metadata?: JsonNullableFilter<"MCRT">
    mct?: XOR<MCTNullableRelationFilter, MCTWhereInput> | null
    seriv?: XOR<SERIVNullableRelationFilter, SERIVWhereInput> | null
    mcrt_approvers?: MCRTApproverListRelationFilter
    mcrt_items?: MCRTItemListRelationFilter
  }

  export type MCRTOrderByWithRelationInput = {
    id?: SortOrder
    mct_id?: SortOrderInput | SortOrder
    mct_number?: SortOrderInput | SortOrder
    seriv_id?: SortOrderInput | SortOrder
    seriv_number?: SortOrderInput | SortOrder
    mcrt_number?: SortOrder
    mcrt_date?: SortOrder
    is_completed?: SortOrder
    returned_by_id?: SortOrder
    wo_number?: SortOrderInput | SortOrder
    mo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    note?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mct?: MCTOrderByWithRelationInput
    seriv?: SERIVOrderByWithRelationInput
    mcrt_approvers?: MCRTApproverOrderByRelationAggregateInput
    mcrt_items?: MCRTItemOrderByRelationAggregateInput
  }

  export type MCRTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mcrt_number?: string
    AND?: MCRTWhereInput | MCRTWhereInput[]
    OR?: MCRTWhereInput[]
    NOT?: MCRTWhereInput | MCRTWhereInput[]
    mct_id?: StringNullableFilter<"MCRT"> | string | null
    mct_number?: StringNullableFilter<"MCRT"> | string | null
    seriv_id?: StringNullableFilter<"MCRT"> | string | null
    seriv_number?: StringNullableFilter<"MCRT"> | string | null
    mcrt_date?: DateTimeFilter<"MCRT"> | Date | string
    is_completed?: BoolFilter<"MCRT"> | boolean
    returned_by_id?: StringFilter<"MCRT"> | string
    wo_number?: StringNullableFilter<"MCRT"> | string | null
    mo_number?: StringNullableFilter<"MCRT"> | string | null
    jo_number?: StringNullableFilter<"MCRT"> | string | null
    note?: StringFilter<"MCRT"> | string
    cancelled_by?: StringNullableFilter<"MCRT"> | string | null
    created_by?: StringFilter<"MCRT"> | string
    updated_by?: StringNullableFilter<"MCRT"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MCRT"> | Date | string | null
    created_at?: DateTimeFilter<"MCRT"> | Date | string
    updated_at?: DateTimeFilter<"MCRT"> | Date | string
    metadata?: JsonNullableFilter<"MCRT">
    mct?: XOR<MCTNullableRelationFilter, MCTWhereInput> | null
    seriv?: XOR<SERIVNullableRelationFilter, SERIVWhereInput> | null
    mcrt_approvers?: MCRTApproverListRelationFilter
    mcrt_items?: MCRTItemListRelationFilter
  }, "id" | "mcrt_number">

  export type MCRTOrderByWithAggregationInput = {
    id?: SortOrder
    mct_id?: SortOrderInput | SortOrder
    mct_number?: SortOrderInput | SortOrder
    seriv_id?: SortOrderInput | SortOrder
    seriv_number?: SortOrderInput | SortOrder
    mcrt_number?: SortOrder
    mcrt_date?: SortOrder
    is_completed?: SortOrder
    returned_by_id?: SortOrder
    wo_number?: SortOrderInput | SortOrder
    mo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    note?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MCRTCountOrderByAggregateInput
    _max?: MCRTMaxOrderByAggregateInput
    _min?: MCRTMinOrderByAggregateInput
  }

  export type MCRTScalarWhereWithAggregatesInput = {
    AND?: MCRTScalarWhereWithAggregatesInput | MCRTScalarWhereWithAggregatesInput[]
    OR?: MCRTScalarWhereWithAggregatesInput[]
    NOT?: MCRTScalarWhereWithAggregatesInput | MCRTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCRT"> | string
    mct_id?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    mct_number?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    seriv_id?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    seriv_number?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    mcrt_number?: StringWithAggregatesFilter<"MCRT"> | string
    mcrt_date?: DateTimeWithAggregatesFilter<"MCRT"> | Date | string
    is_completed?: BoolWithAggregatesFilter<"MCRT"> | boolean
    returned_by_id?: StringWithAggregatesFilter<"MCRT"> | string
    wo_number?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    mo_number?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    jo_number?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    note?: StringWithAggregatesFilter<"MCRT"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    created_by?: StringWithAggregatesFilter<"MCRT"> | string
    updated_by?: StringNullableWithAggregatesFilter<"MCRT"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"MCRT"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MCRT"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MCRT"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MCRT">
  }

  export type MCRTApproverWhereInput = {
    AND?: MCRTApproverWhereInput | MCRTApproverWhereInput[]
    OR?: MCRTApproverWhereInput[]
    NOT?: MCRTApproverWhereInput | MCRTApproverWhereInput[]
    id?: StringFilter<"MCRTApprover"> | string
    mcrt_id?: StringFilter<"MCRTApprover"> | string
    approver_id?: StringFilter<"MCRTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCRTApprover"> | Date | string | null
    notes?: StringFilter<"MCRTApprover"> | string
    status?: IntFilter<"MCRTApprover"> | number
    label?: StringFilter<"MCRTApprover"> | string
    label_id?: StringFilter<"MCRTApprover"> | string
    order?: IntFilter<"MCRTApprover"> | number
    updated_by?: StringNullableFilter<"MCRTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCRTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCRTApprover">
    mcrt?: XOR<MCRTRelationFilter, MCRTWhereInput>
  }

  export type MCRTApproverOrderByWithRelationInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mcrt?: MCRTOrderByWithRelationInput
  }

  export type MCRTApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MCRTApproverWhereInput | MCRTApproverWhereInput[]
    OR?: MCRTApproverWhereInput[]
    NOT?: MCRTApproverWhereInput | MCRTApproverWhereInput[]
    mcrt_id?: StringFilter<"MCRTApprover"> | string
    approver_id?: StringFilter<"MCRTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCRTApprover"> | Date | string | null
    notes?: StringFilter<"MCRTApprover"> | string
    status?: IntFilter<"MCRTApprover"> | number
    label?: StringFilter<"MCRTApprover"> | string
    label_id?: StringFilter<"MCRTApprover"> | string
    order?: IntFilter<"MCRTApprover"> | number
    updated_by?: StringNullableFilter<"MCRTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCRTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCRTApprover">
    mcrt?: XOR<MCRTRelationFilter, MCRTWhereInput>
  }, "id">

  export type MCRTApproverOrderByWithAggregationInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MCRTApproverCountOrderByAggregateInput
    _avg?: MCRTApproverAvgOrderByAggregateInput
    _max?: MCRTApproverMaxOrderByAggregateInput
    _min?: MCRTApproverMinOrderByAggregateInput
    _sum?: MCRTApproverSumOrderByAggregateInput
  }

  export type MCRTApproverScalarWhereWithAggregatesInput = {
    AND?: MCRTApproverScalarWhereWithAggregatesInput | MCRTApproverScalarWhereWithAggregatesInput[]
    OR?: MCRTApproverScalarWhereWithAggregatesInput[]
    NOT?: MCRTApproverScalarWhereWithAggregatesInput | MCRTApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCRTApprover"> | string
    mcrt_id?: StringWithAggregatesFilter<"MCRTApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MCRTApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"MCRTApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"MCRTApprover"> | string
    status?: IntWithAggregatesFilter<"MCRTApprover"> | number
    label?: StringWithAggregatesFilter<"MCRTApprover"> | string
    label_id?: StringWithAggregatesFilter<"MCRTApprover"> | string
    order?: IntWithAggregatesFilter<"MCRTApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"MCRTApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"MCRTApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MCRTApprover">
  }

  export type MCRTItemWhereInput = {
    AND?: MCRTItemWhereInput | MCRTItemWhereInput[]
    OR?: MCRTItemWhereInput[]
    NOT?: MCRTItemWhereInput | MCRTItemWhereInput[]
    id?: StringFilter<"MCRTItem"> | string
    mcrt_id?: StringFilter<"MCRTItem"> | string
    item_id?: StringFilter<"MCRTItem"> | string
    quantity?: IntFilter<"MCRTItem"> | number
    price?: FloatFilter<"MCRTItem"> | number
    created_by?: StringFilter<"MCRTItem"> | string
    created_at?: DateTimeFilter<"MCRTItem"> | Date | string
    metadata?: JsonNullableFilter<"MCRTItem">
    mcrt?: XOR<MCRTRelationFilter, MCRTWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }

  export type MCRTItemOrderByWithRelationInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mcrt?: MCRTOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
  }

  export type MCRTItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MCRTItemWhereInput | MCRTItemWhereInput[]
    OR?: MCRTItemWhereInput[]
    NOT?: MCRTItemWhereInput | MCRTItemWhereInput[]
    mcrt_id?: StringFilter<"MCRTItem"> | string
    item_id?: StringFilter<"MCRTItem"> | string
    quantity?: IntFilter<"MCRTItem"> | number
    price?: FloatFilter<"MCRTItem"> | number
    created_by?: StringFilter<"MCRTItem"> | string
    created_at?: DateTimeFilter<"MCRTItem"> | Date | string
    metadata?: JsonNullableFilter<"MCRTItem">
    mcrt?: XOR<MCRTRelationFilter, MCRTWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }, "id">

  export type MCRTItemOrderByWithAggregationInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MCRTItemCountOrderByAggregateInput
    _avg?: MCRTItemAvgOrderByAggregateInput
    _max?: MCRTItemMaxOrderByAggregateInput
    _min?: MCRTItemMinOrderByAggregateInput
    _sum?: MCRTItemSumOrderByAggregateInput
  }

  export type MCRTItemScalarWhereWithAggregatesInput = {
    AND?: MCRTItemScalarWhereWithAggregatesInput | MCRTItemScalarWhereWithAggregatesInput[]
    OR?: MCRTItemScalarWhereWithAggregatesInput[]
    NOT?: MCRTItemScalarWhereWithAggregatesInput | MCRTItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCRTItem"> | string
    mcrt_id?: StringWithAggregatesFilter<"MCRTItem"> | string
    item_id?: StringWithAggregatesFilter<"MCRTItem"> | string
    quantity?: IntWithAggregatesFilter<"MCRTItem"> | number
    price?: FloatWithAggregatesFilter<"MCRTItem"> | number
    created_by?: StringWithAggregatesFilter<"MCRTItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"MCRTItem"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MCRTItem">
  }

  export type MSTWhereInput = {
    AND?: MSTWhereInput | MSTWhereInput[]
    OR?: MSTWhereInput[]
    NOT?: MSTWhereInput | MSTWhereInput[]
    id?: StringFilter<"MST"> | string
    mst_number?: StringFilter<"MST"> | string
    mst_date?: DateTimeFilter<"MST"> | Date | string
    returned_by_id?: StringFilter<"MST"> | string
    cwo_number?: StringNullableFilter<"MST"> | string | null
    mwo_number?: StringNullableFilter<"MST"> | string | null
    jo_number?: StringNullableFilter<"MST"> | string | null
    remarks?: StringFilter<"MST"> | string
    cancelled_by?: StringNullableFilter<"MST"> | string | null
    created_by?: StringFilter<"MST"> | string
    updated_by?: StringNullableFilter<"MST"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MST"> | Date | string | null
    created_at?: DateTimeFilter<"MST"> | Date | string
    updated_at?: DateTimeFilter<"MST"> | Date | string
    metadata?: JsonNullableFilter<"MST">
    mst_approvers?: MSTApproverListRelationFilter
    mst_items?: MSTItemListRelationFilter
  }

  export type MSTOrderByWithRelationInput = {
    id?: SortOrder
    mst_number?: SortOrder
    mst_date?: SortOrder
    returned_by_id?: SortOrder
    cwo_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    remarks?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mst_approvers?: MSTApproverOrderByRelationAggregateInput
    mst_items?: MSTItemOrderByRelationAggregateInput
  }

  export type MSTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mst_number?: string
    AND?: MSTWhereInput | MSTWhereInput[]
    OR?: MSTWhereInput[]
    NOT?: MSTWhereInput | MSTWhereInput[]
    mst_date?: DateTimeFilter<"MST"> | Date | string
    returned_by_id?: StringFilter<"MST"> | string
    cwo_number?: StringNullableFilter<"MST"> | string | null
    mwo_number?: StringNullableFilter<"MST"> | string | null
    jo_number?: StringNullableFilter<"MST"> | string | null
    remarks?: StringFilter<"MST"> | string
    cancelled_by?: StringNullableFilter<"MST"> | string | null
    created_by?: StringFilter<"MST"> | string
    updated_by?: StringNullableFilter<"MST"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MST"> | Date | string | null
    created_at?: DateTimeFilter<"MST"> | Date | string
    updated_at?: DateTimeFilter<"MST"> | Date | string
    metadata?: JsonNullableFilter<"MST">
    mst_approvers?: MSTApproverListRelationFilter
    mst_items?: MSTItemListRelationFilter
  }, "id" | "mst_number">

  export type MSTOrderByWithAggregationInput = {
    id?: SortOrder
    mst_number?: SortOrder
    mst_date?: SortOrder
    returned_by_id?: SortOrder
    cwo_number?: SortOrderInput | SortOrder
    mwo_number?: SortOrderInput | SortOrder
    jo_number?: SortOrderInput | SortOrder
    remarks?: SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MSTCountOrderByAggregateInput
    _max?: MSTMaxOrderByAggregateInput
    _min?: MSTMinOrderByAggregateInput
  }

  export type MSTScalarWhereWithAggregatesInput = {
    AND?: MSTScalarWhereWithAggregatesInput | MSTScalarWhereWithAggregatesInput[]
    OR?: MSTScalarWhereWithAggregatesInput[]
    NOT?: MSTScalarWhereWithAggregatesInput | MSTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MST"> | string
    mst_number?: StringWithAggregatesFilter<"MST"> | string
    mst_date?: DateTimeWithAggregatesFilter<"MST"> | Date | string
    returned_by_id?: StringWithAggregatesFilter<"MST"> | string
    cwo_number?: StringNullableWithAggregatesFilter<"MST"> | string | null
    mwo_number?: StringNullableWithAggregatesFilter<"MST"> | string | null
    jo_number?: StringNullableWithAggregatesFilter<"MST"> | string | null
    remarks?: StringWithAggregatesFilter<"MST"> | string
    cancelled_by?: StringNullableWithAggregatesFilter<"MST"> | string | null
    created_by?: StringWithAggregatesFilter<"MST"> | string
    updated_by?: StringNullableWithAggregatesFilter<"MST"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"MST"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MST"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MST"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MST">
  }

  export type MSTApproverWhereInput = {
    AND?: MSTApproverWhereInput | MSTApproverWhereInput[]
    OR?: MSTApproverWhereInput[]
    NOT?: MSTApproverWhereInput | MSTApproverWhereInput[]
    id?: StringFilter<"MSTApprover"> | string
    mst_id?: StringFilter<"MSTApprover"> | string
    approver_id?: StringFilter<"MSTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MSTApprover"> | Date | string | null
    notes?: StringFilter<"MSTApprover"> | string
    status?: IntFilter<"MSTApprover"> | number
    label?: StringFilter<"MSTApprover"> | string
    label_id?: StringFilter<"MSTApprover"> | string
    order?: IntFilter<"MSTApprover"> | number
    updated_by?: StringNullableFilter<"MSTApprover"> | string | null
    updated_at?: DateTimeFilter<"MSTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MSTApprover">
    mst?: XOR<MSTRelationFilter, MSTWhereInput>
  }

  export type MSTApproverOrderByWithRelationInput = {
    id?: SortOrder
    mst_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mst?: MSTOrderByWithRelationInput
  }

  export type MSTApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MSTApproverWhereInput | MSTApproverWhereInput[]
    OR?: MSTApproverWhereInput[]
    NOT?: MSTApproverWhereInput | MSTApproverWhereInput[]
    mst_id?: StringFilter<"MSTApprover"> | string
    approver_id?: StringFilter<"MSTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MSTApprover"> | Date | string | null
    notes?: StringFilter<"MSTApprover"> | string
    status?: IntFilter<"MSTApprover"> | number
    label?: StringFilter<"MSTApprover"> | string
    label_id?: StringFilter<"MSTApprover"> | string
    order?: IntFilter<"MSTApprover"> | number
    updated_by?: StringNullableFilter<"MSTApprover"> | string | null
    updated_at?: DateTimeFilter<"MSTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MSTApprover">
    mst?: XOR<MSTRelationFilter, MSTWhereInput>
  }, "id">

  export type MSTApproverOrderByWithAggregationInput = {
    id?: SortOrder
    mst_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MSTApproverCountOrderByAggregateInput
    _avg?: MSTApproverAvgOrderByAggregateInput
    _max?: MSTApproverMaxOrderByAggregateInput
    _min?: MSTApproverMinOrderByAggregateInput
    _sum?: MSTApproverSumOrderByAggregateInput
  }

  export type MSTApproverScalarWhereWithAggregatesInput = {
    AND?: MSTApproverScalarWhereWithAggregatesInput | MSTApproverScalarWhereWithAggregatesInput[]
    OR?: MSTApproverScalarWhereWithAggregatesInput[]
    NOT?: MSTApproverScalarWhereWithAggregatesInput | MSTApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MSTApprover"> | string
    mst_id?: StringWithAggregatesFilter<"MSTApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MSTApprover"> | string
    date_approval?: DateTimeNullableWithAggregatesFilter<"MSTApprover"> | Date | string | null
    notes?: StringWithAggregatesFilter<"MSTApprover"> | string
    status?: IntWithAggregatesFilter<"MSTApprover"> | number
    label?: StringWithAggregatesFilter<"MSTApprover"> | string
    label_id?: StringWithAggregatesFilter<"MSTApprover"> | string
    order?: IntWithAggregatesFilter<"MSTApprover"> | number
    updated_by?: StringNullableWithAggregatesFilter<"MSTApprover"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"MSTApprover"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MSTApprover">
  }

  export type MSTItemWhereInput = {
    AND?: MSTItemWhereInput | MSTItemWhereInput[]
    OR?: MSTItemWhereInput[]
    NOT?: MSTItemWhereInput | MSTItemWhereInput[]
    id?: StringFilter<"MSTItem"> | string
    mst_id?: StringFilter<"MSTItem"> | string
    item_id?: StringFilter<"MSTItem"> | string
    quantity?: IntFilter<"MSTItem"> | number
    price?: FloatFilter<"MSTItem"> | number
    status?: IntFilter<"MSTItem"> | number
    created_by?: StringFilter<"MSTItem"> | string
    created_at?: DateTimeFilter<"MSTItem"> | Date | string
    metadata?: JsonNullableFilter<"MSTItem">
    mst?: XOR<MSTRelationFilter, MSTWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type MSTItemOrderByWithRelationInput = {
    id?: SortOrder
    mst_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    mst?: MSTOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type MSTItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MSTItemWhereInput | MSTItemWhereInput[]
    OR?: MSTItemWhereInput[]
    NOT?: MSTItemWhereInput | MSTItemWhereInput[]
    mst_id?: StringFilter<"MSTItem"> | string
    item_id?: StringFilter<"MSTItem"> | string
    quantity?: IntFilter<"MSTItem"> | number
    price?: FloatFilter<"MSTItem"> | number
    status?: IntFilter<"MSTItem"> | number
    created_by?: StringFilter<"MSTItem"> | string
    created_at?: DateTimeFilter<"MSTItem"> | Date | string
    metadata?: JsonNullableFilter<"MSTItem">
    mst?: XOR<MSTRelationFilter, MSTWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id">

  export type MSTItemOrderByWithAggregationInput = {
    id?: SortOrder
    mst_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MSTItemCountOrderByAggregateInput
    _avg?: MSTItemAvgOrderByAggregateInput
    _max?: MSTItemMaxOrderByAggregateInput
    _min?: MSTItemMinOrderByAggregateInput
    _sum?: MSTItemSumOrderByAggregateInput
  }

  export type MSTItemScalarWhereWithAggregatesInput = {
    AND?: MSTItemScalarWhereWithAggregatesInput | MSTItemScalarWhereWithAggregatesInput[]
    OR?: MSTItemScalarWhereWithAggregatesInput[]
    NOT?: MSTItemScalarWhereWithAggregatesInput | MSTItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MSTItem"> | string
    mst_id?: StringWithAggregatesFilter<"MSTItem"> | string
    item_id?: StringWithAggregatesFilter<"MSTItem"> | string
    quantity?: IntWithAggregatesFilter<"MSTItem"> | number
    price?: FloatWithAggregatesFilter<"MSTItem"> | number
    status?: IntWithAggregatesFilter<"MSTItem"> | number
    created_by?: StringWithAggregatesFilter<"MSTItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"MSTItem"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"MSTItem">
  }

  export type ItemTypeCreateInput = {
    code: string
    name: string
    items?: ItemCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: number
    code: string
    name: string
  }

  export type ItemTypeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contact: string
    tin?: string
    address?: string
    vat_type?: number
    is_vat_registered?: boolean
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    MEQSSupplier?: MEQSSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contact: string
    tin?: string
    address?: string
    vat_type?: number
    is_vat_registered?: boolean
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    MEQSSupplier?: MEQSSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    MEQSSupplier?: MEQSSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    MEQSSupplier?: MEQSSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contact: string
    tin?: string
    address?: string
    vat_type?: number
    is_vat_registered?: boolean
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UnitCreateInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutUnitInput
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutUnitInput
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutUnitNestedInput
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutUnitNestedInput
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleCreateInput = {
    id?: string
    name: string
    plate_number: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sprs?: SPRCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    name: string
    plate_number: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sprs?: SPRUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sprs?: SPRUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sprs?: SPRUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    name: string
    plate_number: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationCreateInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationCreateNestedManyWithoutStationInput
    osrivs?: OSRIVCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVCreateNestedManyWithoutItem_fromInput
  }

  export type StationUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedCreateNestedManyWithoutStationInput
    osrivs?: OSRIVUncheckedCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVUncheckedCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVUncheckedCreateNestedManyWithoutItem_fromInput
  }

  export type StationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUpdateManyWithoutItem_fromNestedInput
  }

  export type StationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUncheckedUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUncheckedUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUncheckedUpdateManyWithoutItem_fromNestedInput
  }

  export type StationCreateManyInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PendingCreateInput = {
    approver_id: string
    reference_number: string
    reference_table: string
    description: string
    transaction_date?: Date | string
  }

  export type PendingUncheckedCreateInput = {
    id?: number
    approver_id: string
    reference_number: string
    reference_table: string
    description: string
    transaction_date?: Date | string
  }

  export type PendingUpdateInput = {
    approver_id?: StringFieldUpdateOperationsInput | string
    reference_number?: StringFieldUpdateOperationsInput | string
    reference_table?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver_id?: StringFieldUpdateOperationsInput | string
    reference_number?: StringFieldUpdateOperationsInput | string
    reference_table?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCreateManyInput = {
    id?: number
    approver_id: string
    reference_number: string
    reference_table: string
    description: string
    transaction_date?: Date | string
  }

  export type PendingUpdateManyMutationInput = {
    approver_id?: StringFieldUpdateOperationsInput | string
    reference_number?: StringFieldUpdateOperationsInput | string
    reference_table?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    approver_id?: StringFieldUpdateOperationsInput | string
    reference_number?: StringFieldUpdateOperationsInput | string
    reference_table?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    key: string
    value: string
  }

  export type SettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
  }

  export type SettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type SettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationCreateInput = {
    id?: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_locationsInput
    station: StationCreateNestedOneWithoutItemsInput
    origin_movements?: ItemMovementCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationUncheckedCreateInput = {
    id?: string
    item_id: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_locationsNestedInput
    station?: StationUpdateOneRequiredWithoutItemsNestedInput
    origin_movements?: ItemMovementUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationCreateManyInput = {
    id?: string
    item_id: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateInput = {
    id?: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin: ItemLocationCreateNestedOneWithoutOrigin_movementsInput
    destination: ItemLocationCreateNestedOneWithoutDestination_movementsInput
  }

  export type ItemMovementUncheckedCreateInput = {
    id?: string
    origin_id: string
    destination_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin?: ItemLocationUpdateOneRequiredWithoutOrigin_movementsNestedInput
    destination?: ItemLocationUpdateOneRequiredWithoutDestination_movementsNestedInput
  }

  export type ItemMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: StringFieldUpdateOperationsInput | string
    destination_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateManyInput = {
    id?: string
    origin_id: string
    destination_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: StringFieldUpdateOperationsInput | string
    destination_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateManyInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemCodeTrackerCreateInput = {
    item_code: string
    year: number
    last_incremental: number
  }

  export type ItemCodeTrackerUncheckedCreateInput = {
    id?: number
    item_code: string
    year: number
    last_incremental: number
  }

  export type ItemCodeTrackerUpdateInput = {
    item_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    last_incremental?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCodeTrackerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    last_incremental?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCodeTrackerCreateManyInput = {
    id?: number
    item_code: string
    year: number
    last_incremental: number
  }

  export type ItemCodeTrackerUpdateManyMutationInput = {
    item_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    last_incremental?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCodeTrackerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    last_incremental?: IntFieldUpdateOperationsInput | number
  }

  export type CanvassCreateInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassCreateManyInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateInput = {
    id?: string
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    unit?: UnitCreateNestedOneWithoutCanvass_itemsInput
    item?: ItemCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateInput = {
    id?: string
    canvass_id: string
    unit_id?: string | null
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneWithoutCanvass_itemsNestedInput
    item?: ItemUpdateOneWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemCreateManyInput = {
    id?: string
    canvass_id: string
    unit_id?: string | null
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVCreateInput = {
    id?: string
    rv_number: string
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutRvInput
    meqs?: MEQSCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateInput = {
    id?: string
    rv_number: string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutRvNestedInput
    meqs?: MEQSUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type RVCreateManyInput = {
    id?: string
    rv_number: string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv: RVCreateNestedOneWithoutRv_approversInput
  }

  export type RVApproverUncheckedCreateInput = {
    id?: string
    rv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv?: RVUpdateOneRequiredWithoutRv_approversNestedInput
  }

  export type RVApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverCreateManyInput = {
    id?: string
    rv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOCreateInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutJoInput
    meqs?: MEQSCreateNestedOneWithoutJoInput
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
  }

  export type JOUncheckedCreateInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id?: string | null
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
  }

  export type JOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutJoNestedInput
    meqs?: MEQSUpdateOneWithoutJoNestedInput
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
  }

  export type JOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
  }

  export type JOCreateManyInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id?: string | null
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo: JOCreateNestedOneWithoutJo_approversInput
  }

  export type JOApproverUncheckedCreateInput = {
    id?: string
    jo_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneRequiredWithoutJo_approversNestedInput
  }

  export type JOApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverCreateManyInput = {
    id?: string
    jo_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRCreateInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutSprInput
    meqs?: MEQSCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutSprNestedInput
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type SPRCreateManyInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spr: SPRCreateNestedOneWithoutSpr_approversInput
  }

  export type SPRApproverUncheckedCreateInput = {
    id?: string
    spr_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spr?: SPRUpdateOneRequiredWithoutSpr_approversNestedInput
  }

  export type SPRApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverCreateManyInput = {
    id?: string
    spr_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSCreateInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSCreateManyInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierCreateInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierCreateManyInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemCreateInput = {
    id?: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item: CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput
    rr_items?: RRItemCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemUncheckedCreateInput = {
    id?: string
    meqs_supplier_id: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item?: CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    rr_items?: RRItemUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemCreateManyInput = {
    id?: string
    meqs_supplier_id: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentCreateInput = {
    id?: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutAttachmentsInput
  }

  export type MEQSSupplierAttachmentUncheckedCreateInput = {
    id?: string
    meqs_supplier_id: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MEQSSupplierAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentCreateManyInput = {
    id?: string
    meqs_supplier_id: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_approversInput
  }

  export type MEQSApproverUncheckedCreateInput = {
    id?: string
    meqs_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_approversNestedInput
  }

  export type MEQSApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverCreateManyInput = {
    id?: string
    meqs_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POCreateInput = {
    id?: string
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierCreateNestedOneWithoutPoInput
    rrs?: RRCreateNestedManyWithoutPoInput
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
  }

  export type POUncheckedCreateInput = {
    id?: string
    meqs_supplier_id?: string | null
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedCreateNestedManyWithoutPoInput
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
  }

  export type POUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierUpdateOneWithoutPoNestedInput
    rrs?: RRUpdateManyWithoutPoNestedInput
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
  }

  export type POUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedUpdateManyWithoutPoNestedInput
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
  }

  export type POCreateManyInput = {
    id?: string
    meqs_supplier_id?: string | null
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po: POCreateNestedOneWithoutPo_approversInput
  }

  export type POApproverUncheckedCreateInput = {
    id?: string
    po_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POUpdateOneRequiredWithoutPo_approversNestedInput
  }

  export type POApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverCreateManyInput = {
    id?: string
    po_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRCreateInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POCreateNestedOneWithoutRrsInput
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateInput = {
    id?: string
    po_id?: string | null
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POUpdateOneWithoutRrsNestedInput
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type RRCreateManyInput = {
    id?: string
    po_id?: string | null
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr: RRCreateNestedOneWithoutRr_approversInput
  }

  export type RRApproverUncheckedCreateInput = {
    id?: string
    rr_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr?: RRUpdateOneRequiredWithoutRr_approversNestedInput
  }

  export type RRApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverCreateManyInput = {
    id?: string
    rr_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemCreateInput = {
    id?: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
    meqs_supplier_item: MEQSSupplierItemCreateNestedOneWithoutRr_itemsInput
  }

  export type RRItemUncheckedCreateInput = {
    id?: string
    rr_id: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
    meqs_supplier_item?: MEQSSupplierItemUpdateOneRequiredWithoutRr_itemsNestedInput
  }

  export type RRItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_item_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemCreateManyInput = {
    id?: string
    rr_id: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_item_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVCreateInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutOsrivsInput
    osriv_approvers?: OSRIVApproverCreateNestedManyWithoutOsrivInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVUncheckedCreateInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedCreateNestedManyWithoutOsrivInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutOsrivsNestedInput
    osriv_approvers?: OSRIVApproverUpdateManyWithoutOsrivNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedUpdateManyWithoutOsrivNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVCreateManyInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv: OSRIVCreateNestedOneWithoutOsriv_approversInput
  }

  export type OSRIVApproverUncheckedCreateInput = {
    id?: string
    osriv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv?: OSRIVUpdateOneRequiredWithoutOsriv_approversNestedInput
  }

  export type OSRIVApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverCreateManyInput = {
    id?: string
    osriv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemCreateInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv: OSRIVCreateNestedOneWithoutOsriv_itemsInput
    item: ItemCreateNestedOneWithoutOsriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemUncheckedCreateInput = {
    id?: string
    osriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv?: OSRIVUpdateOneRequiredWithoutOsriv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutOsriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemCreateManyInput = {
    id?: string
    osriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVCreateInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutSerivsInput
    seriv_approvers?: SERIVApproverCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemCreateNestedManyWithoutSerivInput
    mcrts?: MCRTCreateNestedManyWithoutSerivInput
  }

  export type SERIVUncheckedCreateInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutSerivInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutSerivInput
  }

  export type SERIVUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutSerivsNestedInput
    seriv_approvers?: SERIVApproverUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutSerivNestedInput
  }

  export type SERIVCreateManyInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv: SERIVCreateNestedOneWithoutSeriv_approversInput
  }

  export type SERIVApproverUncheckedCreateInput = {
    id?: string
    seriv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVUpdateOneRequiredWithoutSeriv_approversNestedInput
  }

  export type SERIVApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverCreateManyInput = {
    id?: string
    seriv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemCreateInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv: SERIVCreateNestedOneWithoutSeriv_itemsInput
    item: ItemCreateNestedOneWithoutSeriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemUncheckedCreateInput = {
    id?: string
    seriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVUpdateOneRequiredWithoutSeriv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutSeriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemCreateManyInput = {
    id?: string
    seriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVCreateInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutMrvsInput
    mrv_approvers?: MRVApproverCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemCreateNestedManyWithoutMrvInput
    mct?: MCTCreateNestedOneWithoutMrvInput
    project: ProjectCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutMrvInput
    mct?: MCTUncheckedCreateNestedOneWithoutMrvInput
  }

  export type MRVUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutMrvsNestedInput
    mrv_approvers?: MRVApproverUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUpdateManyWithoutMrvNestedInput
    mct?: MCTUpdateOneWithoutMrvNestedInput
    project?: ProjectUpdateOneRequiredWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutMrvNestedInput
    mct?: MCTUncheckedUpdateOneWithoutMrvNestedInput
  }

  export type MRVCreateManyInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv: MRVCreateNestedOneWithoutMrv_approversInput
  }

  export type MRVApproverUncheckedCreateInput = {
    id?: string
    mrv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneRequiredWithoutMrv_approversNestedInput
  }

  export type MRVApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverCreateManyInput = {
    id?: string
    mrv_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemCreateInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv: MRVCreateNestedOneWithoutMrv_itemsInput
    item: ItemCreateNestedOneWithoutMrv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemUncheckedCreateInput = {
    id?: string
    mrv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneRequiredWithoutMrv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutMrv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemCreateManyInput = {
    id?: string
    mrv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTCreateInput = {
    id?: string
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVCreateNestedOneWithoutMctInput
    mct_approvers?: MCTApproverCreateNestedManyWithoutMctInput
    mcrts?: MCRTCreateNestedManyWithoutMctInput
  }

  export type MCTUncheckedCreateInput = {
    id?: string
    mrv_id?: string | null
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedCreateNestedManyWithoutMctInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutMctInput
  }

  export type MCTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneWithoutMctNestedInput
    mct_approvers?: MCTApproverUpdateManyWithoutMctNestedInput
    mcrts?: MCRTUpdateManyWithoutMctNestedInput
  }

  export type MCTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedUpdateManyWithoutMctNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutMctNestedInput
  }

  export type MCTCreateManyInput = {
    id?: string
    mrv_id?: string | null
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct: MCTCreateNestedOneWithoutMct_approversInput
  }

  export type MCTApproverUncheckedCreateInput = {
    id?: string
    mct_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTUpdateOneRequiredWithoutMct_approversNestedInput
  }

  export type MCTApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverCreateManyInput = {
    id?: string
    mct_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTCreateInput = {
    id?: string
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTCreateNestedOneWithoutMcrtsInput
    seriv?: SERIVCreateNestedOneWithoutMcrtsInput
    mcrt_approvers?: MCRTApproverCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUncheckedCreateInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTUpdateOneWithoutMcrtsNestedInput
    seriv?: SERIVUpdateOneWithoutMcrtsNestedInput
    mcrt_approvers?: MCRTApproverUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTCreateManyInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt: MCRTCreateNestedOneWithoutMcrt_approversInput
  }

  export type MCRTApproverUncheckedCreateInput = {
    id?: string
    mcrt_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt?: MCRTUpdateOneRequiredWithoutMcrt_approversNestedInput
  }

  export type MCRTApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverCreateManyInput = {
    id?: string
    mcrt_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemCreateInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt: MCRTCreateNestedOneWithoutMcrt_itemsInput
    item: ItemCreateNestedOneWithoutMcrt_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemUncheckedCreateInput = {
    id?: string
    mcrt_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt?: MCRTUpdateOneRequiredWithoutMcrt_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutMcrt_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemCreateManyInput = {
    id?: string
    mcrt_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTCreateInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverCreateNestedManyWithoutMstInput
    mst_items?: MSTItemCreateNestedManyWithoutMstInput
  }

  export type MSTUncheckedCreateInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUncheckedCreateNestedManyWithoutMstInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutMstInput
  }

  export type MSTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUpdateManyWithoutMstNestedInput
    mst_items?: MSTItemUpdateManyWithoutMstNestedInput
  }

  export type MSTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUncheckedUpdateManyWithoutMstNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutMstNestedInput
  }

  export type MSTCreateManyInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverCreateInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst: MSTCreateNestedOneWithoutMst_approversInput
  }

  export type MSTApproverUncheckedCreateInput = {
    id?: string
    mst_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst?: MSTUpdateOneRequiredWithoutMst_approversNestedInput
  }

  export type MSTApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverCreateManyInput = {
    id?: string
    mst_id: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateInput = {
    id?: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst: MSTCreateNestedOneWithoutMst_itemsInput
    item: ItemCreateNestedOneWithoutMst_itemsInput
  }

  export type MSTItemUncheckedCreateInput = {
    id?: string
    mst_id: string
    item_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst?: MSTUpdateOneRequiredWithoutMst_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutMst_itemsNestedInput
  }

  export type MSTItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateManyInput = {
    id?: string
    mst_id: string
    item_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ItemTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ItemTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MEQSSupplierListRelationFilter = {
    every?: MEQSSupplierWhereInput
    some?: MEQSSupplierWhereInput
    none?: MEQSSupplierWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MEQSSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    tin?: SortOrder
    address?: SortOrder
    vat_type?: SortOrder
    is_vat_registered?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    vat_type?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    tin?: SortOrder
    address?: SortOrder
    vat_type?: SortOrder
    is_vat_registered?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    tin?: SortOrder
    address?: SortOrder
    vat_type?: SortOrder
    is_vat_registered?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    vat_type?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CanvassItemListRelationFilter = {
    every?: CanvassItemWhereInput
    some?: CanvassItemWhereInput
    none?: CanvassItemWhereInput
  }

  export type CanvassItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SPRListRelationFilter = {
    every?: SPRWhereInput
    some?: SPRWhereInput
    none?: SPRWhereInput
  }

  export type SPROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ItemLocationListRelationFilter = {
    every?: ItemLocationWhereInput
    some?: ItemLocationWhereInput
    none?: ItemLocationWhereInput
  }

  export type OSRIVListRelationFilter = {
    every?: OSRIVWhereInput
    some?: OSRIVWhereInput
    none?: OSRIVWhereInput
  }

  export type MRVListRelationFilter = {
    every?: MRVWhereInput
    some?: MRVWhereInput
    none?: MRVWhereInput
  }

  export type SERIVListRelationFilter = {
    every?: SERIVWhereInput
    some?: SERIVWhereInput
    none?: SERIVWhereInput
  }

  export type ItemLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OSRIVOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MRVOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SERIVOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type StationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type StationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PendingApprover_idReference_numberReference_tableCompoundUniqueInput = {
    approver_id: string
    reference_number: string
    reference_table: string
  }

  export type PendingCountOrderByAggregateInput = {
    id?: SortOrder
    approver_id?: SortOrder
    reference_number?: SortOrder
    reference_table?: SortOrder
    description?: SortOrder
    transaction_date?: SortOrder
  }

  export type PendingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PendingMaxOrderByAggregateInput = {
    id?: SortOrder
    approver_id?: SortOrder
    reference_number?: SortOrder
    reference_table?: SortOrder
    description?: SortOrder
    transaction_date?: SortOrder
  }

  export type PendingMinOrderByAggregateInput = {
    id?: SortOrder
    approver_id?: SortOrder
    reference_number?: SortOrder
    reference_table?: SortOrder
    description?: SortOrder
    transaction_date?: SortOrder
  }

  export type PendingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemTypeRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type ItemTransactionListRelationFilter = {
    every?: ItemTransactionWhereInput
    some?: ItemTransactionWhereInput
    none?: ItemTransactionWhereInput
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type OSRIVItemListRelationFilter = {
    every?: OSRIVItemWhereInput
    some?: OSRIVItemWhereInput
    none?: OSRIVItemWhereInput
  }

  export type SERIVItemListRelationFilter = {
    every?: SERIVItemWhereInput
    some?: SERIVItemWhereInput
    none?: SERIVItemWhereInput
  }

  export type MRVItemListRelationFilter = {
    every?: MRVItemWhereInput
    some?: MRVItemWhereInput
    none?: MRVItemWhereInput
  }

  export type MCRTItemListRelationFilter = {
    every?: MCRTItemWhereInput
    some?: MCRTItemWhereInput
    none?: MCRTItemWhereInput
  }

  export type MSTItemListRelationFilter = {
    every?: MSTItemWhereInput
    some?: MSTItemWhereInput
    none?: MSTItemWhereInput
  }

  export type ItemTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OSRIVItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SERIVItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MRVItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCRTItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MSTItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    item_type_id?: SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    item_type_id?: SortOrder
    total_quantity?: SortOrder
    quantity_on_queue?: SortOrder
    initial_quantity?: SortOrder
    alert_level?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type StationRelationFilter = {
    is?: StationWhereInput
    isNot?: StationWhereInput
  }

  export type ItemMovementListRelationFilter = {
    every?: ItemMovementWhereInput
    some?: ItemMovementWhereInput
    none?: ItemMovementWhereInput
  }

  export type ItemMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemLocationCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    station_id?: SortOrder
    quantity_on_hand?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type ItemLocationAvgOrderByAggregateInput = {
    quantity_on_hand?: SortOrder
  }

  export type ItemLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    station_id?: SortOrder
    quantity_on_hand?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ItemLocationMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    station_id?: SortOrder
    quantity_on_hand?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ItemLocationSumOrderByAggregateInput = {
    quantity_on_hand?: SortOrder
  }

  export type ItemLocationRelationFilter = {
    is?: ItemLocationWhereInput
    isNot?: ItemLocationWhereInput
  }

  export type ItemMovementCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    quantity_moved?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type ItemMovementAvgOrderByAggregateInput = {
    quantity_moved?: SortOrder
  }

  export type ItemMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    quantity_moved?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ItemMovementMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    quantity_moved?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ItemMovementSumOrderByAggregateInput = {
    quantity_moved?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RRItemNullableRelationFilter = {
    is?: RRItemWhereInput | null
    isNot?: RRItemWhereInput | null
  }

  export type OSRIVItemNullableRelationFilter = {
    is?: OSRIVItemWhereInput | null
    isNot?: OSRIVItemWhereInput | null
  }

  export type SERIVItemNullableRelationFilter = {
    is?: SERIVItemWhereInput | null
    isNot?: SERIVItemWhereInput | null
  }

  export type MRVItemNullableRelationFilter = {
    is?: MRVItemWhereInput | null
    isNot?: MRVItemWhereInput | null
  }

  export type MCRTItemNullableRelationFilter = {
    is?: MCRTItemWhereInput | null
    isNot?: MCRTItemWhereInput | null
  }

  export type ItemTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    osriv_item_id?: SortOrder
    seriv_item_id?: SortOrder
    mrv_item_id?: SortOrder
    mcrt_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    metadata?: SortOrder
  }

  export type ItemTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ItemTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    osriv_item_id?: SortOrder
    seriv_item_id?: SortOrder
    mrv_item_id?: SortOrder
    mcrt_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ItemTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    osriv_item_id?: SortOrder
    seriv_item_id?: SortOrder
    mrv_item_id?: SortOrder
    mcrt_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type ItemTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ItemCodeTrackerCountOrderByAggregateInput = {
    id?: SortOrder
    item_code?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type ItemCodeTrackerAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type ItemCodeTrackerMaxOrderByAggregateInput = {
    id?: SortOrder
    item_code?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type ItemCodeTrackerMinOrderByAggregateInput = {
    id?: SortOrder
    item_code?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type ItemCodeTrackerSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    last_incremental?: SortOrder
  }

  export type JONullableRelationFilter = {
    is?: JOWhereInput | null
    isNot?: JOWhereInput | null
  }

  export type RVNullableRelationFilter = {
    is?: RVWhereInput | null
    isNot?: RVWhereInput | null
  }

  export type SPRNullableRelationFilter = {
    is?: SPRWhereInput | null
    isNot?: SPRWhereInput | null
  }

  export type CanvassCountOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    metadata?: SortOrder
  }

  export type CanvassMaxOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CanvassMinOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    deleted_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type MEQSSupplierItemListRelationFilter = {
    every?: MEQSSupplierItemWhereInput
    some?: MEQSSupplierItemWhereInput
    none?: MEQSSupplierItemWhereInput
  }

  export type CanvassRelationFilter = {
    is?: CanvassWhereInput
    isNot?: CanvassWhereInput
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ItemNullableRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type MEQSSupplierItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvassItemCountOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    unit_id?: SortOrder
    item_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
  }

  export type CanvassItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CanvassItemMaxOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    unit_id?: SortOrder
    item_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
  }

  export type CanvassItemMinOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    unit_id?: SortOrder
    item_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
  }

  export type CanvassItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CanvassNullableRelationFilter = {
    is?: CanvassWhereInput | null
    isNot?: CanvassWhereInput | null
  }

  export type MEQSNullableRelationFilter = {
    is?: MEQSWhereInput | null
    isNot?: MEQSWhereInput | null
  }

  export type RVApproverListRelationFilter = {
    every?: RVApproverWhereInput
    some?: RVApproverWhereInput
    none?: RVApproverWhereInput
  }

  export type RVApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RVCountOrderByAggregateInput = {
    id?: SortOrder
    rv_number?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type RVMaxOrderByAggregateInput = {
    id?: SortOrder
    rv_number?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RVMinOrderByAggregateInput = {
    id?: SortOrder
    rv_number?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RVRelationFilter = {
    is?: RVWhereInput
    isNot?: RVWhereInput
  }

  export type RVApproverCountOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrder
  }

  export type RVApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RVApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type RVApproverMinOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type RVApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type JOApproverListRelationFilter = {
    every?: JOApproverWhereInput
    some?: JOApproverWhereInput
    none?: JOApproverWhereInput
  }

  export type JOApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JOCountOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type JOMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JOMinOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JORelationFilter = {
    is?: JOWhereInput
    isNot?: JOWhereInput
  }

  export type JOApproverCountOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrder
  }

  export type JOApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type JOApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type JOApproverMinOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type JOApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type SPRApproverListRelationFilter = {
    every?: SPRApproverWhereInput
    some?: SPRApproverWhereInput
    none?: SPRApproverWhereInput
  }

  export type SPRApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SPRCountOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type SPRMaxOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SPRMinOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SPRRelationFilter = {
    is?: SPRWhereInput
    isNot?: SPRWhereInput
  }

  export type SPRApproverCountOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
    metadata?: SortOrder
  }

  export type SPRApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type SPRApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type SPRApproverMinOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    is_supervisor?: SortOrder
  }

  export type SPRApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverListRelationFilter = {
    every?: MEQSApproverWhereInput
    some?: MEQSApproverWhereInput
    none?: MEQSApproverWhereInput
  }

  export type MEQSApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MEQSCountOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    jo_number?: SortOrder
    rv_id?: SortOrder
    rv_number?: SortOrder
    spr_id?: SortOrder
    spr_number?: SortOrder
    meqs_number?: SortOrder
    meqs_date?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cancelled_at?: SortOrder
    metadata?: SortOrder
  }

  export type MEQSMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    jo_number?: SortOrder
    rv_id?: SortOrder
    rv_number?: SortOrder
    spr_id?: SortOrder
    spr_number?: SortOrder
    meqs_number?: SortOrder
    meqs_date?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cancelled_at?: SortOrder
  }

  export type MEQSMinOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    jo_number?: SortOrder
    rv_id?: SortOrder
    rv_number?: SortOrder
    spr_id?: SortOrder
    spr_number?: SortOrder
    meqs_number?: SortOrder
    meqs_date?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cancelled_at?: SortOrder
  }

  export type MEQSRelationFilter = {
    is?: MEQSWhereInput
    isNot?: MEQSWhereInput
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type MEQSSupplierAttachmentListRelationFilter = {
    every?: MEQSSupplierAttachmentWhereInput
    some?: MEQSSupplierAttachmentWhereInput
    none?: MEQSSupplierAttachmentWhereInput
  }

  export type PONullableRelationFilter = {
    is?: POWhereInput | null
    isNot?: POWhereInput | null
  }

  export type MEQSSupplierAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MEQSSupplierMeqs_idSupplier_idCompoundUniqueInput = {
    meqs_id: string
    supplier_id: string
  }

  export type MEQSSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    metadata?: SortOrder
  }

  export type MEQSSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
  }

  export type MEQSSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
  }

  export type CanvassItemRelationFilter = {
    is?: CanvassItemWhereInput
    isNot?: CanvassItemWhereInput
  }

  export type MEQSSupplierRelationFilter = {
    is?: MEQSSupplierWhereInput
    isNot?: MEQSSupplierWhereInput
  }

  export type RRItemListRelationFilter = {
    every?: RRItemWhereInput
    some?: RRItemWhereInput
    none?: RRItemWhereInput
  }

  export type RRItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MEQSSupplierItemCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    canvass_item_id?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    is_awarded?: SortOrder
    vat_type?: SortOrder
    metadata?: SortOrder
  }

  export type MEQSSupplierItemAvgOrderByAggregateInput = {
    price?: SortOrder
    vat_type?: SortOrder
  }

  export type MEQSSupplierItemMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    canvass_item_id?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    is_awarded?: SortOrder
    vat_type?: SortOrder
  }

  export type MEQSSupplierItemMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    canvass_item_id?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    is_awarded?: SortOrder
    vat_type?: SortOrder
  }

  export type MEQSSupplierItemSumOrderByAggregateInput = {
    price?: SortOrder
    vat_type?: SortOrder
  }

  export type MEQSSupplierAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    filename?: SortOrder
    src?: SortOrder
    metadata?: SortOrder
  }

  export type MEQSSupplierAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    filename?: SortOrder
    src?: SortOrder
  }

  export type MEQSSupplierAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    filename?: SortOrder
    src?: SortOrder
  }

  export type MEQSApproverCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrder
  }

  export type MEQSApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MEQSSupplierNullableRelationFilter = {
    is?: MEQSSupplierWhereInput | null
    isNot?: MEQSSupplierWhereInput | null
  }

  export type RRListRelationFilter = {
    every?: RRWhereInput
    some?: RRWhereInput
    none?: RRWhereInput
  }

  export type POApproverListRelationFilter = {
    every?: POApproverWhereInput
    some?: POApproverWhereInput
    none?: POApproverWhereInput
  }

  export type RROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    meqs_number?: SortOrder
    po_number?: SortOrder
    fund_source_id?: SortOrder
    po_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type POMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    meqs_number?: SortOrder
    po_number?: SortOrder
    fund_source_id?: SortOrder
    po_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type POMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    meqs_number?: SortOrder
    po_number?: SortOrder
    fund_source_id?: SortOrder
    po_date?: SortOrder
    notes?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PORelationFilter = {
    is?: POWhereInput
    isNot?: POWhereInput
  }

  export type POApproverCountOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrder
  }

  export type POApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type POApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type POApproverMinOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type POApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RRApproverListRelationFilter = {
    every?: RRApproverWhereInput
    some?: RRApproverWhereInput
    none?: RRApproverWhereInput
  }

  export type RRApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RRCountOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    po_number?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type RRAvgOrderByAggregateInput = {
    delivery_charge?: SortOrder
  }

  export type RRMaxOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    po_number?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RRMinOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    po_number?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RRSumOrderByAggregateInput = {
    delivery_charge?: SortOrder
  }

  export type RRRelationFilter = {
    is?: RRWhereInput
    isNot?: RRWhereInput
  }

  export type RRApproverCountOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    metadata?: SortOrder
  }

  export type RRApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RRApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type RRApproverMinOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
  }

  export type RRApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type ItemTransactionNullableRelationFilter = {
    is?: ItemTransactionWhereInput | null
    isNot?: ItemTransactionWhereInput | null
  }

  export type MEQSSupplierItemRelationFilter = {
    is?: MEQSSupplierItemWhereInput
    isNot?: MEQSSupplierItemWhereInput
  }

  export type RRItemCountOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    meqs_supplier_item_id?: SortOrder
    quantity_accepted?: SortOrder
    metadata?: SortOrder
  }

  export type RRItemAvgOrderByAggregateInput = {
    quantity_accepted?: SortOrder
  }

  export type RRItemMaxOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    meqs_supplier_item_id?: SortOrder
    quantity_accepted?: SortOrder
  }

  export type RRItemMinOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    meqs_supplier_item_id?: SortOrder
    quantity_accepted?: SortOrder
  }

  export type RRItemSumOrderByAggregateInput = {
    quantity_accepted?: SortOrder
  }

  export type OSRIVApproverListRelationFilter = {
    every?: OSRIVApproverWhereInput
    some?: OSRIVApproverWhereInput
    none?: OSRIVApproverWhereInput
  }

  export type OSRIVApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OSRIVCountOrderByAggregateInput = {
    id?: SortOrder
    osriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    requested_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type OSRIVMaxOrderByAggregateInput = {
    id?: SortOrder
    osriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    requested_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OSRIVMinOrderByAggregateInput = {
    id?: SortOrder
    osriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    requested_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OSRIVRelationFilter = {
    is?: OSRIVWhereInput
    isNot?: OSRIVWhereInput
  }

  export type OSRIVApproverOsriv_idLabel_idCompoundUniqueInput = {
    osriv_id: string
    label_id: string
  }

  export type OSRIVApproverCountOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type OSRIVApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type OSRIVApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type OSRIVApproverMinOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type OSRIVApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type OSRIVItemCountOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type OSRIVItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OSRIVItemMaxOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type OSRIVItemMinOrderByAggregateInput = {
    id?: SortOrder
    osriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type OSRIVItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type SERIVApproverListRelationFilter = {
    every?: SERIVApproverWhereInput
    some?: SERIVApproverWhereInput
    none?: SERIVApproverWhereInput
  }

  export type MCRTListRelationFilter = {
    every?: MCRTWhereInput
    some?: MCRTWhereInput
    none?: MCRTWhereInput
  }

  export type SERIVApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCRTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SERIVCountOrderByAggregateInput = {
    id?: SortOrder
    seriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type SERIVAvgOrderByAggregateInput = {
    request_type?: SortOrder
  }

  export type SERIVMaxOrderByAggregateInput = {
    id?: SortOrder
    seriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SERIVMinOrderByAggregateInput = {
    id?: SortOrder
    seriv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SERIVSumOrderByAggregateInput = {
    request_type?: SortOrder
  }

  export type SERIVRelationFilter = {
    is?: SERIVWhereInput
    isNot?: SERIVWhereInput
  }

  export type SERIVApproverSeriv_idLabel_idCompoundUniqueInput = {
    seriv_id: string
    label_id: string
  }

  export type SERIVApproverCountOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type SERIVApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type SERIVApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type SERIVApproverMinOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type SERIVApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type SERIVItemCountOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type SERIVItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type SERIVItemMaxOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type SERIVItemMinOrderByAggregateInput = {
    id?: SortOrder
    seriv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type SERIVItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MRVApproverListRelationFilter = {
    every?: MRVApproverWhereInput
    some?: MRVApproverWhereInput
    none?: MRVApproverWhereInput
  }

  export type MCTNullableRelationFilter = {
    is?: MCTWhereInput | null
    isNot?: MCTWhereInput | null
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type MRVApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MRVCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    mrv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MRVAvgOrderByAggregateInput = {
    request_type?: SortOrder
  }

  export type MRVMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    mrv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MRVMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    mrv_number?: SortOrder
    date_requested?: SortOrder
    exp_date?: SortOrder
    purpose?: SortOrder
    note?: SortOrder
    is_completed?: SortOrder
    request_type?: SortOrder
    or_number?: SortOrder
    mwo_number?: SortOrder
    cwo_number?: SortOrder
    jo_number?: SortOrder
    consumer_name?: SortOrder
    location?: SortOrder
    requested_by_id?: SortOrder
    withdrawn_by_id?: SortOrder
    item_from_id?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MRVSumOrderByAggregateInput = {
    request_type?: SortOrder
  }

  export type MRVRelationFilter = {
    is?: MRVWhereInput
    isNot?: MRVWhereInput
  }

  export type MRVApproverMrv_idLabel_idCompoundUniqueInput = {
    mrv_id: string
    label_id: string
  }

  export type MRVApproverCountOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MRVApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MRVApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MRVApproverMinOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MRVApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MRVItemCountOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type MRVItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MRVItemMaxOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MRVItemMinOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MRVItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MRVNullableRelationFilter = {
    is?: MRVWhereInput | null
    isNot?: MRVWhereInput | null
  }

  export type MCTApproverListRelationFilter = {
    every?: MCTApproverWhereInput
    some?: MCTApproverWhereInput
    none?: MCTApproverWhereInput
  }

  export type MCTApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCTCountOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    mrv_number?: SortOrder
    mct_number?: SortOrder
    mct_date?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MCTMaxOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    mrv_number?: SortOrder
    mct_number?: SortOrder
    mct_date?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MCTMinOrderByAggregateInput = {
    id?: SortOrder
    mrv_id?: SortOrder
    mrv_number?: SortOrder
    mct_number?: SortOrder
    mct_date?: SortOrder
    is_completed?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MCTRelationFilter = {
    is?: MCTWhereInput
    isNot?: MCTWhereInput
  }

  export type MCTApproverCountOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MCTApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MCTApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MCTApproverMinOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MCTApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type SERIVNullableRelationFilter = {
    is?: SERIVWhereInput | null
    isNot?: SERIVWhereInput | null
  }

  export type MCRTApproverListRelationFilter = {
    every?: MCRTApproverWhereInput
    some?: MCRTApproverWhereInput
    none?: MCRTApproverWhereInput
  }

  export type MCRTApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCRTCountOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    mct_number?: SortOrder
    seriv_id?: SortOrder
    seriv_number?: SortOrder
    mcrt_number?: SortOrder
    mcrt_date?: SortOrder
    is_completed?: SortOrder
    returned_by_id?: SortOrder
    wo_number?: SortOrder
    mo_number?: SortOrder
    jo_number?: SortOrder
    note?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MCRTMaxOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    mct_number?: SortOrder
    seriv_id?: SortOrder
    seriv_number?: SortOrder
    mcrt_number?: SortOrder
    mcrt_date?: SortOrder
    is_completed?: SortOrder
    returned_by_id?: SortOrder
    wo_number?: SortOrder
    mo_number?: SortOrder
    jo_number?: SortOrder
    note?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MCRTMinOrderByAggregateInput = {
    id?: SortOrder
    mct_id?: SortOrder
    mct_number?: SortOrder
    seriv_id?: SortOrder
    seriv_number?: SortOrder
    mcrt_number?: SortOrder
    mcrt_date?: SortOrder
    is_completed?: SortOrder
    returned_by_id?: SortOrder
    wo_number?: SortOrder
    mo_number?: SortOrder
    jo_number?: SortOrder
    note?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MCRTRelationFilter = {
    is?: MCRTWhereInput
    isNot?: MCRTWhereInput
  }

  export type MCRTApproverCountOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MCRTApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MCRTApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MCRTApproverMinOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MCRTApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MCRTItemCountOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type MCRTItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MCRTItemMaxOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MCRTItemMinOrderByAggregateInput = {
    id?: SortOrder
    mcrt_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MCRTItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MSTApproverListRelationFilter = {
    every?: MSTApproverWhereInput
    some?: MSTApproverWhereInput
    none?: MSTApproverWhereInput
  }

  export type MSTApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MSTCountOrderByAggregateInput = {
    id?: SortOrder
    mst_number?: SortOrder
    mst_date?: SortOrder
    returned_by_id?: SortOrder
    cwo_number?: SortOrder
    mwo_number?: SortOrder
    jo_number?: SortOrder
    remarks?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MSTMaxOrderByAggregateInput = {
    id?: SortOrder
    mst_number?: SortOrder
    mst_date?: SortOrder
    returned_by_id?: SortOrder
    cwo_number?: SortOrder
    mwo_number?: SortOrder
    jo_number?: SortOrder
    remarks?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MSTMinOrderByAggregateInput = {
    id?: SortOrder
    mst_number?: SortOrder
    mst_date?: SortOrder
    returned_by_id?: SortOrder
    cwo_number?: SortOrder
    mwo_number?: SortOrder
    jo_number?: SortOrder
    remarks?: SortOrder
    cancelled_by?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MSTRelationFilter = {
    is?: MSTWhereInput
    isNot?: MSTWhereInput
  }

  export type MSTApproverCountOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    metadata?: SortOrder
  }

  export type MSTApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MSTApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MSTApproverMinOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    approver_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    label_id?: SortOrder
    order?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
  }

  export type MSTApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MSTItemCountOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    metadata?: SortOrder
  }

  export type MSTItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
  }

  export type MSTItemMaxOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MSTItemMinOrderByAggregateInput = {
    id?: SortOrder
    mst_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MSTItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    status?: SortOrder
  }

  export type ItemCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ItemUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItem_typeInput | ItemUpsertWithWhereUniqueWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItem_typeInput | ItemUpdateWithWhereUniqueWithoutItem_typeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItem_typeInput | ItemUpdateManyWithWhereWithoutItem_typeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ItemUncheckedUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItem_typeInput | ItemUpsertWithWhereUniqueWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItem_typeInput | ItemUpdateWithWhereUniqueWithoutItem_typeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItem_typeInput | ItemUpdateManyWithWhereWithoutItem_typeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type MEQSSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type MEQSSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MEQSSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutSupplierInput | MEQSSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutSupplierInput | MEQSSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type CanvassItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CanvassItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutUnitInput | CanvassItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutUnitInput | CanvassItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutUnitInput | CanvassItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CanvassItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutUnitInput | CanvassItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutUnitInput | CanvassItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutUnitInput | CanvassItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type SPRCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
  }

  export type SPRUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
  }

  export type SPRUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    upsert?: SPRUpsertWithWhereUniqueWithoutVehicleInput | SPRUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    set?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    disconnect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    delete?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    update?: SPRUpdateWithWhereUniqueWithoutVehicleInput | SPRUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SPRUpdateManyWithWhereWithoutVehicleInput | SPRUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SPRScalarWhereInput | SPRScalarWhereInput[]
  }

  export type SPRUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    upsert?: SPRUpsertWithWhereUniqueWithoutVehicleInput | SPRUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    set?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    disconnect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    delete?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    update?: SPRUpdateWithWhereUniqueWithoutVehicleInput | SPRUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SPRUpdateManyWithWhereWithoutVehicleInput | SPRUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SPRScalarWhereInput | SPRScalarWhereInput[]
  }

  export type ItemLocationCreateNestedManyWithoutStationInput = {
    create?: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput> | ItemLocationCreateWithoutStationInput[] | ItemLocationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutStationInput | ItemLocationCreateOrConnectWithoutStationInput[]
    createMany?: ItemLocationCreateManyStationInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type OSRIVCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput> | OSRIVCreateWithoutItem_fromInput[] | OSRIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: OSRIVCreateOrConnectWithoutItem_fromInput | OSRIVCreateOrConnectWithoutItem_fromInput[]
    createMany?: OSRIVCreateManyItem_fromInputEnvelope
    connect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
  }

  export type MRVCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput> | MRVCreateWithoutItem_fromInput[] | MRVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutItem_fromInput | MRVCreateOrConnectWithoutItem_fromInput[]
    createMany?: MRVCreateManyItem_fromInputEnvelope
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
  }

  export type SERIVCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput> | SERIVCreateWithoutItem_fromInput[] | SERIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: SERIVCreateOrConnectWithoutItem_fromInput | SERIVCreateOrConnectWithoutItem_fromInput[]
    createMany?: SERIVCreateManyItem_fromInputEnvelope
    connect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
  }

  export type ItemLocationUncheckedCreateNestedManyWithoutStationInput = {
    create?: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput> | ItemLocationCreateWithoutStationInput[] | ItemLocationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutStationInput | ItemLocationCreateOrConnectWithoutStationInput[]
    createMany?: ItemLocationCreateManyStationInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type OSRIVUncheckedCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput> | OSRIVCreateWithoutItem_fromInput[] | OSRIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: OSRIVCreateOrConnectWithoutItem_fromInput | OSRIVCreateOrConnectWithoutItem_fromInput[]
    createMany?: OSRIVCreateManyItem_fromInputEnvelope
    connect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
  }

  export type MRVUncheckedCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput> | MRVCreateWithoutItem_fromInput[] | MRVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutItem_fromInput | MRVCreateOrConnectWithoutItem_fromInput[]
    createMany?: MRVCreateManyItem_fromInputEnvelope
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
  }

  export type SERIVUncheckedCreateNestedManyWithoutItem_fromInput = {
    create?: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput> | SERIVCreateWithoutItem_fromInput[] | SERIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: SERIVCreateOrConnectWithoutItem_fromInput | SERIVCreateOrConnectWithoutItem_fromInput[]
    createMany?: SERIVCreateManyItem_fromInputEnvelope
    connect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
  }

  export type ItemLocationUpdateManyWithoutStationNestedInput = {
    create?: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput> | ItemLocationCreateWithoutStationInput[] | ItemLocationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutStationInput | ItemLocationCreateOrConnectWithoutStationInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutStationInput | ItemLocationUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: ItemLocationCreateManyStationInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutStationInput | ItemLocationUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutStationInput | ItemLocationUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type OSRIVUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput> | OSRIVCreateWithoutItem_fromInput[] | OSRIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: OSRIVCreateOrConnectWithoutItem_fromInput | OSRIVCreateOrConnectWithoutItem_fromInput[]
    upsert?: OSRIVUpsertWithWhereUniqueWithoutItem_fromInput | OSRIVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: OSRIVCreateManyItem_fromInputEnvelope
    set?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    disconnect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    delete?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    connect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    update?: OSRIVUpdateWithWhereUniqueWithoutItem_fromInput | OSRIVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: OSRIVUpdateManyWithWhereWithoutItem_fromInput | OSRIVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: OSRIVScalarWhereInput | OSRIVScalarWhereInput[]
  }

  export type MRVUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput> | MRVCreateWithoutItem_fromInput[] | MRVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutItem_fromInput | MRVCreateOrConnectWithoutItem_fromInput[]
    upsert?: MRVUpsertWithWhereUniqueWithoutItem_fromInput | MRVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: MRVCreateManyItem_fromInputEnvelope
    set?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    disconnect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    delete?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    update?: MRVUpdateWithWhereUniqueWithoutItem_fromInput | MRVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: MRVUpdateManyWithWhereWithoutItem_fromInput | MRVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: MRVScalarWhereInput | MRVScalarWhereInput[]
  }

  export type SERIVUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput> | SERIVCreateWithoutItem_fromInput[] | SERIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: SERIVCreateOrConnectWithoutItem_fromInput | SERIVCreateOrConnectWithoutItem_fromInput[]
    upsert?: SERIVUpsertWithWhereUniqueWithoutItem_fromInput | SERIVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: SERIVCreateManyItem_fromInputEnvelope
    set?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    disconnect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    delete?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    connect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    update?: SERIVUpdateWithWhereUniqueWithoutItem_fromInput | SERIVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: SERIVUpdateManyWithWhereWithoutItem_fromInput | SERIVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: SERIVScalarWhereInput | SERIVScalarWhereInput[]
  }

  export type ItemLocationUncheckedUpdateManyWithoutStationNestedInput = {
    create?: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput> | ItemLocationCreateWithoutStationInput[] | ItemLocationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutStationInput | ItemLocationCreateOrConnectWithoutStationInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutStationInput | ItemLocationUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: ItemLocationCreateManyStationInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutStationInput | ItemLocationUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutStationInput | ItemLocationUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type OSRIVUncheckedUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput> | OSRIVCreateWithoutItem_fromInput[] | OSRIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: OSRIVCreateOrConnectWithoutItem_fromInput | OSRIVCreateOrConnectWithoutItem_fromInput[]
    upsert?: OSRIVUpsertWithWhereUniqueWithoutItem_fromInput | OSRIVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: OSRIVCreateManyItem_fromInputEnvelope
    set?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    disconnect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    delete?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    connect?: OSRIVWhereUniqueInput | OSRIVWhereUniqueInput[]
    update?: OSRIVUpdateWithWhereUniqueWithoutItem_fromInput | OSRIVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: OSRIVUpdateManyWithWhereWithoutItem_fromInput | OSRIVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: OSRIVScalarWhereInput | OSRIVScalarWhereInput[]
  }

  export type MRVUncheckedUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput> | MRVCreateWithoutItem_fromInput[] | MRVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutItem_fromInput | MRVCreateOrConnectWithoutItem_fromInput[]
    upsert?: MRVUpsertWithWhereUniqueWithoutItem_fromInput | MRVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: MRVCreateManyItem_fromInputEnvelope
    set?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    disconnect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    delete?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    update?: MRVUpdateWithWhereUniqueWithoutItem_fromInput | MRVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: MRVUpdateManyWithWhereWithoutItem_fromInput | MRVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: MRVScalarWhereInput | MRVScalarWhereInput[]
  }

  export type SERIVUncheckedUpdateManyWithoutItem_fromNestedInput = {
    create?: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput> | SERIVCreateWithoutItem_fromInput[] | SERIVUncheckedCreateWithoutItem_fromInput[]
    connectOrCreate?: SERIVCreateOrConnectWithoutItem_fromInput | SERIVCreateOrConnectWithoutItem_fromInput[]
    upsert?: SERIVUpsertWithWhereUniqueWithoutItem_fromInput | SERIVUpsertWithWhereUniqueWithoutItem_fromInput[]
    createMany?: SERIVCreateManyItem_fromInputEnvelope
    set?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    disconnect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    delete?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    connect?: SERIVWhereUniqueInput | SERIVWhereUniqueInput[]
    update?: SERIVUpdateWithWhereUniqueWithoutItem_fromInput | SERIVUpdateWithWhereUniqueWithoutItem_fromInput[]
    updateMany?: SERIVUpdateManyWithWhereWithoutItem_fromInput | SERIVUpdateManyWithWhereWithoutItem_fromInput[]
    deleteMany?: SERIVScalarWhereInput | SERIVScalarWhereInput[]
  }

  export type MRVCreateNestedManyWithoutProjectInput = {
    create?: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput> | MRVCreateWithoutProjectInput[] | MRVUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutProjectInput | MRVCreateOrConnectWithoutProjectInput[]
    createMany?: MRVCreateManyProjectInputEnvelope
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
  }

  export type MRVUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput> | MRVCreateWithoutProjectInput[] | MRVUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutProjectInput | MRVCreateOrConnectWithoutProjectInput[]
    createMany?: MRVCreateManyProjectInputEnvelope
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
  }

  export type MRVUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput> | MRVCreateWithoutProjectInput[] | MRVUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutProjectInput | MRVCreateOrConnectWithoutProjectInput[]
    upsert?: MRVUpsertWithWhereUniqueWithoutProjectInput | MRVUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MRVCreateManyProjectInputEnvelope
    set?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    disconnect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    delete?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    update?: MRVUpdateWithWhereUniqueWithoutProjectInput | MRVUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MRVUpdateManyWithWhereWithoutProjectInput | MRVUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MRVScalarWhereInput | MRVScalarWhereInput[]
  }

  export type MRVUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput> | MRVCreateWithoutProjectInput[] | MRVUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MRVCreateOrConnectWithoutProjectInput | MRVCreateOrConnectWithoutProjectInput[]
    upsert?: MRVUpsertWithWhereUniqueWithoutProjectInput | MRVUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MRVCreateManyProjectInputEnvelope
    set?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    disconnect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    delete?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    connect?: MRVWhereUniqueInput | MRVWhereUniqueInput[]
    update?: MRVUpdateWithWhereUniqueWithoutProjectInput | MRVUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MRVUpdateManyWithWhereWithoutProjectInput | MRVUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MRVScalarWhereInput | MRVScalarWhereInput[]
  }

  export type ItemTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type ItemTransactionCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
  }

  export type UnitCreateNestedOneWithoutItemsInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type CanvassItemCreateNestedManyWithoutItemInput = {
    create?: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput> | CanvassItemCreateWithoutItemInput[] | CanvassItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutItemInput | CanvassItemCreateOrConnectWithoutItemInput[]
    createMany?: CanvassItemCreateManyItemInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type ItemLocationCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type OSRIVItemCreateNestedManyWithoutItemInput = {
    create?: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput> | OSRIVItemCreateWithoutItemInput[] | OSRIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItemInput | OSRIVItemCreateOrConnectWithoutItemInput[]
    createMany?: OSRIVItemCreateManyItemInputEnvelope
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
  }

  export type SERIVItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput> | SERIVItemCreateWithoutItemInput[] | SERIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItemInput | SERIVItemCreateOrConnectWithoutItemInput[]
    createMany?: SERIVItemCreateManyItemInputEnvelope
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
  }

  export type MRVItemCreateNestedManyWithoutItemInput = {
    create?: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput> | MRVItemCreateWithoutItemInput[] | MRVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutItemInput | MRVItemCreateOrConnectWithoutItemInput[]
    createMany?: MRVItemCreateManyItemInputEnvelope
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
  }

  export type MCRTItemCreateNestedManyWithoutItemInput = {
    create?: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput> | MCRTItemCreateWithoutItemInput[] | MCRTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItemInput | MCRTItemCreateOrConnectWithoutItemInput[]
    createMany?: MCRTItemCreateManyItemInputEnvelope
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
  }

  export type MSTItemCreateNestedManyWithoutItemInput = {
    create?: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput> | MSTItemCreateWithoutItemInput[] | MSTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutItemInput | MSTItemCreateOrConnectWithoutItemInput[]
    createMany?: MSTItemCreateManyItemInputEnvelope
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
  }

  export type ItemTransactionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput> | CanvassItemCreateWithoutItemInput[] | CanvassItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutItemInput | CanvassItemCreateOrConnectWithoutItemInput[]
    createMany?: CanvassItemCreateManyItemInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type ItemLocationUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type OSRIVItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput> | OSRIVItemCreateWithoutItemInput[] | OSRIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItemInput | OSRIVItemCreateOrConnectWithoutItemInput[]
    createMany?: OSRIVItemCreateManyItemInputEnvelope
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
  }

  export type SERIVItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput> | SERIVItemCreateWithoutItemInput[] | SERIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItemInput | SERIVItemCreateOrConnectWithoutItemInput[]
    createMany?: SERIVItemCreateManyItemInputEnvelope
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
  }

  export type MRVItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput> | MRVItemCreateWithoutItemInput[] | MRVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutItemInput | MRVItemCreateOrConnectWithoutItemInput[]
    createMany?: MRVItemCreateManyItemInputEnvelope
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
  }

  export type MCRTItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput> | MCRTItemCreateWithoutItemInput[] | MCRTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItemInput | MCRTItemCreateOrConnectWithoutItemInput[]
    createMany?: MCRTItemCreateManyItemInputEnvelope
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
  }

  export type MSTItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput> | MSTItemCreateWithoutItemInput[] | MSTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutItemInput | MSTItemCreateOrConnectWithoutItemInput[]
    createMany?: MSTItemCreateManyItemInputEnvelope
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
  }

  export type ItemTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    upsert?: ItemTypeUpsertWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutItemsInput, ItemTypeUpdateWithoutItemsInput>, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTransactionUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    upsert?: ItemTransactionUpsertWithWhereUniqueWithoutItemInput | ItemTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    set?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    disconnect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    delete?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    update?: ItemTransactionUpdateWithWhereUniqueWithoutItemInput | ItemTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemTransactionUpdateManyWithWhereWithoutItemInput | ItemTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
  }

  export type UnitUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    upsert?: UnitUpsertWithoutItemsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutItemsInput, UnitUpdateWithoutItemsInput>, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type CanvassItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput> | CanvassItemCreateWithoutItemInput[] | CanvassItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutItemInput | CanvassItemCreateOrConnectWithoutItemInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutItemInput | CanvassItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CanvassItemCreateManyItemInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutItemInput | CanvassItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutItemInput | CanvassItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type ItemLocationUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutItemInput | ItemLocationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutItemInput | ItemLocationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutItemInput | ItemLocationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type OSRIVItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput> | OSRIVItemCreateWithoutItemInput[] | OSRIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItemInput | OSRIVItemCreateOrConnectWithoutItemInput[]
    upsert?: OSRIVItemUpsertWithWhereUniqueWithoutItemInput | OSRIVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: OSRIVItemCreateManyItemInputEnvelope
    set?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    disconnect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    delete?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    update?: OSRIVItemUpdateWithWhereUniqueWithoutItemInput | OSRIVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: OSRIVItemUpdateManyWithWhereWithoutItemInput | OSRIVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
  }

  export type SERIVItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput> | SERIVItemCreateWithoutItemInput[] | SERIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItemInput | SERIVItemCreateOrConnectWithoutItemInput[]
    upsert?: SERIVItemUpsertWithWhereUniqueWithoutItemInput | SERIVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SERIVItemCreateManyItemInputEnvelope
    set?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    disconnect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    delete?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    update?: SERIVItemUpdateWithWhereUniqueWithoutItemInput | SERIVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SERIVItemUpdateManyWithWhereWithoutItemInput | SERIVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
  }

  export type MRVItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput> | MRVItemCreateWithoutItemInput[] | MRVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutItemInput | MRVItemCreateOrConnectWithoutItemInput[]
    upsert?: MRVItemUpsertWithWhereUniqueWithoutItemInput | MRVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MRVItemCreateManyItemInputEnvelope
    set?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    disconnect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    delete?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    update?: MRVItemUpdateWithWhereUniqueWithoutItemInput | MRVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MRVItemUpdateManyWithWhereWithoutItemInput | MRVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
  }

  export type MCRTItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput> | MCRTItemCreateWithoutItemInput[] | MCRTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItemInput | MCRTItemCreateOrConnectWithoutItemInput[]
    upsert?: MCRTItemUpsertWithWhereUniqueWithoutItemInput | MCRTItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MCRTItemCreateManyItemInputEnvelope
    set?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    disconnect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    delete?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    update?: MCRTItemUpdateWithWhereUniqueWithoutItemInput | MCRTItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MCRTItemUpdateManyWithWhereWithoutItemInput | MCRTItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
  }

  export type MSTItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput> | MSTItemCreateWithoutItemInput[] | MSTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutItemInput | MSTItemCreateOrConnectWithoutItemInput[]
    upsert?: MSTItemUpsertWithWhereUniqueWithoutItemInput | MSTItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MSTItemCreateManyItemInputEnvelope
    set?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    disconnect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    delete?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    update?: MSTItemUpdateWithWhereUniqueWithoutItemInput | MSTItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MSTItemUpdateManyWithWhereWithoutItemInput | MSTItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
  }

  export type ItemTransactionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    upsert?: ItemTransactionUpsertWithWhereUniqueWithoutItemInput | ItemTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    set?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    disconnect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    delete?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    update?: ItemTransactionUpdateWithWhereUniqueWithoutItemInput | ItemTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemTransactionUpdateManyWithWhereWithoutItemInput | ItemTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
  }

  export type CanvassItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput> | CanvassItemCreateWithoutItemInput[] | CanvassItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutItemInput | CanvassItemCreateOrConnectWithoutItemInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutItemInput | CanvassItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CanvassItemCreateManyItemInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutItemInput | CanvassItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutItemInput | CanvassItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type ItemLocationUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutItemInput | ItemLocationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutItemInput | ItemLocationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutItemInput | ItemLocationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type OSRIVItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput> | OSRIVItemCreateWithoutItemInput[] | OSRIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItemInput | OSRIVItemCreateOrConnectWithoutItemInput[]
    upsert?: OSRIVItemUpsertWithWhereUniqueWithoutItemInput | OSRIVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: OSRIVItemCreateManyItemInputEnvelope
    set?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    disconnect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    delete?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    update?: OSRIVItemUpdateWithWhereUniqueWithoutItemInput | OSRIVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: OSRIVItemUpdateManyWithWhereWithoutItemInput | OSRIVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
  }

  export type SERIVItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput> | SERIVItemCreateWithoutItemInput[] | SERIVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItemInput | SERIVItemCreateOrConnectWithoutItemInput[]
    upsert?: SERIVItemUpsertWithWhereUniqueWithoutItemInput | SERIVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SERIVItemCreateManyItemInputEnvelope
    set?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    disconnect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    delete?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    update?: SERIVItemUpdateWithWhereUniqueWithoutItemInput | SERIVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SERIVItemUpdateManyWithWhereWithoutItemInput | SERIVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
  }

  export type MRVItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput> | MRVItemCreateWithoutItemInput[] | MRVItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutItemInput | MRVItemCreateOrConnectWithoutItemInput[]
    upsert?: MRVItemUpsertWithWhereUniqueWithoutItemInput | MRVItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MRVItemCreateManyItemInputEnvelope
    set?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    disconnect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    delete?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    update?: MRVItemUpdateWithWhereUniqueWithoutItemInput | MRVItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MRVItemUpdateManyWithWhereWithoutItemInput | MRVItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
  }

  export type MCRTItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput> | MCRTItemCreateWithoutItemInput[] | MCRTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItemInput | MCRTItemCreateOrConnectWithoutItemInput[]
    upsert?: MCRTItemUpsertWithWhereUniqueWithoutItemInput | MCRTItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MCRTItemCreateManyItemInputEnvelope
    set?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    disconnect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    delete?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    update?: MCRTItemUpdateWithWhereUniqueWithoutItemInput | MCRTItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MCRTItemUpdateManyWithWhereWithoutItemInput | MCRTItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
  }

  export type MSTItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput> | MSTItemCreateWithoutItemInput[] | MSTItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutItemInput | MSTItemCreateOrConnectWithoutItemInput[]
    upsert?: MSTItemUpsertWithWhereUniqueWithoutItemInput | MSTItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MSTItemCreateManyItemInputEnvelope
    set?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    disconnect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    delete?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    update?: MSTItemUpdateWithWhereUniqueWithoutItemInput | MSTItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MSTItemUpdateManyWithWhereWithoutItemInput | MSTItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutItem_locationsInput = {
    create?: XOR<ItemCreateWithoutItem_locationsInput, ItemUncheckedCreateWithoutItem_locationsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_locationsInput
    connect?: ItemWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutItemsInput = {
    create?: XOR<StationCreateWithoutItemsInput, StationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StationCreateOrConnectWithoutItemsInput
    connect?: StationWhereUniqueInput
  }

  export type ItemMovementCreateNestedManyWithoutOriginInput = {
    create?: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput> | ItemMovementCreateWithoutOriginInput[] | ItemMovementUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutOriginInput | ItemMovementCreateOrConnectWithoutOriginInput[]
    createMany?: ItemMovementCreateManyOriginInputEnvelope
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
  }

  export type ItemMovementCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput> | ItemMovementCreateWithoutDestinationInput[] | ItemMovementUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutDestinationInput | ItemMovementCreateOrConnectWithoutDestinationInput[]
    createMany?: ItemMovementCreateManyDestinationInputEnvelope
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
  }

  export type ItemMovementUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput> | ItemMovementCreateWithoutOriginInput[] | ItemMovementUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutOriginInput | ItemMovementCreateOrConnectWithoutOriginInput[]
    createMany?: ItemMovementCreateManyOriginInputEnvelope
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
  }

  export type ItemMovementUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput> | ItemMovementCreateWithoutDestinationInput[] | ItemMovementUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutDestinationInput | ItemMovementCreateOrConnectWithoutDestinationInput[]
    createMany?: ItemMovementCreateManyDestinationInputEnvelope
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutItem_locationsNestedInput = {
    create?: XOR<ItemCreateWithoutItem_locationsInput, ItemUncheckedCreateWithoutItem_locationsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_locationsInput
    upsert?: ItemUpsertWithoutItem_locationsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItem_locationsInput, ItemUpdateWithoutItem_locationsInput>, ItemUncheckedUpdateWithoutItem_locationsInput>
  }

  export type StationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<StationCreateWithoutItemsInput, StationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StationCreateOrConnectWithoutItemsInput
    upsert?: StationUpsertWithoutItemsInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutItemsInput, StationUpdateWithoutItemsInput>, StationUncheckedUpdateWithoutItemsInput>
  }

  export type ItemMovementUpdateManyWithoutOriginNestedInput = {
    create?: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput> | ItemMovementCreateWithoutOriginInput[] | ItemMovementUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutOriginInput | ItemMovementCreateOrConnectWithoutOriginInput[]
    upsert?: ItemMovementUpsertWithWhereUniqueWithoutOriginInput | ItemMovementUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: ItemMovementCreateManyOriginInputEnvelope
    set?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    disconnect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    delete?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    update?: ItemMovementUpdateWithWhereUniqueWithoutOriginInput | ItemMovementUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: ItemMovementUpdateManyWithWhereWithoutOriginInput | ItemMovementUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
  }

  export type ItemMovementUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput> | ItemMovementCreateWithoutDestinationInput[] | ItemMovementUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutDestinationInput | ItemMovementCreateOrConnectWithoutDestinationInput[]
    upsert?: ItemMovementUpsertWithWhereUniqueWithoutDestinationInput | ItemMovementUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ItemMovementCreateManyDestinationInputEnvelope
    set?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    disconnect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    delete?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    update?: ItemMovementUpdateWithWhereUniqueWithoutDestinationInput | ItemMovementUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ItemMovementUpdateManyWithWhereWithoutDestinationInput | ItemMovementUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
  }

  export type ItemMovementUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput> | ItemMovementCreateWithoutOriginInput[] | ItemMovementUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutOriginInput | ItemMovementCreateOrConnectWithoutOriginInput[]
    upsert?: ItemMovementUpsertWithWhereUniqueWithoutOriginInput | ItemMovementUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: ItemMovementCreateManyOriginInputEnvelope
    set?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    disconnect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    delete?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    update?: ItemMovementUpdateWithWhereUniqueWithoutOriginInput | ItemMovementUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: ItemMovementUpdateManyWithWhereWithoutOriginInput | ItemMovementUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
  }

  export type ItemMovementUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput> | ItemMovementCreateWithoutDestinationInput[] | ItemMovementUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ItemMovementCreateOrConnectWithoutDestinationInput | ItemMovementCreateOrConnectWithoutDestinationInput[]
    upsert?: ItemMovementUpsertWithWhereUniqueWithoutDestinationInput | ItemMovementUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ItemMovementCreateManyDestinationInputEnvelope
    set?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    disconnect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    delete?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    connect?: ItemMovementWhereUniqueInput | ItemMovementWhereUniqueInput[]
    update?: ItemMovementUpdateWithWhereUniqueWithoutDestinationInput | ItemMovementUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ItemMovementUpdateManyWithWhereWithoutDestinationInput | ItemMovementUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
  }

  export type ItemLocationCreateNestedOneWithoutOrigin_movementsInput = {
    create?: XOR<ItemLocationCreateWithoutOrigin_movementsInput, ItemLocationUncheckedCreateWithoutOrigin_movementsInput>
    connectOrCreate?: ItemLocationCreateOrConnectWithoutOrigin_movementsInput
    connect?: ItemLocationWhereUniqueInput
  }

  export type ItemLocationCreateNestedOneWithoutDestination_movementsInput = {
    create?: XOR<ItemLocationCreateWithoutDestination_movementsInput, ItemLocationUncheckedCreateWithoutDestination_movementsInput>
    connectOrCreate?: ItemLocationCreateOrConnectWithoutDestination_movementsInput
    connect?: ItemLocationWhereUniqueInput
  }

  export type ItemLocationUpdateOneRequiredWithoutOrigin_movementsNestedInput = {
    create?: XOR<ItemLocationCreateWithoutOrigin_movementsInput, ItemLocationUncheckedCreateWithoutOrigin_movementsInput>
    connectOrCreate?: ItemLocationCreateOrConnectWithoutOrigin_movementsInput
    upsert?: ItemLocationUpsertWithoutOrigin_movementsInput
    connect?: ItemLocationWhereUniqueInput
    update?: XOR<XOR<ItemLocationUpdateToOneWithWhereWithoutOrigin_movementsInput, ItemLocationUpdateWithoutOrigin_movementsInput>, ItemLocationUncheckedUpdateWithoutOrigin_movementsInput>
  }

  export type ItemLocationUpdateOneRequiredWithoutDestination_movementsNestedInput = {
    create?: XOR<ItemLocationCreateWithoutDestination_movementsInput, ItemLocationUncheckedCreateWithoutDestination_movementsInput>
    connectOrCreate?: ItemLocationCreateOrConnectWithoutDestination_movementsInput
    upsert?: ItemLocationUpsertWithoutDestination_movementsInput
    connect?: ItemLocationWhereUniqueInput
    update?: XOR<XOR<ItemLocationUpdateToOneWithWhereWithoutDestination_movementsInput, ItemLocationUpdateWithoutDestination_movementsInput>, ItemLocationUncheckedUpdateWithoutDestination_movementsInput>
  }

  export type ItemCreateNestedOneWithoutItem_transactionsInput = {
    create?: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_transactionsInput
    connect?: ItemWhereUniqueInput
  }

  export type RRItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_transactionInput
    connect?: RRItemWhereUniqueInput
  }

  export type OSRIVItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<OSRIVItemCreateWithoutItem_transactionInput, OSRIVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItem_transactionInput
    connect?: OSRIVItemWhereUniqueInput
  }

  export type SERIVItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<SERIVItemCreateWithoutItem_transactionInput, SERIVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItem_transactionInput
    connect?: SERIVItemWhereUniqueInput
  }

  export type MRVItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<MRVItemCreateWithoutItem_transactionInput, MRVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: MRVItemCreateOrConnectWithoutItem_transactionInput
    connect?: MRVItemWhereUniqueInput
  }

  export type MCRTItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<MCRTItemCreateWithoutItem_transactionInput, MCRTItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItem_transactionInput
    connect?: MCRTItemWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ItemUpdateOneRequiredWithoutItem_transactionsNestedInput = {
    create?: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_transactionsInput
    upsert?: ItemUpsertWithoutItem_transactionsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItem_transactionsInput, ItemUpdateWithoutItem_transactionsInput>, ItemUncheckedUpdateWithoutItem_transactionsInput>
  }

  export type RRItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_transactionInput
    upsert?: RRItemUpsertWithoutItem_transactionInput
    disconnect?: RRItemWhereInput | boolean
    delete?: RRItemWhereInput | boolean
    connect?: RRItemWhereUniqueInput
    update?: XOR<XOR<RRItemUpdateToOneWithWhereWithoutItem_transactionInput, RRItemUpdateWithoutItem_transactionInput>, RRItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type OSRIVItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<OSRIVItemCreateWithoutItem_transactionInput, OSRIVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutItem_transactionInput
    upsert?: OSRIVItemUpsertWithoutItem_transactionInput
    disconnect?: OSRIVItemWhereInput | boolean
    delete?: OSRIVItemWhereInput | boolean
    connect?: OSRIVItemWhereUniqueInput
    update?: XOR<XOR<OSRIVItemUpdateToOneWithWhereWithoutItem_transactionInput, OSRIVItemUpdateWithoutItem_transactionInput>, OSRIVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type SERIVItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<SERIVItemCreateWithoutItem_transactionInput, SERIVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: SERIVItemCreateOrConnectWithoutItem_transactionInput
    upsert?: SERIVItemUpsertWithoutItem_transactionInput
    disconnect?: SERIVItemWhereInput | boolean
    delete?: SERIVItemWhereInput | boolean
    connect?: SERIVItemWhereUniqueInput
    update?: XOR<XOR<SERIVItemUpdateToOneWithWhereWithoutItem_transactionInput, SERIVItemUpdateWithoutItem_transactionInput>, SERIVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type MRVItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<MRVItemCreateWithoutItem_transactionInput, MRVItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: MRVItemCreateOrConnectWithoutItem_transactionInput
    upsert?: MRVItemUpsertWithoutItem_transactionInput
    disconnect?: MRVItemWhereInput | boolean
    delete?: MRVItemWhereInput | boolean
    connect?: MRVItemWhereUniqueInput
    update?: XOR<XOR<MRVItemUpdateToOneWithWhereWithoutItem_transactionInput, MRVItemUpdateWithoutItem_transactionInput>, MRVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type MCRTItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<MCRTItemCreateWithoutItem_transactionInput, MCRTItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: MCRTItemCreateOrConnectWithoutItem_transactionInput
    upsert?: MCRTItemUpsertWithoutItem_transactionInput
    disconnect?: MCRTItemWhereInput | boolean
    delete?: MCRTItemWhereInput | boolean
    connect?: MCRTItemWhereUniqueInput
    update?: XOR<XOR<MCRTItemUpdateToOneWithWhereWithoutItem_transactionInput, MCRTItemUpdateWithoutItem_transactionInput>, MCRTItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type CanvassItemCreateNestedManyWithoutCanvassInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type JOCreateNestedOneWithoutCanvassInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    connect?: JOWhereUniqueInput
  }

  export type RVCreateNestedOneWithoutCanvassInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    connect?: RVWhereUniqueInput
  }

  export type SPRCreateNestedOneWithoutCanvassInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    connect?: SPRWhereUniqueInput
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutCanvassInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type JOUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    connect?: JOWhereUniqueInput
  }

  export type RVUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    connect?: RVWhereUniqueInput
  }

  export type SPRUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    connect?: SPRWhereUniqueInput
  }

  export type CanvassItemUpdateManyWithoutCanvassNestedInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutCanvassInput | CanvassItemUpsertWithWhereUniqueWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutCanvassInput | CanvassItemUpdateWithWhereUniqueWithoutCanvassInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutCanvassInput | CanvassItemUpdateManyWithWhereWithoutCanvassInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type JOUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    upsert?: JOUpsertWithoutCanvassInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutCanvassInput, JOUpdateWithoutCanvassInput>, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    upsert?: RVUpsertWithoutCanvassInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutCanvassInput, RVUpdateWithoutCanvassInput>, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    upsert?: SPRUpsertWithoutCanvassInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutCanvassInput, SPRUpdateWithoutCanvassInput>, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutCanvassInput | CanvassItemUpsertWithWhereUniqueWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutCanvassInput | CanvassItemUpdateWithWhereUniqueWithoutCanvassInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutCanvassInput | CanvassItemUpdateManyWithWhereWithoutCanvassInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type JOUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    upsert?: JOUpsertWithoutCanvassInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutCanvassInput, JOUpdateWithoutCanvassInput>, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    upsert?: RVUpsertWithoutCanvassInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutCanvassInput, RVUpdateWithoutCanvassInput>, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    upsert?: SPRUpsertWithoutCanvassInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutCanvassInput, SPRUpdateWithoutCanvassInput>, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type CanvassCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutCanvass_itemsInput
    connect?: CanvassWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCanvass_itemsInput
    connect?: UnitWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<ItemCreateWithoutCanvass_itemsInput, ItemUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCanvass_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput | MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput = {
    create?: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutCanvass_itemsInput
    upsert?: CanvassUpsertWithoutCanvass_itemsInput
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutCanvass_itemsInput, CanvassUpdateWithoutCanvass_itemsInput>, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type UnitUpdateOneWithoutCanvass_itemsNestedInput = {
    create?: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCanvass_itemsInput
    upsert?: UnitUpsertWithoutCanvass_itemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutCanvass_itemsInput, UnitUpdateWithoutCanvass_itemsInput>, UnitUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type ItemUpdateOneWithoutCanvass_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutCanvass_itemsInput, ItemUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCanvass_itemsInput
    upsert?: ItemUpsertWithoutCanvass_itemsInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCanvass_itemsInput, ItemUpdateWithoutCanvass_itemsInput>, ItemUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput | MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type CanvassCreateNestedOneWithoutRvInput = {
    create?: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutRvInput
    connect?: CanvassWhereUniqueInput
  }

  export type MEQSCreateNestedOneWithoutRvInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    connect?: MEQSWhereUniqueInput
  }

  export type RVApproverCreateNestedManyWithoutRvInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutRvInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    connect?: MEQSWhereUniqueInput
  }

  export type RVApproverUncheckedCreateNestedManyWithoutRvInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
  }

  export type CanvassUpdateOneWithoutRvNestedInput = {
    create?: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutRvInput
    upsert?: CanvassUpsertWithoutRvInput
    disconnect?: CanvassWhereInput | boolean
    delete?: CanvassWhereInput | boolean
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutRvInput, CanvassUpdateWithoutRvInput>, CanvassUncheckedUpdateWithoutRvInput>
  }

  export type MEQSUpdateOneWithoutRvNestedInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    upsert?: MEQSUpsertWithoutRvInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutRvInput, MEQSUpdateWithoutRvInput>, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUpdateManyWithoutRvNestedInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    upsert?: RVApproverUpsertWithWhereUniqueWithoutRvInput | RVApproverUpsertWithWhereUniqueWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    set?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    disconnect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    delete?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    update?: RVApproverUpdateWithWhereUniqueWithoutRvInput | RVApproverUpdateWithWhereUniqueWithoutRvInput[]
    updateMany?: RVApproverUpdateManyWithWhereWithoutRvInput | RVApproverUpdateManyWithWhereWithoutRvInput[]
    deleteMany?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutRvNestedInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    upsert?: MEQSUpsertWithoutRvInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutRvInput, MEQSUpdateWithoutRvInput>, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUncheckedUpdateManyWithoutRvNestedInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    upsert?: RVApproverUpsertWithWhereUniqueWithoutRvInput | RVApproverUpsertWithWhereUniqueWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    set?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    disconnect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    delete?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    update?: RVApproverUpdateWithWhereUniqueWithoutRvInput | RVApproverUpdateWithWhereUniqueWithoutRvInput[]
    updateMany?: RVApproverUpdateManyWithWhereWithoutRvInput | RVApproverUpdateManyWithWhereWithoutRvInput[]
    deleteMany?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
  }

  export type RVCreateNestedOneWithoutRv_approversInput = {
    create?: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    connectOrCreate?: RVCreateOrConnectWithoutRv_approversInput
    connect?: RVWhereUniqueInput
  }

  export type RVUpdateOneRequiredWithoutRv_approversNestedInput = {
    create?: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    connectOrCreate?: RVCreateOrConnectWithoutRv_approversInput
    upsert?: RVUpsertWithoutRv_approversInput
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutRv_approversInput, RVUpdateWithoutRv_approversInput>, RVUncheckedUpdateWithoutRv_approversInput>
  }

  export type CanvassCreateNestedOneWithoutJoInput = {
    create?: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutJoInput
    connect?: CanvassWhereUniqueInput
  }

  export type MEQSCreateNestedOneWithoutJoInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    connect?: MEQSWhereUniqueInput
  }

  export type JOApproverCreateNestedManyWithoutJoInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutJoInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    connect?: MEQSWhereUniqueInput
  }

  export type JOApproverUncheckedCreateNestedManyWithoutJoInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
  }

  export type CanvassUpdateOneWithoutJoNestedInput = {
    create?: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutJoInput
    upsert?: CanvassUpsertWithoutJoInput
    disconnect?: CanvassWhereInput | boolean
    delete?: CanvassWhereInput | boolean
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutJoInput, CanvassUpdateWithoutJoInput>, CanvassUncheckedUpdateWithoutJoInput>
  }

  export type MEQSUpdateOneWithoutJoNestedInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    upsert?: MEQSUpsertWithoutJoInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutJoInput, MEQSUpdateWithoutJoInput>, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type JOApproverUpdateManyWithoutJoNestedInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    upsert?: JOApproverUpsertWithWhereUniqueWithoutJoInput | JOApproverUpsertWithWhereUniqueWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    set?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    disconnect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    delete?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    update?: JOApproverUpdateWithWhereUniqueWithoutJoInput | JOApproverUpdateWithWhereUniqueWithoutJoInput[]
    updateMany?: JOApproverUpdateManyWithWhereWithoutJoInput | JOApproverUpdateManyWithWhereWithoutJoInput[]
    deleteMany?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutJoNestedInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    upsert?: MEQSUpsertWithoutJoInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutJoInput, MEQSUpdateWithoutJoInput>, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type JOApproverUncheckedUpdateManyWithoutJoNestedInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    upsert?: JOApproverUpsertWithWhereUniqueWithoutJoInput | JOApproverUpsertWithWhereUniqueWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    set?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    disconnect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    delete?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    update?: JOApproverUpdateWithWhereUniqueWithoutJoInput | JOApproverUpdateWithWhereUniqueWithoutJoInput[]
    updateMany?: JOApproverUpdateManyWithWhereWithoutJoInput | JOApproverUpdateManyWithWhereWithoutJoInput[]
    deleteMany?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
  }

  export type JOCreateNestedOneWithoutJo_approversInput = {
    create?: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    connectOrCreate?: JOCreateOrConnectWithoutJo_approversInput
    connect?: JOWhereUniqueInput
  }

  export type JOUpdateOneRequiredWithoutJo_approversNestedInput = {
    create?: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    connectOrCreate?: JOCreateOrConnectWithoutJo_approversInput
    upsert?: JOUpsertWithoutJo_approversInput
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutJo_approversInput, JOUpdateWithoutJo_approversInput>, JOUncheckedUpdateWithoutJo_approversInput>
  }

  export type CanvassCreateNestedOneWithoutSprInput = {
    create?: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutSprInput
    connect?: CanvassWhereUniqueInput
  }

  export type MEQSCreateNestedOneWithoutSprInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    connect?: MEQSWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutSprsInput = {
    create?: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSprsInput
    connect?: VehicleWhereUniqueInput
  }

  export type SPRApproverCreateNestedManyWithoutSprInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutSprInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    connect?: MEQSWhereUniqueInput
  }

  export type SPRApproverUncheckedCreateNestedManyWithoutSprInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
  }

  export type CanvassUpdateOneWithoutSprNestedInput = {
    create?: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutSprInput
    upsert?: CanvassUpsertWithoutSprInput
    disconnect?: CanvassWhereInput | boolean
    delete?: CanvassWhereInput | boolean
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutSprInput, CanvassUpdateWithoutSprInput>, CanvassUncheckedUpdateWithoutSprInput>
  }

  export type MEQSUpdateOneWithoutSprNestedInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    upsert?: MEQSUpsertWithoutSprInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutSprInput, MEQSUpdateWithoutSprInput>, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type VehicleUpdateOneRequiredWithoutSprsNestedInput = {
    create?: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSprsInput
    upsert?: VehicleUpsertWithoutSprsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutSprsInput, VehicleUpdateWithoutSprsInput>, VehicleUncheckedUpdateWithoutSprsInput>
  }

  export type SPRApproverUpdateManyWithoutSprNestedInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    upsert?: SPRApproverUpsertWithWhereUniqueWithoutSprInput | SPRApproverUpsertWithWhereUniqueWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    set?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    disconnect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    delete?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    update?: SPRApproverUpdateWithWhereUniqueWithoutSprInput | SPRApproverUpdateWithWhereUniqueWithoutSprInput[]
    updateMany?: SPRApproverUpdateManyWithWhereWithoutSprInput | SPRApproverUpdateManyWithWhereWithoutSprInput[]
    deleteMany?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutSprNestedInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    upsert?: MEQSUpsertWithoutSprInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutSprInput, MEQSUpdateWithoutSprInput>, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type SPRApproverUncheckedUpdateManyWithoutSprNestedInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    upsert?: SPRApproverUpsertWithWhereUniqueWithoutSprInput | SPRApproverUpsertWithWhereUniqueWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    set?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    disconnect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    delete?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    update?: SPRApproverUpdateWithWhereUniqueWithoutSprInput | SPRApproverUpdateWithWhereUniqueWithoutSprInput[]
    updateMany?: SPRApproverUpdateManyWithWhereWithoutSprInput | SPRApproverUpdateManyWithWhereWithoutSprInput[]
    deleteMany?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
  }

  export type SPRCreateNestedOneWithoutSpr_approversInput = {
    create?: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    connectOrCreate?: SPRCreateOrConnectWithoutSpr_approversInput
    connect?: SPRWhereUniqueInput
  }

  export type SPRUpdateOneRequiredWithoutSpr_approversNestedInput = {
    create?: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    connectOrCreate?: SPRCreateOrConnectWithoutSpr_approversInput
    upsert?: SPRUpsertWithoutSpr_approversInput
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutSpr_approversInput, SPRUpdateWithoutSpr_approversInput>, SPRUncheckedUpdateWithoutSpr_approversInput>
  }

  export type JOCreateNestedOneWithoutMeqsInput = {
    create?: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: JOCreateOrConnectWithoutMeqsInput
    connect?: JOWhereUniqueInput
  }

  export type RVCreateNestedOneWithoutMeqsInput = {
    create?: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: RVCreateOrConnectWithoutMeqsInput
    connect?: RVWhereUniqueInput
  }

  export type SPRCreateNestedOneWithoutMeqsInput = {
    create?: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: SPRCreateOrConnectWithoutMeqsInput
    connect?: SPRWhereUniqueInput
  }

  export type MEQSApproverCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
  }

  export type MEQSSupplierCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
  }

  export type MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type JOUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: JOCreateOrConnectWithoutMeqsInput
    upsert?: JOUpsertWithoutMeqsInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutMeqsInput, JOUpdateWithoutMeqsInput>, JOUncheckedUpdateWithoutMeqsInput>
  }

  export type RVUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: RVCreateOrConnectWithoutMeqsInput
    upsert?: RVUpsertWithoutMeqsInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutMeqsInput, RVUpdateWithoutMeqsInput>, RVUncheckedUpdateWithoutMeqsInput>
  }

  export type SPRUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: SPRCreateOrConnectWithoutMeqsInput
    upsert?: SPRUpsertWithoutMeqsInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutMeqsInput, SPRUpdateWithoutMeqsInput>, SPRUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput | MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    set?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    disconnect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    delete?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    update?: MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput | MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSApproverUpdateManyWithWhereWithoutMeqsInput | MEQSApproverUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
  }

  export type MEQSSupplierUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutMeqsInput | MEQSSupplierUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput | MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    set?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    disconnect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    delete?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    update?: MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput | MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSApproverUpdateManyWithWhereWithoutMeqsInput | MEQSApproverUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutMeqsInput | MEQSSupplierUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSCreateNestedOneWithoutMeqs_suppliersInput = {
    create?: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_suppliersInput
    connect?: MEQSWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutMEQSSupplierInput = {
    create?: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMEQSSupplierInput
    connect?: SupplierWhereUniqueInput
  }

  export type MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
  }

  export type MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type POCreateNestedOneWithoutMeqs_supplierInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    connect?: POWhereUniqueInput
  }

  export type MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
  }

  export type MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type POUncheckedCreateNestedOneWithoutMeqs_supplierInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    connect?: POWhereUniqueInput
  }

  export type MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput = {
    create?: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_suppliersInput
    upsert?: MEQSUpsertWithoutMeqs_suppliersInput
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutMeqs_suppliersInput, MEQSUpdateWithoutMeqs_suppliersInput>, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput = {
    create?: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMEQSSupplierInput
    upsert?: SupplierUpsertWithoutMEQSSupplierInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutMEQSSupplierInput, SupplierUpdateWithoutMEQSSupplierInput>, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
  }

  export type MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    disconnect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    delete?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    update?: MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
  }

  export type MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type POUpdateOneWithoutMeqs_supplierNestedInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    upsert?: POUpsertWithoutMeqs_supplierInput
    disconnect?: POWhereInput | boolean
    delete?: POWhereInput | boolean
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutMeqs_supplierInput, POUpdateWithoutMeqs_supplierInput>, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    disconnect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    delete?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    update?: MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type POUncheckedUpdateOneWithoutMeqs_supplierNestedInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    upsert?: POUpsertWithoutMeqs_supplierInput
    disconnect?: POWhereInput | boolean
    delete?: POWhereInput | boolean
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutMeqs_supplierInput, POUpdateWithoutMeqs_supplierInput>, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput = {
    create?: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput
    connect?: CanvassItemWhereUniqueInput
  }

  export type MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type RRItemCreateNestedManyWithoutMeqs_supplier_itemInput = {
    create?: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput> | RRItemCreateWithoutMeqs_supplier_itemInput[] | RRItemUncheckedCreateWithoutMeqs_supplier_itemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutMeqs_supplier_itemInput | RRItemCreateOrConnectWithoutMeqs_supplier_itemInput[]
    createMany?: RRItemCreateManyMeqs_supplier_itemInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutMeqs_supplier_itemInput = {
    create?: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput> | RRItemCreateWithoutMeqs_supplier_itemInput[] | RRItemUncheckedCreateWithoutMeqs_supplier_itemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutMeqs_supplier_itemInput | RRItemCreateOrConnectWithoutMeqs_supplier_itemInput[]
    createMany?: RRItemCreateManyMeqs_supplier_itemInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput = {
    create?: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput
    upsert?: CanvassItemUpsertWithoutMeqs_supplier_itemsInput
    connect?: CanvassItemWhereUniqueInput
    update?: XOR<XOR<CanvassItemUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput, CanvassItemUpdateWithoutMeqs_supplier_itemsInput>, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput
    upsert?: MEQSSupplierUpsertWithoutMeqs_supplier_itemsInput
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput, MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput>, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type RRItemUpdateManyWithoutMeqs_supplier_itemNestedInput = {
    create?: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput> | RRItemCreateWithoutMeqs_supplier_itemInput[] | RRItemUncheckedCreateWithoutMeqs_supplier_itemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutMeqs_supplier_itemInput | RRItemCreateOrConnectWithoutMeqs_supplier_itemInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutMeqs_supplier_itemInput | RRItemUpsertWithWhereUniqueWithoutMeqs_supplier_itemInput[]
    createMany?: RRItemCreateManyMeqs_supplier_itemInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutMeqs_supplier_itemInput | RRItemUpdateWithWhereUniqueWithoutMeqs_supplier_itemInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutMeqs_supplier_itemInput | RRItemUpdateManyWithWhereWithoutMeqs_supplier_itemInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemNestedInput = {
    create?: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput> | RRItemCreateWithoutMeqs_supplier_itemInput[] | RRItemUncheckedCreateWithoutMeqs_supplier_itemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutMeqs_supplier_itemInput | RRItemCreateOrConnectWithoutMeqs_supplier_itemInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutMeqs_supplier_itemInput | RRItemUpsertWithWhereUniqueWithoutMeqs_supplier_itemInput[]
    createMany?: RRItemCreateManyMeqs_supplier_itemInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutMeqs_supplier_itemInput | RRItemUpdateWithWhereUniqueWithoutMeqs_supplier_itemInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutMeqs_supplier_itemInput | RRItemUpdateManyWithWhereWithoutMeqs_supplier_itemInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type MEQSSupplierCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutAttachmentsInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type MEQSSupplierUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutAttachmentsInput
    upsert?: MEQSSupplierUpsertWithoutAttachmentsInput
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutAttachmentsInput, MEQSSupplierUpdateWithoutAttachmentsInput>, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MEQSCreateNestedOneWithoutMeqs_approversInput = {
    create?: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_approversInput
    connect?: MEQSWhereUniqueInput
  }

  export type MEQSUpdateOneRequiredWithoutMeqs_approversNestedInput = {
    create?: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_approversInput
    upsert?: MEQSUpsertWithoutMeqs_approversInput
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutMeqs_approversInput, MEQSUpdateWithoutMeqs_approversInput>, MEQSUncheckedUpdateWithoutMeqs_approversInput>
  }

  export type MEQSSupplierCreateNestedOneWithoutPoInput = {
    create?: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutPoInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type RRCreateNestedManyWithoutPoInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput> | RRCreateWithoutPoInput[] | RRUncheckedCreateWithoutPoInput[]
    connectOrCreate?: RRCreateOrConnectWithoutPoInput | RRCreateOrConnectWithoutPoInput[]
    createMany?: RRCreateManyPoInputEnvelope
    connect?: RRWhereUniqueInput | RRWhereUniqueInput[]
  }

  export type POApproverCreateNestedManyWithoutPoInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
  }

  export type RRUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput> | RRCreateWithoutPoInput[] | RRUncheckedCreateWithoutPoInput[]
    connectOrCreate?: RRCreateOrConnectWithoutPoInput | RRCreateOrConnectWithoutPoInput[]
    createMany?: RRCreateManyPoInputEnvelope
    connect?: RRWhereUniqueInput | RRWhereUniqueInput[]
  }

  export type POApproverUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
  }

  export type MEQSSupplierUpdateOneWithoutPoNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutPoInput
    upsert?: MEQSSupplierUpsertWithoutPoInput
    disconnect?: MEQSSupplierWhereInput | boolean
    delete?: MEQSSupplierWhereInput | boolean
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutPoInput, MEQSSupplierUpdateWithoutPoInput>, MEQSSupplierUncheckedUpdateWithoutPoInput>
  }

  export type RRUpdateManyWithoutPoNestedInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput> | RRCreateWithoutPoInput[] | RRUncheckedCreateWithoutPoInput[]
    connectOrCreate?: RRCreateOrConnectWithoutPoInput | RRCreateOrConnectWithoutPoInput[]
    upsert?: RRUpsertWithWhereUniqueWithoutPoInput | RRUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: RRCreateManyPoInputEnvelope
    set?: RRWhereUniqueInput | RRWhereUniqueInput[]
    disconnect?: RRWhereUniqueInput | RRWhereUniqueInput[]
    delete?: RRWhereUniqueInput | RRWhereUniqueInput[]
    connect?: RRWhereUniqueInput | RRWhereUniqueInput[]
    update?: RRUpdateWithWhereUniqueWithoutPoInput | RRUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: RRUpdateManyWithWhereWithoutPoInput | RRUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: RRScalarWhereInput | RRScalarWhereInput[]
  }

  export type POApproverUpdateManyWithoutPoNestedInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    upsert?: POApproverUpsertWithWhereUniqueWithoutPoInput | POApproverUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    set?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    disconnect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    delete?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    update?: POApproverUpdateWithWhereUniqueWithoutPoInput | POApproverUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: POApproverUpdateManyWithWhereWithoutPoInput | POApproverUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
  }

  export type RRUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput> | RRCreateWithoutPoInput[] | RRUncheckedCreateWithoutPoInput[]
    connectOrCreate?: RRCreateOrConnectWithoutPoInput | RRCreateOrConnectWithoutPoInput[]
    upsert?: RRUpsertWithWhereUniqueWithoutPoInput | RRUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: RRCreateManyPoInputEnvelope
    set?: RRWhereUniqueInput | RRWhereUniqueInput[]
    disconnect?: RRWhereUniqueInput | RRWhereUniqueInput[]
    delete?: RRWhereUniqueInput | RRWhereUniqueInput[]
    connect?: RRWhereUniqueInput | RRWhereUniqueInput[]
    update?: RRUpdateWithWhereUniqueWithoutPoInput | RRUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: RRUpdateManyWithWhereWithoutPoInput | RRUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: RRScalarWhereInput | RRScalarWhereInput[]
  }

  export type POApproverUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    upsert?: POApproverUpsertWithWhereUniqueWithoutPoInput | POApproverUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    set?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    disconnect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    delete?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    update?: POApproverUpdateWithWhereUniqueWithoutPoInput | POApproverUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: POApproverUpdateManyWithWhereWithoutPoInput | POApproverUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
  }

  export type POCreateNestedOneWithoutPo_approversInput = {
    create?: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    connectOrCreate?: POCreateOrConnectWithoutPo_approversInput
    connect?: POWhereUniqueInput
  }

  export type POUpdateOneRequiredWithoutPo_approversNestedInput = {
    create?: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    connectOrCreate?: POCreateOrConnectWithoutPo_approversInput
    upsert?: POUpsertWithoutPo_approversInput
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutPo_approversInput, POUpdateWithoutPo_approversInput>, POUncheckedUpdateWithoutPo_approversInput>
  }

  export type POCreateNestedOneWithoutRrsInput = {
    create?: XOR<POCreateWithoutRrsInput, POUncheckedCreateWithoutRrsInput>
    connectOrCreate?: POCreateOrConnectWithoutRrsInput
    connect?: POWhereUniqueInput
  }

  export type RRApproverCreateNestedManyWithoutRrInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
  }

  export type RRItemCreateNestedManyWithoutRrInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type RRApproverUncheckedCreateNestedManyWithoutRrInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutRrInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type POUpdateOneWithoutRrsNestedInput = {
    create?: XOR<POCreateWithoutRrsInput, POUncheckedCreateWithoutRrsInput>
    connectOrCreate?: POCreateOrConnectWithoutRrsInput
    upsert?: POUpsertWithoutRrsInput
    disconnect?: POWhereInput | boolean
    delete?: POWhereInput | boolean
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutRrsInput, POUpdateWithoutRrsInput>, POUncheckedUpdateWithoutRrsInput>
  }

  export type RRApproverUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    upsert?: RRApproverUpsertWithWhereUniqueWithoutRrInput | RRApproverUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    set?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    disconnect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    delete?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    update?: RRApproverUpdateWithWhereUniqueWithoutRrInput | RRApproverUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRApproverUpdateManyWithWhereWithoutRrInput | RRApproverUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
  }

  export type RRItemUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutRrInput | RRItemUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutRrInput | RRItemUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutRrInput | RRItemUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type RRApproverUncheckedUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    upsert?: RRApproverUpsertWithWhereUniqueWithoutRrInput | RRApproverUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    set?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    disconnect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    delete?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    update?: RRApproverUpdateWithWhereUniqueWithoutRrInput | RRApproverUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRApproverUpdateManyWithWhereWithoutRrInput | RRApproverUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutRrInput | RRItemUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutRrInput | RRItemUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutRrInput | RRItemUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type RRCreateNestedOneWithoutRr_approversInput = {
    create?: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_approversInput
    connect?: RRWhereUniqueInput
  }

  export type RRUpdateOneRequiredWithoutRr_approversNestedInput = {
    create?: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_approversInput
    upsert?: RRUpsertWithoutRr_approversInput
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutRr_approversInput, RRUpdateWithoutRr_approversInput>, RRUncheckedUpdateWithoutRr_approversInput>
  }

  export type RRCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_itemsInput
    connect?: RRWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutRr_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type MEQSSupplierItemCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutRr_itemsInput, MEQSSupplierItemUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutRr_itemsInput
    connect?: MEQSSupplierItemWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type RRUpdateOneRequiredWithoutRr_itemsNestedInput = {
    create?: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_itemsInput
    upsert?: RRUpsertWithoutRr_itemsInput
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutRr_itemsInput, RRUpdateWithoutRr_itemsInput>, RRUncheckedUpdateWithoutRr_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutRr_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    upsert?: ItemTransactionUpsertWithoutRr_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput, ItemTransactionUpdateWithoutRr_itemInput>, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type MEQSSupplierItemUpdateOneRequiredWithoutRr_itemsNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutRr_itemsInput, MEQSSupplierItemUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutRr_itemsInput
    upsert?: MEQSSupplierItemUpsertWithoutRr_itemsInput
    connect?: MEQSSupplierItemWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierItemUpdateToOneWithWhereWithoutRr_itemsInput, MEQSSupplierItemUpdateWithoutRr_itemsInput>, MEQSSupplierItemUncheckedUpdateWithoutRr_itemsInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    upsert?: ItemTransactionUpsertWithoutRr_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput, ItemTransactionUpdateWithoutRr_itemInput>, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type StationCreateNestedOneWithoutOsrivsInput = {
    create?: XOR<StationCreateWithoutOsrivsInput, StationUncheckedCreateWithoutOsrivsInput>
    connectOrCreate?: StationCreateOrConnectWithoutOsrivsInput
    connect?: StationWhereUniqueInput
  }

  export type OSRIVApproverCreateNestedManyWithoutOsrivInput = {
    create?: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput> | OSRIVApproverCreateWithoutOsrivInput[] | OSRIVApproverUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVApproverCreateOrConnectWithoutOsrivInput | OSRIVApproverCreateOrConnectWithoutOsrivInput[]
    createMany?: OSRIVApproverCreateManyOsrivInputEnvelope
    connect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
  }

  export type OSRIVItemCreateNestedManyWithoutOsrivInput = {
    create?: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput> | OSRIVItemCreateWithoutOsrivInput[] | OSRIVItemUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutOsrivInput | OSRIVItemCreateOrConnectWithoutOsrivInput[]
    createMany?: OSRIVItemCreateManyOsrivInputEnvelope
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
  }

  export type OSRIVApproverUncheckedCreateNestedManyWithoutOsrivInput = {
    create?: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput> | OSRIVApproverCreateWithoutOsrivInput[] | OSRIVApproverUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVApproverCreateOrConnectWithoutOsrivInput | OSRIVApproverCreateOrConnectWithoutOsrivInput[]
    createMany?: OSRIVApproverCreateManyOsrivInputEnvelope
    connect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
  }

  export type OSRIVItemUncheckedCreateNestedManyWithoutOsrivInput = {
    create?: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput> | OSRIVItemCreateWithoutOsrivInput[] | OSRIVItemUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutOsrivInput | OSRIVItemCreateOrConnectWithoutOsrivInput[]
    createMany?: OSRIVItemCreateManyOsrivInputEnvelope
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
  }

  export type StationUpdateOneRequiredWithoutOsrivsNestedInput = {
    create?: XOR<StationCreateWithoutOsrivsInput, StationUncheckedCreateWithoutOsrivsInput>
    connectOrCreate?: StationCreateOrConnectWithoutOsrivsInput
    upsert?: StationUpsertWithoutOsrivsInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutOsrivsInput, StationUpdateWithoutOsrivsInput>, StationUncheckedUpdateWithoutOsrivsInput>
  }

  export type OSRIVApproverUpdateManyWithoutOsrivNestedInput = {
    create?: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput> | OSRIVApproverCreateWithoutOsrivInput[] | OSRIVApproverUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVApproverCreateOrConnectWithoutOsrivInput | OSRIVApproverCreateOrConnectWithoutOsrivInput[]
    upsert?: OSRIVApproverUpsertWithWhereUniqueWithoutOsrivInput | OSRIVApproverUpsertWithWhereUniqueWithoutOsrivInput[]
    createMany?: OSRIVApproverCreateManyOsrivInputEnvelope
    set?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    disconnect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    delete?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    connect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    update?: OSRIVApproverUpdateWithWhereUniqueWithoutOsrivInput | OSRIVApproverUpdateWithWhereUniqueWithoutOsrivInput[]
    updateMany?: OSRIVApproverUpdateManyWithWhereWithoutOsrivInput | OSRIVApproverUpdateManyWithWhereWithoutOsrivInput[]
    deleteMany?: OSRIVApproverScalarWhereInput | OSRIVApproverScalarWhereInput[]
  }

  export type OSRIVItemUpdateManyWithoutOsrivNestedInput = {
    create?: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput> | OSRIVItemCreateWithoutOsrivInput[] | OSRIVItemUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutOsrivInput | OSRIVItemCreateOrConnectWithoutOsrivInput[]
    upsert?: OSRIVItemUpsertWithWhereUniqueWithoutOsrivInput | OSRIVItemUpsertWithWhereUniqueWithoutOsrivInput[]
    createMany?: OSRIVItemCreateManyOsrivInputEnvelope
    set?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    disconnect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    delete?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    update?: OSRIVItemUpdateWithWhereUniqueWithoutOsrivInput | OSRIVItemUpdateWithWhereUniqueWithoutOsrivInput[]
    updateMany?: OSRIVItemUpdateManyWithWhereWithoutOsrivInput | OSRIVItemUpdateManyWithWhereWithoutOsrivInput[]
    deleteMany?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
  }

  export type OSRIVApproverUncheckedUpdateManyWithoutOsrivNestedInput = {
    create?: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput> | OSRIVApproverCreateWithoutOsrivInput[] | OSRIVApproverUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVApproverCreateOrConnectWithoutOsrivInput | OSRIVApproverCreateOrConnectWithoutOsrivInput[]
    upsert?: OSRIVApproverUpsertWithWhereUniqueWithoutOsrivInput | OSRIVApproverUpsertWithWhereUniqueWithoutOsrivInput[]
    createMany?: OSRIVApproverCreateManyOsrivInputEnvelope
    set?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    disconnect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    delete?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    connect?: OSRIVApproverWhereUniqueInput | OSRIVApproverWhereUniqueInput[]
    update?: OSRIVApproverUpdateWithWhereUniqueWithoutOsrivInput | OSRIVApproverUpdateWithWhereUniqueWithoutOsrivInput[]
    updateMany?: OSRIVApproverUpdateManyWithWhereWithoutOsrivInput | OSRIVApproverUpdateManyWithWhereWithoutOsrivInput[]
    deleteMany?: OSRIVApproverScalarWhereInput | OSRIVApproverScalarWhereInput[]
  }

  export type OSRIVItemUncheckedUpdateManyWithoutOsrivNestedInput = {
    create?: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput> | OSRIVItemCreateWithoutOsrivInput[] | OSRIVItemUncheckedCreateWithoutOsrivInput[]
    connectOrCreate?: OSRIVItemCreateOrConnectWithoutOsrivInput | OSRIVItemCreateOrConnectWithoutOsrivInput[]
    upsert?: OSRIVItemUpsertWithWhereUniqueWithoutOsrivInput | OSRIVItemUpsertWithWhereUniqueWithoutOsrivInput[]
    createMany?: OSRIVItemCreateManyOsrivInputEnvelope
    set?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    disconnect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    delete?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    connect?: OSRIVItemWhereUniqueInput | OSRIVItemWhereUniqueInput[]
    update?: OSRIVItemUpdateWithWhereUniqueWithoutOsrivInput | OSRIVItemUpdateWithWhereUniqueWithoutOsrivInput[]
    updateMany?: OSRIVItemUpdateManyWithWhereWithoutOsrivInput | OSRIVItemUpdateManyWithWhereWithoutOsrivInput[]
    deleteMany?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
  }

  export type OSRIVCreateNestedOneWithoutOsriv_approversInput = {
    create?: XOR<OSRIVCreateWithoutOsriv_approversInput, OSRIVUncheckedCreateWithoutOsriv_approversInput>
    connectOrCreate?: OSRIVCreateOrConnectWithoutOsriv_approversInput
    connect?: OSRIVWhereUniqueInput
  }

  export type OSRIVUpdateOneRequiredWithoutOsriv_approversNestedInput = {
    create?: XOR<OSRIVCreateWithoutOsriv_approversInput, OSRIVUncheckedCreateWithoutOsriv_approversInput>
    connectOrCreate?: OSRIVCreateOrConnectWithoutOsriv_approversInput
    upsert?: OSRIVUpsertWithoutOsriv_approversInput
    connect?: OSRIVWhereUniqueInput
    update?: XOR<XOR<OSRIVUpdateToOneWithWhereWithoutOsriv_approversInput, OSRIVUpdateWithoutOsriv_approversInput>, OSRIVUncheckedUpdateWithoutOsriv_approversInput>
  }

  export type OSRIVCreateNestedOneWithoutOsriv_itemsInput = {
    create?: XOR<OSRIVCreateWithoutOsriv_itemsInput, OSRIVUncheckedCreateWithoutOsriv_itemsInput>
    connectOrCreate?: OSRIVCreateOrConnectWithoutOsriv_itemsInput
    connect?: OSRIVWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutOsriv_itemsInput = {
    create?: XOR<ItemCreateWithoutOsriv_itemsInput, ItemUncheckedCreateWithoutOsriv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOsriv_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutOsriv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutOsriv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutOsriv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutOsriv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type OSRIVUpdateOneRequiredWithoutOsriv_itemsNestedInput = {
    create?: XOR<OSRIVCreateWithoutOsriv_itemsInput, OSRIVUncheckedCreateWithoutOsriv_itemsInput>
    connectOrCreate?: OSRIVCreateOrConnectWithoutOsriv_itemsInput
    upsert?: OSRIVUpsertWithoutOsriv_itemsInput
    connect?: OSRIVWhereUniqueInput
    update?: XOR<XOR<OSRIVUpdateToOneWithWhereWithoutOsriv_itemsInput, OSRIVUpdateWithoutOsriv_itemsInput>, OSRIVUncheckedUpdateWithoutOsriv_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutOsriv_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutOsriv_itemsInput, ItemUncheckedCreateWithoutOsriv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOsriv_itemsInput
    upsert?: ItemUpsertWithoutOsriv_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutOsriv_itemsInput, ItemUpdateWithoutOsriv_itemsInput>, ItemUncheckedUpdateWithoutOsriv_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutOsriv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutOsriv_itemInput
    upsert?: ItemTransactionUpsertWithoutOsriv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutOsriv_itemInput, ItemTransactionUpdateWithoutOsriv_itemInput>, ItemTransactionUncheckedUpdateWithoutOsriv_itemInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutOsriv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutOsriv_itemInput
    upsert?: ItemTransactionUpsertWithoutOsriv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutOsriv_itemInput, ItemTransactionUpdateWithoutOsriv_itemInput>, ItemTransactionUncheckedUpdateWithoutOsriv_itemInput>
  }

  export type StationCreateNestedOneWithoutSerivsInput = {
    create?: XOR<StationCreateWithoutSerivsInput, StationUncheckedCreateWithoutSerivsInput>
    connectOrCreate?: StationCreateOrConnectWithoutSerivsInput
    connect?: StationWhereUniqueInput
  }

  export type SERIVApproverCreateNestedManyWithoutSerivInput = {
    create?: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput> | SERIVApproverCreateWithoutSerivInput[] | SERIVApproverUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVApproverCreateOrConnectWithoutSerivInput | SERIVApproverCreateOrConnectWithoutSerivInput[]
    createMany?: SERIVApproverCreateManySerivInputEnvelope
    connect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
  }

  export type SERIVItemCreateNestedManyWithoutSerivInput = {
    create?: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput> | SERIVItemCreateWithoutSerivInput[] | SERIVItemUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutSerivInput | SERIVItemCreateOrConnectWithoutSerivInput[]
    createMany?: SERIVItemCreateManySerivInputEnvelope
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
  }

  export type MCRTCreateNestedManyWithoutSerivInput = {
    create?: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput> | MCRTCreateWithoutSerivInput[] | MCRTUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutSerivInput | MCRTCreateOrConnectWithoutSerivInput[]
    createMany?: MCRTCreateManySerivInputEnvelope
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
  }

  export type SERIVApproverUncheckedCreateNestedManyWithoutSerivInput = {
    create?: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput> | SERIVApproverCreateWithoutSerivInput[] | SERIVApproverUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVApproverCreateOrConnectWithoutSerivInput | SERIVApproverCreateOrConnectWithoutSerivInput[]
    createMany?: SERIVApproverCreateManySerivInputEnvelope
    connect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
  }

  export type SERIVItemUncheckedCreateNestedManyWithoutSerivInput = {
    create?: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput> | SERIVItemCreateWithoutSerivInput[] | SERIVItemUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutSerivInput | SERIVItemCreateOrConnectWithoutSerivInput[]
    createMany?: SERIVItemCreateManySerivInputEnvelope
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
  }

  export type MCRTUncheckedCreateNestedManyWithoutSerivInput = {
    create?: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput> | MCRTCreateWithoutSerivInput[] | MCRTUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutSerivInput | MCRTCreateOrConnectWithoutSerivInput[]
    createMany?: MCRTCreateManySerivInputEnvelope
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
  }

  export type StationUpdateOneRequiredWithoutSerivsNestedInput = {
    create?: XOR<StationCreateWithoutSerivsInput, StationUncheckedCreateWithoutSerivsInput>
    connectOrCreate?: StationCreateOrConnectWithoutSerivsInput
    upsert?: StationUpsertWithoutSerivsInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutSerivsInput, StationUpdateWithoutSerivsInput>, StationUncheckedUpdateWithoutSerivsInput>
  }

  export type SERIVApproverUpdateManyWithoutSerivNestedInput = {
    create?: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput> | SERIVApproverCreateWithoutSerivInput[] | SERIVApproverUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVApproverCreateOrConnectWithoutSerivInput | SERIVApproverCreateOrConnectWithoutSerivInput[]
    upsert?: SERIVApproverUpsertWithWhereUniqueWithoutSerivInput | SERIVApproverUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: SERIVApproverCreateManySerivInputEnvelope
    set?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    disconnect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    delete?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    connect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    update?: SERIVApproverUpdateWithWhereUniqueWithoutSerivInput | SERIVApproverUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: SERIVApproverUpdateManyWithWhereWithoutSerivInput | SERIVApproverUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: SERIVApproverScalarWhereInput | SERIVApproverScalarWhereInput[]
  }

  export type SERIVItemUpdateManyWithoutSerivNestedInput = {
    create?: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput> | SERIVItemCreateWithoutSerivInput[] | SERIVItemUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutSerivInput | SERIVItemCreateOrConnectWithoutSerivInput[]
    upsert?: SERIVItemUpsertWithWhereUniqueWithoutSerivInput | SERIVItemUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: SERIVItemCreateManySerivInputEnvelope
    set?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    disconnect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    delete?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    update?: SERIVItemUpdateWithWhereUniqueWithoutSerivInput | SERIVItemUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: SERIVItemUpdateManyWithWhereWithoutSerivInput | SERIVItemUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
  }

  export type MCRTUpdateManyWithoutSerivNestedInput = {
    create?: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput> | MCRTCreateWithoutSerivInput[] | MCRTUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutSerivInput | MCRTCreateOrConnectWithoutSerivInput[]
    upsert?: MCRTUpsertWithWhereUniqueWithoutSerivInput | MCRTUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: MCRTCreateManySerivInputEnvelope
    set?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    disconnect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    delete?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    update?: MCRTUpdateWithWhereUniqueWithoutSerivInput | MCRTUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: MCRTUpdateManyWithWhereWithoutSerivInput | MCRTUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
  }

  export type SERIVApproverUncheckedUpdateManyWithoutSerivNestedInput = {
    create?: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput> | SERIVApproverCreateWithoutSerivInput[] | SERIVApproverUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVApproverCreateOrConnectWithoutSerivInput | SERIVApproverCreateOrConnectWithoutSerivInput[]
    upsert?: SERIVApproverUpsertWithWhereUniqueWithoutSerivInput | SERIVApproverUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: SERIVApproverCreateManySerivInputEnvelope
    set?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    disconnect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    delete?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    connect?: SERIVApproverWhereUniqueInput | SERIVApproverWhereUniqueInput[]
    update?: SERIVApproverUpdateWithWhereUniqueWithoutSerivInput | SERIVApproverUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: SERIVApproverUpdateManyWithWhereWithoutSerivInput | SERIVApproverUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: SERIVApproverScalarWhereInput | SERIVApproverScalarWhereInput[]
  }

  export type SERIVItemUncheckedUpdateManyWithoutSerivNestedInput = {
    create?: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput> | SERIVItemCreateWithoutSerivInput[] | SERIVItemUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: SERIVItemCreateOrConnectWithoutSerivInput | SERIVItemCreateOrConnectWithoutSerivInput[]
    upsert?: SERIVItemUpsertWithWhereUniqueWithoutSerivInput | SERIVItemUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: SERIVItemCreateManySerivInputEnvelope
    set?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    disconnect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    delete?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    connect?: SERIVItemWhereUniqueInput | SERIVItemWhereUniqueInput[]
    update?: SERIVItemUpdateWithWhereUniqueWithoutSerivInput | SERIVItemUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: SERIVItemUpdateManyWithWhereWithoutSerivInput | SERIVItemUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
  }

  export type MCRTUncheckedUpdateManyWithoutSerivNestedInput = {
    create?: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput> | MCRTCreateWithoutSerivInput[] | MCRTUncheckedCreateWithoutSerivInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutSerivInput | MCRTCreateOrConnectWithoutSerivInput[]
    upsert?: MCRTUpsertWithWhereUniqueWithoutSerivInput | MCRTUpsertWithWhereUniqueWithoutSerivInput[]
    createMany?: MCRTCreateManySerivInputEnvelope
    set?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    disconnect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    delete?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    update?: MCRTUpdateWithWhereUniqueWithoutSerivInput | MCRTUpdateWithWhereUniqueWithoutSerivInput[]
    updateMany?: MCRTUpdateManyWithWhereWithoutSerivInput | MCRTUpdateManyWithWhereWithoutSerivInput[]
    deleteMany?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
  }

  export type SERIVCreateNestedOneWithoutSeriv_approversInput = {
    create?: XOR<SERIVCreateWithoutSeriv_approversInput, SERIVUncheckedCreateWithoutSeriv_approversInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutSeriv_approversInput
    connect?: SERIVWhereUniqueInput
  }

  export type SERIVUpdateOneRequiredWithoutSeriv_approversNestedInput = {
    create?: XOR<SERIVCreateWithoutSeriv_approversInput, SERIVUncheckedCreateWithoutSeriv_approversInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutSeriv_approversInput
    upsert?: SERIVUpsertWithoutSeriv_approversInput
    connect?: SERIVWhereUniqueInput
    update?: XOR<XOR<SERIVUpdateToOneWithWhereWithoutSeriv_approversInput, SERIVUpdateWithoutSeriv_approversInput>, SERIVUncheckedUpdateWithoutSeriv_approversInput>
  }

  export type SERIVCreateNestedOneWithoutSeriv_itemsInput = {
    create?: XOR<SERIVCreateWithoutSeriv_itemsInput, SERIVUncheckedCreateWithoutSeriv_itemsInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutSeriv_itemsInput
    connect?: SERIVWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutSeriv_itemsInput = {
    create?: XOR<ItemCreateWithoutSeriv_itemsInput, ItemUncheckedCreateWithoutSeriv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSeriv_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutSeriv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutSeriv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutSeriv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutSeriv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type SERIVUpdateOneRequiredWithoutSeriv_itemsNestedInput = {
    create?: XOR<SERIVCreateWithoutSeriv_itemsInput, SERIVUncheckedCreateWithoutSeriv_itemsInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutSeriv_itemsInput
    upsert?: SERIVUpsertWithoutSeriv_itemsInput
    connect?: SERIVWhereUniqueInput
    update?: XOR<XOR<SERIVUpdateToOneWithWhereWithoutSeriv_itemsInput, SERIVUpdateWithoutSeriv_itemsInput>, SERIVUncheckedUpdateWithoutSeriv_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutSeriv_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutSeriv_itemsInput, ItemUncheckedCreateWithoutSeriv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSeriv_itemsInput
    upsert?: ItemUpsertWithoutSeriv_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSeriv_itemsInput, ItemUpdateWithoutSeriv_itemsInput>, ItemUncheckedUpdateWithoutSeriv_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutSeriv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutSeriv_itemInput
    upsert?: ItemTransactionUpsertWithoutSeriv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutSeriv_itemInput, ItemTransactionUpdateWithoutSeriv_itemInput>, ItemTransactionUncheckedUpdateWithoutSeriv_itemInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutSeriv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutSeriv_itemInput
    upsert?: ItemTransactionUpsertWithoutSeriv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutSeriv_itemInput, ItemTransactionUpdateWithoutSeriv_itemInput>, ItemTransactionUncheckedUpdateWithoutSeriv_itemInput>
  }

  export type StationCreateNestedOneWithoutMrvsInput = {
    create?: XOR<StationCreateWithoutMrvsInput, StationUncheckedCreateWithoutMrvsInput>
    connectOrCreate?: StationCreateOrConnectWithoutMrvsInput
    connect?: StationWhereUniqueInput
  }

  export type MRVApproverCreateNestedManyWithoutMrvInput = {
    create?: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput> | MRVApproverCreateWithoutMrvInput[] | MRVApproverUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVApproverCreateOrConnectWithoutMrvInput | MRVApproverCreateOrConnectWithoutMrvInput[]
    createMany?: MRVApproverCreateManyMrvInputEnvelope
    connect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
  }

  export type MRVItemCreateNestedManyWithoutMrvInput = {
    create?: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput> | MRVItemCreateWithoutMrvInput[] | MRVItemUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutMrvInput | MRVItemCreateOrConnectWithoutMrvInput[]
    createMany?: MRVItemCreateManyMrvInputEnvelope
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
  }

  export type MCTCreateNestedOneWithoutMrvInput = {
    create?: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMrvInput
    connect?: MCTWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMrvInput = {
    create?: XOR<ProjectCreateWithoutMrvInput, ProjectUncheckedCreateWithoutMrvInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMrvInput
    connect?: ProjectWhereUniqueInput
  }

  export type MRVApproverUncheckedCreateNestedManyWithoutMrvInput = {
    create?: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput> | MRVApproverCreateWithoutMrvInput[] | MRVApproverUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVApproverCreateOrConnectWithoutMrvInput | MRVApproverCreateOrConnectWithoutMrvInput[]
    createMany?: MRVApproverCreateManyMrvInputEnvelope
    connect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
  }

  export type MRVItemUncheckedCreateNestedManyWithoutMrvInput = {
    create?: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput> | MRVItemCreateWithoutMrvInput[] | MRVItemUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutMrvInput | MRVItemCreateOrConnectWithoutMrvInput[]
    createMany?: MRVItemCreateManyMrvInputEnvelope
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
  }

  export type MCTUncheckedCreateNestedOneWithoutMrvInput = {
    create?: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMrvInput
    connect?: MCTWhereUniqueInput
  }

  export type StationUpdateOneRequiredWithoutMrvsNestedInput = {
    create?: XOR<StationCreateWithoutMrvsInput, StationUncheckedCreateWithoutMrvsInput>
    connectOrCreate?: StationCreateOrConnectWithoutMrvsInput
    upsert?: StationUpsertWithoutMrvsInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutMrvsInput, StationUpdateWithoutMrvsInput>, StationUncheckedUpdateWithoutMrvsInput>
  }

  export type MRVApproverUpdateManyWithoutMrvNestedInput = {
    create?: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput> | MRVApproverCreateWithoutMrvInput[] | MRVApproverUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVApproverCreateOrConnectWithoutMrvInput | MRVApproverCreateOrConnectWithoutMrvInput[]
    upsert?: MRVApproverUpsertWithWhereUniqueWithoutMrvInput | MRVApproverUpsertWithWhereUniqueWithoutMrvInput[]
    createMany?: MRVApproverCreateManyMrvInputEnvelope
    set?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    disconnect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    delete?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    connect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    update?: MRVApproverUpdateWithWhereUniqueWithoutMrvInput | MRVApproverUpdateWithWhereUniqueWithoutMrvInput[]
    updateMany?: MRVApproverUpdateManyWithWhereWithoutMrvInput | MRVApproverUpdateManyWithWhereWithoutMrvInput[]
    deleteMany?: MRVApproverScalarWhereInput | MRVApproverScalarWhereInput[]
  }

  export type MRVItemUpdateManyWithoutMrvNestedInput = {
    create?: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput> | MRVItemCreateWithoutMrvInput[] | MRVItemUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutMrvInput | MRVItemCreateOrConnectWithoutMrvInput[]
    upsert?: MRVItemUpsertWithWhereUniqueWithoutMrvInput | MRVItemUpsertWithWhereUniqueWithoutMrvInput[]
    createMany?: MRVItemCreateManyMrvInputEnvelope
    set?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    disconnect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    delete?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    update?: MRVItemUpdateWithWhereUniqueWithoutMrvInput | MRVItemUpdateWithWhereUniqueWithoutMrvInput[]
    updateMany?: MRVItemUpdateManyWithWhereWithoutMrvInput | MRVItemUpdateManyWithWhereWithoutMrvInput[]
    deleteMany?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
  }

  export type MCTUpdateOneWithoutMrvNestedInput = {
    create?: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMrvInput
    upsert?: MCTUpsertWithoutMrvInput
    disconnect?: MCTWhereInput | boolean
    delete?: MCTWhereInput | boolean
    connect?: MCTWhereUniqueInput
    update?: XOR<XOR<MCTUpdateToOneWithWhereWithoutMrvInput, MCTUpdateWithoutMrvInput>, MCTUncheckedUpdateWithoutMrvInput>
  }

  export type ProjectUpdateOneRequiredWithoutMrvNestedInput = {
    create?: XOR<ProjectCreateWithoutMrvInput, ProjectUncheckedCreateWithoutMrvInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMrvInput
    upsert?: ProjectUpsertWithoutMrvInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMrvInput, ProjectUpdateWithoutMrvInput>, ProjectUncheckedUpdateWithoutMrvInput>
  }

  export type MRVApproverUncheckedUpdateManyWithoutMrvNestedInput = {
    create?: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput> | MRVApproverCreateWithoutMrvInput[] | MRVApproverUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVApproverCreateOrConnectWithoutMrvInput | MRVApproverCreateOrConnectWithoutMrvInput[]
    upsert?: MRVApproverUpsertWithWhereUniqueWithoutMrvInput | MRVApproverUpsertWithWhereUniqueWithoutMrvInput[]
    createMany?: MRVApproverCreateManyMrvInputEnvelope
    set?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    disconnect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    delete?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    connect?: MRVApproverWhereUniqueInput | MRVApproverWhereUniqueInput[]
    update?: MRVApproverUpdateWithWhereUniqueWithoutMrvInput | MRVApproverUpdateWithWhereUniqueWithoutMrvInput[]
    updateMany?: MRVApproverUpdateManyWithWhereWithoutMrvInput | MRVApproverUpdateManyWithWhereWithoutMrvInput[]
    deleteMany?: MRVApproverScalarWhereInput | MRVApproverScalarWhereInput[]
  }

  export type MRVItemUncheckedUpdateManyWithoutMrvNestedInput = {
    create?: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput> | MRVItemCreateWithoutMrvInput[] | MRVItemUncheckedCreateWithoutMrvInput[]
    connectOrCreate?: MRVItemCreateOrConnectWithoutMrvInput | MRVItemCreateOrConnectWithoutMrvInput[]
    upsert?: MRVItemUpsertWithWhereUniqueWithoutMrvInput | MRVItemUpsertWithWhereUniqueWithoutMrvInput[]
    createMany?: MRVItemCreateManyMrvInputEnvelope
    set?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    disconnect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    delete?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    connect?: MRVItemWhereUniqueInput | MRVItemWhereUniqueInput[]
    update?: MRVItemUpdateWithWhereUniqueWithoutMrvInput | MRVItemUpdateWithWhereUniqueWithoutMrvInput[]
    updateMany?: MRVItemUpdateManyWithWhereWithoutMrvInput | MRVItemUpdateManyWithWhereWithoutMrvInput[]
    deleteMany?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
  }

  export type MCTUncheckedUpdateOneWithoutMrvNestedInput = {
    create?: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMrvInput
    upsert?: MCTUpsertWithoutMrvInput
    disconnect?: MCTWhereInput | boolean
    delete?: MCTWhereInput | boolean
    connect?: MCTWhereUniqueInput
    update?: XOR<XOR<MCTUpdateToOneWithWhereWithoutMrvInput, MCTUpdateWithoutMrvInput>, MCTUncheckedUpdateWithoutMrvInput>
  }

  export type MRVCreateNestedOneWithoutMrv_approversInput = {
    create?: XOR<MRVCreateWithoutMrv_approversInput, MRVUncheckedCreateWithoutMrv_approversInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMrv_approversInput
    connect?: MRVWhereUniqueInput
  }

  export type MRVUpdateOneRequiredWithoutMrv_approversNestedInput = {
    create?: XOR<MRVCreateWithoutMrv_approversInput, MRVUncheckedCreateWithoutMrv_approversInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMrv_approversInput
    upsert?: MRVUpsertWithoutMrv_approversInput
    connect?: MRVWhereUniqueInput
    update?: XOR<XOR<MRVUpdateToOneWithWhereWithoutMrv_approversInput, MRVUpdateWithoutMrv_approversInput>, MRVUncheckedUpdateWithoutMrv_approversInput>
  }

  export type MRVCreateNestedOneWithoutMrv_itemsInput = {
    create?: XOR<MRVCreateWithoutMrv_itemsInput, MRVUncheckedCreateWithoutMrv_itemsInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMrv_itemsInput
    connect?: MRVWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutMrv_itemsInput = {
    create?: XOR<ItemCreateWithoutMrv_itemsInput, ItemUncheckedCreateWithoutMrv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMrv_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutMrv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMrv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutMrv_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMrv_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type MRVUpdateOneRequiredWithoutMrv_itemsNestedInput = {
    create?: XOR<MRVCreateWithoutMrv_itemsInput, MRVUncheckedCreateWithoutMrv_itemsInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMrv_itemsInput
    upsert?: MRVUpsertWithoutMrv_itemsInput
    connect?: MRVWhereUniqueInput
    update?: XOR<XOR<MRVUpdateToOneWithWhereWithoutMrv_itemsInput, MRVUpdateWithoutMrv_itemsInput>, MRVUncheckedUpdateWithoutMrv_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutMrv_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutMrv_itemsInput, ItemUncheckedCreateWithoutMrv_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMrv_itemsInput
    upsert?: ItemUpsertWithoutMrv_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutMrv_itemsInput, ItemUpdateWithoutMrv_itemsInput>, ItemUncheckedUpdateWithoutMrv_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutMrv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMrv_itemInput
    upsert?: ItemTransactionUpsertWithoutMrv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutMrv_itemInput, ItemTransactionUpdateWithoutMrv_itemInput>, ItemTransactionUncheckedUpdateWithoutMrv_itemInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutMrv_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMrv_itemInput
    upsert?: ItemTransactionUpsertWithoutMrv_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutMrv_itemInput, ItemTransactionUpdateWithoutMrv_itemInput>, ItemTransactionUncheckedUpdateWithoutMrv_itemInput>
  }

  export type MRVCreateNestedOneWithoutMctInput = {
    create?: XOR<MRVCreateWithoutMctInput, MRVUncheckedCreateWithoutMctInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMctInput
    connect?: MRVWhereUniqueInput
  }

  export type MCTApproverCreateNestedManyWithoutMctInput = {
    create?: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput> | MCTApproverCreateWithoutMctInput[] | MCTApproverUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCTApproverCreateOrConnectWithoutMctInput | MCTApproverCreateOrConnectWithoutMctInput[]
    createMany?: MCTApproverCreateManyMctInputEnvelope
    connect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
  }

  export type MCRTCreateNestedManyWithoutMctInput = {
    create?: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput> | MCRTCreateWithoutMctInput[] | MCRTUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutMctInput | MCRTCreateOrConnectWithoutMctInput[]
    createMany?: MCRTCreateManyMctInputEnvelope
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
  }

  export type MCTApproverUncheckedCreateNestedManyWithoutMctInput = {
    create?: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput> | MCTApproverCreateWithoutMctInput[] | MCTApproverUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCTApproverCreateOrConnectWithoutMctInput | MCTApproverCreateOrConnectWithoutMctInput[]
    createMany?: MCTApproverCreateManyMctInputEnvelope
    connect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
  }

  export type MCRTUncheckedCreateNestedManyWithoutMctInput = {
    create?: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput> | MCRTCreateWithoutMctInput[] | MCRTUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutMctInput | MCRTCreateOrConnectWithoutMctInput[]
    createMany?: MCRTCreateManyMctInputEnvelope
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
  }

  export type MRVUpdateOneWithoutMctNestedInput = {
    create?: XOR<MRVCreateWithoutMctInput, MRVUncheckedCreateWithoutMctInput>
    connectOrCreate?: MRVCreateOrConnectWithoutMctInput
    upsert?: MRVUpsertWithoutMctInput
    disconnect?: MRVWhereInput | boolean
    delete?: MRVWhereInput | boolean
    connect?: MRVWhereUniqueInput
    update?: XOR<XOR<MRVUpdateToOneWithWhereWithoutMctInput, MRVUpdateWithoutMctInput>, MRVUncheckedUpdateWithoutMctInput>
  }

  export type MCTApproverUpdateManyWithoutMctNestedInput = {
    create?: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput> | MCTApproverCreateWithoutMctInput[] | MCTApproverUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCTApproverCreateOrConnectWithoutMctInput | MCTApproverCreateOrConnectWithoutMctInput[]
    upsert?: MCTApproverUpsertWithWhereUniqueWithoutMctInput | MCTApproverUpsertWithWhereUniqueWithoutMctInput[]
    createMany?: MCTApproverCreateManyMctInputEnvelope
    set?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    disconnect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    delete?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    connect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    update?: MCTApproverUpdateWithWhereUniqueWithoutMctInput | MCTApproverUpdateWithWhereUniqueWithoutMctInput[]
    updateMany?: MCTApproverUpdateManyWithWhereWithoutMctInput | MCTApproverUpdateManyWithWhereWithoutMctInput[]
    deleteMany?: MCTApproverScalarWhereInput | MCTApproverScalarWhereInput[]
  }

  export type MCRTUpdateManyWithoutMctNestedInput = {
    create?: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput> | MCRTCreateWithoutMctInput[] | MCRTUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutMctInput | MCRTCreateOrConnectWithoutMctInput[]
    upsert?: MCRTUpsertWithWhereUniqueWithoutMctInput | MCRTUpsertWithWhereUniqueWithoutMctInput[]
    createMany?: MCRTCreateManyMctInputEnvelope
    set?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    disconnect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    delete?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    update?: MCRTUpdateWithWhereUniqueWithoutMctInput | MCRTUpdateWithWhereUniqueWithoutMctInput[]
    updateMany?: MCRTUpdateManyWithWhereWithoutMctInput | MCRTUpdateManyWithWhereWithoutMctInput[]
    deleteMany?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
  }

  export type MCTApproverUncheckedUpdateManyWithoutMctNestedInput = {
    create?: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput> | MCTApproverCreateWithoutMctInput[] | MCTApproverUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCTApproverCreateOrConnectWithoutMctInput | MCTApproverCreateOrConnectWithoutMctInput[]
    upsert?: MCTApproverUpsertWithWhereUniqueWithoutMctInput | MCTApproverUpsertWithWhereUniqueWithoutMctInput[]
    createMany?: MCTApproverCreateManyMctInputEnvelope
    set?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    disconnect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    delete?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    connect?: MCTApproverWhereUniqueInput | MCTApproverWhereUniqueInput[]
    update?: MCTApproverUpdateWithWhereUniqueWithoutMctInput | MCTApproverUpdateWithWhereUniqueWithoutMctInput[]
    updateMany?: MCTApproverUpdateManyWithWhereWithoutMctInput | MCTApproverUpdateManyWithWhereWithoutMctInput[]
    deleteMany?: MCTApproverScalarWhereInput | MCTApproverScalarWhereInput[]
  }

  export type MCRTUncheckedUpdateManyWithoutMctNestedInput = {
    create?: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput> | MCRTCreateWithoutMctInput[] | MCRTUncheckedCreateWithoutMctInput[]
    connectOrCreate?: MCRTCreateOrConnectWithoutMctInput | MCRTCreateOrConnectWithoutMctInput[]
    upsert?: MCRTUpsertWithWhereUniqueWithoutMctInput | MCRTUpsertWithWhereUniqueWithoutMctInput[]
    createMany?: MCRTCreateManyMctInputEnvelope
    set?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    disconnect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    delete?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    connect?: MCRTWhereUniqueInput | MCRTWhereUniqueInput[]
    update?: MCRTUpdateWithWhereUniqueWithoutMctInput | MCRTUpdateWithWhereUniqueWithoutMctInput[]
    updateMany?: MCRTUpdateManyWithWhereWithoutMctInput | MCRTUpdateManyWithWhereWithoutMctInput[]
    deleteMany?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
  }

  export type MCTCreateNestedOneWithoutMct_approversInput = {
    create?: XOR<MCTCreateWithoutMct_approversInput, MCTUncheckedCreateWithoutMct_approversInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMct_approversInput
    connect?: MCTWhereUniqueInput
  }

  export type MCTUpdateOneRequiredWithoutMct_approversNestedInput = {
    create?: XOR<MCTCreateWithoutMct_approversInput, MCTUncheckedCreateWithoutMct_approversInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMct_approversInput
    upsert?: MCTUpsertWithoutMct_approversInput
    connect?: MCTWhereUniqueInput
    update?: XOR<XOR<MCTUpdateToOneWithWhereWithoutMct_approversInput, MCTUpdateWithoutMct_approversInput>, MCTUncheckedUpdateWithoutMct_approversInput>
  }

  export type MCTCreateNestedOneWithoutMcrtsInput = {
    create?: XOR<MCTCreateWithoutMcrtsInput, MCTUncheckedCreateWithoutMcrtsInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMcrtsInput
    connect?: MCTWhereUniqueInput
  }

  export type SERIVCreateNestedOneWithoutMcrtsInput = {
    create?: XOR<SERIVCreateWithoutMcrtsInput, SERIVUncheckedCreateWithoutMcrtsInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutMcrtsInput
    connect?: SERIVWhereUniqueInput
  }

  export type MCRTApproverCreateNestedManyWithoutMcrtInput = {
    create?: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput> | MCRTApproverCreateWithoutMcrtInput[] | MCRTApproverUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTApproverCreateOrConnectWithoutMcrtInput | MCRTApproverCreateOrConnectWithoutMcrtInput[]
    createMany?: MCRTApproverCreateManyMcrtInputEnvelope
    connect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
  }

  export type MCRTItemCreateNestedManyWithoutMcrtInput = {
    create?: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput> | MCRTItemCreateWithoutMcrtInput[] | MCRTItemUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutMcrtInput | MCRTItemCreateOrConnectWithoutMcrtInput[]
    createMany?: MCRTItemCreateManyMcrtInputEnvelope
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
  }

  export type MCRTApproverUncheckedCreateNestedManyWithoutMcrtInput = {
    create?: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput> | MCRTApproverCreateWithoutMcrtInput[] | MCRTApproverUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTApproverCreateOrConnectWithoutMcrtInput | MCRTApproverCreateOrConnectWithoutMcrtInput[]
    createMany?: MCRTApproverCreateManyMcrtInputEnvelope
    connect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
  }

  export type MCRTItemUncheckedCreateNestedManyWithoutMcrtInput = {
    create?: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput> | MCRTItemCreateWithoutMcrtInput[] | MCRTItemUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutMcrtInput | MCRTItemCreateOrConnectWithoutMcrtInput[]
    createMany?: MCRTItemCreateManyMcrtInputEnvelope
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
  }

  export type MCTUpdateOneWithoutMcrtsNestedInput = {
    create?: XOR<MCTCreateWithoutMcrtsInput, MCTUncheckedCreateWithoutMcrtsInput>
    connectOrCreate?: MCTCreateOrConnectWithoutMcrtsInput
    upsert?: MCTUpsertWithoutMcrtsInput
    disconnect?: MCTWhereInput | boolean
    delete?: MCTWhereInput | boolean
    connect?: MCTWhereUniqueInput
    update?: XOR<XOR<MCTUpdateToOneWithWhereWithoutMcrtsInput, MCTUpdateWithoutMcrtsInput>, MCTUncheckedUpdateWithoutMcrtsInput>
  }

  export type SERIVUpdateOneWithoutMcrtsNestedInput = {
    create?: XOR<SERIVCreateWithoutMcrtsInput, SERIVUncheckedCreateWithoutMcrtsInput>
    connectOrCreate?: SERIVCreateOrConnectWithoutMcrtsInput
    upsert?: SERIVUpsertWithoutMcrtsInput
    disconnect?: SERIVWhereInput | boolean
    delete?: SERIVWhereInput | boolean
    connect?: SERIVWhereUniqueInput
    update?: XOR<XOR<SERIVUpdateToOneWithWhereWithoutMcrtsInput, SERIVUpdateWithoutMcrtsInput>, SERIVUncheckedUpdateWithoutMcrtsInput>
  }

  export type MCRTApproverUpdateManyWithoutMcrtNestedInput = {
    create?: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput> | MCRTApproverCreateWithoutMcrtInput[] | MCRTApproverUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTApproverCreateOrConnectWithoutMcrtInput | MCRTApproverCreateOrConnectWithoutMcrtInput[]
    upsert?: MCRTApproverUpsertWithWhereUniqueWithoutMcrtInput | MCRTApproverUpsertWithWhereUniqueWithoutMcrtInput[]
    createMany?: MCRTApproverCreateManyMcrtInputEnvelope
    set?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    disconnect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    delete?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    connect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    update?: MCRTApproverUpdateWithWhereUniqueWithoutMcrtInput | MCRTApproverUpdateWithWhereUniqueWithoutMcrtInput[]
    updateMany?: MCRTApproverUpdateManyWithWhereWithoutMcrtInput | MCRTApproverUpdateManyWithWhereWithoutMcrtInput[]
    deleteMany?: MCRTApproverScalarWhereInput | MCRTApproverScalarWhereInput[]
  }

  export type MCRTItemUpdateManyWithoutMcrtNestedInput = {
    create?: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput> | MCRTItemCreateWithoutMcrtInput[] | MCRTItemUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutMcrtInput | MCRTItemCreateOrConnectWithoutMcrtInput[]
    upsert?: MCRTItemUpsertWithWhereUniqueWithoutMcrtInput | MCRTItemUpsertWithWhereUniqueWithoutMcrtInput[]
    createMany?: MCRTItemCreateManyMcrtInputEnvelope
    set?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    disconnect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    delete?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    update?: MCRTItemUpdateWithWhereUniqueWithoutMcrtInput | MCRTItemUpdateWithWhereUniqueWithoutMcrtInput[]
    updateMany?: MCRTItemUpdateManyWithWhereWithoutMcrtInput | MCRTItemUpdateManyWithWhereWithoutMcrtInput[]
    deleteMany?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
  }

  export type MCRTApproverUncheckedUpdateManyWithoutMcrtNestedInput = {
    create?: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput> | MCRTApproverCreateWithoutMcrtInput[] | MCRTApproverUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTApproverCreateOrConnectWithoutMcrtInput | MCRTApproverCreateOrConnectWithoutMcrtInput[]
    upsert?: MCRTApproverUpsertWithWhereUniqueWithoutMcrtInput | MCRTApproverUpsertWithWhereUniqueWithoutMcrtInput[]
    createMany?: MCRTApproverCreateManyMcrtInputEnvelope
    set?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    disconnect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    delete?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    connect?: MCRTApproverWhereUniqueInput | MCRTApproverWhereUniqueInput[]
    update?: MCRTApproverUpdateWithWhereUniqueWithoutMcrtInput | MCRTApproverUpdateWithWhereUniqueWithoutMcrtInput[]
    updateMany?: MCRTApproverUpdateManyWithWhereWithoutMcrtInput | MCRTApproverUpdateManyWithWhereWithoutMcrtInput[]
    deleteMany?: MCRTApproverScalarWhereInput | MCRTApproverScalarWhereInput[]
  }

  export type MCRTItemUncheckedUpdateManyWithoutMcrtNestedInput = {
    create?: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput> | MCRTItemCreateWithoutMcrtInput[] | MCRTItemUncheckedCreateWithoutMcrtInput[]
    connectOrCreate?: MCRTItemCreateOrConnectWithoutMcrtInput | MCRTItemCreateOrConnectWithoutMcrtInput[]
    upsert?: MCRTItemUpsertWithWhereUniqueWithoutMcrtInput | MCRTItemUpsertWithWhereUniqueWithoutMcrtInput[]
    createMany?: MCRTItemCreateManyMcrtInputEnvelope
    set?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    disconnect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    delete?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    connect?: MCRTItemWhereUniqueInput | MCRTItemWhereUniqueInput[]
    update?: MCRTItemUpdateWithWhereUniqueWithoutMcrtInput | MCRTItemUpdateWithWhereUniqueWithoutMcrtInput[]
    updateMany?: MCRTItemUpdateManyWithWhereWithoutMcrtInput | MCRTItemUpdateManyWithWhereWithoutMcrtInput[]
    deleteMany?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
  }

  export type MCRTCreateNestedOneWithoutMcrt_approversInput = {
    create?: XOR<MCRTCreateWithoutMcrt_approversInput, MCRTUncheckedCreateWithoutMcrt_approversInput>
    connectOrCreate?: MCRTCreateOrConnectWithoutMcrt_approversInput
    connect?: MCRTWhereUniqueInput
  }

  export type MCRTUpdateOneRequiredWithoutMcrt_approversNestedInput = {
    create?: XOR<MCRTCreateWithoutMcrt_approversInput, MCRTUncheckedCreateWithoutMcrt_approversInput>
    connectOrCreate?: MCRTCreateOrConnectWithoutMcrt_approversInput
    upsert?: MCRTUpsertWithoutMcrt_approversInput
    connect?: MCRTWhereUniqueInput
    update?: XOR<XOR<MCRTUpdateToOneWithWhereWithoutMcrt_approversInput, MCRTUpdateWithoutMcrt_approversInput>, MCRTUncheckedUpdateWithoutMcrt_approversInput>
  }

  export type MCRTCreateNestedOneWithoutMcrt_itemsInput = {
    create?: XOR<MCRTCreateWithoutMcrt_itemsInput, MCRTUncheckedCreateWithoutMcrt_itemsInput>
    connectOrCreate?: MCRTCreateOrConnectWithoutMcrt_itemsInput
    connect?: MCRTWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutMcrt_itemsInput = {
    create?: XOR<ItemCreateWithoutMcrt_itemsInput, ItemUncheckedCreateWithoutMcrt_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMcrt_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutMcrt_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMcrt_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutMcrt_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMcrt_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type MCRTUpdateOneRequiredWithoutMcrt_itemsNestedInput = {
    create?: XOR<MCRTCreateWithoutMcrt_itemsInput, MCRTUncheckedCreateWithoutMcrt_itemsInput>
    connectOrCreate?: MCRTCreateOrConnectWithoutMcrt_itemsInput
    upsert?: MCRTUpsertWithoutMcrt_itemsInput
    connect?: MCRTWhereUniqueInput
    update?: XOR<XOR<MCRTUpdateToOneWithWhereWithoutMcrt_itemsInput, MCRTUpdateWithoutMcrt_itemsInput>, MCRTUncheckedUpdateWithoutMcrt_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutMcrt_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutMcrt_itemsInput, ItemUncheckedCreateWithoutMcrt_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMcrt_itemsInput
    upsert?: ItemUpsertWithoutMcrt_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutMcrt_itemsInput, ItemUpdateWithoutMcrt_itemsInput>, ItemUncheckedUpdateWithoutMcrt_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutMcrt_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMcrt_itemInput
    upsert?: ItemTransactionUpsertWithoutMcrt_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutMcrt_itemInput, ItemTransactionUpdateWithoutMcrt_itemInput>, ItemTransactionUncheckedUpdateWithoutMcrt_itemInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutMcrt_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutMcrt_itemInput
    upsert?: ItemTransactionUpsertWithoutMcrt_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutMcrt_itemInput, ItemTransactionUpdateWithoutMcrt_itemInput>, ItemTransactionUncheckedUpdateWithoutMcrt_itemInput>
  }

  export type MSTApproverCreateNestedManyWithoutMstInput = {
    create?: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput> | MSTApproverCreateWithoutMstInput[] | MSTApproverUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTApproverCreateOrConnectWithoutMstInput | MSTApproverCreateOrConnectWithoutMstInput[]
    createMany?: MSTApproverCreateManyMstInputEnvelope
    connect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
  }

  export type MSTItemCreateNestedManyWithoutMstInput = {
    create?: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput> | MSTItemCreateWithoutMstInput[] | MSTItemUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutMstInput | MSTItemCreateOrConnectWithoutMstInput[]
    createMany?: MSTItemCreateManyMstInputEnvelope
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
  }

  export type MSTApproverUncheckedCreateNestedManyWithoutMstInput = {
    create?: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput> | MSTApproverCreateWithoutMstInput[] | MSTApproverUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTApproverCreateOrConnectWithoutMstInput | MSTApproverCreateOrConnectWithoutMstInput[]
    createMany?: MSTApproverCreateManyMstInputEnvelope
    connect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
  }

  export type MSTItemUncheckedCreateNestedManyWithoutMstInput = {
    create?: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput> | MSTItemCreateWithoutMstInput[] | MSTItemUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutMstInput | MSTItemCreateOrConnectWithoutMstInput[]
    createMany?: MSTItemCreateManyMstInputEnvelope
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
  }

  export type MSTApproverUpdateManyWithoutMstNestedInput = {
    create?: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput> | MSTApproverCreateWithoutMstInput[] | MSTApproverUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTApproverCreateOrConnectWithoutMstInput | MSTApproverCreateOrConnectWithoutMstInput[]
    upsert?: MSTApproverUpsertWithWhereUniqueWithoutMstInput | MSTApproverUpsertWithWhereUniqueWithoutMstInput[]
    createMany?: MSTApproverCreateManyMstInputEnvelope
    set?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    disconnect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    delete?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    connect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    update?: MSTApproverUpdateWithWhereUniqueWithoutMstInput | MSTApproverUpdateWithWhereUniqueWithoutMstInput[]
    updateMany?: MSTApproverUpdateManyWithWhereWithoutMstInput | MSTApproverUpdateManyWithWhereWithoutMstInput[]
    deleteMany?: MSTApproverScalarWhereInput | MSTApproverScalarWhereInput[]
  }

  export type MSTItemUpdateManyWithoutMstNestedInput = {
    create?: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput> | MSTItemCreateWithoutMstInput[] | MSTItemUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutMstInput | MSTItemCreateOrConnectWithoutMstInput[]
    upsert?: MSTItemUpsertWithWhereUniqueWithoutMstInput | MSTItemUpsertWithWhereUniqueWithoutMstInput[]
    createMany?: MSTItemCreateManyMstInputEnvelope
    set?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    disconnect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    delete?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    update?: MSTItemUpdateWithWhereUniqueWithoutMstInput | MSTItemUpdateWithWhereUniqueWithoutMstInput[]
    updateMany?: MSTItemUpdateManyWithWhereWithoutMstInput | MSTItemUpdateManyWithWhereWithoutMstInput[]
    deleteMany?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
  }

  export type MSTApproverUncheckedUpdateManyWithoutMstNestedInput = {
    create?: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput> | MSTApproverCreateWithoutMstInput[] | MSTApproverUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTApproverCreateOrConnectWithoutMstInput | MSTApproverCreateOrConnectWithoutMstInput[]
    upsert?: MSTApproverUpsertWithWhereUniqueWithoutMstInput | MSTApproverUpsertWithWhereUniqueWithoutMstInput[]
    createMany?: MSTApproverCreateManyMstInputEnvelope
    set?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    disconnect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    delete?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    connect?: MSTApproverWhereUniqueInput | MSTApproverWhereUniqueInput[]
    update?: MSTApproverUpdateWithWhereUniqueWithoutMstInput | MSTApproverUpdateWithWhereUniqueWithoutMstInput[]
    updateMany?: MSTApproverUpdateManyWithWhereWithoutMstInput | MSTApproverUpdateManyWithWhereWithoutMstInput[]
    deleteMany?: MSTApproverScalarWhereInput | MSTApproverScalarWhereInput[]
  }

  export type MSTItemUncheckedUpdateManyWithoutMstNestedInput = {
    create?: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput> | MSTItemCreateWithoutMstInput[] | MSTItemUncheckedCreateWithoutMstInput[]
    connectOrCreate?: MSTItemCreateOrConnectWithoutMstInput | MSTItemCreateOrConnectWithoutMstInput[]
    upsert?: MSTItemUpsertWithWhereUniqueWithoutMstInput | MSTItemUpsertWithWhereUniqueWithoutMstInput[]
    createMany?: MSTItemCreateManyMstInputEnvelope
    set?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    disconnect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    delete?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    connect?: MSTItemWhereUniqueInput | MSTItemWhereUniqueInput[]
    update?: MSTItemUpdateWithWhereUniqueWithoutMstInput | MSTItemUpdateWithWhereUniqueWithoutMstInput[]
    updateMany?: MSTItemUpdateManyWithWhereWithoutMstInput | MSTItemUpdateManyWithWhereWithoutMstInput[]
    deleteMany?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
  }

  export type MSTCreateNestedOneWithoutMst_approversInput = {
    create?: XOR<MSTCreateWithoutMst_approversInput, MSTUncheckedCreateWithoutMst_approversInput>
    connectOrCreate?: MSTCreateOrConnectWithoutMst_approversInput
    connect?: MSTWhereUniqueInput
  }

  export type MSTUpdateOneRequiredWithoutMst_approversNestedInput = {
    create?: XOR<MSTCreateWithoutMst_approversInput, MSTUncheckedCreateWithoutMst_approversInput>
    connectOrCreate?: MSTCreateOrConnectWithoutMst_approversInput
    upsert?: MSTUpsertWithoutMst_approversInput
    connect?: MSTWhereUniqueInput
    update?: XOR<XOR<MSTUpdateToOneWithWhereWithoutMst_approversInput, MSTUpdateWithoutMst_approversInput>, MSTUncheckedUpdateWithoutMst_approversInput>
  }

  export type MSTCreateNestedOneWithoutMst_itemsInput = {
    create?: XOR<MSTCreateWithoutMst_itemsInput, MSTUncheckedCreateWithoutMst_itemsInput>
    connectOrCreate?: MSTCreateOrConnectWithoutMst_itemsInput
    connect?: MSTWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutMst_itemsInput = {
    create?: XOR<ItemCreateWithoutMst_itemsInput, ItemUncheckedCreateWithoutMst_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMst_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type MSTUpdateOneRequiredWithoutMst_itemsNestedInput = {
    create?: XOR<MSTCreateWithoutMst_itemsInput, MSTUncheckedCreateWithoutMst_itemsInput>
    connectOrCreate?: MSTCreateOrConnectWithoutMst_itemsInput
    upsert?: MSTUpsertWithoutMst_itemsInput
    connect?: MSTWhereUniqueInput
    update?: XOR<XOR<MSTUpdateToOneWithWhereWithoutMst_itemsInput, MSTUpdateWithoutMst_itemsInput>, MSTUncheckedUpdateWithoutMst_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutMst_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutMst_itemsInput, ItemUncheckedCreateWithoutMst_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMst_itemsInput
    upsert?: ItemUpsertWithoutMst_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutMst_itemsInput, ItemUpdateWithoutMst_itemsInput>, ItemUncheckedUpdateWithoutMst_itemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ItemCreateWithoutItem_typeInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItem_typeInput = {
    id?: string
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemCreateManyItem_typeInputEnvelope = {
    data: ItemCreateManyItem_typeInput | ItemCreateManyItem_typeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
  }

  export type ItemUpdateManyWithWhereWithoutItem_typeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItem_typeInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    item_type_id?: IntFilter<"Item"> | number
    unit_id?: StringFilter<"Item"> | string
    code?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    total_quantity?: IntFilter<"Item"> | number
    quantity_on_queue?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    alert_level?: IntFilter<"Item"> | number
    created_by?: StringFilter<"Item"> | string
    updated_by?: StringNullableFilter<"Item"> | string | null
    deleted_by?: StringNullableFilter<"Item"> | string | null
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    metadata?: JsonNullableFilter<"Item">
  }

  export type MEQSSupplierCreateWithoutSupplierInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutSupplierInput = {
    id?: string
    meqs_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type MEQSSupplierCreateManySupplierInputEnvelope = {
    data: MEQSSupplierCreateManySupplierInput | MEQSSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    update: XOR<MEQSSupplierUpdateWithoutSupplierInput, MEQSSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    data: XOR<MEQSSupplierUpdateWithoutSupplierInput, MEQSSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type MEQSSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: MEQSSupplierScalarWhereInput
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type MEQSSupplierScalarWhereInput = {
    AND?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
    OR?: MEQSSupplierScalarWhereInput[]
    NOT?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
    id?: StringFilter<"MEQSSupplier"> | string
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    metadata?: JsonNullableFilter<"MEQSSupplier">
  }

  export type CanvassItemCreateWithoutUnitInput = {
    id?: string
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    item?: ItemCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateWithoutUnitInput = {
    id?: string
    canvass_id: string
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput>
  }

  export type CanvassItemCreateManyUnitInputEnvelope = {
    data: CanvassItemCreateManyUnitInput | CanvassItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutUnitInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUnitInput = {
    id?: string
    item_type_id: number
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUnitInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemCreateManyUnitInputEnvelope = {
    data: ItemCreateManyUnitInput | ItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutUnitInput, CanvassItemUncheckedUpdateWithoutUnitInput>
    create: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutUnitInput, CanvassItemUncheckedUpdateWithoutUnitInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutUnitInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type CanvassItemScalarWhereInput = {
    AND?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
    OR?: CanvassItemScalarWhereInput[]
    NOT?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
    id?: StringFilter<"CanvassItem"> | string
    canvass_id?: StringFilter<"CanvassItem"> | string
    unit_id?: StringNullableFilter<"CanvassItem"> | string | null
    item_id?: StringNullableFilter<"CanvassItem"> | string | null
    description?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    metadata?: JsonNullableFilter<"CanvassItem">
  }

  export type ItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
  }

  export type ItemUpdateManyWithWhereWithoutUnitInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type SPRCreateWithoutVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutSprInput
    meqs?: MEQSCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput>
  }

  export type SPRCreateManyVehicleInputEnvelope = {
    data: SPRCreateManyVehicleInput | SPRCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type SPRUpsertWithWhereUniqueWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    update: XOR<SPRUpdateWithoutVehicleInput, SPRUncheckedUpdateWithoutVehicleInput>
    create: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput>
  }

  export type SPRUpdateWithWhereUniqueWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    data: XOR<SPRUpdateWithoutVehicleInput, SPRUncheckedUpdateWithoutVehicleInput>
  }

  export type SPRUpdateManyWithWhereWithoutVehicleInput = {
    where: SPRScalarWhereInput
    data: XOR<SPRUpdateManyMutationInput, SPRUncheckedUpdateManyWithoutVehicleInput>
  }

  export type SPRScalarWhereInput = {
    AND?: SPRScalarWhereInput | SPRScalarWhereInput[]
    OR?: SPRScalarWhereInput[]
    NOT?: SPRScalarWhereInput | SPRScalarWhereInput[]
    id?: StringFilter<"SPR"> | string
    spr_number?: StringFilter<"SPR"> | string
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    canvass_id?: StringNullableFilter<"SPR"> | string | null
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    notes?: StringFilter<"SPR"> | string
    cancelled_by?: StringNullableFilter<"SPR"> | string | null
    created_by?: StringFilter<"SPR"> | string
    updated_by?: StringNullableFilter<"SPR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SPR"> | Date | string | null
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    metadata?: JsonNullableFilter<"SPR">
  }

  export type ItemLocationCreateWithoutStationInput = {
    id?: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_locationsInput
    origin_movements?: ItemMovementCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationUncheckedCreateWithoutStationInput = {
    id?: string
    item_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationCreateOrConnectWithoutStationInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput>
  }

  export type ItemLocationCreateManyStationInputEnvelope = {
    data: ItemLocationCreateManyStationInput | ItemLocationCreateManyStationInput[]
    skipDuplicates?: boolean
  }

  export type OSRIVCreateWithoutItem_fromInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverCreateNestedManyWithoutOsrivInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVUncheckedCreateWithoutItem_fromInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedCreateNestedManyWithoutOsrivInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVCreateOrConnectWithoutItem_fromInput = {
    where: OSRIVWhereUniqueInput
    create: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput>
  }

  export type OSRIVCreateManyItem_fromInputEnvelope = {
    data: OSRIVCreateManyItem_fromInput | OSRIVCreateManyItem_fromInput[]
    skipDuplicates?: boolean
  }

  export type MRVCreateWithoutItem_fromInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemCreateNestedManyWithoutMrvInput
    mct?: MCTCreateNestedOneWithoutMrvInput
    project: ProjectCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateWithoutItem_fromInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutMrvInput
    mct?: MCTUncheckedCreateNestedOneWithoutMrvInput
  }

  export type MRVCreateOrConnectWithoutItem_fromInput = {
    where: MRVWhereUniqueInput
    create: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput>
  }

  export type MRVCreateManyItem_fromInputEnvelope = {
    data: MRVCreateManyItem_fromInput | MRVCreateManyItem_fromInput[]
    skipDuplicates?: boolean
  }

  export type SERIVCreateWithoutItem_fromInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemCreateNestedManyWithoutSerivInput
    mcrts?: MCRTCreateNestedManyWithoutSerivInput
  }

  export type SERIVUncheckedCreateWithoutItem_fromInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutSerivInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutSerivInput
  }

  export type SERIVCreateOrConnectWithoutItem_fromInput = {
    where: SERIVWhereUniqueInput
    create: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput>
  }

  export type SERIVCreateManyItem_fromInputEnvelope = {
    data: SERIVCreateManyItem_fromInput | SERIVCreateManyItem_fromInput[]
    skipDuplicates?: boolean
  }

  export type ItemLocationUpsertWithWhereUniqueWithoutStationInput = {
    where: ItemLocationWhereUniqueInput
    update: XOR<ItemLocationUpdateWithoutStationInput, ItemLocationUncheckedUpdateWithoutStationInput>
    create: XOR<ItemLocationCreateWithoutStationInput, ItemLocationUncheckedCreateWithoutStationInput>
  }

  export type ItemLocationUpdateWithWhereUniqueWithoutStationInput = {
    where: ItemLocationWhereUniqueInput
    data: XOR<ItemLocationUpdateWithoutStationInput, ItemLocationUncheckedUpdateWithoutStationInput>
  }

  export type ItemLocationUpdateManyWithWhereWithoutStationInput = {
    where: ItemLocationScalarWhereInput
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyWithoutStationInput>
  }

  export type ItemLocationScalarWhereInput = {
    AND?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
    OR?: ItemLocationScalarWhereInput[]
    NOT?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
    id?: StringFilter<"ItemLocation"> | string
    item_id?: StringFilter<"ItemLocation"> | string
    station_id?: StringFilter<"ItemLocation"> | string
    quantity_on_hand?: IntFilter<"ItemLocation"> | number
    created_by?: StringFilter<"ItemLocation"> | string
    created_at?: DateTimeFilter<"ItemLocation"> | Date | string
    metadata?: JsonNullableFilter<"ItemLocation">
  }

  export type OSRIVUpsertWithWhereUniqueWithoutItem_fromInput = {
    where: OSRIVWhereUniqueInput
    update: XOR<OSRIVUpdateWithoutItem_fromInput, OSRIVUncheckedUpdateWithoutItem_fromInput>
    create: XOR<OSRIVCreateWithoutItem_fromInput, OSRIVUncheckedCreateWithoutItem_fromInput>
  }

  export type OSRIVUpdateWithWhereUniqueWithoutItem_fromInput = {
    where: OSRIVWhereUniqueInput
    data: XOR<OSRIVUpdateWithoutItem_fromInput, OSRIVUncheckedUpdateWithoutItem_fromInput>
  }

  export type OSRIVUpdateManyWithWhereWithoutItem_fromInput = {
    where: OSRIVScalarWhereInput
    data: XOR<OSRIVUpdateManyMutationInput, OSRIVUncheckedUpdateManyWithoutItem_fromInput>
  }

  export type OSRIVScalarWhereInput = {
    AND?: OSRIVScalarWhereInput | OSRIVScalarWhereInput[]
    OR?: OSRIVScalarWhereInput[]
    NOT?: OSRIVScalarWhereInput | OSRIVScalarWhereInput[]
    id?: StringFilter<"OSRIV"> | string
    osriv_number?: StringFilter<"OSRIV"> | string
    date_requested?: DateTimeFilter<"OSRIV"> | Date | string
    exp_date?: DateTimeFilter<"OSRIV"> | Date | string
    purpose?: StringFilter<"OSRIV"> | string
    note?: StringFilter<"OSRIV"> | string
    is_completed?: BoolFilter<"OSRIV"> | boolean
    requested_by_id?: StringFilter<"OSRIV"> | string
    item_from_id?: StringFilter<"OSRIV"> | string
    cancelled_by?: StringNullableFilter<"OSRIV"> | string | null
    created_by?: StringFilter<"OSRIV"> | string
    updated_by?: StringNullableFilter<"OSRIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"OSRIV"> | Date | string | null
    created_at?: DateTimeFilter<"OSRIV"> | Date | string
    updated_at?: DateTimeFilter<"OSRIV"> | Date | string
    metadata?: JsonNullableFilter<"OSRIV">
  }

  export type MRVUpsertWithWhereUniqueWithoutItem_fromInput = {
    where: MRVWhereUniqueInput
    update: XOR<MRVUpdateWithoutItem_fromInput, MRVUncheckedUpdateWithoutItem_fromInput>
    create: XOR<MRVCreateWithoutItem_fromInput, MRVUncheckedCreateWithoutItem_fromInput>
  }

  export type MRVUpdateWithWhereUniqueWithoutItem_fromInput = {
    where: MRVWhereUniqueInput
    data: XOR<MRVUpdateWithoutItem_fromInput, MRVUncheckedUpdateWithoutItem_fromInput>
  }

  export type MRVUpdateManyWithWhereWithoutItem_fromInput = {
    where: MRVScalarWhereInput
    data: XOR<MRVUpdateManyMutationInput, MRVUncheckedUpdateManyWithoutItem_fromInput>
  }

  export type MRVScalarWhereInput = {
    AND?: MRVScalarWhereInput | MRVScalarWhereInput[]
    OR?: MRVScalarWhereInput[]
    NOT?: MRVScalarWhereInput | MRVScalarWhereInput[]
    id?: StringFilter<"MRV"> | string
    project_id?: StringFilter<"MRV"> | string
    mrv_number?: StringFilter<"MRV"> | string
    date_requested?: DateTimeFilter<"MRV"> | Date | string
    exp_date?: DateTimeFilter<"MRV"> | Date | string
    purpose?: StringFilter<"MRV"> | string
    note?: StringFilter<"MRV"> | string
    is_completed?: BoolFilter<"MRV"> | boolean
    request_type?: IntFilter<"MRV"> | number
    or_number?: StringNullableFilter<"MRV"> | string | null
    mwo_number?: StringNullableFilter<"MRV"> | string | null
    cwo_number?: StringNullableFilter<"MRV"> | string | null
    jo_number?: StringNullableFilter<"MRV"> | string | null
    consumer_name?: StringFilter<"MRV"> | string
    location?: StringFilter<"MRV"> | string
    requested_by_id?: StringFilter<"MRV"> | string
    withdrawn_by_id?: StringFilter<"MRV"> | string
    item_from_id?: StringFilter<"MRV"> | string
    cancelled_by?: StringNullableFilter<"MRV"> | string | null
    created_by?: StringFilter<"MRV"> | string
    updated_by?: StringNullableFilter<"MRV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MRV"> | Date | string | null
    created_at?: DateTimeFilter<"MRV"> | Date | string
    updated_at?: DateTimeFilter<"MRV"> | Date | string
    metadata?: JsonNullableFilter<"MRV">
  }

  export type SERIVUpsertWithWhereUniqueWithoutItem_fromInput = {
    where: SERIVWhereUniqueInput
    update: XOR<SERIVUpdateWithoutItem_fromInput, SERIVUncheckedUpdateWithoutItem_fromInput>
    create: XOR<SERIVCreateWithoutItem_fromInput, SERIVUncheckedCreateWithoutItem_fromInput>
  }

  export type SERIVUpdateWithWhereUniqueWithoutItem_fromInput = {
    where: SERIVWhereUniqueInput
    data: XOR<SERIVUpdateWithoutItem_fromInput, SERIVUncheckedUpdateWithoutItem_fromInput>
  }

  export type SERIVUpdateManyWithWhereWithoutItem_fromInput = {
    where: SERIVScalarWhereInput
    data: XOR<SERIVUpdateManyMutationInput, SERIVUncheckedUpdateManyWithoutItem_fromInput>
  }

  export type SERIVScalarWhereInput = {
    AND?: SERIVScalarWhereInput | SERIVScalarWhereInput[]
    OR?: SERIVScalarWhereInput[]
    NOT?: SERIVScalarWhereInput | SERIVScalarWhereInput[]
    id?: StringFilter<"SERIV"> | string
    seriv_number?: StringFilter<"SERIV"> | string
    date_requested?: DateTimeFilter<"SERIV"> | Date | string
    exp_date?: DateTimeFilter<"SERIV"> | Date | string
    purpose?: StringFilter<"SERIV"> | string
    note?: StringFilter<"SERIV"> | string
    is_completed?: BoolFilter<"SERIV"> | boolean
    request_type?: IntFilter<"SERIV"> | number
    or_number?: StringNullableFilter<"SERIV"> | string | null
    mwo_number?: StringNullableFilter<"SERIV"> | string | null
    cwo_number?: StringNullableFilter<"SERIV"> | string | null
    jo_number?: StringNullableFilter<"SERIV"> | string | null
    consumer_name?: StringFilter<"SERIV"> | string
    location?: StringFilter<"SERIV"> | string
    requested_by_id?: StringFilter<"SERIV"> | string
    withdrawn_by_id?: StringFilter<"SERIV"> | string
    item_from_id?: StringFilter<"SERIV"> | string
    cancelled_by?: StringNullableFilter<"SERIV"> | string | null
    created_by?: StringFilter<"SERIV"> | string
    updated_by?: StringNullableFilter<"SERIV"> | string | null
    cancelled_at?: DateTimeNullableFilter<"SERIV"> | Date | string | null
    created_at?: DateTimeFilter<"SERIV"> | Date | string
    updated_at?: DateTimeFilter<"SERIV"> | Date | string
    metadata?: JsonNullableFilter<"SERIV">
  }

  export type MRVCreateWithoutProjectInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutMrvsInput
    mrv_approvers?: MRVApproverCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemCreateNestedManyWithoutMrvInput
    mct?: MCTCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateWithoutProjectInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutMrvInput
    mct?: MCTUncheckedCreateNestedOneWithoutMrvInput
  }

  export type MRVCreateOrConnectWithoutProjectInput = {
    where: MRVWhereUniqueInput
    create: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput>
  }

  export type MRVCreateManyProjectInputEnvelope = {
    data: MRVCreateManyProjectInput | MRVCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MRVUpsertWithWhereUniqueWithoutProjectInput = {
    where: MRVWhereUniqueInput
    update: XOR<MRVUpdateWithoutProjectInput, MRVUncheckedUpdateWithoutProjectInput>
    create: XOR<MRVCreateWithoutProjectInput, MRVUncheckedCreateWithoutProjectInput>
  }

  export type MRVUpdateWithWhereUniqueWithoutProjectInput = {
    where: MRVWhereUniqueInput
    data: XOR<MRVUpdateWithoutProjectInput, MRVUncheckedUpdateWithoutProjectInput>
  }

  export type MRVUpdateManyWithWhereWithoutProjectInput = {
    where: MRVScalarWhereInput
    data: XOR<MRVUpdateManyMutationInput, MRVUncheckedUpdateManyWithoutProjectInput>
  }

  export type ItemTypeCreateWithoutItemsInput = {
    code: string
    name: string
  }

  export type ItemTypeUncheckedCreateWithoutItemsInput = {
    id?: number
    code: string
    name: string
  }

  export type ItemTypeCreateOrConnectWithoutItemsInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
  }

  export type ItemTransactionCreateWithoutItemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutItemInput = {
    id?: number
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput>
  }

  export type ItemTransactionCreateManyItemInputEnvelope = {
    data: ItemTransactionCreateManyItemInput | ItemTransactionCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutItemsInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type CanvassItemCreateWithoutItemInput = {
    id?: string
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    unit?: UnitCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateWithoutItemInput = {
    id?: string
    canvass_id: string
    unit_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutItemInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput>
  }

  export type CanvassItemCreateManyItemInputEnvelope = {
    data: CanvassItemCreateManyItemInput | CanvassItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemLocationCreateWithoutItemInput = {
    id?: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    station: StationCreateNestedOneWithoutItemsInput
    origin_movements?: ItemMovementCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationUncheckedCreateWithoutItemInput = {
    id?: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedCreateNestedManyWithoutOriginInput
    destination_movements?: ItemMovementUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationCreateOrConnectWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput>
  }

  export type ItemLocationCreateManyItemInputEnvelope = {
    data: ItemLocationCreateManyItemInput | ItemLocationCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type OSRIVItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv: OSRIVCreateNestedOneWithoutOsriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemUncheckedCreateWithoutItemInput = {
    id?: string
    osriv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemCreateOrConnectWithoutItemInput = {
    where: OSRIVItemWhereUniqueInput
    create: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput>
  }

  export type OSRIVItemCreateManyItemInputEnvelope = {
    data: OSRIVItemCreateManyItemInput | OSRIVItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SERIVItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv: SERIVCreateNestedOneWithoutSeriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemUncheckedCreateWithoutItemInput = {
    id?: string
    seriv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemCreateOrConnectWithoutItemInput = {
    where: SERIVItemWhereUniqueInput
    create: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput>
  }

  export type SERIVItemCreateManyItemInputEnvelope = {
    data: SERIVItemCreateManyItemInput | SERIVItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type MRVItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv: MRVCreateNestedOneWithoutMrv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemUncheckedCreateWithoutItemInput = {
    id?: string
    mrv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemCreateOrConnectWithoutItemInput = {
    where: MRVItemWhereUniqueInput
    create: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput>
  }

  export type MRVItemCreateManyItemInputEnvelope = {
    data: MRVItemCreateManyItemInput | MRVItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type MCRTItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt: MCRTCreateNestedOneWithoutMcrt_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemUncheckedCreateWithoutItemInput = {
    id?: string
    mcrt_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemCreateOrConnectWithoutItemInput = {
    where: MCRTItemWhereUniqueInput
    create: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput>
  }

  export type MCRTItemCreateManyItemInputEnvelope = {
    data: MCRTItemCreateManyItemInput | MCRTItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type MSTItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst: MSTCreateNestedOneWithoutMst_itemsInput
  }

  export type MSTItemUncheckedCreateWithoutItemInput = {
    id?: string
    mst_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateOrConnectWithoutItemInput = {
    where: MSTItemWhereUniqueInput
    create: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput>
  }

  export type MSTItemCreateManyItemInputEnvelope = {
    data: MSTItemCreateManyItemInput | MSTItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemTypeUpsertWithoutItemsInput = {
    update: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTypeUpdateWithoutItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ItemTypeUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ItemTransactionUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    update: XOR<ItemTransactionUpdateWithoutItemInput, ItemTransactionUncheckedUpdateWithoutItemInput>
    create: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput>
  }

  export type ItemTransactionUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    data: XOR<ItemTransactionUpdateWithoutItemInput, ItemTransactionUncheckedUpdateWithoutItemInput>
  }

  export type ItemTransactionUpdateManyWithWhereWithoutItemInput = {
    where: ItemTransactionScalarWhereInput
    data: XOR<ItemTransactionUpdateManyMutationInput, ItemTransactionUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemTransactionScalarWhereInput = {
    AND?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
    OR?: ItemTransactionScalarWhereInput[]
    NOT?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
    id?: IntFilter<"ItemTransaction"> | number
    item_id?: StringFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    osriv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    seriv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    mrv_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    mcrt_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: IntFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    created_by?: StringFilter<"ItemTransaction"> | string
    metadata?: JsonNullableFilter<"ItemTransaction">
  }

  export type UnitUpsertWithoutItemsInput = {
    update: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutItemInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutItemInput, CanvassItemUncheckedUpdateWithoutItemInput>
    create: XOR<CanvassItemCreateWithoutItemInput, CanvassItemUncheckedCreateWithoutItemInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutItemInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutItemInput, CanvassItemUncheckedUpdateWithoutItemInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutItemInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemLocationUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    update: XOR<ItemLocationUpdateWithoutItemInput, ItemLocationUncheckedUpdateWithoutItemInput>
    create: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput>
  }

  export type ItemLocationUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    data: XOR<ItemLocationUpdateWithoutItemInput, ItemLocationUncheckedUpdateWithoutItemInput>
  }

  export type ItemLocationUpdateManyWithWhereWithoutItemInput = {
    where: ItemLocationScalarWhereInput
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyWithoutItemInput>
  }

  export type OSRIVItemUpsertWithWhereUniqueWithoutItemInput = {
    where: OSRIVItemWhereUniqueInput
    update: XOR<OSRIVItemUpdateWithoutItemInput, OSRIVItemUncheckedUpdateWithoutItemInput>
    create: XOR<OSRIVItemCreateWithoutItemInput, OSRIVItemUncheckedCreateWithoutItemInput>
  }

  export type OSRIVItemUpdateWithWhereUniqueWithoutItemInput = {
    where: OSRIVItemWhereUniqueInput
    data: XOR<OSRIVItemUpdateWithoutItemInput, OSRIVItemUncheckedUpdateWithoutItemInput>
  }

  export type OSRIVItemUpdateManyWithWhereWithoutItemInput = {
    where: OSRIVItemScalarWhereInput
    data: XOR<OSRIVItemUpdateManyMutationInput, OSRIVItemUncheckedUpdateManyWithoutItemInput>
  }

  export type OSRIVItemScalarWhereInput = {
    AND?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
    OR?: OSRIVItemScalarWhereInput[]
    NOT?: OSRIVItemScalarWhereInput | OSRIVItemScalarWhereInput[]
    id?: StringFilter<"OSRIVItem"> | string
    osriv_id?: StringFilter<"OSRIVItem"> | string
    item_id?: StringFilter<"OSRIVItem"> | string
    quantity?: IntFilter<"OSRIVItem"> | number
    price?: FloatFilter<"OSRIVItem"> | number
    created_by?: StringFilter<"OSRIVItem"> | string
    created_at?: DateTimeFilter<"OSRIVItem"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVItem">
  }

  export type SERIVItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SERIVItemWhereUniqueInput
    update: XOR<SERIVItemUpdateWithoutItemInput, SERIVItemUncheckedUpdateWithoutItemInput>
    create: XOR<SERIVItemCreateWithoutItemInput, SERIVItemUncheckedCreateWithoutItemInput>
  }

  export type SERIVItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SERIVItemWhereUniqueInput
    data: XOR<SERIVItemUpdateWithoutItemInput, SERIVItemUncheckedUpdateWithoutItemInput>
  }

  export type SERIVItemUpdateManyWithWhereWithoutItemInput = {
    where: SERIVItemScalarWhereInput
    data: XOR<SERIVItemUpdateManyMutationInput, SERIVItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SERIVItemScalarWhereInput = {
    AND?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
    OR?: SERIVItemScalarWhereInput[]
    NOT?: SERIVItemScalarWhereInput | SERIVItemScalarWhereInput[]
    id?: StringFilter<"SERIVItem"> | string
    seriv_id?: StringFilter<"SERIVItem"> | string
    item_id?: StringFilter<"SERIVItem"> | string
    quantity?: IntFilter<"SERIVItem"> | number
    price?: FloatFilter<"SERIVItem"> | number
    created_by?: StringFilter<"SERIVItem"> | string
    created_at?: DateTimeFilter<"SERIVItem"> | Date | string
    metadata?: JsonNullableFilter<"SERIVItem">
  }

  export type MRVItemUpsertWithWhereUniqueWithoutItemInput = {
    where: MRVItemWhereUniqueInput
    update: XOR<MRVItemUpdateWithoutItemInput, MRVItemUncheckedUpdateWithoutItemInput>
    create: XOR<MRVItemCreateWithoutItemInput, MRVItemUncheckedCreateWithoutItemInput>
  }

  export type MRVItemUpdateWithWhereUniqueWithoutItemInput = {
    where: MRVItemWhereUniqueInput
    data: XOR<MRVItemUpdateWithoutItemInput, MRVItemUncheckedUpdateWithoutItemInput>
  }

  export type MRVItemUpdateManyWithWhereWithoutItemInput = {
    where: MRVItemScalarWhereInput
    data: XOR<MRVItemUpdateManyMutationInput, MRVItemUncheckedUpdateManyWithoutItemInput>
  }

  export type MRVItemScalarWhereInput = {
    AND?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
    OR?: MRVItemScalarWhereInput[]
    NOT?: MRVItemScalarWhereInput | MRVItemScalarWhereInput[]
    id?: StringFilter<"MRVItem"> | string
    mrv_id?: StringFilter<"MRVItem"> | string
    item_id?: StringFilter<"MRVItem"> | string
    quantity?: IntFilter<"MRVItem"> | number
    price?: FloatFilter<"MRVItem"> | number
    created_by?: StringFilter<"MRVItem"> | string
    created_at?: DateTimeFilter<"MRVItem"> | Date | string
    metadata?: JsonNullableFilter<"MRVItem">
  }

  export type MCRTItemUpsertWithWhereUniqueWithoutItemInput = {
    where: MCRTItemWhereUniqueInput
    update: XOR<MCRTItemUpdateWithoutItemInput, MCRTItemUncheckedUpdateWithoutItemInput>
    create: XOR<MCRTItemCreateWithoutItemInput, MCRTItemUncheckedCreateWithoutItemInput>
  }

  export type MCRTItemUpdateWithWhereUniqueWithoutItemInput = {
    where: MCRTItemWhereUniqueInput
    data: XOR<MCRTItemUpdateWithoutItemInput, MCRTItemUncheckedUpdateWithoutItemInput>
  }

  export type MCRTItemUpdateManyWithWhereWithoutItemInput = {
    where: MCRTItemScalarWhereInput
    data: XOR<MCRTItemUpdateManyMutationInput, MCRTItemUncheckedUpdateManyWithoutItemInput>
  }

  export type MCRTItemScalarWhereInput = {
    AND?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
    OR?: MCRTItemScalarWhereInput[]
    NOT?: MCRTItemScalarWhereInput | MCRTItemScalarWhereInput[]
    id?: StringFilter<"MCRTItem"> | string
    mcrt_id?: StringFilter<"MCRTItem"> | string
    item_id?: StringFilter<"MCRTItem"> | string
    quantity?: IntFilter<"MCRTItem"> | number
    price?: FloatFilter<"MCRTItem"> | number
    created_by?: StringFilter<"MCRTItem"> | string
    created_at?: DateTimeFilter<"MCRTItem"> | Date | string
    metadata?: JsonNullableFilter<"MCRTItem">
  }

  export type MSTItemUpsertWithWhereUniqueWithoutItemInput = {
    where: MSTItemWhereUniqueInput
    update: XOR<MSTItemUpdateWithoutItemInput, MSTItemUncheckedUpdateWithoutItemInput>
    create: XOR<MSTItemCreateWithoutItemInput, MSTItemUncheckedCreateWithoutItemInput>
  }

  export type MSTItemUpdateWithWhereUniqueWithoutItemInput = {
    where: MSTItemWhereUniqueInput
    data: XOR<MSTItemUpdateWithoutItemInput, MSTItemUncheckedUpdateWithoutItemInput>
  }

  export type MSTItemUpdateManyWithWhereWithoutItemInput = {
    where: MSTItemScalarWhereInput
    data: XOR<MSTItemUpdateManyMutationInput, MSTItemUncheckedUpdateManyWithoutItemInput>
  }

  export type MSTItemScalarWhereInput = {
    AND?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
    OR?: MSTItemScalarWhereInput[]
    NOT?: MSTItemScalarWhereInput | MSTItemScalarWhereInput[]
    id?: StringFilter<"MSTItem"> | string
    mst_id?: StringFilter<"MSTItem"> | string
    item_id?: StringFilter<"MSTItem"> | string
    quantity?: IntFilter<"MSTItem"> | number
    price?: FloatFilter<"MSTItem"> | number
    status?: IntFilter<"MSTItem"> | number
    created_by?: StringFilter<"MSTItem"> | string
    created_at?: DateTimeFilter<"MSTItem"> | Date | string
    metadata?: JsonNullableFilter<"MSTItem">
  }

  export type ItemCreateWithoutItem_locationsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItem_locationsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_locationsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_locationsInput, ItemUncheckedCreateWithoutItem_locationsInput>
  }

  export type StationCreateWithoutItemsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osrivs?: OSRIVCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVCreateNestedManyWithoutItem_fromInput
  }

  export type StationUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osrivs?: OSRIVUncheckedCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVUncheckedCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVUncheckedCreateNestedManyWithoutItem_fromInput
  }

  export type StationCreateOrConnectWithoutItemsInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutItemsInput, StationUncheckedCreateWithoutItemsInput>
  }

  export type ItemMovementCreateWithoutOriginInput = {
    id?: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    destination: ItemLocationCreateNestedOneWithoutDestination_movementsInput
  }

  export type ItemMovementUncheckedCreateWithoutOriginInput = {
    id?: string
    destination_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateOrConnectWithoutOriginInput = {
    where: ItemMovementWhereUniqueInput
    create: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput>
  }

  export type ItemMovementCreateManyOriginInputEnvelope = {
    data: ItemMovementCreateManyOriginInput | ItemMovementCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type ItemMovementCreateWithoutDestinationInput = {
    id?: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin: ItemLocationCreateNestedOneWithoutOrigin_movementsInput
  }

  export type ItemMovementUncheckedCreateWithoutDestinationInput = {
    id?: string
    origin_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateOrConnectWithoutDestinationInput = {
    where: ItemMovementWhereUniqueInput
    create: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput>
  }

  export type ItemMovementCreateManyDestinationInputEnvelope = {
    data: ItemMovementCreateManyDestinationInput | ItemMovementCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutItem_locationsInput = {
    update: XOR<ItemUpdateWithoutItem_locationsInput, ItemUncheckedUpdateWithoutItem_locationsInput>
    create: XOR<ItemCreateWithoutItem_locationsInput, ItemUncheckedCreateWithoutItem_locationsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItem_locationsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItem_locationsInput, ItemUncheckedUpdateWithoutItem_locationsInput>
  }

  export type ItemUpdateWithoutItem_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type StationUpsertWithoutItemsInput = {
    update: XOR<StationUpdateWithoutItemsInput, StationUncheckedUpdateWithoutItemsInput>
    create: XOR<StationCreateWithoutItemsInput, StationUncheckedCreateWithoutItemsInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutItemsInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutItemsInput, StationUncheckedUpdateWithoutItemsInput>
  }

  export type StationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osrivs?: OSRIVUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUpdateManyWithoutItem_fromNestedInput
  }

  export type StationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osrivs?: OSRIVUncheckedUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUncheckedUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUncheckedUpdateManyWithoutItem_fromNestedInput
  }

  export type ItemMovementUpsertWithWhereUniqueWithoutOriginInput = {
    where: ItemMovementWhereUniqueInput
    update: XOR<ItemMovementUpdateWithoutOriginInput, ItemMovementUncheckedUpdateWithoutOriginInput>
    create: XOR<ItemMovementCreateWithoutOriginInput, ItemMovementUncheckedCreateWithoutOriginInput>
  }

  export type ItemMovementUpdateWithWhereUniqueWithoutOriginInput = {
    where: ItemMovementWhereUniqueInput
    data: XOR<ItemMovementUpdateWithoutOriginInput, ItemMovementUncheckedUpdateWithoutOriginInput>
  }

  export type ItemMovementUpdateManyWithWhereWithoutOriginInput = {
    where: ItemMovementScalarWhereInput
    data: XOR<ItemMovementUpdateManyMutationInput, ItemMovementUncheckedUpdateManyWithoutOriginInput>
  }

  export type ItemMovementScalarWhereInput = {
    AND?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
    OR?: ItemMovementScalarWhereInput[]
    NOT?: ItemMovementScalarWhereInput | ItemMovementScalarWhereInput[]
    id?: StringFilter<"ItemMovement"> | string
    origin_id?: StringFilter<"ItemMovement"> | string
    destination_id?: StringFilter<"ItemMovement"> | string
    quantity_moved?: IntFilter<"ItemMovement"> | number
    created_by?: StringFilter<"ItemMovement"> | string
    created_at?: DateTimeFilter<"ItemMovement"> | Date | string
    metadata?: JsonNullableFilter<"ItemMovement">
  }

  export type ItemMovementUpsertWithWhereUniqueWithoutDestinationInput = {
    where: ItemMovementWhereUniqueInput
    update: XOR<ItemMovementUpdateWithoutDestinationInput, ItemMovementUncheckedUpdateWithoutDestinationInput>
    create: XOR<ItemMovementCreateWithoutDestinationInput, ItemMovementUncheckedCreateWithoutDestinationInput>
  }

  export type ItemMovementUpdateWithWhereUniqueWithoutDestinationInput = {
    where: ItemMovementWhereUniqueInput
    data: XOR<ItemMovementUpdateWithoutDestinationInput, ItemMovementUncheckedUpdateWithoutDestinationInput>
  }

  export type ItemMovementUpdateManyWithWhereWithoutDestinationInput = {
    where: ItemMovementScalarWhereInput
    data: XOR<ItemMovementUpdateManyMutationInput, ItemMovementUncheckedUpdateManyWithoutDestinationInput>
  }

  export type ItemLocationCreateWithoutOrigin_movementsInput = {
    id?: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_locationsInput
    station: StationCreateNestedOneWithoutItemsInput
    destination_movements?: ItemMovementCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationUncheckedCreateWithoutOrigin_movementsInput = {
    id?: string
    item_id: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    destination_movements?: ItemMovementUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type ItemLocationCreateOrConnectWithoutOrigin_movementsInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutOrigin_movementsInput, ItemLocationUncheckedCreateWithoutOrigin_movementsInput>
  }

  export type ItemLocationCreateWithoutDestination_movementsInput = {
    id?: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_locationsInput
    station: StationCreateNestedOneWithoutItemsInput
    origin_movements?: ItemMovementCreateNestedManyWithoutOriginInput
  }

  export type ItemLocationUncheckedCreateWithoutDestination_movementsInput = {
    id?: string
    item_id: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedCreateNestedManyWithoutOriginInput
  }

  export type ItemLocationCreateOrConnectWithoutDestination_movementsInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutDestination_movementsInput, ItemLocationUncheckedCreateWithoutDestination_movementsInput>
  }

  export type ItemLocationUpsertWithoutOrigin_movementsInput = {
    update: XOR<ItemLocationUpdateWithoutOrigin_movementsInput, ItemLocationUncheckedUpdateWithoutOrigin_movementsInput>
    create: XOR<ItemLocationCreateWithoutOrigin_movementsInput, ItemLocationUncheckedCreateWithoutOrigin_movementsInput>
    where?: ItemLocationWhereInput
  }

  export type ItemLocationUpdateToOneWithWhereWithoutOrigin_movementsInput = {
    where?: ItemLocationWhereInput
    data: XOR<ItemLocationUpdateWithoutOrigin_movementsInput, ItemLocationUncheckedUpdateWithoutOrigin_movementsInput>
  }

  export type ItemLocationUpdateWithoutOrigin_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_locationsNestedInput
    station?: StationUpdateOneRequiredWithoutItemsNestedInput
    destination_movements?: ItemMovementUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutOrigin_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    destination_movements?: ItemMovementUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUpsertWithoutDestination_movementsInput = {
    update: XOR<ItemLocationUpdateWithoutDestination_movementsInput, ItemLocationUncheckedUpdateWithoutDestination_movementsInput>
    create: XOR<ItemLocationCreateWithoutDestination_movementsInput, ItemLocationUncheckedCreateWithoutDestination_movementsInput>
    where?: ItemLocationWhereInput
  }

  export type ItemLocationUpdateToOneWithWhereWithoutDestination_movementsInput = {
    where?: ItemLocationWhereInput
    data: XOR<ItemLocationUpdateWithoutDestination_movementsInput, ItemLocationUncheckedUpdateWithoutDestination_movementsInput>
  }

  export type ItemLocationUpdateWithoutDestination_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_locationsNestedInput
    station?: StationUpdateOneRequiredWithoutItemsNestedInput
    origin_movements?: ItemMovementUpdateManyWithoutOriginNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutDestination_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedUpdateManyWithoutOriginNestedInput
  }

  export type ItemCreateWithoutItem_transactionsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItem_transactionsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_transactionsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
  }

  export type RRItemCreateWithoutItem_transactionInput = {
    id?: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr: RRCreateNestedOneWithoutRr_itemsInput
    meqs_supplier_item: MEQSSupplierItemCreateNestedOneWithoutRr_itemsInput
  }

  export type RRItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    rr_id: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemCreateOrConnectWithoutItem_transactionInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type OSRIVItemCreateWithoutItem_transactionInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv: OSRIVCreateNestedOneWithoutOsriv_itemsInput
    item: ItemCreateNestedOneWithoutOsriv_itemsInput
  }

  export type OSRIVItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    osriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemCreateOrConnectWithoutItem_transactionInput = {
    where: OSRIVItemWhereUniqueInput
    create: XOR<OSRIVItemCreateWithoutItem_transactionInput, OSRIVItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type SERIVItemCreateWithoutItem_transactionInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv: SERIVCreateNestedOneWithoutSeriv_itemsInput
    item: ItemCreateNestedOneWithoutSeriv_itemsInput
  }

  export type SERIVItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    seriv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemCreateOrConnectWithoutItem_transactionInput = {
    where: SERIVItemWhereUniqueInput
    create: XOR<SERIVItemCreateWithoutItem_transactionInput, SERIVItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type MRVItemCreateWithoutItem_transactionInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv: MRVCreateNestedOneWithoutMrv_itemsInput
    item: ItemCreateNestedOneWithoutMrv_itemsInput
  }

  export type MRVItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    mrv_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemCreateOrConnectWithoutItem_transactionInput = {
    where: MRVItemWhereUniqueInput
    create: XOR<MRVItemCreateWithoutItem_transactionInput, MRVItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type MCRTItemCreateWithoutItem_transactionInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt: MCRTCreateNestedOneWithoutMcrt_itemsInput
    item: ItemCreateNestedOneWithoutMcrt_itemsInput
  }

  export type MCRTItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    mcrt_id: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemCreateOrConnectWithoutItem_transactionInput = {
    where: MCRTItemWhereUniqueInput
    create: XOR<MCRTItemCreateWithoutItem_transactionInput, MCRTItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type ItemUpsertWithoutItem_transactionsInput = {
    update: XOR<ItemUpdateWithoutItem_transactionsInput, ItemUncheckedUpdateWithoutItem_transactionsInput>
    create: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItem_transactionsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItem_transactionsInput, ItemUncheckedUpdateWithoutItem_transactionsInput>
  }

  export type ItemUpdateWithoutItem_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type RRItemUpsertWithoutItem_transactionInput = {
    update: XOR<RRItemUpdateWithoutItem_transactionInput, RRItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    where?: RRItemWhereInput
  }

  export type RRItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: RRItemWhereInput
    data: XOR<RRItemUpdateWithoutItem_transactionInput, RRItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type RRItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    meqs_supplier_item?: MEQSSupplierItemUpdateOneRequiredWithoutRr_itemsNestedInput
  }

  export type RRItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_item_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemUpsertWithoutItem_transactionInput = {
    update: XOR<OSRIVItemUpdateWithoutItem_transactionInput, OSRIVItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<OSRIVItemCreateWithoutItem_transactionInput, OSRIVItemUncheckedCreateWithoutItem_transactionInput>
    where?: OSRIVItemWhereInput
  }

  export type OSRIVItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: OSRIVItemWhereInput
    data: XOR<OSRIVItemUpdateWithoutItem_transactionInput, OSRIVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type OSRIVItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv?: OSRIVUpdateOneRequiredWithoutOsriv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutOsriv_itemsNestedInput
  }

  export type OSRIVItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemUpsertWithoutItem_transactionInput = {
    update: XOR<SERIVItemUpdateWithoutItem_transactionInput, SERIVItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<SERIVItemCreateWithoutItem_transactionInput, SERIVItemUncheckedCreateWithoutItem_transactionInput>
    where?: SERIVItemWhereInput
  }

  export type SERIVItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: SERIVItemWhereInput
    data: XOR<SERIVItemUpdateWithoutItem_transactionInput, SERIVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type SERIVItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVUpdateOneRequiredWithoutSeriv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutSeriv_itemsNestedInput
  }

  export type SERIVItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemUpsertWithoutItem_transactionInput = {
    update: XOR<MRVItemUpdateWithoutItem_transactionInput, MRVItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<MRVItemCreateWithoutItem_transactionInput, MRVItemUncheckedCreateWithoutItem_transactionInput>
    where?: MRVItemWhereInput
  }

  export type MRVItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: MRVItemWhereInput
    data: XOR<MRVItemUpdateWithoutItem_transactionInput, MRVItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type MRVItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneRequiredWithoutMrv_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutMrv_itemsNestedInput
  }

  export type MRVItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemUpsertWithoutItem_transactionInput = {
    update: XOR<MCRTItemUpdateWithoutItem_transactionInput, MCRTItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<MCRTItemCreateWithoutItem_transactionInput, MCRTItemUncheckedCreateWithoutItem_transactionInput>
    where?: MCRTItemWhereInput
  }

  export type MCRTItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: MCRTItemWhereInput
    data: XOR<MCRTItemUpdateWithoutItem_transactionInput, MCRTItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type MCRTItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt?: MCRTUpdateOneRequiredWithoutMcrt_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutMcrt_itemsNestedInput
  }

  export type MCRTItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateWithoutCanvassInput = {
    id?: string
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
    unit?: UnitCreateNestedOneWithoutCanvass_itemsInput
    item?: ItemCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateWithoutCanvassInput = {
    id?: string
    unit_id?: string | null
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemCreateManyCanvassInputEnvelope = {
    data: CanvassItemCreateManyCanvassInput | CanvassItemCreateManyCanvassInput[]
    skipDuplicates?: boolean
  }

  export type JOCreateWithoutCanvassInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSCreateNestedOneWithoutJoInput
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
  }

  export type JOUncheckedCreateWithoutCanvassInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
  }

  export type JOCreateOrConnectWithoutCanvassInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
  }

  export type RVCreateWithoutCanvassInput = {
    id?: string
    rv_number: string
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateWithoutCanvassInput = {
    id?: string
    rv_number: string
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVCreateOrConnectWithoutCanvassInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
  }

  export type SPRCreateWithoutCanvassInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutCanvassInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutCanvassInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutCanvassInput, CanvassItemUncheckedUpdateWithoutCanvassInput>
    create: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutCanvassInput, CanvassItemUncheckedUpdateWithoutCanvassInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutCanvassInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutCanvassInput>
  }

  export type JOUpsertWithoutCanvassInput = {
    update: XOR<JOUpdateWithoutCanvassInput, JOUncheckedUpdateWithoutCanvassInput>
    create: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutCanvassInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutCanvassInput, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type JOUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneWithoutJoNestedInput
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
  }

  export type RVUpsertWithoutCanvassInput = {
    update: XOR<RVUpdateWithoutCanvassInput, RVUncheckedUpdateWithoutCanvassInput>
    create: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutCanvassInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutCanvassInput, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type SPRUpsertWithoutCanvassInput = {
    update: XOR<SPRUpdateWithoutCanvassInput, SPRUncheckedUpdateWithoutCanvassInput>
    create: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutCanvassInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutCanvassInput, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type MEQSSupplierItemCreateWithoutCanvass_itemInput = {
    id?: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput
    rr_items?: RRItemCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput = {
    id?: string
    meqs_supplier_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    create: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemCreateManyCanvass_itemInputEnvelope = {
    data: MEQSSupplierItemCreateManyCanvass_itemInput | MEQSSupplierItemCreateManyCanvass_itemInput[]
    skipDuplicates?: boolean
  }

  export type CanvassCreateWithoutCanvass_itemsInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutCanvass_itemsInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type UnitCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutCanvass_itemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type ItemCreateWithoutCanvass_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCanvass_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCanvass_itemsInput, ItemUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    update: XOR<MEQSSupplierItemUpdateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput>
    create: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    data: XOR<MEQSSupplierItemUpdateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput = {
    where: MEQSSupplierItemScalarWhereInput
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemScalarWhereInput = {
    AND?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
    OR?: MEQSSupplierItemScalarWhereInput[]
    NOT?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
    id?: StringFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    notes?: StringFilter<"MEQSSupplierItem"> | string
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    metadata?: JsonNullableFilter<"MEQSSupplierItem">
  }

  export type CanvassUpsertWithoutCanvass_itemsInput = {
    update: XOR<CanvassUpdateWithoutCanvass_itemsInput, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutCanvass_itemsInput, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type CanvassUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type UnitUpsertWithoutCanvass_itemsInput = {
    update: XOR<UnitUpdateWithoutCanvass_itemsInput, UnitUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutCanvass_itemsInput, UnitUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type UnitUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ItemUpsertWithoutCanvass_itemsInput = {
    update: XOR<ItemUpdateWithoutCanvass_itemsInput, ItemUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<ItemCreateWithoutCanvass_itemsInput, ItemUncheckedCreateWithoutCanvass_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCanvass_itemsInput, ItemUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type ItemUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CanvassCreateWithoutRvInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutRvInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutRvInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
  }

  export type MEQSCreateWithoutRvInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutRvInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutRvInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
  }

  export type RVApproverCreateWithoutRvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUncheckedCreateWithoutRvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverCreateOrConnectWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    create: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput>
  }

  export type RVApproverCreateManyRvInputEnvelope = {
    data: RVApproverCreateManyRvInput | RVApproverCreateManyRvInput[]
    skipDuplicates?: boolean
  }

  export type CanvassUpsertWithoutRvInput = {
    update: XOR<CanvassUpdateWithoutRvInput, CanvassUncheckedUpdateWithoutRvInput>
    create: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutRvInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutRvInput, CanvassUncheckedUpdateWithoutRvInput>
  }

  export type CanvassUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type MEQSUpsertWithoutRvInput = {
    update: XOR<MEQSUpdateWithoutRvInput, MEQSUncheckedUpdateWithoutRvInput>
    create: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutRvInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutRvInput, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type MEQSUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type RVApproverUpsertWithWhereUniqueWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    update: XOR<RVApproverUpdateWithoutRvInput, RVApproverUncheckedUpdateWithoutRvInput>
    create: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput>
  }

  export type RVApproverUpdateWithWhereUniqueWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    data: XOR<RVApproverUpdateWithoutRvInput, RVApproverUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUpdateManyWithWhereWithoutRvInput = {
    where: RVApproverScalarWhereInput
    data: XOR<RVApproverUpdateManyMutationInput, RVApproverUncheckedUpdateManyWithoutRvInput>
  }

  export type RVApproverScalarWhereInput = {
    AND?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
    OR?: RVApproverScalarWhereInput[]
    NOT?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
    id?: StringFilter<"RVApprover"> | string
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringFilter<"RVApprover"> | string
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    is_supervisor?: BoolFilter<"RVApprover"> | boolean
    metadata?: JsonNullableFilter<"RVApprover">
  }

  export type RVCreateWithoutRv_approversInput = {
    id?: string
    rv_number: string
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutRvInput
    meqs?: MEQSCreateNestedOneWithoutRvInput
  }

  export type RVUncheckedCreateWithoutRv_approversInput = {
    id?: string
    rv_number: string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
  }

  export type RVCreateOrConnectWithoutRv_approversInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
  }

  export type RVUpsertWithoutRv_approversInput = {
    update: XOR<RVUpdateWithoutRv_approversInput, RVUncheckedUpdateWithoutRv_approversInput>
    create: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutRv_approversInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutRv_approversInput, RVUncheckedUpdateWithoutRv_approversInput>
  }

  export type RVUpdateWithoutRv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutRvNestedInput
    meqs?: MEQSUpdateOneWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutRv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
  }

  export type CanvassCreateWithoutJoInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutJoInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutJoInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
  }

  export type MEQSCreateWithoutJoInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutJoInput = {
    id?: string
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutJoInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
  }

  export type JOApproverCreateWithoutJoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUncheckedCreateWithoutJoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverCreateOrConnectWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    create: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput>
  }

  export type JOApproverCreateManyJoInputEnvelope = {
    data: JOApproverCreateManyJoInput | JOApproverCreateManyJoInput[]
    skipDuplicates?: boolean
  }

  export type CanvassUpsertWithoutJoInput = {
    update: XOR<CanvassUpdateWithoutJoInput, CanvassUncheckedUpdateWithoutJoInput>
    create: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutJoInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutJoInput, CanvassUncheckedUpdateWithoutJoInput>
  }

  export type CanvassUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type MEQSUpsertWithoutJoInput = {
    update: XOR<MEQSUpdateWithoutJoInput, MEQSUncheckedUpdateWithoutJoInput>
    create: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutJoInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutJoInput, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type MEQSUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type JOApproverUpsertWithWhereUniqueWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    update: XOR<JOApproverUpdateWithoutJoInput, JOApproverUncheckedUpdateWithoutJoInput>
    create: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput>
  }

  export type JOApproverUpdateWithWhereUniqueWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    data: XOR<JOApproverUpdateWithoutJoInput, JOApproverUncheckedUpdateWithoutJoInput>
  }

  export type JOApproverUpdateManyWithWhereWithoutJoInput = {
    where: JOApproverScalarWhereInput
    data: XOR<JOApproverUpdateManyMutationInput, JOApproverUncheckedUpdateManyWithoutJoInput>
  }

  export type JOApproverScalarWhereInput = {
    AND?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
    OR?: JOApproverScalarWhereInput[]
    NOT?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
    id?: StringFilter<"JOApprover"> | string
    jo_id?: StringFilter<"JOApprover"> | string
    approver_id?: StringFilter<"JOApprover"> | string
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringFilter<"JOApprover"> | string
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    is_supervisor?: BoolFilter<"JOApprover"> | boolean
    metadata?: JsonNullableFilter<"JOApprover">
  }

  export type JOCreateWithoutJo_approversInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutJoInput
    meqs?: MEQSCreateNestedOneWithoutJoInput
  }

  export type JOUncheckedCreateWithoutJo_approversInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id?: string | null
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
  }

  export type JOCreateOrConnectWithoutJo_approversInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
  }

  export type JOUpsertWithoutJo_approversInput = {
    update: XOR<JOUpdateWithoutJo_approversInput, JOUncheckedUpdateWithoutJo_approversInput>
    create: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutJo_approversInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutJo_approversInput, JOUncheckedUpdateWithoutJo_approversInput>
  }

  export type JOUpdateWithoutJo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutJoNestedInput
    meqs?: MEQSUpdateOneWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutJo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
  }

  export type CanvassCreateWithoutSprInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutSprInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutSprInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
  }

  export type MEQSCreateWithoutSprInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutSprInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutSprInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
  }

  export type VehicleCreateWithoutSprsInput = {
    id?: string
    name: string
    plate_number: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleUncheckedCreateWithoutSprsInput = {
    id?: string
    name: string
    plate_number: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleCreateOrConnectWithoutSprsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
  }

  export type SPRApproverCreateWithoutSprInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUncheckedCreateWithoutSprInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverCreateOrConnectWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    create: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput>
  }

  export type SPRApproverCreateManySprInputEnvelope = {
    data: SPRApproverCreateManySprInput | SPRApproverCreateManySprInput[]
    skipDuplicates?: boolean
  }

  export type CanvassUpsertWithoutSprInput = {
    update: XOR<CanvassUpdateWithoutSprInput, CanvassUncheckedUpdateWithoutSprInput>
    create: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutSprInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutSprInput, CanvassUncheckedUpdateWithoutSprInput>
  }

  export type CanvassUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type MEQSUpsertWithoutSprInput = {
    update: XOR<MEQSUpdateWithoutSprInput, MEQSUncheckedUpdateWithoutSprInput>
    create: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutSprInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutSprInput, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type MEQSUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type VehicleUpsertWithoutSprsInput = {
    update: XOR<VehicleUpdateWithoutSprsInput, VehicleUncheckedUpdateWithoutSprsInput>
    create: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutSprsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutSprsInput, VehicleUncheckedUpdateWithoutSprsInput>
  }

  export type VehicleUpdateWithoutSprsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VehicleUncheckedUpdateWithoutSprsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUpsertWithWhereUniqueWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    update: XOR<SPRApproverUpdateWithoutSprInput, SPRApproverUncheckedUpdateWithoutSprInput>
    create: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput>
  }

  export type SPRApproverUpdateWithWhereUniqueWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    data: XOR<SPRApproverUpdateWithoutSprInput, SPRApproverUncheckedUpdateWithoutSprInput>
  }

  export type SPRApproverUpdateManyWithWhereWithoutSprInput = {
    where: SPRApproverScalarWhereInput
    data: XOR<SPRApproverUpdateManyMutationInput, SPRApproverUncheckedUpdateManyWithoutSprInput>
  }

  export type SPRApproverScalarWhereInput = {
    AND?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
    OR?: SPRApproverScalarWhereInput[]
    NOT?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
    id?: StringFilter<"SPRApprover"> | string
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringFilter<"SPRApprover"> | string
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    is_supervisor?: BoolFilter<"SPRApprover"> | boolean
    metadata?: JsonNullableFilter<"SPRApprover">
  }

  export type SPRCreateWithoutSpr_approversInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutSprInput
    meqs?: MEQSCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
  }

  export type SPRUncheckedCreateWithoutSpr_approversInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutSpr_approversInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
  }

  export type SPRUpsertWithoutSpr_approversInput = {
    update: XOR<SPRUpdateWithoutSpr_approversInput, SPRUncheckedUpdateWithoutSpr_approversInput>
    create: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutSpr_approversInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutSpr_approversInput, SPRUncheckedUpdateWithoutSpr_approversInput>
  }

  export type SPRUpdateWithoutSpr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutSprNestedInput
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
  }

  export type SPRUncheckedUpdateWithoutSpr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
  }

  export type JOCreateWithoutMeqsInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutJoInput
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
  }

  export type JOUncheckedCreateWithoutMeqsInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id?: string | null
    equipment?: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
  }

  export type JOCreateOrConnectWithoutMeqsInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
  }

  export type RVCreateWithoutMeqsInput = {
    id?: string
    rv_number: string
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateWithoutMeqsInput = {
    id?: string
    rv_number: string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVCreateOrConnectWithoutMeqsInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
  }

  export type SPRCreateWithoutMeqsInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutMeqsInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutMeqsInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverCreateWithoutMeqsInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUncheckedCreateWithoutMeqsInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverCreateOrConnectWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    create: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverCreateManyMeqsInputEnvelope = {
    data: MEQSApproverCreateManyMeqsInput | MEQSApproverCreateManyMeqsInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierCreateWithoutMeqsInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutMeqsInput = {
    id?: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSSupplierCreateManyMeqsInputEnvelope = {
    data: MEQSSupplierCreateManyMeqsInput | MEQSSupplierCreateManyMeqsInput[]
    skipDuplicates?: boolean
  }

  export type JOUpsertWithoutMeqsInput = {
    update: XOR<JOUpdateWithoutMeqsInput, JOUncheckedUpdateWithoutMeqsInput>
    create: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutMeqsInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutMeqsInput, JOUncheckedUpdateWithoutMeqsInput>
  }

  export type JOUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutJoNestedInput
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
  }

  export type RVUpsertWithoutMeqsInput = {
    update: XOR<RVUpdateWithoutMeqsInput, RVUncheckedUpdateWithoutMeqsInput>
    create: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutMeqsInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutMeqsInput, RVUncheckedUpdateWithoutMeqsInput>
  }

  export type RVUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_number?: StringFieldUpdateOperationsInput | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type SPRUpsertWithoutMeqsInput = {
    update: XOR<SPRUpdateWithoutMeqsInput, SPRUncheckedUpdateWithoutMeqsInput>
    create: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutMeqsInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutMeqsInput, SPRUncheckedUpdateWithoutMeqsInput>
  }

  export type SPRUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    update: XOR<MEQSApproverUpdateWithoutMeqsInput, MEQSApproverUncheckedUpdateWithoutMeqsInput>
    create: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    data: XOR<MEQSApproverUpdateWithoutMeqsInput, MEQSApproverUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateManyWithWhereWithoutMeqsInput = {
    where: MEQSApproverScalarWhereInput
    data: XOR<MEQSApproverUpdateManyMutationInput, MEQSApproverUncheckedUpdateManyWithoutMeqsInput>
  }

  export type MEQSApproverScalarWhereInput = {
    AND?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
    OR?: MEQSApproverScalarWhereInput[]
    NOT?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
    id?: StringFilter<"MEQSApprover"> | string
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringFilter<"MEQSApprover"> | string
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    metadata?: JsonNullableFilter<"MEQSApprover">
  }

  export type MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    update: XOR<MEQSSupplierUpdateWithoutMeqsInput, MEQSSupplierUncheckedUpdateWithoutMeqsInput>
    create: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    data: XOR<MEQSSupplierUpdateWithoutMeqsInput, MEQSSupplierUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSSupplierUpdateManyWithWhereWithoutMeqsInput = {
    where: MEQSSupplierScalarWhereInput
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyWithoutMeqsInput>
  }

  export type MEQSCreateWithoutMeqs_suppliersInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutMeqs_suppliersInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutMeqs_suppliersInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
  }

  export type SupplierCreateWithoutMEQSSupplierInput = {
    id?: string
    name: string
    contact: string
    tin?: string
    address?: string
    vat_type?: number
    is_vat_registered?: boolean
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupplierUncheckedCreateWithoutMEQSSupplierInput = {
    id?: string
    name: string
    contact: string
    tin?: string
    address?: string
    vat_type?: number
    is_vat_registered?: boolean
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupplierCreateOrConnectWithoutMEQSSupplierInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
  }

  export type MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput = {
    id?: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    create: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope = {
    data: MEQSSupplierAttachmentCreateManyMeqs_supplierInput | MEQSSupplierAttachmentCreateManyMeqs_supplierInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierItemCreateWithoutMeqs_supplierInput = {
    id?: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item: CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput
    rr_items?: RRItemCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedCreateNestedManyWithoutMeqs_supplier_itemInput
  }

  export type MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    create: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope = {
    data: MEQSSupplierItemCreateManyMeqs_supplierInput | MEQSSupplierItemCreateManyMeqs_supplierInput[]
    skipDuplicates?: boolean
  }

  export type POCreateWithoutMeqs_supplierInput = {
    id?: string
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRCreateNestedManyWithoutPoInput
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
  }

  export type POUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedCreateNestedManyWithoutPoInput
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
  }

  export type POCreateOrConnectWithoutMeqs_supplierInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSUpsertWithoutMeqs_suppliersInput = {
    update: XOR<MEQSUpdateWithoutMeqs_suppliersInput, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
    create: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutMeqs_suppliersInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutMeqs_suppliersInput, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
  }

  export type MEQSUpdateWithoutMeqs_suppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutMeqs_suppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type SupplierUpsertWithoutMEQSSupplierInput = {
    update: XOR<SupplierUpdateWithoutMEQSSupplierInput, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
    create: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutMEQSSupplierInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutMEQSSupplierInput, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
  }

  export type SupplierUpdateWithoutMEQSSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupplierUncheckedUpdateWithoutMEQSSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    is_vat_registered?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    update: XOR<MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    data: XOR<MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentScalarWhereInput
    data: XOR<MEQSSupplierAttachmentUpdateManyMutationInput, MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentScalarWhereInput = {
    AND?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
    OR?: MEQSSupplierAttachmentScalarWhereInput[]
    NOT?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
    id?: StringFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    filename?: StringFilter<"MEQSSupplierAttachment"> | string
    src?: StringFilter<"MEQSSupplierAttachment"> | string
    metadata?: JsonNullableFilter<"MEQSSupplierAttachment">
  }

  export type MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    update: XOR<MEQSSupplierItemUpdateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    data: XOR<MEQSSupplierItemUpdateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemScalarWhereInput
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierInput>
  }

  export type POUpsertWithoutMeqs_supplierInput = {
    update: XOR<POUpdateWithoutMeqs_supplierInput, POUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutMeqs_supplierInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutMeqs_supplierInput, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type POUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUpdateManyWithoutPoNestedInput
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedUpdateManyWithoutPoNestedInput
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
  }

  export type CanvassItemCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    unit?: UnitCreateNestedOneWithoutCanvass_itemsInput
    item?: ItemCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    canvass_id: string
    unit_id?: string | null
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
  }

  export type RRItemCreateWithoutMeqs_supplier_itemInput = {
    id?: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateWithoutMeqs_supplier_itemInput = {
    id?: string
    rr_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutMeqs_supplier_itemInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput>
  }

  export type RRItemCreateManyMeqs_supplier_itemInputEnvelope = {
    data: RRItemCreateManyMeqs_supplier_itemInput | RRItemCreateManyMeqs_supplier_itemInput[]
    skipDuplicates?: boolean
  }

  export type CanvassItemUpsertWithoutMeqs_supplier_itemsInput = {
    update: XOR<CanvassItemUpdateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
    create: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    where?: CanvassItemWhereInput
  }

  export type CanvassItemUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput = {
    where?: CanvassItemWhereInput
    data: XOR<CanvassItemUpdateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type CanvassItemUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneWithoutCanvass_itemsNestedInput
    item?: ItemUpdateOneWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierUpsertWithoutMeqs_supplier_itemsInput = {
    update: XOR<MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
    create: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type RRItemUpsertWithWhereUniqueWithoutMeqs_supplier_itemInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutMeqs_supplier_itemInput, RRItemUncheckedUpdateWithoutMeqs_supplier_itemInput>
    create: XOR<RRItemCreateWithoutMeqs_supplier_itemInput, RRItemUncheckedCreateWithoutMeqs_supplier_itemInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutMeqs_supplier_itemInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutMeqs_supplier_itemInput, RRItemUncheckedUpdateWithoutMeqs_supplier_itemInput>
  }

  export type RRItemUpdateManyWithWhereWithoutMeqs_supplier_itemInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemInput>
  }

  export type RRItemScalarWhereInput = {
    AND?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
    OR?: RRItemScalarWhereInput[]
    NOT?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
    id?: StringFilter<"RRItem"> | string
    rr_id?: StringFilter<"RRItem"> | string
    meqs_supplier_item_id?: StringFilter<"RRItem"> | string
    quantity_accepted?: IntFilter<"RRItem"> | number
    metadata?: JsonNullableFilter<"RRItem">
  }

  export type MEQSSupplierCreateWithoutAttachmentsInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutAttachmentsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
  }

  export type MEQSSupplierUpsertWithoutAttachmentsInput = {
    update: XOR<MEQSSupplierUpdateWithoutAttachmentsInput, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutAttachmentsInput, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MEQSSupplierUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSCreateWithoutMeqs_approversInput = {
    id?: string
    jo_number?: string | null
    rv_number?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutMeqs_approversInput = {
    id?: string
    jo_id?: string | null
    jo_number?: string | null
    rv_id?: string | null
    rv_number?: string | null
    spr_id?: string | null
    spr_number?: string | null
    meqs_number: string
    meqs_date: Date | string
    notes: string
    created_by: string
    updated_by?: string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    cancelled_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutMeqs_approversInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
  }

  export type MEQSUpsertWithoutMeqs_approversInput = {
    update: XOR<MEQSUpdateWithoutMeqs_approversInput, MEQSUncheckedUpdateWithoutMeqs_approversInput>
    create: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutMeqs_approversInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutMeqs_approversInput, MEQSUncheckedUpdateWithoutMeqs_approversInput>
  }

  export type MEQSUpdateWithoutMeqs_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutMeqs_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_number?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_number?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSSupplierCreateWithoutPoInput = {
    id?: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutPoInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutPoInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
  }

  export type RRCreateWithoutPoInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutPoInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutPoInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
  }

  export type RRCreateManyPoInputEnvelope = {
    data: RRCreateManyPoInput | RRCreateManyPoInput[]
    skipDuplicates?: boolean
  }

  export type POApproverCreateWithoutPoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUncheckedCreateWithoutPoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverCreateOrConnectWithoutPoInput = {
    where: POApproverWhereUniqueInput
    create: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput>
  }

  export type POApproverCreateManyPoInputEnvelope = {
    data: POApproverCreateManyPoInput | POApproverCreateManyPoInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierUpsertWithoutPoInput = {
    update: XOR<MEQSSupplierUpdateWithoutPoInput, MEQSSupplierUncheckedUpdateWithoutPoInput>
    create: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutPoInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutPoInput, MEQSSupplierUncheckedUpdateWithoutPoInput>
  }

  export type MEQSSupplierUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
  }

  export type RRUpsertWithWhereUniqueWithoutPoInput = {
    where: RRWhereUniqueInput
    update: XOR<RRUpdateWithoutPoInput, RRUncheckedUpdateWithoutPoInput>
    create: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
  }

  export type RRUpdateWithWhereUniqueWithoutPoInput = {
    where: RRWhereUniqueInput
    data: XOR<RRUpdateWithoutPoInput, RRUncheckedUpdateWithoutPoInput>
  }

  export type RRUpdateManyWithWhereWithoutPoInput = {
    where: RRScalarWhereInput
    data: XOR<RRUpdateManyMutationInput, RRUncheckedUpdateManyWithoutPoInput>
  }

  export type RRScalarWhereInput = {
    AND?: RRScalarWhereInput | RRScalarWhereInput[]
    OR?: RRScalarWhereInput[]
    NOT?: RRScalarWhereInput | RRScalarWhereInput[]
    id?: StringFilter<"RR"> | string
    po_id?: StringNullableFilter<"RR"> | string | null
    po_number?: StringFilter<"RR"> | string
    rr_number?: StringFilter<"RR"> | string
    rr_date?: DateTimeFilter<"RR"> | Date | string
    received_by_id?: StringFilter<"RR"> | string
    invoice_number?: StringFilter<"RR"> | string
    delivery_number?: StringNullableFilter<"RR"> | string | null
    notes?: StringFilter<"RR"> | string
    delivery_charge?: FloatFilter<"RR"> | number
    is_completed?: BoolFilter<"RR"> | boolean
    cancelled_by?: StringNullableFilter<"RR"> | string | null
    created_by?: StringFilter<"RR"> | string
    updated_by?: StringNullableFilter<"RR"> | string | null
    cancelled_at?: DateTimeNullableFilter<"RR"> | Date | string | null
    created_at?: DateTimeFilter<"RR"> | Date | string
    updated_at?: DateTimeFilter<"RR"> | Date | string
    metadata?: JsonNullableFilter<"RR">
  }

  export type POApproverUpsertWithWhereUniqueWithoutPoInput = {
    where: POApproverWhereUniqueInput
    update: XOR<POApproverUpdateWithoutPoInput, POApproverUncheckedUpdateWithoutPoInput>
    create: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput>
  }

  export type POApproverUpdateWithWhereUniqueWithoutPoInput = {
    where: POApproverWhereUniqueInput
    data: XOR<POApproverUpdateWithoutPoInput, POApproverUncheckedUpdateWithoutPoInput>
  }

  export type POApproverUpdateManyWithWhereWithoutPoInput = {
    where: POApproverScalarWhereInput
    data: XOR<POApproverUpdateManyMutationInput, POApproverUncheckedUpdateManyWithoutPoInput>
  }

  export type POApproverScalarWhereInput = {
    AND?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
    OR?: POApproverScalarWhereInput[]
    NOT?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
    id?: StringFilter<"POApprover"> | string
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    metadata?: JsonNullableFilter<"POApprover">
  }

  export type POCreateWithoutPo_approversInput = {
    id?: string
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierCreateNestedOneWithoutPoInput
    rrs?: RRCreateNestedManyWithoutPoInput
  }

  export type POUncheckedCreateWithoutPo_approversInput = {
    id?: string
    meqs_supplier_id?: string | null
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedCreateNestedManyWithoutPoInput
  }

  export type POCreateOrConnectWithoutPo_approversInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
  }

  export type POUpsertWithoutPo_approversInput = {
    update: XOR<POUpdateWithoutPo_approversInput, POUncheckedUpdateWithoutPo_approversInput>
    create: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutPo_approversInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutPo_approversInput, POUncheckedUpdateWithoutPo_approversInput>
  }

  export type POUpdateWithoutPo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierUpdateOneWithoutPoNestedInput
    rrs?: RRUpdateManyWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutPo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rrs?: RRUncheckedUpdateManyWithoutPoNestedInput
  }

  export type POCreateWithoutRrsInput = {
    id?: string
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierCreateNestedOneWithoutPoInput
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
  }

  export type POUncheckedCreateWithoutRrsInput = {
    id?: string
    meqs_supplier_id?: string | null
    meqs_number: string
    po_number: string
    fund_source_id?: string | null
    po_date: Date | string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
  }

  export type POCreateOrConnectWithoutRrsInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutRrsInput, POUncheckedCreateWithoutRrsInput>
  }

  export type RRApproverCreateWithoutRrInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUncheckedCreateWithoutRrInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverCreateOrConnectWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    create: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput>
  }

  export type RRApproverCreateManyRrInputEnvelope = {
    data: RRApproverCreateManyRrInput | RRApproverCreateManyRrInput[]
    skipDuplicates?: boolean
  }

  export type RRItemCreateWithoutRrInput = {
    id?: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
    meqs_supplier_item: MEQSSupplierItemCreateNestedOneWithoutRr_itemsInput
  }

  export type RRItemUncheckedCreateWithoutRrInput = {
    id?: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutRrInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput>
  }

  export type RRItemCreateManyRrInputEnvelope = {
    data: RRItemCreateManyRrInput | RRItemCreateManyRrInput[]
    skipDuplicates?: boolean
  }

  export type POUpsertWithoutRrsInput = {
    update: XOR<POUpdateWithoutRrsInput, POUncheckedUpdateWithoutRrsInput>
    create: XOR<POCreateWithoutRrsInput, POUncheckedCreateWithoutRrsInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutRrsInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutRrsInput, POUncheckedUpdateWithoutRrsInput>
  }

  export type POUpdateWithoutRrsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierUpdateOneWithoutPoNestedInput
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutRrsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    fund_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
  }

  export type RRApproverUpsertWithWhereUniqueWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    update: XOR<RRApproverUpdateWithoutRrInput, RRApproverUncheckedUpdateWithoutRrInput>
    create: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput>
  }

  export type RRApproverUpdateWithWhereUniqueWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    data: XOR<RRApproverUpdateWithoutRrInput, RRApproverUncheckedUpdateWithoutRrInput>
  }

  export type RRApproverUpdateManyWithWhereWithoutRrInput = {
    where: RRApproverScalarWhereInput
    data: XOR<RRApproverUpdateManyMutationInput, RRApproverUncheckedUpdateManyWithoutRrInput>
  }

  export type RRApproverScalarWhereInput = {
    AND?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
    OR?: RRApproverScalarWhereInput[]
    NOT?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
    id?: StringFilter<"RRApprover"> | string
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringFilter<"RRApprover"> | string
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    metadata?: JsonNullableFilter<"RRApprover">
  }

  export type RRItemUpsertWithWhereUniqueWithoutRrInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutRrInput, RRItemUncheckedUpdateWithoutRrInput>
    create: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutRrInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutRrInput, RRItemUncheckedUpdateWithoutRrInput>
  }

  export type RRItemUpdateManyWithWhereWithoutRrInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutRrInput>
  }

  export type RRCreateWithoutRr_approversInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POCreateNestedOneWithoutRrsInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutRr_approversInput = {
    id?: string
    po_id?: string | null
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutRr_approversInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
  }

  export type RRUpsertWithoutRr_approversInput = {
    update: XOR<RRUpdateWithoutRr_approversInput, RRUncheckedUpdateWithoutRr_approversInput>
    create: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    where?: RRWhereInput
  }

  export type RRUpdateToOneWithWhereWithoutRr_approversInput = {
    where?: RRWhereInput
    data: XOR<RRUpdateWithoutRr_approversInput, RRUncheckedUpdateWithoutRr_approversInput>
  }

  export type RRUpdateWithoutRr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POUpdateOneWithoutRrsNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutRr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type RRCreateWithoutRr_itemsInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POCreateNestedOneWithoutRrsInput
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    po_id?: string | null
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutRr_itemsInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
  }

  export type ItemTransactionCreateWithoutRr_itemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutRr_itemInput = {
    id?: number
    item_id: string
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutRr_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
  }

  export type MEQSSupplierItemCreateWithoutRr_itemsInput = {
    id?: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item: CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput
  }

  export type MEQSSupplierItemUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    meqs_supplier_id: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemCreateOrConnectWithoutRr_itemsInput = {
    where: MEQSSupplierItemWhereUniqueInput
    create: XOR<MEQSSupplierItemCreateWithoutRr_itemsInput, MEQSSupplierItemUncheckedCreateWithoutRr_itemsInput>
  }

  export type RRUpsertWithoutRr_itemsInput = {
    update: XOR<RRUpdateWithoutRr_itemsInput, RRUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    where?: RRWhereInput
  }

  export type RRUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: RRWhereInput
    data: XOR<RRUpdateWithoutRr_itemsInput, RRUncheckedUpdateWithoutRr_itemsInput>
  }

  export type RRUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    po?: POUpdateOneWithoutRrsNestedInput
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: NullableStringFieldUpdateOperationsInput | string | null
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
  }

  export type ItemTransactionUpsertWithoutRr_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutRr_itemInput, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
    create: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutRr_itemInput, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type ItemTransactionUpdateWithoutRr_itemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutRr_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemUpsertWithoutRr_itemsInput = {
    update: XOR<MEQSSupplierItemUpdateWithoutRr_itemsInput, MEQSSupplierItemUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<MEQSSupplierItemCreateWithoutRr_itemsInput, MEQSSupplierItemUncheckedCreateWithoutRr_itemsInput>
    where?: MEQSSupplierItemWhereInput
  }

  export type MEQSSupplierItemUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: MEQSSupplierItemWhereInput
    data: XOR<MEQSSupplierItemUpdateWithoutRr_itemsInput, MEQSSupplierItemUncheckedUpdateWithoutRr_itemsInput>
  }

  export type MEQSSupplierItemUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item?: CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationCreateWithoutOsrivsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationCreateNestedManyWithoutStationInput
    mrvs?: MRVCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVCreateNestedManyWithoutItem_fromInput
  }

  export type StationUncheckedCreateWithoutOsrivsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedCreateNestedManyWithoutStationInput
    mrvs?: MRVUncheckedCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVUncheckedCreateNestedManyWithoutItem_fromInput
  }

  export type StationCreateOrConnectWithoutOsrivsInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutOsrivsInput, StationUncheckedCreateWithoutOsrivsInput>
  }

  export type OSRIVApproverCreateWithoutOsrivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUncheckedCreateWithoutOsrivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverCreateOrConnectWithoutOsrivInput = {
    where: OSRIVApproverWhereUniqueInput
    create: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput>
  }

  export type OSRIVApproverCreateManyOsrivInputEnvelope = {
    data: OSRIVApproverCreateManyOsrivInput | OSRIVApproverCreateManyOsrivInput[]
    skipDuplicates?: boolean
  }

  export type OSRIVItemCreateWithoutOsrivInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutOsriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemUncheckedCreateWithoutOsrivInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutOsriv_itemInput
  }

  export type OSRIVItemCreateOrConnectWithoutOsrivInput = {
    where: OSRIVItemWhereUniqueInput
    create: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput>
  }

  export type OSRIVItemCreateManyOsrivInputEnvelope = {
    data: OSRIVItemCreateManyOsrivInput | OSRIVItemCreateManyOsrivInput[]
    skipDuplicates?: boolean
  }

  export type StationUpsertWithoutOsrivsInput = {
    update: XOR<StationUpdateWithoutOsrivsInput, StationUncheckedUpdateWithoutOsrivsInput>
    create: XOR<StationCreateWithoutOsrivsInput, StationUncheckedCreateWithoutOsrivsInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutOsrivsInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutOsrivsInput, StationUncheckedUpdateWithoutOsrivsInput>
  }

  export type StationUpdateWithoutOsrivsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUpdateManyWithoutStationNestedInput
    mrvs?: MRVUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUpdateManyWithoutItem_fromNestedInput
  }

  export type StationUncheckedUpdateWithoutOsrivsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedUpdateManyWithoutStationNestedInput
    mrvs?: MRVUncheckedUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUncheckedUpdateManyWithoutItem_fromNestedInput
  }

  export type OSRIVApproverUpsertWithWhereUniqueWithoutOsrivInput = {
    where: OSRIVApproverWhereUniqueInput
    update: XOR<OSRIVApproverUpdateWithoutOsrivInput, OSRIVApproverUncheckedUpdateWithoutOsrivInput>
    create: XOR<OSRIVApproverCreateWithoutOsrivInput, OSRIVApproverUncheckedCreateWithoutOsrivInput>
  }

  export type OSRIVApproverUpdateWithWhereUniqueWithoutOsrivInput = {
    where: OSRIVApproverWhereUniqueInput
    data: XOR<OSRIVApproverUpdateWithoutOsrivInput, OSRIVApproverUncheckedUpdateWithoutOsrivInput>
  }

  export type OSRIVApproverUpdateManyWithWhereWithoutOsrivInput = {
    where: OSRIVApproverScalarWhereInput
    data: XOR<OSRIVApproverUpdateManyMutationInput, OSRIVApproverUncheckedUpdateManyWithoutOsrivInput>
  }

  export type OSRIVApproverScalarWhereInput = {
    AND?: OSRIVApproverScalarWhereInput | OSRIVApproverScalarWhereInput[]
    OR?: OSRIVApproverScalarWhereInput[]
    NOT?: OSRIVApproverScalarWhereInput | OSRIVApproverScalarWhereInput[]
    id?: StringFilter<"OSRIVApprover"> | string
    osriv_id?: StringFilter<"OSRIVApprover"> | string
    approver_id?: StringFilter<"OSRIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"OSRIVApprover"> | Date | string | null
    notes?: StringFilter<"OSRIVApprover"> | string
    status?: IntFilter<"OSRIVApprover"> | number
    label?: StringFilter<"OSRIVApprover"> | string
    label_id?: StringFilter<"OSRIVApprover"> | string
    order?: IntFilter<"OSRIVApprover"> | number
    updated_by?: StringNullableFilter<"OSRIVApprover"> | string | null
    updated_at?: DateTimeFilter<"OSRIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"OSRIVApprover">
  }

  export type OSRIVItemUpsertWithWhereUniqueWithoutOsrivInput = {
    where: OSRIVItemWhereUniqueInput
    update: XOR<OSRIVItemUpdateWithoutOsrivInput, OSRIVItemUncheckedUpdateWithoutOsrivInput>
    create: XOR<OSRIVItemCreateWithoutOsrivInput, OSRIVItemUncheckedCreateWithoutOsrivInput>
  }

  export type OSRIVItemUpdateWithWhereUniqueWithoutOsrivInput = {
    where: OSRIVItemWhereUniqueInput
    data: XOR<OSRIVItemUpdateWithoutOsrivInput, OSRIVItemUncheckedUpdateWithoutOsrivInput>
  }

  export type OSRIVItemUpdateManyWithWhereWithoutOsrivInput = {
    where: OSRIVItemScalarWhereInput
    data: XOR<OSRIVItemUpdateManyMutationInput, OSRIVItemUncheckedUpdateManyWithoutOsrivInput>
  }

  export type OSRIVCreateWithoutOsriv_approversInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutOsrivsInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVUncheckedCreateWithoutOsriv_approversInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVCreateOrConnectWithoutOsriv_approversInput = {
    where: OSRIVWhereUniqueInput
    create: XOR<OSRIVCreateWithoutOsriv_approversInput, OSRIVUncheckedCreateWithoutOsriv_approversInput>
  }

  export type OSRIVUpsertWithoutOsriv_approversInput = {
    update: XOR<OSRIVUpdateWithoutOsriv_approversInput, OSRIVUncheckedUpdateWithoutOsriv_approversInput>
    create: XOR<OSRIVCreateWithoutOsriv_approversInput, OSRIVUncheckedCreateWithoutOsriv_approversInput>
    where?: OSRIVWhereInput
  }

  export type OSRIVUpdateToOneWithWhereWithoutOsriv_approversInput = {
    where?: OSRIVWhereInput
    data: XOR<OSRIVUpdateWithoutOsriv_approversInput, OSRIVUncheckedUpdateWithoutOsriv_approversInput>
  }

  export type OSRIVUpdateWithoutOsriv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutOsrivsNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVUncheckedUpdateWithoutOsriv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVCreateWithoutOsriv_itemsInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutOsrivsInput
    osriv_approvers?: OSRIVApproverCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVUncheckedCreateWithoutOsriv_itemsInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedCreateNestedManyWithoutOsrivInput
  }

  export type OSRIVCreateOrConnectWithoutOsriv_itemsInput = {
    where: OSRIVWhereUniqueInput
    create: XOR<OSRIVCreateWithoutOsriv_itemsInput, OSRIVUncheckedCreateWithoutOsriv_itemsInput>
  }

  export type ItemCreateWithoutOsriv_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutOsriv_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutOsriv_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutOsriv_itemsInput, ItemUncheckedCreateWithoutOsriv_itemsInput>
  }

  export type ItemTransactionCreateWithoutOsriv_itemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutOsriv_itemInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutOsriv_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
  }

  export type OSRIVUpsertWithoutOsriv_itemsInput = {
    update: XOR<OSRIVUpdateWithoutOsriv_itemsInput, OSRIVUncheckedUpdateWithoutOsriv_itemsInput>
    create: XOR<OSRIVCreateWithoutOsriv_itemsInput, OSRIVUncheckedCreateWithoutOsriv_itemsInput>
    where?: OSRIVWhereInput
  }

  export type OSRIVUpdateToOneWithWhereWithoutOsriv_itemsInput = {
    where?: OSRIVWhereInput
    data: XOR<OSRIVUpdateWithoutOsriv_itemsInput, OSRIVUncheckedUpdateWithoutOsriv_itemsInput>
  }

  export type OSRIVUpdateWithoutOsriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutOsrivsNestedInput
    osriv_approvers?: OSRIVApproverUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVUncheckedUpdateWithoutOsriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedUpdateManyWithoutOsrivNestedInput
  }

  export type ItemUpsertWithoutOsriv_itemsInput = {
    update: XOR<ItemUpdateWithoutOsriv_itemsInput, ItemUncheckedUpdateWithoutOsriv_itemsInput>
    create: XOR<ItemCreateWithoutOsriv_itemsInput, ItemUncheckedCreateWithoutOsriv_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutOsriv_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutOsriv_itemsInput, ItemUncheckedUpdateWithoutOsriv_itemsInput>
  }

  export type ItemUpdateWithoutOsriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutOsriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemTransactionUpsertWithoutOsriv_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutOsriv_itemInput, ItemTransactionUncheckedUpdateWithoutOsriv_itemInput>
    create: XOR<ItemTransactionCreateWithoutOsriv_itemInput, ItemTransactionUncheckedCreateWithoutOsriv_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutOsriv_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutOsriv_itemInput, ItemTransactionUncheckedUpdateWithoutOsriv_itemInput>
  }

  export type ItemTransactionUpdateWithoutOsriv_itemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutOsriv_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationCreateWithoutSerivsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationCreateNestedManyWithoutStationInput
    osrivs?: OSRIVCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVCreateNestedManyWithoutItem_fromInput
  }

  export type StationUncheckedCreateWithoutSerivsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedCreateNestedManyWithoutStationInput
    osrivs?: OSRIVUncheckedCreateNestedManyWithoutItem_fromInput
    mrvs?: MRVUncheckedCreateNestedManyWithoutItem_fromInput
  }

  export type StationCreateOrConnectWithoutSerivsInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutSerivsInput, StationUncheckedCreateWithoutSerivsInput>
  }

  export type SERIVApproverCreateWithoutSerivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUncheckedCreateWithoutSerivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverCreateOrConnectWithoutSerivInput = {
    where: SERIVApproverWhereUniqueInput
    create: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput>
  }

  export type SERIVApproverCreateManySerivInputEnvelope = {
    data: SERIVApproverCreateManySerivInput | SERIVApproverCreateManySerivInput[]
    skipDuplicates?: boolean
  }

  export type SERIVItemCreateWithoutSerivInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutSeriv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemUncheckedCreateWithoutSerivInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutSeriv_itemInput
  }

  export type SERIVItemCreateOrConnectWithoutSerivInput = {
    where: SERIVItemWhereUniqueInput
    create: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput>
  }

  export type SERIVItemCreateManySerivInputEnvelope = {
    data: SERIVItemCreateManySerivInput | SERIVItemCreateManySerivInput[]
    skipDuplicates?: boolean
  }

  export type MCRTCreateWithoutSerivInput = {
    id?: string
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTCreateNestedOneWithoutMcrtsInput
    mcrt_approvers?: MCRTApproverCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUncheckedCreateWithoutSerivInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutMcrtInput
  }

  export type MCRTCreateOrConnectWithoutSerivInput = {
    where: MCRTWhereUniqueInput
    create: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput>
  }

  export type MCRTCreateManySerivInputEnvelope = {
    data: MCRTCreateManySerivInput | MCRTCreateManySerivInput[]
    skipDuplicates?: boolean
  }

  export type StationUpsertWithoutSerivsInput = {
    update: XOR<StationUpdateWithoutSerivsInput, StationUncheckedUpdateWithoutSerivsInput>
    create: XOR<StationCreateWithoutSerivsInput, StationUncheckedCreateWithoutSerivsInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutSerivsInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutSerivsInput, StationUncheckedUpdateWithoutSerivsInput>
  }

  export type StationUpdateWithoutSerivsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUpdateManyWithoutItem_fromNestedInput
  }

  export type StationUncheckedUpdateWithoutSerivsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUncheckedUpdateManyWithoutItem_fromNestedInput
    mrvs?: MRVUncheckedUpdateManyWithoutItem_fromNestedInput
  }

  export type SERIVApproverUpsertWithWhereUniqueWithoutSerivInput = {
    where: SERIVApproverWhereUniqueInput
    update: XOR<SERIVApproverUpdateWithoutSerivInput, SERIVApproverUncheckedUpdateWithoutSerivInput>
    create: XOR<SERIVApproverCreateWithoutSerivInput, SERIVApproverUncheckedCreateWithoutSerivInput>
  }

  export type SERIVApproverUpdateWithWhereUniqueWithoutSerivInput = {
    where: SERIVApproverWhereUniqueInput
    data: XOR<SERIVApproverUpdateWithoutSerivInput, SERIVApproverUncheckedUpdateWithoutSerivInput>
  }

  export type SERIVApproverUpdateManyWithWhereWithoutSerivInput = {
    where: SERIVApproverScalarWhereInput
    data: XOR<SERIVApproverUpdateManyMutationInput, SERIVApproverUncheckedUpdateManyWithoutSerivInput>
  }

  export type SERIVApproverScalarWhereInput = {
    AND?: SERIVApproverScalarWhereInput | SERIVApproverScalarWhereInput[]
    OR?: SERIVApproverScalarWhereInput[]
    NOT?: SERIVApproverScalarWhereInput | SERIVApproverScalarWhereInput[]
    id?: StringFilter<"SERIVApprover"> | string
    seriv_id?: StringFilter<"SERIVApprover"> | string
    approver_id?: StringFilter<"SERIVApprover"> | string
    date_approval?: DateTimeNullableFilter<"SERIVApprover"> | Date | string | null
    notes?: StringFilter<"SERIVApprover"> | string
    status?: IntFilter<"SERIVApprover"> | number
    label?: StringFilter<"SERIVApprover"> | string
    label_id?: StringFilter<"SERIVApprover"> | string
    order?: IntFilter<"SERIVApprover"> | number
    updated_by?: StringNullableFilter<"SERIVApprover"> | string | null
    updated_at?: DateTimeFilter<"SERIVApprover"> | Date | string
    metadata?: JsonNullableFilter<"SERIVApprover">
  }

  export type SERIVItemUpsertWithWhereUniqueWithoutSerivInput = {
    where: SERIVItemWhereUniqueInput
    update: XOR<SERIVItemUpdateWithoutSerivInput, SERIVItemUncheckedUpdateWithoutSerivInput>
    create: XOR<SERIVItemCreateWithoutSerivInput, SERIVItemUncheckedCreateWithoutSerivInput>
  }

  export type SERIVItemUpdateWithWhereUniqueWithoutSerivInput = {
    where: SERIVItemWhereUniqueInput
    data: XOR<SERIVItemUpdateWithoutSerivInput, SERIVItemUncheckedUpdateWithoutSerivInput>
  }

  export type SERIVItemUpdateManyWithWhereWithoutSerivInput = {
    where: SERIVItemScalarWhereInput
    data: XOR<SERIVItemUpdateManyMutationInput, SERIVItemUncheckedUpdateManyWithoutSerivInput>
  }

  export type MCRTUpsertWithWhereUniqueWithoutSerivInput = {
    where: MCRTWhereUniqueInput
    update: XOR<MCRTUpdateWithoutSerivInput, MCRTUncheckedUpdateWithoutSerivInput>
    create: XOR<MCRTCreateWithoutSerivInput, MCRTUncheckedCreateWithoutSerivInput>
  }

  export type MCRTUpdateWithWhereUniqueWithoutSerivInput = {
    where: MCRTWhereUniqueInput
    data: XOR<MCRTUpdateWithoutSerivInput, MCRTUncheckedUpdateWithoutSerivInput>
  }

  export type MCRTUpdateManyWithWhereWithoutSerivInput = {
    where: MCRTScalarWhereInput
    data: XOR<MCRTUpdateManyMutationInput, MCRTUncheckedUpdateManyWithoutSerivInput>
  }

  export type MCRTScalarWhereInput = {
    AND?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
    OR?: MCRTScalarWhereInput[]
    NOT?: MCRTScalarWhereInput | MCRTScalarWhereInput[]
    id?: StringFilter<"MCRT"> | string
    mct_id?: StringNullableFilter<"MCRT"> | string | null
    mct_number?: StringNullableFilter<"MCRT"> | string | null
    seriv_id?: StringNullableFilter<"MCRT"> | string | null
    seriv_number?: StringNullableFilter<"MCRT"> | string | null
    mcrt_number?: StringFilter<"MCRT"> | string
    mcrt_date?: DateTimeFilter<"MCRT"> | Date | string
    is_completed?: BoolFilter<"MCRT"> | boolean
    returned_by_id?: StringFilter<"MCRT"> | string
    wo_number?: StringNullableFilter<"MCRT"> | string | null
    mo_number?: StringNullableFilter<"MCRT"> | string | null
    jo_number?: StringNullableFilter<"MCRT"> | string | null
    note?: StringFilter<"MCRT"> | string
    cancelled_by?: StringNullableFilter<"MCRT"> | string | null
    created_by?: StringFilter<"MCRT"> | string
    updated_by?: StringNullableFilter<"MCRT"> | string | null
    cancelled_at?: DateTimeNullableFilter<"MCRT"> | Date | string | null
    created_at?: DateTimeFilter<"MCRT"> | Date | string
    updated_at?: DateTimeFilter<"MCRT"> | Date | string
    metadata?: JsonNullableFilter<"MCRT">
  }

  export type SERIVCreateWithoutSeriv_approversInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutSerivsInput
    seriv_items?: SERIVItemCreateNestedManyWithoutSerivInput
    mcrts?: MCRTCreateNestedManyWithoutSerivInput
  }

  export type SERIVUncheckedCreateWithoutSeriv_approversInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutSerivInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutSerivInput
  }

  export type SERIVCreateOrConnectWithoutSeriv_approversInput = {
    where: SERIVWhereUniqueInput
    create: XOR<SERIVCreateWithoutSeriv_approversInput, SERIVUncheckedCreateWithoutSeriv_approversInput>
  }

  export type SERIVUpsertWithoutSeriv_approversInput = {
    update: XOR<SERIVUpdateWithoutSeriv_approversInput, SERIVUncheckedUpdateWithoutSeriv_approversInput>
    create: XOR<SERIVCreateWithoutSeriv_approversInput, SERIVUncheckedCreateWithoutSeriv_approversInput>
    where?: SERIVWhereInput
  }

  export type SERIVUpdateToOneWithWhereWithoutSeriv_approversInput = {
    where?: SERIVWhereInput
    data: XOR<SERIVUpdateWithoutSeriv_approversInput, SERIVUncheckedUpdateWithoutSeriv_approversInput>
  }

  export type SERIVUpdateWithoutSeriv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutSerivsNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateWithoutSeriv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutSerivNestedInput
  }

  export type SERIVCreateWithoutSeriv_itemsInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutSerivsInput
    seriv_approvers?: SERIVApproverCreateNestedManyWithoutSerivInput
    mcrts?: MCRTCreateNestedManyWithoutSerivInput
  }

  export type SERIVUncheckedCreateWithoutSeriv_itemsInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedCreateNestedManyWithoutSerivInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutSerivInput
  }

  export type SERIVCreateOrConnectWithoutSeriv_itemsInput = {
    where: SERIVWhereUniqueInput
    create: XOR<SERIVCreateWithoutSeriv_itemsInput, SERIVUncheckedCreateWithoutSeriv_itemsInput>
  }

  export type ItemCreateWithoutSeriv_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSeriv_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSeriv_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSeriv_itemsInput, ItemUncheckedCreateWithoutSeriv_itemsInput>
  }

  export type ItemTransactionCreateWithoutSeriv_itemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutSeriv_itemInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    osriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutSeriv_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
  }

  export type SERIVUpsertWithoutSeriv_itemsInput = {
    update: XOR<SERIVUpdateWithoutSeriv_itemsInput, SERIVUncheckedUpdateWithoutSeriv_itemsInput>
    create: XOR<SERIVCreateWithoutSeriv_itemsInput, SERIVUncheckedCreateWithoutSeriv_itemsInput>
    where?: SERIVWhereInput
  }

  export type SERIVUpdateToOneWithWhereWithoutSeriv_itemsInput = {
    where?: SERIVWhereInput
    data: XOR<SERIVUpdateWithoutSeriv_itemsInput, SERIVUncheckedUpdateWithoutSeriv_itemsInput>
  }

  export type SERIVUpdateWithoutSeriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutSerivsNestedInput
    seriv_approvers?: SERIVApproverUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateWithoutSeriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutSerivNestedInput
  }

  export type ItemUpsertWithoutSeriv_itemsInput = {
    update: XOR<ItemUpdateWithoutSeriv_itemsInput, ItemUncheckedUpdateWithoutSeriv_itemsInput>
    create: XOR<ItemCreateWithoutSeriv_itemsInput, ItemUncheckedCreateWithoutSeriv_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSeriv_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSeriv_itemsInput, ItemUncheckedUpdateWithoutSeriv_itemsInput>
  }

  export type ItemUpdateWithoutSeriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSeriv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemTransactionUpsertWithoutSeriv_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutSeriv_itemInput, ItemTransactionUncheckedUpdateWithoutSeriv_itemInput>
    create: XOR<ItemTransactionCreateWithoutSeriv_itemInput, ItemTransactionUncheckedCreateWithoutSeriv_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutSeriv_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutSeriv_itemInput, ItemTransactionUncheckedUpdateWithoutSeriv_itemInput>
  }

  export type ItemTransactionUpdateWithoutSeriv_itemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutSeriv_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StationCreateWithoutMrvsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationCreateNestedManyWithoutStationInput
    osrivs?: OSRIVCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVCreateNestedManyWithoutItem_fromInput
  }

  export type StationUncheckedCreateWithoutMrvsInput = {
    id?: string
    name: string
    location: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedCreateNestedManyWithoutStationInput
    osrivs?: OSRIVUncheckedCreateNestedManyWithoutItem_fromInput
    serivs?: SERIVUncheckedCreateNestedManyWithoutItem_fromInput
  }

  export type StationCreateOrConnectWithoutMrvsInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutMrvsInput, StationUncheckedCreateWithoutMrvsInput>
  }

  export type MRVApproverCreateWithoutMrvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUncheckedCreateWithoutMrvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverCreateOrConnectWithoutMrvInput = {
    where: MRVApproverWhereUniqueInput
    create: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput>
  }

  export type MRVApproverCreateManyMrvInputEnvelope = {
    data: MRVApproverCreateManyMrvInput | MRVApproverCreateManyMrvInput[]
    skipDuplicates?: boolean
  }

  export type MRVItemCreateWithoutMrvInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutMrv_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemUncheckedCreateWithoutMrvInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMrv_itemInput
  }

  export type MRVItemCreateOrConnectWithoutMrvInput = {
    where: MRVItemWhereUniqueInput
    create: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput>
  }

  export type MRVItemCreateManyMrvInputEnvelope = {
    data: MRVItemCreateManyMrvInput | MRVItemCreateManyMrvInput[]
    skipDuplicates?: boolean
  }

  export type MCTCreateWithoutMrvInput = {
    id?: string
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverCreateNestedManyWithoutMctInput
    mcrts?: MCRTCreateNestedManyWithoutMctInput
  }

  export type MCTUncheckedCreateWithoutMrvInput = {
    id?: string
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedCreateNestedManyWithoutMctInput
    mcrts?: MCRTUncheckedCreateNestedManyWithoutMctInput
  }

  export type MCTCreateOrConnectWithoutMrvInput = {
    where: MCTWhereUniqueInput
    create: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
  }

  export type ProjectCreateWithoutMrvInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUncheckedCreateWithoutMrvInput = {
    id?: string
    name: string
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateOrConnectWithoutMrvInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMrvInput, ProjectUncheckedCreateWithoutMrvInput>
  }

  export type StationUpsertWithoutMrvsInput = {
    update: XOR<StationUpdateWithoutMrvsInput, StationUncheckedUpdateWithoutMrvsInput>
    create: XOR<StationCreateWithoutMrvsInput, StationUncheckedCreateWithoutMrvsInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutMrvsInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutMrvsInput, StationUncheckedUpdateWithoutMrvsInput>
  }

  export type StationUpdateWithoutMrvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUpdateManyWithoutItem_fromNestedInput
  }

  export type StationUncheckedUpdateWithoutMrvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    items?: ItemLocationUncheckedUpdateManyWithoutStationNestedInput
    osrivs?: OSRIVUncheckedUpdateManyWithoutItem_fromNestedInput
    serivs?: SERIVUncheckedUpdateManyWithoutItem_fromNestedInput
  }

  export type MRVApproverUpsertWithWhereUniqueWithoutMrvInput = {
    where: MRVApproverWhereUniqueInput
    update: XOR<MRVApproverUpdateWithoutMrvInput, MRVApproverUncheckedUpdateWithoutMrvInput>
    create: XOR<MRVApproverCreateWithoutMrvInput, MRVApproverUncheckedCreateWithoutMrvInput>
  }

  export type MRVApproverUpdateWithWhereUniqueWithoutMrvInput = {
    where: MRVApproverWhereUniqueInput
    data: XOR<MRVApproverUpdateWithoutMrvInput, MRVApproverUncheckedUpdateWithoutMrvInput>
  }

  export type MRVApproverUpdateManyWithWhereWithoutMrvInput = {
    where: MRVApproverScalarWhereInput
    data: XOR<MRVApproverUpdateManyMutationInput, MRVApproverUncheckedUpdateManyWithoutMrvInput>
  }

  export type MRVApproverScalarWhereInput = {
    AND?: MRVApproverScalarWhereInput | MRVApproverScalarWhereInput[]
    OR?: MRVApproverScalarWhereInput[]
    NOT?: MRVApproverScalarWhereInput | MRVApproverScalarWhereInput[]
    id?: StringFilter<"MRVApprover"> | string
    mrv_id?: StringFilter<"MRVApprover"> | string
    approver_id?: StringFilter<"MRVApprover"> | string
    date_approval?: DateTimeNullableFilter<"MRVApprover"> | Date | string | null
    notes?: StringFilter<"MRVApprover"> | string
    status?: IntFilter<"MRVApprover"> | number
    label?: StringFilter<"MRVApprover"> | string
    label_id?: StringFilter<"MRVApprover"> | string
    order?: IntFilter<"MRVApprover"> | number
    updated_by?: StringNullableFilter<"MRVApprover"> | string | null
    updated_at?: DateTimeFilter<"MRVApprover"> | Date | string
    metadata?: JsonNullableFilter<"MRVApprover">
  }

  export type MRVItemUpsertWithWhereUniqueWithoutMrvInput = {
    where: MRVItemWhereUniqueInput
    update: XOR<MRVItemUpdateWithoutMrvInput, MRVItemUncheckedUpdateWithoutMrvInput>
    create: XOR<MRVItemCreateWithoutMrvInput, MRVItemUncheckedCreateWithoutMrvInput>
  }

  export type MRVItemUpdateWithWhereUniqueWithoutMrvInput = {
    where: MRVItemWhereUniqueInput
    data: XOR<MRVItemUpdateWithoutMrvInput, MRVItemUncheckedUpdateWithoutMrvInput>
  }

  export type MRVItemUpdateManyWithWhereWithoutMrvInput = {
    where: MRVItemScalarWhereInput
    data: XOR<MRVItemUpdateManyMutationInput, MRVItemUncheckedUpdateManyWithoutMrvInput>
  }

  export type MCTUpsertWithoutMrvInput = {
    update: XOR<MCTUpdateWithoutMrvInput, MCTUncheckedUpdateWithoutMrvInput>
    create: XOR<MCTCreateWithoutMrvInput, MCTUncheckedCreateWithoutMrvInput>
    where?: MCTWhereInput
  }

  export type MCTUpdateToOneWithWhereWithoutMrvInput = {
    where?: MCTWhereInput
    data: XOR<MCTUpdateWithoutMrvInput, MCTUncheckedUpdateWithoutMrvInput>
  }

  export type MCTUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUpdateManyWithoutMctNestedInput
    mcrts?: MCRTUpdateManyWithoutMctNestedInput
  }

  export type MCTUncheckedUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedUpdateManyWithoutMctNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutMctNestedInput
  }

  export type ProjectUpsertWithoutMrvInput = {
    update: XOR<ProjectUpdateWithoutMrvInput, ProjectUncheckedUpdateWithoutMrvInput>
    create: XOR<ProjectCreateWithoutMrvInput, ProjectUncheckedCreateWithoutMrvInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMrvInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMrvInput, ProjectUncheckedUpdateWithoutMrvInput>
  }

  export type ProjectUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUncheckedUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVCreateWithoutMrv_approversInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutMrvsInput
    mrv_items?: MRVItemCreateNestedManyWithoutMrvInput
    mct?: MCTCreateNestedOneWithoutMrvInput
    project: ProjectCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateWithoutMrv_approversInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutMrvInput
    mct?: MCTUncheckedCreateNestedOneWithoutMrvInput
  }

  export type MRVCreateOrConnectWithoutMrv_approversInput = {
    where: MRVWhereUniqueInput
    create: XOR<MRVCreateWithoutMrv_approversInput, MRVUncheckedCreateWithoutMrv_approversInput>
  }

  export type MRVUpsertWithoutMrv_approversInput = {
    update: XOR<MRVUpdateWithoutMrv_approversInput, MRVUncheckedUpdateWithoutMrv_approversInput>
    create: XOR<MRVCreateWithoutMrv_approversInput, MRVUncheckedCreateWithoutMrv_approversInput>
    where?: MRVWhereInput
  }

  export type MRVUpdateToOneWithWhereWithoutMrv_approversInput = {
    where?: MRVWhereInput
    data: XOR<MRVUpdateWithoutMrv_approversInput, MRVUncheckedUpdateWithoutMrv_approversInput>
  }

  export type MRVUpdateWithoutMrv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutMrvsNestedInput
    mrv_items?: MRVItemUpdateManyWithoutMrvNestedInput
    mct?: MCTUpdateOneWithoutMrvNestedInput
    project?: ProjectUpdateOneRequiredWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateWithoutMrv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_items?: MRVItemUncheckedUpdateManyWithoutMrvNestedInput
    mct?: MCTUncheckedUpdateOneWithoutMrvNestedInput
  }

  export type MRVCreateWithoutMrv_itemsInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutMrvsInput
    mrv_approvers?: MRVApproverCreateNestedManyWithoutMrvInput
    mct?: MCTCreateNestedOneWithoutMrvInput
    project: ProjectCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateWithoutMrv_itemsInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedCreateNestedManyWithoutMrvInput
    mct?: MCTUncheckedCreateNestedOneWithoutMrvInput
  }

  export type MRVCreateOrConnectWithoutMrv_itemsInput = {
    where: MRVWhereUniqueInput
    create: XOR<MRVCreateWithoutMrv_itemsInput, MRVUncheckedCreateWithoutMrv_itemsInput>
  }

  export type ItemCreateWithoutMrv_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutMrv_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutMrv_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutMrv_itemsInput, ItemUncheckedCreateWithoutMrv_itemsInput>
  }

  export type ItemTransactionCreateWithoutMrv_itemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mcrt_item?: MCRTItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutMrv_itemInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutMrv_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
  }

  export type MRVUpsertWithoutMrv_itemsInput = {
    update: XOR<MRVUpdateWithoutMrv_itemsInput, MRVUncheckedUpdateWithoutMrv_itemsInput>
    create: XOR<MRVCreateWithoutMrv_itemsInput, MRVUncheckedCreateWithoutMrv_itemsInput>
    where?: MRVWhereInput
  }

  export type MRVUpdateToOneWithWhereWithoutMrv_itemsInput = {
    where?: MRVWhereInput
    data: XOR<MRVUpdateWithoutMrv_itemsInput, MRVUncheckedUpdateWithoutMrv_itemsInput>
  }

  export type MRVUpdateWithoutMrv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutMrvsNestedInput
    mrv_approvers?: MRVApproverUpdateManyWithoutMrvNestedInput
    mct?: MCTUpdateOneWithoutMrvNestedInput
    project?: ProjectUpdateOneRequiredWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateWithoutMrv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedUpdateManyWithoutMrvNestedInput
    mct?: MCTUncheckedUpdateOneWithoutMrvNestedInput
  }

  export type ItemUpsertWithoutMrv_itemsInput = {
    update: XOR<ItemUpdateWithoutMrv_itemsInput, ItemUncheckedUpdateWithoutMrv_itemsInput>
    create: XOR<ItemCreateWithoutMrv_itemsInput, ItemUncheckedCreateWithoutMrv_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutMrv_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutMrv_itemsInput, ItemUncheckedUpdateWithoutMrv_itemsInput>
  }

  export type ItemUpdateWithoutMrv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutMrv_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemTransactionUpsertWithoutMrv_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutMrv_itemInput, ItemTransactionUncheckedUpdateWithoutMrv_itemInput>
    create: XOR<ItemTransactionCreateWithoutMrv_itemInput, ItemTransactionUncheckedCreateWithoutMrv_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutMrv_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutMrv_itemInput, ItemTransactionUncheckedUpdateWithoutMrv_itemInput>
  }

  export type ItemTransactionUpdateWithoutMrv_itemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutMrv_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVCreateWithoutMctInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutMrvsInput
    mrv_approvers?: MRVApproverCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemCreateNestedManyWithoutMrvInput
    project: ProjectCreateNestedOneWithoutMrvInput
  }

  export type MRVUncheckedCreateWithoutMctInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedCreateNestedManyWithoutMrvInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutMrvInput
  }

  export type MRVCreateOrConnectWithoutMctInput = {
    where: MRVWhereUniqueInput
    create: XOR<MRVCreateWithoutMctInput, MRVUncheckedCreateWithoutMctInput>
  }

  export type MCTApproverCreateWithoutMctInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUncheckedCreateWithoutMctInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverCreateOrConnectWithoutMctInput = {
    where: MCTApproverWhereUniqueInput
    create: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput>
  }

  export type MCTApproverCreateManyMctInputEnvelope = {
    data: MCTApproverCreateManyMctInput | MCTApproverCreateManyMctInput[]
    skipDuplicates?: boolean
  }

  export type MCRTCreateWithoutMctInput = {
    id?: string
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVCreateNestedOneWithoutMcrtsInput
    mcrt_approvers?: MCRTApproverCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUncheckedCreateWithoutMctInput = {
    id?: string
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedCreateNestedManyWithoutMcrtInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutMcrtInput
  }

  export type MCRTCreateOrConnectWithoutMctInput = {
    where: MCRTWhereUniqueInput
    create: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput>
  }

  export type MCRTCreateManyMctInputEnvelope = {
    data: MCRTCreateManyMctInput | MCRTCreateManyMctInput[]
    skipDuplicates?: boolean
  }

  export type MRVUpsertWithoutMctInput = {
    update: XOR<MRVUpdateWithoutMctInput, MRVUncheckedUpdateWithoutMctInput>
    create: XOR<MRVCreateWithoutMctInput, MRVUncheckedCreateWithoutMctInput>
    where?: MRVWhereInput
  }

  export type MRVUpdateToOneWithWhereWithoutMctInput = {
    where?: MRVWhereInput
    data: XOR<MRVUpdateWithoutMctInput, MRVUncheckedUpdateWithoutMctInput>
  }

  export type MRVUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutMrvsNestedInput
    mrv_approvers?: MRVApproverUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUpdateManyWithoutMrvNestedInput
    project?: ProjectUpdateOneRequiredWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutMrvNestedInput
  }

  export type MCTApproverUpsertWithWhereUniqueWithoutMctInput = {
    where: MCTApproverWhereUniqueInput
    update: XOR<MCTApproverUpdateWithoutMctInput, MCTApproverUncheckedUpdateWithoutMctInput>
    create: XOR<MCTApproverCreateWithoutMctInput, MCTApproverUncheckedCreateWithoutMctInput>
  }

  export type MCTApproverUpdateWithWhereUniqueWithoutMctInput = {
    where: MCTApproverWhereUniqueInput
    data: XOR<MCTApproverUpdateWithoutMctInput, MCTApproverUncheckedUpdateWithoutMctInput>
  }

  export type MCTApproverUpdateManyWithWhereWithoutMctInput = {
    where: MCTApproverScalarWhereInput
    data: XOR<MCTApproverUpdateManyMutationInput, MCTApproverUncheckedUpdateManyWithoutMctInput>
  }

  export type MCTApproverScalarWhereInput = {
    AND?: MCTApproverScalarWhereInput | MCTApproverScalarWhereInput[]
    OR?: MCTApproverScalarWhereInput[]
    NOT?: MCTApproverScalarWhereInput | MCTApproverScalarWhereInput[]
    id?: StringFilter<"MCTApprover"> | string
    mct_id?: StringFilter<"MCTApprover"> | string
    approver_id?: StringFilter<"MCTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCTApprover"> | Date | string | null
    notes?: StringFilter<"MCTApprover"> | string
    status?: IntFilter<"MCTApprover"> | number
    label?: StringFilter<"MCTApprover"> | string
    label_id?: StringFilter<"MCTApprover"> | string
    order?: IntFilter<"MCTApprover"> | number
    updated_by?: StringNullableFilter<"MCTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCTApprover">
  }

  export type MCRTUpsertWithWhereUniqueWithoutMctInput = {
    where: MCRTWhereUniqueInput
    update: XOR<MCRTUpdateWithoutMctInput, MCRTUncheckedUpdateWithoutMctInput>
    create: XOR<MCRTCreateWithoutMctInput, MCRTUncheckedCreateWithoutMctInput>
  }

  export type MCRTUpdateWithWhereUniqueWithoutMctInput = {
    where: MCRTWhereUniqueInput
    data: XOR<MCRTUpdateWithoutMctInput, MCRTUncheckedUpdateWithoutMctInput>
  }

  export type MCRTUpdateManyWithWhereWithoutMctInput = {
    where: MCRTScalarWhereInput
    data: XOR<MCRTUpdateManyMutationInput, MCRTUncheckedUpdateManyWithoutMctInput>
  }

  export type MCTCreateWithoutMct_approversInput = {
    id?: string
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVCreateNestedOneWithoutMctInput
    mcrts?: MCRTCreateNestedManyWithoutMctInput
  }

  export type MCTUncheckedCreateWithoutMct_approversInput = {
    id?: string
    mrv_id?: string | null
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrts?: MCRTUncheckedCreateNestedManyWithoutMctInput
  }

  export type MCTCreateOrConnectWithoutMct_approversInput = {
    where: MCTWhereUniqueInput
    create: XOR<MCTCreateWithoutMct_approversInput, MCTUncheckedCreateWithoutMct_approversInput>
  }

  export type MCTUpsertWithoutMct_approversInput = {
    update: XOR<MCTUpdateWithoutMct_approversInput, MCTUncheckedUpdateWithoutMct_approversInput>
    create: XOR<MCTCreateWithoutMct_approversInput, MCTUncheckedCreateWithoutMct_approversInput>
    where?: MCTWhereInput
  }

  export type MCTUpdateToOneWithWhereWithoutMct_approversInput = {
    where?: MCTWhereInput
    data: XOR<MCTUpdateWithoutMct_approversInput, MCTUncheckedUpdateWithoutMct_approversInput>
  }

  export type MCTUpdateWithoutMct_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneWithoutMctNestedInput
    mcrts?: MCRTUpdateManyWithoutMctNestedInput
  }

  export type MCTUncheckedUpdateWithoutMct_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrts?: MCRTUncheckedUpdateManyWithoutMctNestedInput
  }

  export type MCTCreateWithoutMcrtsInput = {
    id?: string
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVCreateNestedOneWithoutMctInput
    mct_approvers?: MCTApproverCreateNestedManyWithoutMctInput
  }

  export type MCTUncheckedCreateWithoutMcrtsInput = {
    id?: string
    mrv_id?: string | null
    mrv_number: string
    mct_number: string
    mct_date: Date | string
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedCreateNestedManyWithoutMctInput
  }

  export type MCTCreateOrConnectWithoutMcrtsInput = {
    where: MCTWhereUniqueInput
    create: XOR<MCTCreateWithoutMcrtsInput, MCTUncheckedCreateWithoutMcrtsInput>
  }

  export type SERIVCreateWithoutMcrtsInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from: StationCreateNestedOneWithoutSerivsInput
    seriv_approvers?: SERIVApproverCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemCreateNestedManyWithoutSerivInput
  }

  export type SERIVUncheckedCreateWithoutMcrtsInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedCreateNestedManyWithoutSerivInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutSerivInput
  }

  export type SERIVCreateOrConnectWithoutMcrtsInput = {
    where: SERIVWhereUniqueInput
    create: XOR<SERIVCreateWithoutMcrtsInput, SERIVUncheckedCreateWithoutMcrtsInput>
  }

  export type MCRTApproverCreateWithoutMcrtInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUncheckedCreateWithoutMcrtInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverCreateOrConnectWithoutMcrtInput = {
    where: MCRTApproverWhereUniqueInput
    create: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput>
  }

  export type MCRTApproverCreateManyMcrtInputEnvelope = {
    data: MCRTApproverCreateManyMcrtInput | MCRTApproverCreateManyMcrtInput[]
    skipDuplicates?: boolean
  }

  export type MCRTItemCreateWithoutMcrtInput = {
    id?: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutMcrt_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemUncheckedCreateWithoutMcrtInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutMcrt_itemInput
  }

  export type MCRTItemCreateOrConnectWithoutMcrtInput = {
    where: MCRTItemWhereUniqueInput
    create: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput>
  }

  export type MCRTItemCreateManyMcrtInputEnvelope = {
    data: MCRTItemCreateManyMcrtInput | MCRTItemCreateManyMcrtInput[]
    skipDuplicates?: boolean
  }

  export type MCTUpsertWithoutMcrtsInput = {
    update: XOR<MCTUpdateWithoutMcrtsInput, MCTUncheckedUpdateWithoutMcrtsInput>
    create: XOR<MCTCreateWithoutMcrtsInput, MCTUncheckedCreateWithoutMcrtsInput>
    where?: MCTWhereInput
  }

  export type MCTUpdateToOneWithWhereWithoutMcrtsInput = {
    where?: MCTWhereInput
    data: XOR<MCTUpdateWithoutMcrtsInput, MCTUncheckedUpdateWithoutMcrtsInput>
  }

  export type MCTUpdateWithoutMcrtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneWithoutMctNestedInput
    mct_approvers?: MCTApproverUpdateManyWithoutMctNestedInput
  }

  export type MCTUncheckedUpdateWithoutMcrtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_number?: StringFieldUpdateOperationsInput | string
    mct_number?: StringFieldUpdateOperationsInput | string
    mct_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct_approvers?: MCTApproverUncheckedUpdateManyWithoutMctNestedInput
  }

  export type SERIVUpsertWithoutMcrtsInput = {
    update: XOR<SERIVUpdateWithoutMcrtsInput, SERIVUncheckedUpdateWithoutMcrtsInput>
    create: XOR<SERIVCreateWithoutMcrtsInput, SERIVUncheckedCreateWithoutMcrtsInput>
    where?: SERIVWhereInput
  }

  export type SERIVUpdateToOneWithWhereWithoutMcrtsInput = {
    where?: SERIVWhereInput
    data: XOR<SERIVUpdateWithoutMcrtsInput, SERIVUncheckedUpdateWithoutMcrtsInput>
  }

  export type SERIVUpdateWithoutMcrtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutSerivsNestedInput
    seriv_approvers?: SERIVApproverUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateWithoutMcrtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutSerivNestedInput
  }

  export type MCRTApproverUpsertWithWhereUniqueWithoutMcrtInput = {
    where: MCRTApproverWhereUniqueInput
    update: XOR<MCRTApproverUpdateWithoutMcrtInput, MCRTApproverUncheckedUpdateWithoutMcrtInput>
    create: XOR<MCRTApproverCreateWithoutMcrtInput, MCRTApproverUncheckedCreateWithoutMcrtInput>
  }

  export type MCRTApproverUpdateWithWhereUniqueWithoutMcrtInput = {
    where: MCRTApproverWhereUniqueInput
    data: XOR<MCRTApproverUpdateWithoutMcrtInput, MCRTApproverUncheckedUpdateWithoutMcrtInput>
  }

  export type MCRTApproverUpdateManyWithWhereWithoutMcrtInput = {
    where: MCRTApproverScalarWhereInput
    data: XOR<MCRTApproverUpdateManyMutationInput, MCRTApproverUncheckedUpdateManyWithoutMcrtInput>
  }

  export type MCRTApproverScalarWhereInput = {
    AND?: MCRTApproverScalarWhereInput | MCRTApproverScalarWhereInput[]
    OR?: MCRTApproverScalarWhereInput[]
    NOT?: MCRTApproverScalarWhereInput | MCRTApproverScalarWhereInput[]
    id?: StringFilter<"MCRTApprover"> | string
    mcrt_id?: StringFilter<"MCRTApprover"> | string
    approver_id?: StringFilter<"MCRTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MCRTApprover"> | Date | string | null
    notes?: StringFilter<"MCRTApprover"> | string
    status?: IntFilter<"MCRTApprover"> | number
    label?: StringFilter<"MCRTApprover"> | string
    label_id?: StringFilter<"MCRTApprover"> | string
    order?: IntFilter<"MCRTApprover"> | number
    updated_by?: StringNullableFilter<"MCRTApprover"> | string | null
    updated_at?: DateTimeFilter<"MCRTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MCRTApprover">
  }

  export type MCRTItemUpsertWithWhereUniqueWithoutMcrtInput = {
    where: MCRTItemWhereUniqueInput
    update: XOR<MCRTItemUpdateWithoutMcrtInput, MCRTItemUncheckedUpdateWithoutMcrtInput>
    create: XOR<MCRTItemCreateWithoutMcrtInput, MCRTItemUncheckedCreateWithoutMcrtInput>
  }

  export type MCRTItemUpdateWithWhereUniqueWithoutMcrtInput = {
    where: MCRTItemWhereUniqueInput
    data: XOR<MCRTItemUpdateWithoutMcrtInput, MCRTItemUncheckedUpdateWithoutMcrtInput>
  }

  export type MCRTItemUpdateManyWithWhereWithoutMcrtInput = {
    where: MCRTItemScalarWhereInput
    data: XOR<MCRTItemUpdateManyMutationInput, MCRTItemUncheckedUpdateManyWithoutMcrtInput>
  }

  export type MCRTCreateWithoutMcrt_approversInput = {
    id?: string
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTCreateNestedOneWithoutMcrtsInput
    seriv?: SERIVCreateNestedOneWithoutMcrtsInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUncheckedCreateWithoutMcrt_approversInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutMcrtInput
  }

  export type MCRTCreateOrConnectWithoutMcrt_approversInput = {
    where: MCRTWhereUniqueInput
    create: XOR<MCRTCreateWithoutMcrt_approversInput, MCRTUncheckedCreateWithoutMcrt_approversInput>
  }

  export type MCRTUpsertWithoutMcrt_approversInput = {
    update: XOR<MCRTUpdateWithoutMcrt_approversInput, MCRTUncheckedUpdateWithoutMcrt_approversInput>
    create: XOR<MCRTCreateWithoutMcrt_approversInput, MCRTUncheckedCreateWithoutMcrt_approversInput>
    where?: MCRTWhereInput
  }

  export type MCRTUpdateToOneWithWhereWithoutMcrt_approversInput = {
    where?: MCRTWhereInput
    data: XOR<MCRTUpdateWithoutMcrt_approversInput, MCRTUncheckedUpdateWithoutMcrt_approversInput>
  }

  export type MCRTUpdateWithoutMcrt_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTUpdateOneWithoutMcrtsNestedInput
    seriv?: SERIVUpdateOneWithoutMcrtsNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateWithoutMcrt_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTCreateWithoutMcrt_itemsInput = {
    id?: string
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTCreateNestedOneWithoutMcrtsInput
    seriv?: SERIVCreateNestedOneWithoutMcrtsInput
    mcrt_approvers?: MCRTApproverCreateNestedManyWithoutMcrtInput
  }

  export type MCRTUncheckedCreateWithoutMcrt_itemsInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedCreateNestedManyWithoutMcrtInput
  }

  export type MCRTCreateOrConnectWithoutMcrt_itemsInput = {
    where: MCRTWhereUniqueInput
    create: XOR<MCRTCreateWithoutMcrt_itemsInput, MCRTUncheckedCreateWithoutMcrt_itemsInput>
  }

  export type ItemCreateWithoutMcrt_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mst_items?: MSTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutMcrt_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutMcrt_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutMcrt_itemsInput, ItemUncheckedCreateWithoutMcrt_itemsInput>
  }

  export type ItemTransactionCreateWithoutMcrt_itemInput = {
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
    osriv_item?: OSRIVItemCreateNestedOneWithoutItem_transactionInput
    seriv_item?: SERIVItemCreateNestedOneWithoutItem_transactionInput
    mrv_item?: MRVItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutMcrt_itemInput = {
    id?: number
    item_id: string
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateOrConnectWithoutMcrt_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
  }

  export type MCRTUpsertWithoutMcrt_itemsInput = {
    update: XOR<MCRTUpdateWithoutMcrt_itemsInput, MCRTUncheckedUpdateWithoutMcrt_itemsInput>
    create: XOR<MCRTCreateWithoutMcrt_itemsInput, MCRTUncheckedCreateWithoutMcrt_itemsInput>
    where?: MCRTWhereInput
  }

  export type MCRTUpdateToOneWithWhereWithoutMcrt_itemsInput = {
    where?: MCRTWhereInput
    data: XOR<MCRTUpdateWithoutMcrt_itemsInput, MCRTUncheckedUpdateWithoutMcrt_itemsInput>
  }

  export type MCRTUpdateWithoutMcrt_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTUpdateOneWithoutMcrtsNestedInput
    seriv?: SERIVUpdateOneWithoutMcrtsNestedInput
    mcrt_approvers?: MCRTApproverUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateWithoutMcrt_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedUpdateManyWithoutMcrtNestedInput
  }

  export type ItemUpsertWithoutMcrt_itemsInput = {
    update: XOR<ItemUpdateWithoutMcrt_itemsInput, ItemUncheckedUpdateWithoutMcrt_itemsInput>
    create: XOR<ItemCreateWithoutMcrt_itemsInput, ItemUncheckedCreateWithoutMcrt_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutMcrt_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutMcrt_itemsInput, ItemUncheckedUpdateWithoutMcrt_itemsInput>
  }

  export type ItemUpdateWithoutMcrt_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutMcrt_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemTransactionUpsertWithoutMcrt_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutMcrt_itemInput, ItemTransactionUncheckedUpdateWithoutMcrt_itemInput>
    create: XOR<ItemTransactionCreateWithoutMcrt_itemInput, ItemTransactionUncheckedCreateWithoutMcrt_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutMcrt_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutMcrt_itemInput, ItemTransactionUncheckedUpdateWithoutMcrt_itemInput>
  }

  export type ItemTransactionUpdateWithoutMcrt_itemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutMcrt_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverCreateWithoutMstInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUncheckedCreateWithoutMstInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverCreateOrConnectWithoutMstInput = {
    where: MSTApproverWhereUniqueInput
    create: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput>
  }

  export type MSTApproverCreateManyMstInputEnvelope = {
    data: MSTApproverCreateManyMstInput | MSTApproverCreateManyMstInput[]
    skipDuplicates?: boolean
  }

  export type MSTItemCreateWithoutMstInput = {
    id?: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item: ItemCreateNestedOneWithoutMst_itemsInput
  }

  export type MSTItemUncheckedCreateWithoutMstInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateOrConnectWithoutMstInput = {
    where: MSTItemWhereUniqueInput
    create: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput>
  }

  export type MSTItemCreateManyMstInputEnvelope = {
    data: MSTItemCreateManyMstInput | MSTItemCreateManyMstInput[]
    skipDuplicates?: boolean
  }

  export type MSTApproverUpsertWithWhereUniqueWithoutMstInput = {
    where: MSTApproverWhereUniqueInput
    update: XOR<MSTApproverUpdateWithoutMstInput, MSTApproverUncheckedUpdateWithoutMstInput>
    create: XOR<MSTApproverCreateWithoutMstInput, MSTApproverUncheckedCreateWithoutMstInput>
  }

  export type MSTApproverUpdateWithWhereUniqueWithoutMstInput = {
    where: MSTApproverWhereUniqueInput
    data: XOR<MSTApproverUpdateWithoutMstInput, MSTApproverUncheckedUpdateWithoutMstInput>
  }

  export type MSTApproverUpdateManyWithWhereWithoutMstInput = {
    where: MSTApproverScalarWhereInput
    data: XOR<MSTApproverUpdateManyMutationInput, MSTApproverUncheckedUpdateManyWithoutMstInput>
  }

  export type MSTApproverScalarWhereInput = {
    AND?: MSTApproverScalarWhereInput | MSTApproverScalarWhereInput[]
    OR?: MSTApproverScalarWhereInput[]
    NOT?: MSTApproverScalarWhereInput | MSTApproverScalarWhereInput[]
    id?: StringFilter<"MSTApprover"> | string
    mst_id?: StringFilter<"MSTApprover"> | string
    approver_id?: StringFilter<"MSTApprover"> | string
    date_approval?: DateTimeNullableFilter<"MSTApprover"> | Date | string | null
    notes?: StringFilter<"MSTApprover"> | string
    status?: IntFilter<"MSTApprover"> | number
    label?: StringFilter<"MSTApprover"> | string
    label_id?: StringFilter<"MSTApprover"> | string
    order?: IntFilter<"MSTApprover"> | number
    updated_by?: StringNullableFilter<"MSTApprover"> | string | null
    updated_at?: DateTimeFilter<"MSTApprover"> | Date | string
    metadata?: JsonNullableFilter<"MSTApprover">
  }

  export type MSTItemUpsertWithWhereUniqueWithoutMstInput = {
    where: MSTItemWhereUniqueInput
    update: XOR<MSTItemUpdateWithoutMstInput, MSTItemUncheckedUpdateWithoutMstInput>
    create: XOR<MSTItemCreateWithoutMstInput, MSTItemUncheckedCreateWithoutMstInput>
  }

  export type MSTItemUpdateWithWhereUniqueWithoutMstInput = {
    where: MSTItemWhereUniqueInput
    data: XOR<MSTItemUpdateWithoutMstInput, MSTItemUncheckedUpdateWithoutMstInput>
  }

  export type MSTItemUpdateManyWithWhereWithoutMstInput = {
    where: MSTItemScalarWhereInput
    data: XOR<MSTItemUpdateManyMutationInput, MSTItemUncheckedUpdateManyWithoutMstInput>
  }

  export type MSTCreateWithoutMst_approversInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_items?: MSTItemCreateNestedManyWithoutMstInput
  }

  export type MSTUncheckedCreateWithoutMst_approversInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_items?: MSTItemUncheckedCreateNestedManyWithoutMstInput
  }

  export type MSTCreateOrConnectWithoutMst_approversInput = {
    where: MSTWhereUniqueInput
    create: XOR<MSTCreateWithoutMst_approversInput, MSTUncheckedCreateWithoutMst_approversInput>
  }

  export type MSTUpsertWithoutMst_approversInput = {
    update: XOR<MSTUpdateWithoutMst_approversInput, MSTUncheckedUpdateWithoutMst_approversInput>
    create: XOR<MSTCreateWithoutMst_approversInput, MSTUncheckedCreateWithoutMst_approversInput>
    where?: MSTWhereInput
  }

  export type MSTUpdateToOneWithWhereWithoutMst_approversInput = {
    where?: MSTWhereInput
    data: XOR<MSTUpdateWithoutMst_approversInput, MSTUncheckedUpdateWithoutMst_approversInput>
  }

  export type MSTUpdateWithoutMst_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_items?: MSTItemUpdateManyWithoutMstNestedInput
  }

  export type MSTUncheckedUpdateWithoutMst_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_items?: MSTItemUncheckedUpdateManyWithoutMstNestedInput
  }

  export type MSTCreateWithoutMst_itemsInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverCreateNestedManyWithoutMstInput
  }

  export type MSTUncheckedCreateWithoutMst_itemsInput = {
    id?: string
    mst_number: string
    mst_date: Date | string
    returned_by_id: string
    cwo_number?: string | null
    mwo_number?: string | null
    jo_number?: string | null
    remarks: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUncheckedCreateNestedManyWithoutMstInput
  }

  export type MSTCreateOrConnectWithoutMst_itemsInput = {
    where: MSTWhereUniqueInput
    create: XOR<MSTCreateWithoutMst_itemsInput, MSTUncheckedCreateWithoutMst_itemsInput>
  }

  export type ItemCreateWithoutMst_itemsInput = {
    id?: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
    canvass_items?: CanvassItemCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutMst_itemsInput = {
    id?: string
    item_type_id: number
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutItemInput
    item_locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    osriv_items?: OSRIVItemUncheckedCreateNestedManyWithoutItemInput
    seriv_items?: SERIVItemUncheckedCreateNestedManyWithoutItemInput
    mrv_items?: MRVItemUncheckedCreateNestedManyWithoutItemInput
    mcrt_items?: MCRTItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutMst_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutMst_itemsInput, ItemUncheckedCreateWithoutMst_itemsInput>
  }

  export type MSTUpsertWithoutMst_itemsInput = {
    update: XOR<MSTUpdateWithoutMst_itemsInput, MSTUncheckedUpdateWithoutMst_itemsInput>
    create: XOR<MSTCreateWithoutMst_itemsInput, MSTUncheckedCreateWithoutMst_itemsInput>
    where?: MSTWhereInput
  }

  export type MSTUpdateToOneWithWhereWithoutMst_itemsInput = {
    where?: MSTWhereInput
    data: XOR<MSTUpdateWithoutMst_itemsInput, MSTUncheckedUpdateWithoutMst_itemsInput>
  }

  export type MSTUpdateWithoutMst_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUpdateManyWithoutMstNestedInput
  }

  export type MSTUncheckedUpdateWithoutMst_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_number?: StringFieldUpdateOperationsInput | string
    mst_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_by_id?: StringFieldUpdateOperationsInput | string
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst_approvers?: MSTApproverUncheckedUpdateManyWithoutMstNestedInput
  }

  export type ItemUpsertWithoutMst_itemsInput = {
    update: XOR<ItemUpdateWithoutMst_itemsInput, ItemUncheckedUpdateWithoutMst_itemsInput>
    create: XOR<ItemCreateWithoutMst_itemsInput, ItemUncheckedCreateWithoutMst_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutMst_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutMst_itemsInput, ItemUncheckedUpdateWithoutMst_itemsInput>
  }

  export type ItemUpdateWithoutMst_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutMst_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyItem_typeInput = {
    id?: string
    unit_id: string
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierCreateManySupplierInput = {
    id?: string
    meqs_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateManyUnitInput = {
    id?: string
    canvass_id: string
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemCreateManyUnitInput = {
    id?: string
    item_type_id: number
    code: string
    description?: string | null
    total_quantity: number
    quantity_on_queue?: number
    initial_quantity: number
    alert_level?: number
    created_by: string
    updated_by?: string | null
    deleted_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    item?: ItemUpdateOneWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutItemNestedInput
    item_locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutItemNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutItemNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutItemNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutItemNestedInput
    mst_items?: MSTItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    total_quantity?: IntFieldUpdateOperationsInput | number
    quantity_on_queue?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    alert_level?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRCreateManyVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id?: string | null
    classification_id?: string | null
    supervisor_id: string
    notes: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass?: CanvassUpdateOneWithoutSprNestedInput
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationCreateManyStationInput = {
    id?: string
    item_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVCreateManyItem_fromInput = {
    id?: string
    osriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    requested_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVCreateManyItem_fromInput = {
    id?: string
    project_id: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVCreateManyItem_fromInput = {
    id?: string
    seriv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutItem_locationsNestedInput
    origin_movements?: ItemMovementUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateManyWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUpdateManyWithoutOsrivNestedInput
    osriv_items?: OSRIVItemUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVUncheckedUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv_approvers?: OSRIVApproverUncheckedUpdateManyWithoutOsrivNestedInput
    osriv_items?: OSRIVItemUncheckedUpdateManyWithoutOsrivNestedInput
  }

  export type OSRIVUncheckedUpdateManyWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    requested_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUpdateManyWithoutMrvNestedInput
    mct?: MCTUpdateOneWithoutMrvNestedInput
    project?: ProjectUpdateOneRequiredWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutMrvNestedInput
    mct?: MCTUncheckedUpdateOneWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateManyWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv_approvers?: SERIVApproverUncheckedUpdateManyWithoutSerivNestedInput
    seriv_items?: SERIVItemUncheckedUpdateManyWithoutSerivNestedInput
    mcrts?: MCRTUncheckedUpdateManyWithoutSerivNestedInput
  }

  export type SERIVUncheckedUpdateManyWithoutItem_fromInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVCreateManyProjectInput = {
    id?: string
    mrv_number: string
    date_requested: Date | string
    exp_date: Date | string
    purpose: string
    note?: string
    is_completed?: boolean
    request_type: number
    or_number?: string | null
    mwo_number?: string | null
    cwo_number?: string | null
    jo_number?: string | null
    consumer_name: string
    location: string
    requested_by_id: string
    withdrawn_by_id: string
    item_from_id: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_from?: StationUpdateOneRequiredWithoutMrvsNestedInput
    mrv_approvers?: MRVApproverUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUpdateManyWithoutMrvNestedInput
    mct?: MCTUpdateOneWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv_approvers?: MRVApproverUncheckedUpdateManyWithoutMrvNestedInput
    mrv_items?: MRVItemUncheckedUpdateManyWithoutMrvNestedInput
    mct?: MCTUncheckedUpdateOneWithoutMrvNestedInput
  }

  export type MRVUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    exp_date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    request_type?: IntFieldUpdateOperationsInput | number
    or_number?: NullableStringFieldUpdateOperationsInput | string | null
    mwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    cwo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    requested_by_id?: StringFieldUpdateOperationsInput | string
    withdrawn_by_id?: StringFieldUpdateOperationsInput | string
    item_from_id?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionCreateManyItemInput = {
    id?: number
    rr_item_id?: string | null
    osriv_item_id?: string | null
    seriv_item_id?: string | null
    mrv_item_id?: string | null
    mcrt_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    created_by?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateManyItemInput = {
    id?: string
    canvass_id: string
    unit_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationCreateManyItemInput = {
    id?: string
    station_id: string
    quantity_on_hand: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemCreateManyItemInput = {
    id?: string
    osriv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemCreateManyItemInput = {
    id?: string
    seriv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemCreateManyItemInput = {
    id?: string
    mrv_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemCreateManyItemInput = {
    id?: string
    mcrt_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateManyItemInput = {
    id?: string
    mst_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionUpdateWithoutItemInput = {
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
    osriv_item?: OSRIVItemUpdateOneWithoutItem_transactionNestedInput
    seriv_item?: SERIVItemUpdateOneWithoutItem_transactionNestedInput
    mrv_item?: MRVItemUpdateOneWithoutItem_transactionNestedInput
    mcrt_item?: MCRTItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemTransactionUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    osriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mrv_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemLocationUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    station?: StationUpdateOneRequiredWithoutItemsNestedInput
    origin_movements?: ItemMovementUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin_movements?: ItemMovementUncheckedUpdateManyWithoutOriginNestedInput
    destination_movements?: ItemMovementUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type ItemLocationUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    station_id?: StringFieldUpdateOperationsInput | string
    quantity_on_hand?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    osriv?: OSRIVUpdateOneRequiredWithoutOsriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    osriv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVUpdateOneRequiredWithoutSeriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mrv?: MRVUpdateOneRequiredWithoutMrv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrv_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt?: MCRTUpdateOneRequiredWithoutMcrt_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mcrt_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mst?: MSTUpdateOneRequiredWithoutMst_itemsNestedInput
  }

  export type MSTItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    mst_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateManyOriginInput = {
    id?: string
    destination_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementCreateManyDestinationInput = {
    id?: string
    origin_id: string
    quantity_moved: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    destination?: ItemLocationUpdateOneRequiredWithoutDestination_movementsNestedInput
  }

  export type ItemMovementUncheckedUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUncheckedUpdateManyWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    origin?: ItemLocationUpdateOneRequiredWithoutOrigin_movementsNestedInput
  }

  export type ItemMovementUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemMovementUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: StringFieldUpdateOperationsInput | string
    quantity_moved?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemCreateManyCanvassInput = {
    id?: string
    unit_id?: string | null
    item_id?: string | null
    description: string
    quantity: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CanvassItemUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
    unit?: UnitUpdateOneWithoutCanvass_itemsNestedInput
    item?: ItemUpdateOneWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemCreateManyCanvass_itemInput = {
    id?: string
    meqs_supplier_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemUpdateWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    rr_items?: RRItemUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverCreateManyRvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RVApproverUncheckedUpdateManyWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverCreateManyJoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JOApproverUncheckedUpdateManyWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverCreateManySprInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    is_supervisor?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SPRApproverUncheckedUpdateManyWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    is_supervisor?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverCreateManyMeqsInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierCreateManyMeqsInput = {
    id?: string
    supplier_id: string
    payment_terms: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSApproverUncheckedUpdateManyWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentCreateManyMeqs_supplierInput = {
    id?: string
    filename?: string
    src: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemCreateManyMeqs_supplierInput = {
    id?: string
    canvass_item_id: string
    price: number
    notes: string
    is_awarded?: boolean
    vat_type?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MEQSSupplierItemUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    canvass_item?: CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    rr_items?: RRItemUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_items?: RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    vat_type?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemCreateManyMeqs_supplier_itemInput = {
    id?: string
    rr_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemUpdateWithoutMeqs_supplier_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateWithoutMeqs_supplier_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutMeqs_supplier_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRCreateManyPoInput = {
    id?: string
    po_number: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    invoice_number: string
    delivery_number?: string | null
    notes: string
    delivery_charge: number
    is_completed?: boolean
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverCreateManyPoInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type POApproverUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverCreateManyRrInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemCreateManyRrInput = {
    id?: string
    meqs_supplier_item_id: string
    quantity_accepted: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUncheckedUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRApproverUncheckedUpdateManyWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RRItemUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
    meqs_supplier_item?: MEQSSupplierItemUpdateOneRequiredWithoutRr_itemsNestedInput
  }

  export type RRItemUncheckedUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_item_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_item_id?: StringFieldUpdateOperationsInput | string
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverCreateManyOsrivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemCreateManyOsrivInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUpdateWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUncheckedUpdateWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVApproverUncheckedUpdateManyWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OSRIVItemUpdateWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutOsriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemUncheckedUpdateWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutOsriv_itemNestedInput
  }

  export type OSRIVItemUncheckedUpdateManyWithoutOsrivInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverCreateManySerivInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemCreateManySerivInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTCreateManySerivInput = {
    id?: string
    mct_id?: string | null
    mct_number?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUncheckedUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVApproverUncheckedUpdateManyWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SERIVItemUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutSeriv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemUncheckedUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutSeriv_itemNestedInput
  }

  export type SERIVItemUncheckedUpdateManyWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mct?: MCTUpdateOneWithoutMcrtsNestedInput
    mcrt_approvers?: MCRTApproverUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateManyWithoutSerivInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_id?: NullableStringFieldUpdateOperationsInput | string | null
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverCreateManyMrvInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemCreateManyMrvInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUncheckedUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVApproverUncheckedUpdateManyWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MRVItemUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutMrv_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemUncheckedUpdateWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMrv_itemNestedInput
  }

  export type MRVItemUncheckedUpdateManyWithoutMrvInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverCreateManyMctInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTCreateManyMctInput = {
    id?: string
    mct_number?: string | null
    seriv_id?: string | null
    seriv_number?: string | null
    mcrt_number: string
    mcrt_date: Date | string
    is_completed?: boolean
    returned_by_id: string
    wo_number?: string | null
    mo_number?: string | null
    jo_number?: string | null
    note: string
    cancelled_by?: string | null
    created_by: string
    updated_by?: string | null
    cancelled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUncheckedUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCTApproverUncheckedUpdateManyWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    seriv?: SERIVUpdateOneWithoutMcrtsNestedInput
    mcrt_approvers?: MCRTApproverUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    mcrt_approvers?: MCRTApproverUncheckedUpdateManyWithoutMcrtNestedInput
    mcrt_items?: MCRTItemUncheckedUpdateManyWithoutMcrtNestedInput
  }

  export type MCRTUncheckedUpdateManyWithoutMctInput = {
    id?: StringFieldUpdateOperationsInput | string
    mct_number?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_id?: NullableStringFieldUpdateOperationsInput | string | null
    seriv_number?: NullableStringFieldUpdateOperationsInput | string | null
    mcrt_number?: StringFieldUpdateOperationsInput | string
    mcrt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    returned_by_id?: StringFieldUpdateOperationsInput | string
    wo_number?: NullableStringFieldUpdateOperationsInput | string | null
    mo_number?: NullableStringFieldUpdateOperationsInput | string | null
    jo_number?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverCreateManyMcrtInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemCreateManyMcrtInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUpdateWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUncheckedUpdateWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTApproverUncheckedUpdateManyWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MCRTItemUpdateWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutMcrt_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemUncheckedUpdateWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutMcrt_itemNestedInput
  }

  export type MCRTItemUncheckedUpdateManyWithoutMcrtInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverCreateManyMstInput = {
    id?: string
    approver_id: string
    date_approval?: Date | string | null
    notes: string
    status: number
    label: string
    label_id: string
    order: number
    updated_by?: string | null
    updated_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemCreateManyMstInput = {
    id?: string
    item_id: string
    quantity: number
    price?: number
    status?: number
    created_by: string
    created_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUpdateWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUncheckedUpdateWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTApproverUncheckedUpdateManyWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUpdateWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    item?: ItemUpdateOneRequiredWithoutMst_itemsNestedInput
  }

  export type MSTItemUncheckedUpdateWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MSTItemUncheckedUpdateManyWithoutMstInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ItemTypeCountOutputTypeDefaultArgs instead
     */
    export type ItemTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StationCountOutputTypeDefaultArgs instead
     */
    export type StationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemLocationCountOutputTypeDefaultArgs instead
     */
    export type ItemLocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemLocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassCountOutputTypeDefaultArgs instead
     */
    export type CanvassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassItemCountOutputTypeDefaultArgs instead
     */
    export type CanvassItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVCountOutputTypeDefaultArgs instead
     */
    export type RVCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JOCountOutputTypeDefaultArgs instead
     */
    export type JOCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JOCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRCountOutputTypeDefaultArgs instead
     */
    export type SPRCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSCountOutputTypeDefaultArgs instead
     */
    export type MEQSCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierCountOutputTypeDefaultArgs instead
     */
    export type MEQSSupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierItemCountOutputTypeDefaultArgs instead
     */
    export type MEQSSupplierItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use POCountOutputTypeDefaultArgs instead
     */
    export type POCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRCountOutputTypeDefaultArgs instead
     */
    export type RRCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OSRIVCountOutputTypeDefaultArgs instead
     */
    export type OSRIVCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OSRIVCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SERIVCountOutputTypeDefaultArgs instead
     */
    export type SERIVCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SERIVCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MRVCountOutputTypeDefaultArgs instead
     */
    export type MRVCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MRVCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCTCountOutputTypeDefaultArgs instead
     */
    export type MCTCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCTCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCRTCountOutputTypeDefaultArgs instead
     */
    export type MCRTCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCRTCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MSTCountOutputTypeDefaultArgs instead
     */
    export type MSTCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MSTCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTypeDefaultArgs instead
     */
    export type ItemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StationDefaultArgs instead
     */
    export type StationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingDefaultArgs instead
     */
    export type PendingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemLocationDefaultArgs instead
     */
    export type ItemLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemMovementDefaultArgs instead
     */
    export type ItemMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTransactionDefaultArgs instead
     */
    export type ItemTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCodeTrackerDefaultArgs instead
     */
    export type ItemCodeTrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCodeTrackerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassDefaultArgs instead
     */
    export type CanvassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassItemDefaultArgs instead
     */
    export type CanvassItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVDefaultArgs instead
     */
    export type RVArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVApproverDefaultArgs instead
     */
    export type RVApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JODefaultArgs instead
     */
    export type JOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JODefaultArgs<ExtArgs>
    /**
     * @deprecated Use JOApproverDefaultArgs instead
     */
    export type JOApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JOApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRDefaultArgs instead
     */
    export type SPRArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRApproverDefaultArgs instead
     */
    export type SPRApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSDefaultArgs instead
     */
    export type MEQSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierDefaultArgs instead
     */
    export type MEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierItemDefaultArgs instead
     */
    export type MEQSSupplierItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierAttachmentDefaultArgs instead
     */
    export type MEQSSupplierAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSApproverDefaultArgs instead
     */
    export type MEQSApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PODefaultArgs instead
     */
    export type POArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PODefaultArgs<ExtArgs>
    /**
     * @deprecated Use POApproverDefaultArgs instead
     */
    export type POApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRDefaultArgs instead
     */
    export type RRArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRApproverDefaultArgs instead
     */
    export type RRApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRItemDefaultArgs instead
     */
    export type RRItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OSRIVDefaultArgs instead
     */
    export type OSRIVArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OSRIVDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OSRIVApproverDefaultArgs instead
     */
    export type OSRIVApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OSRIVApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OSRIVItemDefaultArgs instead
     */
    export type OSRIVItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OSRIVItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SERIVDefaultArgs instead
     */
    export type SERIVArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SERIVDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SERIVApproverDefaultArgs instead
     */
    export type SERIVApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SERIVApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SERIVItemDefaultArgs instead
     */
    export type SERIVItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SERIVItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MRVDefaultArgs instead
     */
    export type MRVArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MRVDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MRVApproverDefaultArgs instead
     */
    export type MRVApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MRVApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MRVItemDefaultArgs instead
     */
    export type MRVItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MRVItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCTDefaultArgs instead
     */
    export type MCTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCTApproverDefaultArgs instead
     */
    export type MCTApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCTApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCRTDefaultArgs instead
     */
    export type MCRTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCRTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCRTApproverDefaultArgs instead
     */
    export type MCRTApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCRTApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCRTItemDefaultArgs instead
     */
    export type MCRTItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCRTItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MSTDefaultArgs instead
     */
    export type MSTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MSTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MSTApproverDefaultArgs instead
     */
    export type MSTApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MSTApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MSTItemDefaultArgs instead
     */
    export type MSTItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MSTItemDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}